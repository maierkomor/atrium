/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: R2104.36 (hg:424/c47d8dd02d82)
 * WFC is Copyright 2015-2021, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : swcfg.wfc
 * Copyright: 2018-2021
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2021-10-18, 08:19:22 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from esp8266:
 * Optimize        : "size"
 * 
 * options from esp:
 * bytestype       : "estring"
 * intsize         : 32
 * stringtype      : "estring"
 * toASCII         : "toASCII"
 * toSink          : ""
 * toString        : ""
 * toWire          : ""
 * varintbits      : 32
 * 
 * options from common:
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * BaseClass       : ""
 * calcSize        : "calcSize"
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * copyright       : ""
 * email           : ""
 * endian          : "unknown"
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * SortMembers     : "id"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * UnknownField    : "skip"
 * wireput         : ""
 * wiresize        : ""
 * 
 * disabled flags from esp8266:
 * 	withUnequal
 * enabled flags from esp:
 * 	enumnames, withEqual
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux
 */

#include <map>
#include <stdlib.h>
#include <string.h>
#include "swcfg.h"

#include "wfccore.h"

#if !defined(WFC_ENDIAN) || (WFC_ENDIAN != 0)
#error wfc: incompatible settings concerning endian
#endif


#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
struct cstr_less {
	bool operator () (const char *l, const char *r) const
	{ return strcmp(l,r) < 0; }
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *rstrsn_t_names[] = {
	"brownout",
	"deepsleep",
	"external",
	"internal_wdt",
	"panic",
	"powerup",
	"sdio",
	"software",
	"task_wdt",
	"unknown",
	"watchdog",
};

static rstrsn_t rstrsn_t_values[] = {
	brownout,
	deepsleep,
	external,
	internal_wdt,
	panic,
	powerup,
	sdio,
	software,
	task_wdt,
	unknown,
	watchdog,
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_rstrsn_t(rstrsn_t *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,rstrsn_t, cstr_less> namesmap = {
		{ "brownout", brownout},
		{ "deepsleep", deepsleep},
		{ "external", external},
		{ "internal_wdt", internal_wdt},
		{ "panic", panic},
		{ "powerup", powerup},
		{ "sdio", sdio},
		{ "software", software},
		{ "task_wdt", task_wdt},
		{ "unknown", unknown},
		{ "watchdog", watchdog},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (rstrsn_t)ull;
		return e-s;
	} else
		#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	{
		auto i = namesmap.find(s);
		if (i == namesmap.end())
			return 0;
		*v = i->second;
		return strlen(s);
	}
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(rstrsn_t_names)/sizeof(rstrsn_t_names[0]); ++i) {
			if (0 == strcmp(rstrsn_t_names[i],s))
				return rstrsn_t_values[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *strReset(rstrsn_t e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case unknown:
		return "unknown";
	case powerup:
		return "powerup";
	case external:
		return "external";
	case software:
		return "software";
	case panic:
		return "panic";
	case internal_wdt:
		return "internal_wdt";
	case task_wdt:
		return "task_wdt";
	case watchdog:
		return "watchdog";
	case deepsleep:
		return "deepsleep";
	case brownout:
		return "brownout";
	case sdio:
		return "sdio";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	for (size_t i = 0; i < sizeof(rstrsn_t_values)/sizeof(rstrsn_t_values[0]); ++i) {
		if (e == rstrsn_t_values[i])
			return rstrsn_t_names[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *WeekDay_names[] = {
	"EveryDay",
	"Friday",
	"Holiday",
	"Monday",
	"Saturday",
	"Sunday",
	"Thursday",
	"Tuesday",
	"Wednesday",
	"WeekEnd",
	"WorkDay",
};

static WeekDay WeekDay_values[] = {
	EveryDay,
	Friday,
	Holiday,
	Monday,
	Saturday,
	Sunday,
	Thursday,
	Tuesday,
	Wednesday,
	WeekEnd,
	WorkDay,
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_WeekDay(WeekDay *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,WeekDay, cstr_less> namesmap = {
		{ "EveryDay", EveryDay},
		{ "Friday", Friday},
		{ "Holiday", Holiday},
		{ "Monday", Monday},
		{ "Saturday", Saturday},
		{ "Sunday", Sunday},
		{ "Thursday", Thursday},
		{ "Tuesday", Tuesday},
		{ "Wednesday", Wednesday},
		{ "WeekEnd", WeekEnd},
		{ "WorkDay", WorkDay},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (WeekDay)ull;
		return e-s;
	} else
		#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	{
		auto i = namesmap.find(s);
		if (i == namesmap.end())
			return 0;
		*v = i->second;
		return strlen(s);
	}
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(WeekDay_names)/sizeof(WeekDay_names[0]); ++i) {
			if (0 == strcmp(WeekDay_names[i],s))
				return WeekDay_values[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *WeekDay_str(WeekDay e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case Sunday:
		return "Sunday";
	case Monday:
		return "Monday";
	case Tuesday:
		return "Tuesday";
	case Wednesday:
		return "Wednesday";
	case Thursday:
		return "Thursday";
	case Friday:
		return "Friday";
	case Saturday:
		return "Saturday";
	case WorkDay:
		return "WorkDay";
	case WeekEnd:
		return "WeekEnd";
	case EveryDay:
		return "EveryDay";
	case Holiday:
		return "Holiday";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	for (size_t i = 0; i < sizeof(WeekDay_values)/sizeof(WeekDay_values[0]); ++i) {
		if (e == WeekDay_values[i])
			return WeekDay_names[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *uart_wl_t_names[] = {
	"uart_wl_5",
	"uart_wl_6",
	"uart_wl_7",
	"uart_wl_8",
};

#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_uart_wl_t(uart_wl_t *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,uart_wl_t, cstr_less> namesmap = {
		{ "uart_wl_5", uart_wl_5},
		{ "uart_wl_6", uart_wl_6},
		{ "uart_wl_7", uart_wl_7},
		{ "uart_wl_8", uart_wl_8},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (uart_wl_t)ull;
		return e-s;
	} else
		#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	{
		auto i = namesmap.find(s);
		if (i == namesmap.end())
			return 0;
		*v = i->second;
		return strlen(s);
	}
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(uart_wl_t_names)/sizeof(uart_wl_t_names[0]); ++i) {
			if (0 == strcmp(uart_wl_t_names[i],s))
				return (uart_wl_t)i;
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *uart_wl_t_str(uart_wl_t e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case uart_wl_5:
		return "uart_wl_5";
	case uart_wl_6:
		return "uart_wl_6";
	case uart_wl_7:
		return "uart_wl_7";
	case uart_wl_8:
		return "uart_wl_8";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	return uart_wl_t_names[(size_t)e];
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *uart_sb_t_names[] = {
	"uart_sb_1",
	"uart_sb_1_5",
	"uart_sb_2",
	"uart_sb_none",
};

static uart_sb_t uart_sb_t_values[] = {
	uart_sb_1,
	uart_sb_1_5,
	uart_sb_2,
	uart_sb_none,
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_uart_sb_t(uart_sb_t *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,uart_sb_t, cstr_less> namesmap = {
		{ "uart_sb_1", uart_sb_1},
		{ "uart_sb_1_5", uart_sb_1_5},
		{ "uart_sb_2", uart_sb_2},
		{ "uart_sb_none", uart_sb_none},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (uart_sb_t)ull;
		return e-s;
	} else
		#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	{
		auto i = namesmap.find(s);
		if (i == namesmap.end())
			return 0;
		*v = i->second;
		return strlen(s);
	}
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(uart_sb_t_names)/sizeof(uart_sb_t_names[0]); ++i) {
			if (0 == strcmp(uart_sb_t_names[i],s))
				return uart_sb_t_values[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *uart_sb_t_str(uart_sb_t e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case uart_sb_none:
		return "uart_sb_none";
	case uart_sb_1:
		return "uart_sb_1";
	case uart_sb_1_5:
		return "uart_sb_1_5";
	case uart_sb_2:
		return "uart_sb_2";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	for (size_t i = 0; i < sizeof(uart_sb_t_values)/sizeof(uart_sb_t_values[0]); ++i) {
		if (e == uart_sb_t_values[i])
			return uart_sb_t_names[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *uart_p_t_names[] = {
	"uart_p_e",
	"uart_p_n",
	"uart_p_o",
};

static uart_p_t uart_p_t_values[] = {
	uart_p_e,
	uart_p_n,
	uart_p_o,
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_uart_p_t(uart_p_t *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,uart_p_t, cstr_less> namesmap = {
		{ "uart_p_e", uart_p_e},
		{ "uart_p_n", uart_p_n},
		{ "uart_p_o", uart_p_o},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (uart_p_t)ull;
		return e-s;
	} else
		#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	{
		auto i = namesmap.find(s);
		if (i == namesmap.end())
			return 0;
		*v = i->second;
		return strlen(s);
	}
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(uart_p_t_names)/sizeof(uart_p_t_names[0]); ++i) {
			if (0 == strcmp(uart_p_t_names[i],s))
				return uart_p_t_values[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *uart_p_t_str(uart_p_t e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case uart_p_n:
		return "uart_p_n";
	case uart_p_e:
		return "uart_p_e";
	case uart_p_o:
		return "uart_p_o";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	for (size_t i = 0; i < sizeof(uart_p_t_values)/sizeof(uart_p_t_values[0]); ++i) {
		if (e == uart_p_t_values[i])
			return uart_p_t_names[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *sigtype_t_names[] = {
	"st_float",
	"st_int",
	"st_invalid",
	"st_string",
};

static sigtype_t sigtype_t_values[] = {
	st_float,
	st_int,
	st_invalid,
	st_string,
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_sigtype_t(sigtype_t *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,sigtype_t, cstr_less> namesmap = {
		{ "st_float", st_float},
		{ "st_int", st_int},
		{ "st_invalid", st_invalid},
		{ "st_string", st_string},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (sigtype_t)ull;
		return e-s;
	} else
		#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	{
		auto i = namesmap.find(s);
		if (i == namesmap.end())
			return 0;
		*v = i->second;
		return strlen(s);
	}
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(sigtype_t_names)/sizeof(sigtype_t_names[0]); ++i) {
			if (0 == strcmp(sigtype_t_names[i],s))
				return sigtype_t_values[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *sigtype_t_str(sigtype_t e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case st_invalid:
		return "st_invalid";
	case st_int:
		return "st_int";
	case st_float:
		return "st_float";
	case st_string:
		return "st_string";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	for (size_t i = 0; i < sizeof(sigtype_t_values)/sizeof(sigtype_t_values[0]); ++i) {
		if (e == sigtype_t_values[i])
			return sigtype_t_names[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

WifiConfig::WifiConfig()
: m_ssid()
, m_pass()
, m_mac()
, m_activate(false)
, m_addr4(0)
, m_netmask4(0)
, m_gateway4(0)
, p_validbits(0)
{
}

void WifiConfig::clear()
{
	m_ssid.clear();
	m_pass.clear();
	m_mac.clear();
	m_activate = false;
	m_addr4 = 0;
	m_netmask4 = 0;
	m_gateway4 = 0;
	p_validbits = 0;
}

void WifiConfig::toASCII(stream &o, size_t indent) const
{
	o << "WifiConfig {";
	++indent;
	ascii_indent(o,indent,"ssid");
	ascii_string(o,m_ssid.data(),m_ssid.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"pass");
	ascii_string(o,m_pass.data(),m_pass.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"mac");
	ascii_bytes(o,(const uint8_t*)m_mac.data(),m_mac.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"activate");
	o << (m_activate ? "true" : "false") << ';';
	ascii_indent(o,indent,"addr4");
	ip4_to_ascii(o,m_addr4);
	o << ';';
	ascii_numeric(o, indent, "netmask4", (unsigned) m_netmask4);
	ascii_indent(o,indent,"gateway4");
	ip4_to_ascii(o,m_gateway4);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t WifiConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -1;
		a += x;
		switch (fid) {
		case 0xa:	// ssid id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -2;
			}
			m_ssid.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x12:	// pass id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -3;
			}
			m_pass.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x1a:	// mac id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -4;
			}
			m_mac.assign((const char*)a,ud.vi);
			p_validbits |= ((uint8_t)1U << 0);
			a += ud.vi;
			break;
		case 0x23:	// activate id 4, type bool, coding 8bit
			m_activate = ud.u8;
			break;
		case 0x2d:	// addr4 id 5, type uint32_t, coding 32bit
			set_addr4(ud.u32);
			break;
		case 0x33:	// netmask4 id 6, type uint8_t, coding 8bit
			set_netmask4(ud.u8);
			break;
		case 0x3d:	// gateway4 id 7, type uint32_t, coding 32bit
			set_gateway4(ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -5;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -6;
	return a-(const uint8_t *)b;
}

ssize_t WifiConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has ssid?
	if (!m_ssid.empty()) {
		// 'ssid': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -7;
		*a++ = 0xa;
		n = encode_bytes(m_ssid,a,e);
		if (n < 0)
			return -8;
		a += n;
	}
	// has pass?
	if (!m_pass.empty()) {
		// 'pass': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -9;
		*a++ = 0x12;
		n = encode_bytes(m_pass,a,e);
		if (n < 0)
			return -10;
		a += n;
	}
	// has mac?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'mac': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -11;
		*a++ = 0x1a;
		n = encode_bytes(m_mac,a,e);
		if (n < 0)
			return -12;
		a += n;
	}
	// 'activate': id=4, encoding=8bit, tag=0x23
	if (2 > (e-a))
		return -13;
	*a++ = 0x23;
	*a++ = m_activate;
	// has addr4?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'addr4': id=5, encoding=32bit, tag=0x2d
		if (5 > (e-a))
			return -14;
		*a++ = 0x2d;
		if ((e-a) < 4)
			return -15;
		write_u32(a,(uint32_t)m_addr4);
		a += 4;
	}
	// has netmask4?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'netmask4': id=6, encoding=8bit, tag=0x33
		if (2 > (e-a))
			return -16;
		*a++ = 0x33;
		*a++ = m_netmask4;
	}
	// has gateway4?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'gateway4': id=7, encoding=32bit, tag=0x3d
		if (5 > (e-a))
			return -17;
		*a++ = 0x3d;
		if ((e-a) < 4)
			return -18;
		write_u32(a,(uint32_t)m_gateway4);
		a += 4;
	}
	assert(a <= e);
	return a-b;
}

void WifiConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_ssid()) {
		fsep = json_indent(json,indLvl,fsep,"ssid");
		json_cstr(json,m_ssid.c_str());
	}
	if (has_pass()) {
		fsep = json_indent(json,indLvl,fsep,"pass");
		json_cstr(json,m_pass.c_str());
	}
	if (has_mac()) {
		fsep = json_indent(json,indLvl,fsep,"mac");
		json_string(json,m_mac);
	}
	fsep = json_indent(json,indLvl,fsep,"activate");
	json << (m_activate ? "true" : "false");
	if (has_addr4()) {
		fsep = json_indent(json,indLvl,fsep,"addr4");
		json.put('"');
		ip4_to_ascii(json,m_addr4);
		json.put('"');
	}
	if (has_netmask4()) {
		fsep = json_indent(json,indLvl,fsep,"netmask4");
		to_decstr(json,(unsigned) m_netmask4);
	}
	if (has_gateway4()) {
		fsep = json_indent(json,indLvl,fsep,"gateway4");
		json.put('"');
		ip4_to_ascii(json,m_gateway4);
		json.put('"');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t WifiConfig::calcSize() const
{
	// bool activate: tagsize 1, data size 1
	size_t r = 2;	// required size, default is fixed length
	// optional string ssid, id 1
	if (has_ssid()) {
		size_t ssid_s = m_ssid.size();
		r += ssid_s + wiresize(ssid_s) + 1 /* tag(ssid) 0x8 */;
	}
	// optional string pass, id 2
	if (has_pass()) {
		size_t pass_s = m_pass.size();
		r += pass_s + wiresize(pass_s) + 1 /* tag(pass) 0x10 */;
	}
	// optional bytes mac, id 3
	if (has_mac()) {
		size_t mac_s = m_mac.size();
		r += mac_s + wiresize(mac_s) + 1 /* tag(mac) 0x18 */;
	}
	// optional fixed32 addr4, id 5
	if (has_addr4()) {
		r += 5;
	}
	// optional fixed8 netmask4, id 6
	if (has_netmask4()) {
		r += 2;
	}
	// optional fixed32 gateway4, id 7
	if (has_gateway4()) {
		r += 5;
	}
	return r;
}

bool WifiConfig::operator == (const WifiConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_ssid() && (!(m_ssid == r.m_ssid)))
		return false;
	if (has_pass() && (!(m_pass == r.m_pass)))
		return false;
	if (has_mac() && (!(m_mac == r.m_mac)))
		return false;
	if (!(m_activate == r.m_activate))
		return false;
	if (has_addr4() && (!(m_addr4 == r.m_addr4)))
		return false;
	if (has_netmask4() && (!(m_netmask4 == r.m_netmask4)))
		return false;
	if (has_gateway4() && (!(m_gateway4 == r.m_gateway4)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int WifiConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"ssid")) {
		if (value == 0) {
			clear_ssid();
			return 0;
		}
		m_ssid = value;
		int r = m_ssid.size();
		return r;
	}
	if (0 == strcmp(name,"pass")) {
		if (value == 0) {
			clear_pass();
			return 0;
		}
		m_pass = value;
		int r = m_pass.size();
		return r;
	}
	if (0 == strcmp(name,"mac")) {
		if (value == 0) {
			clear_mac();
			return 0;
		}
		int r = parse_ascii_bytes(m_mac,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"activate")) {
		int r = parse_ascii_bool(&m_activate,value);
		return r;
	}
	if (0 == strcmp(name,"addr4")) {
		if (value == 0) {
			clear_addr4();
			return 0;
		}
		int r = parse_ipv4(&m_addr4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"netmask4")) {
		if (value == 0) {
			clear_netmask4();
			return 0;
		}
		int r = parse_ascii_u8(&m_netmask4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"gateway4")) {
		if (value == 0) {
			clear_gateway4();
			return 0;
		}
		int r = parse_ipv4(&m_gateway4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	return -19;
}

MQTT::MQTT()
: m_uri()
, m_enable(false)
, m_username()
, m_password()
, m_subscribtions()
{
}

void MQTT::clear()
{
	m_uri.clear();
	m_enable = false;
	m_username.clear();
	m_password.clear();
	m_subscribtions.clear();
}

void MQTT::toASCII(stream &o, size_t indent) const
{
	o << "MQTT {";
	++indent;
	ascii_indent(o,indent,"uri");
	ascii_string(o,m_uri.data(),m_uri.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"enable");
	o << (m_enable ? "true" : "false") << ';';
	ascii_indent(o,indent,"username");
	ascii_string(o,m_username.data(),m_username.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"password");
	ascii_string(o,m_password.data(),m_password.size(),indent+2);
	o << ';';
	ascii_indent(o,indent);
	size_t s_subscribtions = m_subscribtions.size();
	o << "subscribtions[" << s_subscribtions << "] = {";
	++indent;
	for (size_t i = 0, e = s_subscribtions; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,m_subscribtions[i].data(),m_subscribtions[i].size(),indent+2);
		o << ';';
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t MQTT::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -20;
		a += x;
		switch (fid) {
		case 0xa:	// uri id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -21;
			}
			m_uri.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x13:	// enable id 2, type bool, coding 8bit
			set_enable(ud.u8);
			break;
		case 0x1a:	// username id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -22;
			}
			m_username.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x22:	// password id 4, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -23;
			}
			m_password.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x2a:	// subscribtions id 5, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -24;
			}
			m_subscribtions.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -25;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -26;
	return a-(const uint8_t *)b;
}

ssize_t MQTT::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has uri?
	if (!m_uri.empty()) {
		// 'uri': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -27;
		*a++ = 0xa;
		n = encode_bytes(m_uri,a,e);
		if (n < 0)
			return -28;
		a += n;
	}
	// has enable?
	if (m_enable != false) {
		// 'enable': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -29;
		*a++ = 0x13;
		*a++ = m_enable;
	}
	// has username?
	if (!m_username.empty()) {
		// 'username': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -30;
		*a++ = 0x1a;
		n = encode_bytes(m_username,a,e);
		if (n < 0)
			return -31;
		a += n;
	}
	// has password?
	if (!m_password.empty()) {
		// 'password': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -32;
		*a++ = 0x22;
		n = encode_bytes(m_password,a,e);
		if (n < 0)
			return -33;
		a += n;
	}
	for (const auto &x : m_subscribtions) {
		// 'subscribtions': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -34;
		*a++ = 0x2a;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -35;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void MQTT::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_uri()) {
		fsep = json_indent(json,indLvl,fsep,"uri");
		json_cstr(json,m_uri.c_str());
	}
	if (has_enable()) {
		fsep = json_indent(json,indLvl,fsep,"enable");
		json << (m_enable ? "true" : "false");
	}
	if (has_username()) {
		fsep = json_indent(json,indLvl,fsep,"username");
		json_cstr(json,m_username.c_str());
	}
	if (has_password()) {
		fsep = json_indent(json,indLvl,fsep,"password");
		json_cstr(json,m_password.c_str());
	}
	if (size_t s = m_subscribtions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"subscribtions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_subscribtions[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t MQTT::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string uri, id 1
	if (has_uri()) {
		size_t uri_s = m_uri.size();
		r += uri_s + wiresize(uri_s) + 1 /* tag(uri) 0x8 */;
	}
	// optional bool enable, id 2
	if (has_enable()) {
		r += 2;
	}
	// optional string username, id 3
	if (has_username()) {
		size_t username_s = m_username.size();
		r += username_s + wiresize(username_s) + 1 /* tag(username) 0x18 */;
	}
	// optional string password, id 4
	if (has_password()) {
		size_t password_s = m_password.size();
		r += password_s + wiresize(password_s) + 1 /* tag(password) 0x20 */;
	}
	// repeated string subscribtions, id 5
	if (!m_subscribtions.empty()) {
		// subscribtions: repeated estring
		for (size_t x = 0, y = m_subscribtions.size(); x < y; ++x) {
			size_t s = m_subscribtions[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(subscribtions) 0x28 */;
		}
	}
	return r;
}

bool MQTT::operator == (const MQTT &r) const
{
	if (has_uri() && (!(m_uri == r.m_uri)))
		return false;
	if (has_enable() && (!(m_enable == r.m_enable)))
		return false;
	if (has_username() && (!(m_username == r.m_username)))
		return false;
	if (has_password() && (!(m_password == r.m_password)))
		return false;
	if (!(m_subscribtions == r.m_subscribtions))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int MQTT::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"uri")) {
		if (value == 0) {
			clear_uri();
			return 0;
		}
		m_uri = value;
		int r = m_uri.size();
		return r;
	}
	if (0 == strcmp(name,"enable")) {
		if (value == 0) {
			clear_enable();
			return 0;
		}
		int r = parse_ascii_bool(&m_enable,value);
		return r;
	}
	if (0 == strcmp(name,"username")) {
		if (value == 0) {
			clear_username();
			return 0;
		}
		m_username = value;
		int r = m_username.size();
		return r;
	}
	if (0 == strcmp(name,"password")) {
		if (value == 0) {
			clear_password();
			return 0;
		}
		m_password = value;
		int r = m_password.size();
		return r;
	}
	if (0 == memcmp(name,"subscribtions",13)) {
		if ((name[13] == 0) && (value == 0)) {
			clear_subscribtions();
			return 0;
		} else if (name[13] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[14] == '+') && (name[15] == ']')) {
				x = m_subscribtions.size();
				m_subscribtions.resize(x+1);
				idxe = (char*)(name + 15);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+14,&idxe,0);
				if (idxe[0] != ']')
					return -36;
				if (m_subscribtions.size() <= x)
					return -37;
				if ((idxe[1] == 0) && (value == 0)) {
					m_subscribtions.erase(m_subscribtions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -38;
			m_subscribtions[x] = value;
			return m_subscribtions[x].size();
		}
	}
	return -39;
}

Date::Date()
: m_day(0)
, m_month(0)
, m_year(0)
, m_endday(0)
, m_endmonth(0)
, m_endyear(0)
{
}

void Date::clear()
{
	m_day = 0;
	m_month = 0;
	m_year = 0;
	m_endday = 0;
	m_endmonth = 0;
	m_endyear = 0;
}

void Date::toASCII(stream &o, size_t indent) const
{
	o << "Date {";
	++indent;
	ascii_numeric(o, indent, "day", (unsigned) m_day);
	ascii_numeric(o, indent, "month", (unsigned) m_month);
	ascii_numeric(o, indent, "year", m_year);
	ascii_numeric(o, indent, "endday", (unsigned) m_endday);
	ascii_numeric(o, indent, "endmonth", (unsigned) m_endmonth);
	ascii_numeric(o, indent, "endyear", (unsigned) m_endyear);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Date::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -40;
		a += x;
		switch (fid) {
		case 0xb:	// day id 1, type uint8_t, coding 8bit
			set_day(ud.u8);
			break;
		case 0x13:	// month id 2, type uint8_t, coding 8bit
			set_month(ud.u8);
			break;
		case 0x1c:	// year id 3, type uint16_t, coding 16bit
			set_year(ud.u16);
			break;
		case 0x23:	// endday id 4, type uint8_t, coding 8bit
			set_endday(ud.u8);
			break;
		case 0x2b:	// endmonth id 5, type uint8_t, coding 8bit
			set_endmonth(ud.u8);
			break;
		case 0x33:	// endyear id 6, type uint8_t, coding 8bit
			set_endyear(ud.u8);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -41;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -42;
	return a-(const uint8_t *)b;
}

ssize_t Date::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	// has day?
	if (m_day != 0) {
		// 'day': id=1, encoding=8bit, tag=0xb
		if (2 > (e-a))
			return -43;
		*a++ = 0xb;
		*a++ = m_day;
	}
	// has month?
	if (m_month != 0) {
		// 'month': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -44;
		*a++ = 0x13;
		*a++ = m_month;
	}
	// has year?
	if (m_year != 0) {
		// 'year': id=3, encoding=16bit, tag=0x1c
		if (3 > (e-a))
			return -45;
		*a++ = 0x1c;
		write_u16(a,m_year);
		a += 2;
	}
	// has endday?
	if (m_endday != 0) {
		// 'endday': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -46;
		*a++ = 0x23;
		*a++ = m_endday;
	}
	// has endmonth?
	if (m_endmonth != 0) {
		// 'endmonth': id=5, encoding=8bit, tag=0x2b
		if (2 > (e-a))
			return -47;
		*a++ = 0x2b;
		*a++ = m_endmonth;
	}
	// has endyear?
	if (m_endyear != 0) {
		// 'endyear': id=6, encoding=8bit, tag=0x33
		if (2 > (e-a))
			return -48;
		*a++ = 0x33;
		*a++ = m_endyear;
	}
	assert(a <= e);
	return a-b;
}

void Date::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_day()) {
		fsep = json_indent(json,indLvl,fsep,"day");
		to_decstr(json,(unsigned) m_day);
	}
	if (has_month()) {
		fsep = json_indent(json,indLvl,fsep,"month");
		to_decstr(json,(unsigned) m_month);
	}
	if (has_year()) {
		fsep = json_indent(json,indLvl,fsep,"year");
		to_decstr(json,m_year);
	}
	if (has_endday()) {
		fsep = json_indent(json,indLvl,fsep,"endday");
		to_decstr(json,(unsigned) m_endday);
	}
	if (has_endmonth()) {
		fsep = json_indent(json,indLvl,fsep,"endmonth");
		to_decstr(json,(unsigned) m_endmonth);
	}
	if (has_endyear()) {
		fsep = json_indent(json,indLvl,fsep,"endyear");
		to_decstr(json,(unsigned) m_endyear);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Date::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed8 day, id 1
	if (has_day()) {
		r += 2;
	}
	// optional fixed8 month, id 2
	if (has_month()) {
		r += 2;
	}
	// optional fixed16 year, id 3
	if (has_year()) {
		r += 3;
	}
	// optional fixed8 endday, id 4
	if (has_endday()) {
		r += 2;
	}
	// optional fixed8 endmonth, id 5
	if (has_endmonth()) {
		r += 2;
	}
	// optional fixed8 endyear, id 6
	if (has_endyear()) {
		r += 2;
	}
	return r;
}

bool Date::operator == (const Date &r) const
{
	if (has_day() && (!(m_day == r.m_day)))
		return false;
	if (has_month() && (!(m_month == r.m_month)))
		return false;
	if (has_year() && (!(m_year == r.m_year)))
		return false;
	if (has_endday() && (!(m_endday == r.m_endday)))
		return false;
	if (has_endmonth() && (!(m_endmonth == r.m_endmonth)))
		return false;
	if (has_endyear() && (!(m_endyear == r.m_endyear)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Date::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"day")) {
		if (value == 0) {
			clear_day();
			return 0;
		}
		int r = parse_ascii_u8(&m_day,value);
		return r;
	}
	if (0 == strcmp(name,"month")) {
		if (value == 0) {
			clear_month();
			return 0;
		}
		int r = parse_ascii_u8(&m_month,value);
		return r;
	}
	if (0 == strcmp(name,"year")) {
		if (value == 0) {
			clear_year();
			return 0;
		}
		int r = parse_ascii_u16(&m_year,value);
		return r;
	}
	if (0 == strcmp(name,"endday")) {
		if (value == 0) {
			clear_endday();
			return 0;
		}
		int r = parse_ascii_u8(&m_endday,value);
		return r;
	}
	if (0 == strcmp(name,"endmonth")) {
		if (value == 0) {
			clear_endmonth();
			return 0;
		}
		int r = parse_ascii_u8(&m_endmonth,value);
		return r;
	}
	if (0 == strcmp(name,"endyear")) {
		if (value == 0) {
			clear_endyear();
			return 0;
		}
		int r = parse_ascii_u8(&m_endyear,value);
		return r;
	}
	return -49;
}

AtAction::AtAction()
: m_day(Sunday)
, m_min_of_day(0)
, m_action()
, m_enable(true)
, p_validbits(0)
{
}

void AtAction::clear()
{
	m_day = Sunday;
	m_min_of_day = 0;
	m_action.clear();
	m_enable = true;
	p_validbits = 0;
}

void AtAction::toASCII(stream &o, size_t indent) const
{
	o << "AtAction {";
	++indent;
	ascii_indent(o,indent,"day");
	if (const char *v = WeekDay_str(m_day))
		o << v;
	else
		o << m_day;
	o << ';';
	ascii_numeric(o, indent, "min_of_day", m_min_of_day);
	ascii_indent(o,indent,"action");
	ascii_string(o,m_action.data(),m_action.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"enable");
	o << (m_enable ? "true" : "false") << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AtAction::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -50;
		a += x;
		switch (fid) {
		case 0x8:	// day id 1, type WeekDay, coding varint
			set_day((WeekDay) (WeekDay)ud.u32);
			break;
		case 0x10:	// min_of_day id 2, type uint32_t, coding varint
			set_min_of_day((uint32_t)ud.u32);
			break;
		case 0x1a:	// action id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -51;
			}
			m_action.assign((const char*)a,ud.vi);
			p_validbits |= ((uint8_t)1U << 2);
			a += ud.vi;
			break;
		case 0x23:	// enable id 4, type bool, coding 8bit
			m_enable = ud.u8;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -52;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -53;
	return a-(const uint8_t *)b;
}

ssize_t AtAction::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has day?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'day': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -54;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_day);
		if (n <= 0)
			return -55;
		a += n;
	}
	// has min_of_day?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'min_of_day': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -56;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_min_of_day);
		if (n <= 0)
			return -57;
		a += n;
	}
	// has action?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'action': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -58;
		*a++ = 0x1a;
		n = encode_bytes(m_action,a,e);
		if (n < 0)
			return -59;
		a += n;
	}
	// 'enable': id=4, encoding=8bit, tag=0x23
	if (2 > (e-a))
		return -60;
	*a++ = 0x23;
	*a++ = m_enable;
	assert(a <= e);
	return a-b;
}

void AtAction::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_day()) {
		fsep = json_indent(json,indLvl,fsep,"day");
		if (const char *v = WeekDay_str(m_day)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_day;
		}
	}
	if (has_min_of_day()) {
		fsep = json_indent(json,indLvl,fsep,"min_of_day");
		json.put('"');
		min_of_day_to_ascii(json,m_min_of_day);
		json.put('"');
	}
	if (has_action()) {
		fsep = json_indent(json,indLvl,fsep,"action");
		json_cstr(json,m_action.c_str());
	}
	fsep = json_indent(json,indLvl,fsep,"enable");
	json << (m_enable ? "true" : "false");
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AtAction::calcSize() const
{
	// bool enable: tagsize 1, data size 1
	size_t r = 2;	// required size, default is fixed length
	// optional WeekDay day, id 1
	if (has_day()) {
		r += wiresize((varint_t)m_day) + 1 /* tag(day) 0x8 */;
	}
	// optional unsigned min_of_day, id 2
	if (has_min_of_day()) {
		r += wiresize((varint_t)m_min_of_day) + 1 /* tag(min_of_day) 0x10 */;
	}
	// optional string action, id 3
	if (has_action()) {
		size_t action_s = m_action.size();
		r += action_s + wiresize(action_s) + 1 /* tag(action) 0x18 */;
	}
	return r;
}

bool AtAction::operator == (const AtAction &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_day() && (!(m_day == r.m_day)))
		return false;
	if (has_min_of_day() && (!(m_min_of_day == r.m_min_of_day)))
		return false;
	if (has_action() && (!(m_action == r.m_action)))
		return false;
	if (!(m_enable == r.m_enable))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AtAction::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"day")) {
		if (value == 0) {
			clear_day();
			return 0;
		}
		WeekDay v;
		size_t r = parse_ascii_WeekDay(&v,value);
		if (r == 0)
			return -61;
		set_day(v);
		return r;
	}
	if (0 == strcmp(name,"min_of_day")) {
		if (value == 0) {
			clear_min_of_day();
			return 0;
		}
		int r = parse_ascii_u32(&m_min_of_day,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"action")) {
		if (value == 0) {
			clear_action();
			return 0;
		}
		m_action = value;
		int r = m_action.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"enable")) {
		int r = parse_ascii_bool(&m_enable,value);
		return r;
	}
	return -62;
}

Influx::Influx()
: m_hostname()
, m_port(0)
, m_measurement()
// omitted obsolete member interval
, m_database()
{
}

void Influx::clear()
{
	m_hostname.clear();
	m_port = 0;
	m_measurement.clear();
	m_database.clear();
}

void Influx::toASCII(stream &o, size_t indent) const
{
	o << "Influx {";
	++indent;
	ascii_indent(o,indent,"hostname");
	ascii_string(o,m_hostname.data(),m_hostname.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "port", m_port);
	ascii_indent(o,indent,"measurement");
	ascii_string(o,m_measurement.data(),m_measurement.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"database");
	ascii_string(o,m_database.data(),m_database.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Influx::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -63;
		a += x;
		switch (fid) {
		case 0xa:	// hostname id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -64;
			}
			m_hostname.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x14:	// port id 2, type uint16_t, coding 16bit
			set_port(ud.u16);
			break;
		case 0x1a:	// measurement id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -65;
			}
			m_measurement.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x20:	// interval id 4, type uint32_t
		case 0x2a:	// database id 5, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -66;
			}
			m_database.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -67;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -68;
	return a-(const uint8_t *)b;
}

ssize_t Influx::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has hostname?
	if (!m_hostname.empty()) {
		// 'hostname': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -69;
		*a++ = 0xa;
		n = encode_bytes(m_hostname,a,e);
		if (n < 0)
			return -70;
		a += n;
	}
	// has port?
	if (m_port != 0) {
		// 'port': id=2, encoding=16bit, tag=0x14
		if (3 > (e-a))
			return -71;
		*a++ = 0x14;
		write_u16(a,m_port);
		a += 2;
	}
	// has measurement?
	if (!m_measurement.empty()) {
		// 'measurement': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -72;
		*a++ = 0x1a;
		n = encode_bytes(m_measurement,a,e);
		if (n < 0)
			return -73;
		a += n;
	}
	// 'interval' is obsolete. Therefore no data will be written.
	// has database?
	if (!m_database.empty()) {
		// 'database': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -74;
		*a++ = 0x2a;
		n = encode_bytes(m_database,a,e);
		if (n < 0)
			return -75;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Influx::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_hostname()) {
		fsep = json_indent(json,indLvl,fsep,"hostname");
		json_cstr(json,m_hostname.c_str());
	}
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		to_decstr(json,m_port);
	}
	if (has_measurement()) {
		fsep = json_indent(json,indLvl,fsep,"measurement");
		json_cstr(json,m_measurement.c_str());
	}
	if (has_database()) {
		fsep = json_indent(json,indLvl,fsep,"database");
		json_cstr(json,m_database.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Influx::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string hostname, id 1
	if (has_hostname()) {
		size_t hostname_s = m_hostname.size();
		r += hostname_s + wiresize(hostname_s) + 1 /* tag(hostname) 0x8 */;
	}
	// optional fixed16 port, id 2
	if (has_port()) {
		r += 3;
	}
	// optional string measurement, id 3
	if (has_measurement()) {
		size_t measurement_s = m_measurement.size();
		r += measurement_s + wiresize(measurement_s) + 1 /* tag(measurement) 0x18 */;
	}
	// obsolete optional unsigned interval, id 4
	// optional string database, id 5
	if (has_database()) {
		size_t database_s = m_database.size();
		r += database_s + wiresize(database_s) + 1 /* tag(database) 0x28 */;
	}
	return r;
}

bool Influx::operator == (const Influx &r) const
{
	if (has_hostname() && (!(m_hostname == r.m_hostname)))
		return false;
	if (has_port() && (!(m_port == r.m_port)))
		return false;
	if (has_measurement() && (!(m_measurement == r.m_measurement)))
		return false;
	// nothing to do for obsolete interval
	if (has_database() && (!(m_database == r.m_database)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Influx::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"hostname")) {
		if (value == 0) {
			clear_hostname();
			return 0;
		}
		m_hostname = value;
		int r = m_hostname.size();
		return r;
	}
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_port,value);
		return r;
	}
	if (0 == strcmp(name,"measurement")) {
		if (value == 0) {
			clear_measurement();
			return 0;
		}
		m_measurement = value;
		int r = m_measurement.size();
		return r;
	}
	if (0 == strcmp(name,"database")) {
		if (value == 0) {
			clear_database();
			return 0;
		}
		m_database = value;
		int r = m_database.size();
		return r;
	}
	return -76;
}

UartSettings::UartSettings()
: m_port(0)
, m_baudrate(0)
, m_config(0)
, m_rx_thresh(0)
, m_tx_bufsize(0)
, m_rx_bufsize(0)
, p_validbits(0)
{
}

void UartSettings::clear()
{
	m_port = 0;
	m_baudrate = 0;
	m_config = 0;
	m_rx_thresh = 0;
	m_tx_bufsize = 0;
	m_rx_bufsize = 0;
	p_validbits = 0;
}

void UartSettings::toASCII(stream &o, size_t indent) const
{
	o << "UartSettings {";
	++indent;
	ascii_numeric(o, indent, "port", (unsigned) m_port);
	ascii_numeric(o, indent, "baudrate", m_baudrate);
	ascii_numeric(o, indent, "config", m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".wl = " ;
	o << uart_wl_t_str(config_wl());
	o << ';';
	ascii_indent(o,indent);
	o << ".sb = " ;
	o << uart_sb_t_str(config_sb());
	o << ';';
	ascii_indent(o,indent);
	o << ".rts = " ;
	o << (config_rts() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".cts = " ;
	o << (config_cts() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".p = " ;
	o << uart_p_t_str(config_p());
	o << ';';
	ascii_indent(o,indent);
	o << ".ref_tick = " ;
	o << (config_ref_tick() ? "true;" : "false;");
	--indent;
	ascii_numeric(o, indent, "rx_thresh", (unsigned) m_rx_thresh);
	ascii_numeric(o, indent, "tx_bufsize", m_tx_bufsize);
	ascii_numeric(o, indent, "rx_bufsize", m_rx_bufsize);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t UartSettings::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -77;
		a += x;
		switch (fid) {
		case 0x8:	// port id 1, type uint8_t, coding varint
			set_port((uint8_t)ud.u32);
			break;
		case 0x10:	// baudrate id 2, type uint32_t, coding varint
			set_baudrate((uint32_t)ud.u32);
			break;
		case 0x1c:	// config id 3, type uartcfg_t, coding 16bit
			set_config((uartcfg_t) ud.u16);
			break;
		case 0x23:	// rx_thresh id 4, type uint8_t, coding 8bit
			set_rx_thresh(ud.u8);
			break;
		case 0x30:	// tx_bufsize id 6, type uint32_t, coding varint
			set_tx_bufsize((uint32_t)ud.u32);
			break;
		case 0x38:	// rx_bufsize id 7, type uint32_t, coding varint
			set_rx_bufsize((uint32_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -78;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -79;
	return a-(const uint8_t *)b;
}

ssize_t UartSettings::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -80;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_port);
		if (n <= 0)
			return -81;
		a += n;
	}
	// has baudrate?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'baudrate': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -82;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_baudrate);
		if (n <= 0)
			return -83;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'config': id=3, encoding=16bit, tag=0x1c
		if (a >= e)
			return -84;
		*a++ = 0x1c;
		write_u16(a,m_config);
		a += 2;
	}
	// has rx_thresh?
	if (m_rx_thresh != 0) {
		// 'rx_thresh': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -85;
		*a++ = 0x23;
		*a++ = m_rx_thresh;
	}
	// has tx_bufsize?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'tx_bufsize': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -86;
		*a++ = 0x30;
		n = write_varint(a,e-a,m_tx_bufsize);
		if (n <= 0)
			return -87;
		a += n;
	}
	// has rx_bufsize?
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'rx_bufsize': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -88;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_rx_bufsize);
		if (n <= 0)
			return -89;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void UartSettings::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		to_decstr(json,(unsigned) m_port);
	}
	if (has_baudrate()) {
		fsep = json_indent(json,indLvl,fsep,"baudrate");
		to_decstr(json,m_baudrate);
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (has_rx_thresh()) {
		fsep = json_indent(json,indLvl,fsep,"rx_thresh");
		to_decstr(json,(unsigned) m_rx_thresh);
	}
	if (has_tx_bufsize()) {
		fsep = json_indent(json,indLvl,fsep,"tx_bufsize");
		to_decstr(json,m_tx_bufsize);
	}
	if (has_rx_bufsize()) {
		fsep = json_indent(json,indLvl,fsep,"rx_bufsize");
		to_decstr(json,m_rx_bufsize);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t UartSettings::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional uint8 port, id 1
	if (has_port()) {
		r += wiresize((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional unsigned baudrate, id 2
	if (has_baudrate()) {
		r += wiresize((varint_t)m_baudrate) + 1 /* tag(baudrate) 0x10 */;
	}
	// optional uartcfg_t config, id 3
	if (has_config()) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	// optional fixed8 rx_thresh, id 4
	if (has_rx_thresh()) {
		r += 2;
	}
	// optional unsigned tx_bufsize, id 6
	if (has_tx_bufsize()) {
		r += wiresize((varint_t)m_tx_bufsize) + 1 /* tag(tx_bufsize) 0x30 */;
	}
	// optional unsigned rx_bufsize, id 7
	if (has_rx_bufsize()) {
		r += wiresize((varint_t)m_rx_bufsize) + 1 /* tag(rx_bufsize) 0x38 */;
	}
	return r;
}

bool UartSettings::operator == (const UartSettings &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_port() && (!(m_port == r.m_port)))
		return false;
	if (has_baudrate() && (!(m_baudrate == r.m_baudrate)))
		return false;
	if (has_config() && (!(m_config == r.m_config)))
		return false;
	if (has_rx_thresh() && (!(m_rx_thresh == r.m_rx_thresh)))
		return false;
	if (has_tx_bufsize() && (!(m_tx_bufsize == r.m_tx_bufsize)))
		return false;
	if (has_rx_bufsize() && (!(m_rx_bufsize == r.m_rx_bufsize)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int UartSettings::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u8(&m_port,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"baudrate")) {
		if (value == 0) {
			clear_baudrate();
			return 0;
		}
		int r = parse_ascii_u32(&m_baudrate,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((uartcfg_t)ull);
			else if (!strcmp(name,"wl"))
				set_config_wl((uart_wl_t)ull);
			else if (!strcmp(name,"sb"))
				set_config_sb((uart_sb_t)ull);
			else if (!strcmp(name,"rts"))
				set_config_rts((bool)ull);
			else if (!strcmp(name,"cts"))
				set_config_cts((bool)ull);
			else if (!strcmp(name,"p"))
				set_config_p((uart_p_t)ull);
			else if (!strcmp(name,"ref_tick"))
				set_config_ref_tick((bool)ull);
			return eptr - value;
		}
		#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		if (*name++ != '.') {
			return -90;
		} else if (!strcmp(name,"wl")) {
			uart_wl_t tmp;
			size_t r = parse_ascii_uart_wl_t(&tmp,value);
			if (r)
				set_config(tmp);
			return r;
		} else if (!strcmp(name,"sb")) {
			uart_sb_t tmp;
			size_t r = parse_ascii_uart_sb_t(&tmp,value);
			if (r)
				set_config(tmp);
			return r;
		} else if (!strcmp(name,"rts")) {
			bool tmp;
			size_t r = parse_ascii_bool(&tmp,value);
			if (r)
				set_config(tmp);
			return r;
		} else if (!strcmp(name,"cts")) {
			bool tmp;
			size_t r = parse_ascii_bool(&tmp,value);
			if (r)
				set_config(tmp);
			return r;
		} else if (!strcmp(name,"p")) {
			uart_p_t tmp;
			size_t r = parse_ascii_uart_p_t(&tmp,value);
			if (r)
				set_config(tmp);
			return r;
		} else if (!strcmp(name,"ref_tick")) {
			bool tmp;
			size_t r = parse_ascii_bool(&tmp,value);
			if (r)
				set_config(tmp);
			return r;
		}
		#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	}
	if (0 == strcmp(name,"rx_thresh")) {
		if (value == 0) {
			clear_rx_thresh();
			return 0;
		}
		int r = parse_ascii_u8(&m_rx_thresh,value);
		return r;
	}
	if (0 == strcmp(name,"tx_bufsize")) {
		if (value == 0) {
			clear_tx_bufsize();
			return 0;
		}
		int r = parse_ascii_u32(&m_tx_bufsize,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	if (0 == strcmp(name,"rx_bufsize")) {
		if (value == 0) {
			clear_rx_bufsize();
			return 0;
		}
		int r = parse_ascii_u32(&m_rx_bufsize,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 4);
		return r;
	}
	return -91;
}

FtpHttpConfig::FtpHttpConfig()
: m_port(0)
, m_start(true)
, m_root()
, m_uploaddir()
, p_validbits(0)
{
}

void FtpHttpConfig::clear()
{
	m_port = 0;
	m_start = true;
	m_root.clear();
	m_uploaddir.clear();
	p_validbits = 0;
}

void FtpHttpConfig::toASCII(stream &o, size_t indent) const
{
	o << "FtpHttpConfig {";
	++indent;
	ascii_numeric(o, indent, "port", m_port);
	ascii_indent(o,indent,"start");
	o << (m_start ? "true" : "false") << ';';
	ascii_indent(o,indent,"root");
	ascii_string(o,m_root.data(),m_root.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"uploaddir");
	ascii_string(o,m_uploaddir.data(),m_uploaddir.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t FtpHttpConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -92;
		a += x;
		switch (fid) {
		case 0xc:	// port id 1, type uint16_t, coding 16bit
			set_port(ud.u16);
			break;
		case 0x13:	// start id 2, type bool, coding 8bit
			set_start(ud.u8);
			break;
		case 0x1a:	// root id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -93;
			}
			m_root.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x22:	// uploaddir id 4, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -94;
			}
			m_uploaddir.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -95;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -96;
	return a-(const uint8_t *)b;
}

ssize_t FtpHttpConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (m_port != 0) {
		// 'port': id=1, encoding=16bit, tag=0xc
		if (3 > (e-a))
			return -97;
		*a++ = 0xc;
		write_u16(a,m_port);
		a += 2;
	}
	// has start?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'start': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -98;
		*a++ = 0x13;
		*a++ = m_start;
	}
	// has root?
	if (!m_root.empty()) {
		// 'root': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -99;
		*a++ = 0x1a;
		n = encode_bytes(m_root,a,e);
		if (n < 0)
			return -100;
		a += n;
	}
	// has uploaddir?
	if (!m_uploaddir.empty()) {
		// 'uploaddir': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -101;
		*a++ = 0x22;
		n = encode_bytes(m_uploaddir,a,e);
		if (n < 0)
			return -102;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void FtpHttpConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		to_decstr(json,m_port);
	}
	if (has_start()) {
		fsep = json_indent(json,indLvl,fsep,"start");
		json << (m_start ? "true" : "false");
	}
	if (has_root()) {
		fsep = json_indent(json,indLvl,fsep,"root");
		json_cstr(json,m_root.c_str());
	}
	if (has_uploaddir()) {
		fsep = json_indent(json,indLvl,fsep,"uploaddir");
		json_cstr(json,m_uploaddir.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t FtpHttpConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed16 port, id 1
	if (has_port()) {
		r += 3;
	}
	// optional bool start, id 2
	if (has_start()) {
		r += 2;
	}
	// optional string root, id 3
	if (has_root()) {
		size_t root_s = m_root.size();
		r += root_s + wiresize(root_s) + 1 /* tag(root) 0x18 */;
	}
	// optional string uploaddir, id 4
	if (has_uploaddir()) {
		size_t uploaddir_s = m_uploaddir.size();
		r += uploaddir_s + wiresize(uploaddir_s) + 1 /* tag(uploaddir) 0x20 */;
	}
	return r;
}

bool FtpHttpConfig::operator == (const FtpHttpConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_port() && (!(m_port == r.m_port)))
		return false;
	if (has_start() && (!(m_start == r.m_start)))
		return false;
	if (has_root() && (!(m_root == r.m_root)))
		return false;
	if (has_uploaddir() && (!(m_uploaddir == r.m_uploaddir)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int FtpHttpConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_port,value);
		return r;
	}
	if (0 == strcmp(name,"start")) {
		if (value == 0) {
			clear_start();
			return 0;
		}
		int r = parse_ascii_bool(&m_start,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"root")) {
		if (value == 0) {
			clear_root();
			return 0;
		}
		m_root = value;
		int r = m_root.size();
		return r;
	}
	if (0 == strcmp(name,"uploaddir")) {
		if (value == 0) {
			clear_uploaddir();
			return 0;
		}
		m_uploaddir = value;
		int r = m_uploaddir.size();
		return r;
	}
	return -103;
}

TerminalConfig::TerminalConfig()
: m_uart_rx(-1)
, m_uart_tx(-1)
, m_name()
, p_validbits(0)
{
}

void TerminalConfig::clear()
{
	m_uart_rx = -1;
	m_uart_tx = -1;
	m_name.clear();
	p_validbits = 0;
}

void TerminalConfig::toASCII(stream &o, size_t indent) const
{
	o << "TerminalConfig {";
	++indent;
	ascii_numeric(o, indent, "uart_rx", (signed) m_uart_rx);
	ascii_numeric(o, indent, "uart_tx", (signed) m_uart_tx);
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t TerminalConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -104;
		a += x;
		switch (fid) {
		case 0x8:	// uart_rx id 1, type int8_t, coding signed varint
			set_uart_rx(varint_sint(ud.u8));
			break;
		case 0x10:	// uart_tx id 2, type int8_t, coding signed varint
			set_uart_tx(varint_sint(ud.u8));
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -105;
			}
			m_name.assign((const char*)a,ud.vi);
			p_validbits |= ((uint8_t)1U << 0);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -106;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -107;
	return a-(const uint8_t *)b;
}

ssize_t TerminalConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has uart_rx?
	if (m_uart_rx != -1) {
		// 'uart_rx': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -108;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_uart_rx));
		if (n <= 0)
			return -109;
		a += n;
	}
	// has uart_tx?
	if (m_uart_tx != -1) {
		// 'uart_tx': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -110;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_uart_tx));
		if (n <= 0)
			return -111;
		a += n;
	}
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -112;
		*a++ = 0x1a;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -113;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void TerminalConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_uart_rx()) {
		fsep = json_indent(json,indLvl,fsep,"uart_rx");
		to_decstr(json,(int) m_uart_rx);
	}
	if (has_uart_tx()) {
		fsep = json_indent(json,indLvl,fsep,"uart_tx");
		to_decstr(json,(int) m_uart_tx);
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TerminalConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 uart_rx, id 1
	if (has_uart_rx()) {
		r += wiresize_s((varint_t)m_uart_rx) + 1 /* tag(uart_rx) 0x8 */;
	}
	// optional sint8 uart_tx, id 2
	if (has_uart_tx()) {
		r += wiresize_s((varint_t)m_uart_tx) + 1 /* tag(uart_tx) 0x10 */;
	}
	// optional string name, id 3
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	return r;
}

bool TerminalConfig::operator == (const TerminalConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_uart_rx() && (!(m_uart_rx == r.m_uart_rx)))
		return false;
	if (has_uart_tx() && (!(m_uart_tx == r.m_uart_tx)))
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TerminalConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"uart_rx")) {
		if (value == 0) {
			clear_uart_rx();
			return 0;
		}
		int r = parse_ascii_s8(&m_uart_rx,value);
		return r;
	}
	if (0 == strcmp(name,"uart_tx")) {
		if (value == 0) {
			clear_uart_tx();
			return 0;
		}
		int r = parse_ascii_s8(&m_uart_tx,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	return -114;
}

Trigger::Trigger()
: m_event()
, m_action()
, p_validbits(0)
{
}

void Trigger::clear()
{
	m_event.clear();
	m_action.clear();
	p_validbits = 0;
}

void Trigger::toASCII(stream &o, size_t indent) const
{
	o << "Trigger {";
	++indent;
	ascii_indent(o,indent,"event");
	ascii_string(o,m_event.data(),m_event.size(),indent+2);
	o << ';';
	ascii_indent(o,indent);
	size_t s_action = m_action.size();
	o << "action[" << s_action << "] = {";
	++indent;
	for (size_t i = 0, e = s_action; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,m_action[i].data(),m_action[i].size(),indent+2);
		o << ';';
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Trigger::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -115;
		a += x;
		switch (fid) {
		case 0xa:	// event id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -116;
			}
			m_event.assign((const char*)a,ud.vi);
			p_validbits |= ((uint8_t)1U << 0);
			a += ud.vi;
			break;
		case 0x12:	// action id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -117;
			}
			m_action.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -118;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -119;
	return a-(const uint8_t *)b;
}

ssize_t Trigger::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has event?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'event': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -120;
		*a++ = 0xa;
		n = encode_bytes(m_event,a,e);
		if (n < 0)
			return -121;
		a += n;
	}
	for (const auto &x : m_action) {
		// 'action': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -122;
		*a++ = 0x12;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -123;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Trigger::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_event()) {
		fsep = json_indent(json,indLvl,fsep,"event");
		json_cstr(json,m_event.c_str());
	}
	if (size_t s = m_action.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"action\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_action[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Trigger::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string event, id 1
	if (has_event()) {
		size_t event_s = m_event.size();
		r += event_s + wiresize(event_s) + 1 /* tag(event) 0x8 */;
	}
	// repeated string action, id 2
	if (!m_action.empty()) {
		// action: repeated estring
		for (size_t x = 0, y = m_action.size(); x < y; ++x) {
			size_t s = m_action[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(action) 0x10 */;
		}
	}
	return r;
}

bool Trigger::operator == (const Trigger &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_event() && (!(m_event == r.m_event)))
		return false;
	if (!(m_action == r.m_action))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Trigger::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"event")) {
		if (value == 0) {
			clear_event();
			return 0;
		}
		m_event = value;
		int r = m_event.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == memcmp(name,"action",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_action();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_action.size();
				m_action.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -124;
				if (m_action.size() <= x)
					return -125;
				if ((idxe[1] == 0) && (value == 0)) {
					m_action.erase(m_action.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -126;
			m_action[x] = value;
			return m_action[x].size();
		}
	}
	return -127;
}

AppParam::AppParam()
: m_key()
, m_uValue(0)
, m_sValue()
, m_dValue(0)
, m_fValue(0)
, p_validbits(0)
{
}

void AppParam::clear()
{
	m_key.clear();
	m_uValue = 0;
	m_sValue.clear();
	m_dValue = 0;
	m_fValue = 0;
	p_validbits = 0;
}

void AppParam::toASCII(stream &o, size_t indent) const
{
	o << "AppParam {";
	++indent;
	ascii_indent(o,indent,"key");
	ascii_string(o,m_key.data(),m_key.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "uValue", m_uValue);
	ascii_indent(o,indent,"sValue");
	ascii_string(o,m_sValue.data(),m_sValue.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "dValue", m_dValue);
	ascii_indent(o,indent,"fValue");
	ascii_numeric(o, indent, "fValue", m_fValue);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AppParam::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -128;
		a += x;
		switch (fid) {
		case 0xa:	// key id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -129;
			}
			m_key.assign((const char*)a,ud.vi);
			p_validbits |= ((uint8_t)1U << 0);
			a += ud.vi;
			break;
		case 0x10:	// uValue id 2, type uint32_t, coding varint
			set_uValue((uint32_t)ud.u32);
			break;
		case 0x1a:	// sValue id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -130;
			}
			m_sValue.assign((const char*)a,ud.vi);
			p_validbits |= ((uint8_t)1U << 2);
			a += ud.vi;
			break;
		case 0x20:	// dValue id 4, type int32_t, coding signed varint
			set_dValue(varint_sint(ud.u32));
			break;
		case 0x29:	// fValue id 5, type double, coding 64bit
			set_fValue(ud.d);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -131;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -132;
	return a-(const uint8_t *)b;
}

ssize_t AppParam::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has key?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'key': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -133;
		*a++ = 0xa;
		n = encode_bytes(m_key,a,e);
		if (n < 0)
			return -134;
		a += n;
	}
	// has uValue?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'uValue': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -135;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_uValue);
		if (n <= 0)
			return -136;
		a += n;
	}
	// has sValue?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'sValue': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -137;
		*a++ = 0x1a;
		n = encode_bytes(m_sValue,a,e);
		if (n < 0)
			return -138;
		a += n;
	}
	// has dValue?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'dValue': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -139;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_dValue));
		if (n <= 0)
			return -140;
		a += n;
	}
	// has fValue?
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'fValue': id=5, encoding=64bit, tag=0x29
		if (9 > (e-a))
			return -141;
		*a++ = 0x29;
		write_u64(a,mangle_double(m_fValue));
		a += 8;
	}
	assert(a <= e);
	return a-b;
}

void AppParam::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_key()) {
		fsep = json_indent(json,indLvl,fsep,"key");
		json_cstr(json,m_key.c_str());
	}
	if (has_uValue()) {
		fsep = json_indent(json,indLvl,fsep,"uValue");
		to_decstr(json,m_uValue);
	}
	if (has_sValue()) {
		fsep = json_indent(json,indLvl,fsep,"sValue");
		json_cstr(json,m_sValue.c_str());
	}
	if (has_dValue()) {
		fsep = json_indent(json,indLvl,fsep,"dValue");
		to_decstr(json,m_dValue);
	}
	if (has_fValue()) {
		fsep = json_indent(json,indLvl,fsep,"fValue");
		to_dblstr(json,m_fValue);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AppParam::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string key, id 1
	if (has_key()) {
		size_t key_s = m_key.size();
		r += key_s + wiresize(key_s) + 1 /* tag(key) 0x8 */;
	}
	// optional unsigned uValue, id 2
	if (has_uValue()) {
		r += wiresize((varint_t)m_uValue) + 1 /* tag(uValue) 0x10 */;
	}
	// optional string sValue, id 3
	if (has_sValue()) {
		size_t sValue_s = m_sValue.size();
		r += sValue_s + wiresize(sValue_s) + 1 /* tag(sValue) 0x18 */;
	}
	// optional signed dValue, id 4
	if (has_dValue()) {
		r += wiresize_s((varint_t)m_dValue) + 1 /* tag(dValue) 0x20 */;
	}
	// optional double fValue, id 5
	if (has_fValue()) {
		r += 9;
	}
	return r;
}

bool AppParam::operator == (const AppParam &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_key() && (!(m_key == r.m_key)))
		return false;
	if (has_uValue() && (!(m_uValue == r.m_uValue)))
		return false;
	if (has_sValue() && (!(m_sValue == r.m_sValue)))
		return false;
	if (has_dValue() && (!(m_dValue == r.m_dValue)))
		return false;
	if (has_fValue() && (!(m_fValue == r.m_fValue)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AppParam::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"key")) {
		if (value == 0) {
			clear_key();
			return 0;
		}
		m_key = value;
		int r = m_key.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"uValue")) {
		if (value == 0) {
			clear_uValue();
			return 0;
		}
		int r = parse_ascii_u32(&m_uValue,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"sValue")) {
		if (value == 0) {
			clear_sValue();
			return 0;
		}
		m_sValue = value;
		int r = m_sValue.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"dValue")) {
		if (value == 0) {
			clear_dValue();
			return 0;
		}
		int r = parse_ascii_s32(&m_dValue,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	if (0 == strcmp(name,"fValue")) {
		if (value == 0) {
			clear_fValue();
			return 0;
		}
		int r = parse_ascii_dbl(&m_fValue,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 4);
		return r;
	}
	return -142;
}

EventTimer::EventTimer()
: m_name()
, m_time(0)
, m_config(0)
, p_validbits(0)
{
}

void EventTimer::clear()
{
	m_name.clear();
	m_time = 0;
	m_config = 0;
	p_validbits = 0;
}

void EventTimer::toASCII(stream &o, size_t indent) const
{
	o << "EventTimer {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "time", m_time);
	ascii_numeric(o, indent, "config", (unsigned) m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".restart = " ;
	o << (config_restart() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".autostart = " ;
	o << (config_autostart() ? "true;" : "false;");
	--indent;
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t EventTimer::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -143;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -144;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// time id 2, type uint32_t, coding varint
			set_time((uint32_t)ud.u32);
			break;
		case 0x18:	// config id 3, type eventcfg_t, coding varint
			set_config((eventcfg_t) (eventcfg_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -145;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -146;
	return a-(const uint8_t *)b;
}

ssize_t EventTimer::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -147;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -148;
		a += n;
	}
	// has time?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'time': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -149;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_time);
		if (n <= 0)
			return -150;
		a += n;
	}
	// has config?
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -151;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -152;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void EventTimer::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_time()) {
		fsep = json_indent(json,indLvl,fsep,"time");
		to_decstr(json,m_time);
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t EventTimer::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional unsigned time, id 2
	if (has_time()) {
		r += wiresize((varint_t)m_time) + 1 /* tag(time) 0x10 */;
	}
	// optional eventcfg_t config, id 3
	if (has_config()) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	return r;
}

bool EventTimer::operator == (const EventTimer &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_time() && (!(m_time == r.m_time)))
		return false;
	if (has_config() && (!(m_config == r.m_config)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int EventTimer::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"time")) {
		if (value == 0) {
			clear_time();
			return 0;
		}
		int r = parse_ascii_u32(&m_time,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((eventcfg_t)ull);
			else if (!strcmp(name,"restart"))
				set_config_restart((bool)ull);
			else if (!strcmp(name,"autostart"))
				set_config_autostart((bool)ull);
			return eptr - value;
		}
		#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		if (*name++ != '.') {
			return -153;
		} else if (!strcmp(name,"restart")) {
			bool tmp;
			size_t r = parse_ascii_bool(&tmp,value);
			if (r)
				set_config(tmp);
			return r;
		} else if (!strcmp(name,"autostart")) {
			bool tmp;
			size_t r = parse_ascii_bool(&tmp,value);
			if (r)
				set_config(tmp);
			return r;
		}
		#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	}
	return -154;
}

FunctionConfig::FunctionConfig()
: m_name()
, m_func()
, m_params()
, p_validbits(0)
{
}

void FunctionConfig::clear()
{
	m_name.clear();
	m_func.clear();
	m_params.clear();
	p_validbits = 0;
}

void FunctionConfig::toASCII(stream &o, size_t indent) const
{
	o << "FunctionConfig {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"func");
	ascii_string(o,m_func.data(),m_func.size(),indent+2);
	o << ';';
	ascii_indent(o,indent);
	size_t s_params = m_params.size();
	o << "params[" << s_params << "] = {";
	++indent;
	for (size_t i = 0, e = s_params; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,m_params[i].data(),m_params[i].size(),indent+2);
		o << ';';
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t FunctionConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -155;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -156;
			}
			m_name.assign((const char*)a,ud.vi);
			p_validbits |= ((uint8_t)1U << 0);
			a += ud.vi;
			break;
		case 0x12:	// func id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -157;
			}
			m_func.assign((const char*)a,ud.vi);
			p_validbits |= ((uint8_t)1U << 1);
			a += ud.vi;
			break;
		case 0x1a:	// params id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -158;
			}
			m_params.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -159;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -160;
	return a-(const uint8_t *)b;
}

ssize_t FunctionConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -161;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -162;
		a += n;
	}
	// has func?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'func': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -163;
		*a++ = 0x12;
		n = encode_bytes(m_func,a,e);
		if (n < 0)
			return -164;
		a += n;
	}
	for (const auto &x : m_params) {
		// 'params': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -165;
		*a++ = 0x1a;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -166;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void FunctionConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_func()) {
		fsep = json_indent(json,indLvl,fsep,"func");
		json_cstr(json,m_func.c_str());
	}
	if (size_t s = m_params.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"params\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_params[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t FunctionConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional string func, id 2
	if (has_func()) {
		size_t func_s = m_func.size();
		r += func_s + wiresize(func_s) + 1 /* tag(func) 0x10 */;
	}
	// repeated string params, id 3
	if (!m_params.empty()) {
		// params: repeated estring
		for (size_t x = 0, y = m_params.size(); x < y; ++x) {
			size_t s = m_params[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(params) 0x18 */;
		}
	}
	return r;
}

bool FunctionConfig::operator == (const FunctionConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_func() && (!(m_func == r.m_func)))
		return false;
	if (!(m_params == r.m_params))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int FunctionConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"func")) {
		if (value == 0) {
			clear_func();
			return 0;
		}
		m_func = value;
		int r = m_func.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == memcmp(name,"params",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_params();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_params.size();
				m_params.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -167;
				if (m_params.size() <= x)
					return -168;
				if ((idxe[1] == 0) && (value == 0)) {
					m_params.erase(m_params.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -169;
			m_params[x] = value;
			return m_params[x].size();
		}
	}
	return -170;
}

SignalConfig::SignalConfig()
: m_name()
, m_type(st_invalid)
, m_iv()
{
}

void SignalConfig::clear()
{
	m_name.clear();
	m_type = st_invalid;
	m_iv.clear();
}

void SignalConfig::toASCII(stream &o, size_t indent) const
{
	o << "SignalConfig {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"type");
	if (const char *v = sigtype_t_str(m_type))
		o << v;
	else
		o << m_type;
	o << ';';
	ascii_indent(o,indent,"iv");
	ascii_string(o,m_iv.data(),m_iv.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SignalConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -171;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -172;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// type id 2, type sigtype_t, coding varint
			set_type((sigtype_t) (sigtype_t)ud.u32);
			break;
		case 0x1a:	// iv id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -173;
			}
			m_iv.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -174;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -175;
	return a-(const uint8_t *)b;
}

ssize_t SignalConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -176;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -177;
		a += n;
	}
	// has type?
	if (m_type != st_invalid) {
		// 'type': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -178;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_type);
		if (n <= 0)
			return -179;
		a += n;
	}
	// has iv?
	if (!m_iv.empty()) {
		// 'iv': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -180;
		*a++ = 0x1a;
		n = encode_bytes(m_iv,a,e);
		if (n < 0)
			return -181;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void SignalConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_type()) {
		fsep = json_indent(json,indLvl,fsep,"type");
		if (const char *v = sigtype_t_str(m_type)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_type;
		}
	}
	if (has_iv()) {
		fsep = json_indent(json,indLvl,fsep,"iv");
		json_cstr(json,m_iv.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SignalConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sigtype_t type, id 2
	if (has_type()) {
		r += wiresize((varint_t)m_type) + 1 /* tag(type) 0x10 */;
	}
	// optional string iv, id 3
	if (has_iv()) {
		size_t iv_s = m_iv.size();
		r += iv_s + wiresize(iv_s) + 1 /* tag(iv) 0x18 */;
	}
	return r;
}

bool SignalConfig::operator == (const SignalConfig &r) const
{
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_type() && (!(m_type == r.m_type)))
		return false;
	if (has_iv() && (!(m_iv == r.m_iv)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SignalConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"type")) {
		if (value == 0) {
			clear_type();
			return 0;
		}
		sigtype_t v;
		size_t r = parse_ascii_sigtype_t(&v,value);
		if (r == 0)
			return -182;
		set_type(v);
		return r;
	}
	if (0 == strcmp(name,"iv")) {
		if (value == 0) {
			clear_iv();
			return 0;
		}
		m_iv = value;
		int r = m_iv.size();
		return r;
	}
	return -183;
}

OwDeviceConfig::OwDeviceConfig()
: m_id(0)
, m_name()
, p_validbits(0)
{
}

void OwDeviceConfig::clear()
{
	m_id = 0;
	m_name.clear();
	p_validbits = 0;
}

void OwDeviceConfig::toASCII(stream &o, size_t indent) const
{
	o << "OwDeviceConfig {";
	++indent;
	ascii_indent(o,indent,"id");
	id64_to_ascii(o,m_id);
	o << ';';
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t OwDeviceConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -184;
		a += x;
		switch (fid) {
		case 0x9:	// id id 1, type uint64_t, coding 64bit
			set_id(ud.u64);
			break;
		case 0x12:	// name id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -185;
			}
			m_name.assign((const char*)a,ud.vi);
			p_validbits |= ((uint8_t)1U << 1);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -186;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -187;
	return a-(const uint8_t *)b;
}

ssize_t OwDeviceConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has id?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'id': id=1, encoding=64bit, tag=0x9
		if (9 > (e-a))
			return -188;
		*a++ = 0x9;
		write_u64(a,(uint64_t)m_id);
		a += 8;
	}
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'name': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -189;
		*a++ = 0x12;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -190;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void OwDeviceConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_id()) {
		fsep = json_indent(json,indLvl,fsep,"id");
		to_decstr(json,m_id);
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t OwDeviceConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed64 id, id 1
	if (has_id()) {
		r += 9;
	}
	// optional string name, id 2
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x10 */;
	}
	return r;
}

bool OwDeviceConfig::operator == (const OwDeviceConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_id() && (!(m_id == r.m_id)))
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int OwDeviceConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"id")) {
		if (value == 0) {
			clear_id();
			return 0;
		}
		int r = parse_ascii_u64(&m_id,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	return -191;
}

NodeConfig::NodeConfig()
: m_magic(0)
, m_nodename()
, m_pass_hash()
, m_cpu_freq(0)
, m_station()
, m_softap()
, m_dns_server()
, m_syslog_host()
, m_sntp_server()
, m_timezone()
#ifdef CONFIG_MQTT
, m_mqtt()
#endif // CONFIG_MQTT
, m_dmesg_size(2048)
#ifdef CONFIG_INFLUX
, m_influx()
#endif // CONFIG_INFLUX
, m_station2ap_time(0)
, m_domainname()
, m_holidays()
, m_at_actions()
, m_actions_enable(1)
, m_triggers()
, m_uart()
, m_terminal()
, m_udp_ctrl_port(12719)
, m_debugs()
#ifdef CONFIG_FTP
, m_ftpd()
#endif // CONFIG_FTP
#ifdef CONFIG_HTTP
, m_httpd()
#endif // CONFIG_HTTP
, m_timefuses()
#ifdef CONFIG_SIGNAL_PROC
, m_signals()
#endif // CONFIG_SIGNAL_PROC
#ifdef CONFIG_SIGNAL_PROC
, m_functions()
#endif // CONFIG_SIGNAL_PROC
, m_max_on_time(0)
, m_threshold_off(0)
, m_threshold_on(0)
, m_dim_step(0)
, m_lightctrl(0)
, m_pwm_freq(0)
#ifdef CONFIG_APP_PARAMS
, m_app_params()
#endif // CONFIG_APP_PARAMS
#ifdef CONFIG_ONEWIRE
, m_owdevices()
#endif // CONFIG_ONEWIRE
, p_validbits(0)
{
}

void NodeConfig::clear()
{
	m_magic = 0;
	m_nodename.clear();
	m_pass_hash.clear();
	m_cpu_freq = 0;
	m_station.clear();
	m_softap.clear();
	m_dns_server.clear();
	m_syslog_host.clear();
	m_sntp_server.clear();
	m_timezone.clear();
	#ifdef CONFIG_MQTT
	m_mqtt.clear();
	#endif // CONFIG_MQTT
	m_dmesg_size = 2048;
	#ifdef CONFIG_INFLUX
	m_influx.clear();
	#endif // CONFIG_INFLUX
	m_station2ap_time = 0;
	m_domainname.clear();
	m_holidays.clear();
	m_at_actions.clear();
	m_actions_enable = 1;
	m_triggers.clear();
	m_uart.clear();
	m_terminal.clear();
	m_udp_ctrl_port = 12719;
	m_debugs.clear();
	#ifdef CONFIG_FTP
	m_ftpd.clear();
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	m_httpd.clear();
	#endif // CONFIG_HTTP
	m_timefuses.clear();
	#ifdef CONFIG_SIGNAL_PROC
	m_signals.clear();
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	m_functions.clear();
	#endif // CONFIG_SIGNAL_PROC
	m_max_on_time = 0;
	m_threshold_off = 0;
	m_threshold_on = 0;
	m_dim_step = 0;
	m_lightctrl = 0;
	m_pwm_freq = 0;
	#ifdef CONFIG_APP_PARAMS
	m_app_params.clear();
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_ONEWIRE
	m_owdevices.clear();
	#endif // CONFIG_ONEWIRE
	p_validbits = 0;
}

void NodeConfig::toASCII(stream &o, size_t indent) const
{
	o << "NodeConfig {";
	++indent;
	ascii_numeric(o, indent, "magic", m_magic);
	ascii_indent(o,indent,"nodename");
	ascii_string(o,m_nodename.data(),m_nodename.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"pass_hash");
	ascii_bytes(o,(const uint8_t*)m_pass_hash.data(),m_pass_hash.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "cpu_freq", m_cpu_freq);
	ascii_indent(o,indent,"station");
	m_station.toASCII(o,indent);
	ascii_indent(o,indent,"softap");
	m_softap.toASCII(o,indent);
	ascii_indent(o,indent);
	size_t s_dns_server = m_dns_server.size();
	o << "dns_server[" << s_dns_server << "] = {";
	++indent;
	for (size_t i = 0, e = s_dns_server; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,m_dns_server[i].data(),m_dns_server[i].size(),indent+2);
		o << ';';
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent,"syslog_host");
	ascii_string(o,m_syslog_host.data(),m_syslog_host.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"sntp_server");
	ascii_string(o,m_sntp_server.data(),m_sntp_server.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"timezone");
	ascii_string(o,m_timezone.data(),m_timezone.size(),indent+2);
	o << ';';
	#ifdef CONFIG_MQTT
	ascii_indent(o,indent,"mqtt");
	m_mqtt.toASCII(o,indent);
	#endif // CONFIG_MQTT
	ascii_numeric(o, indent, "dmesg_size", m_dmesg_size);
	#ifdef CONFIG_INFLUX
	ascii_indent(o,indent,"influx");
	m_influx.toASCII(o,indent);
	#endif // CONFIG_INFLUX
	ascii_numeric(o, indent, "station2ap_time", m_station2ap_time);
	ascii_indent(o,indent,"domainname");
	ascii_string(o,m_domainname.data(),m_domainname.size(),indent+2);
	o << ';';
	ascii_indent(o,indent);
	size_t s_holidays = m_holidays.size();
	o << "holidays[" << s_holidays << "] = {";
	++indent;
	for (size_t i = 0, e = s_holidays; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_holidays[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent);
	size_t s_at_actions = m_at_actions.size();
	o << "at_actions[" << s_at_actions << "] = {";
	++indent;
	for (size_t i = 0, e = s_at_actions; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_at_actions[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_numeric(o, indent, "actions_enable", m_actions_enable);
	ascii_indent(o,indent);
	size_t s_triggers = m_triggers.size();
	o << "triggers[" << s_triggers << "] = {";
	++indent;
	for (size_t i = 0, e = s_triggers; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_triggers[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent);
	size_t s_uart = m_uart.size();
	o << "uart[" << s_uart << "] = {";
	++indent;
	for (size_t i = 0, e = s_uart; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_uart[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent);
	size_t s_terminal = m_terminal.size();
	o << "terminal[" << s_terminal << "] = {";
	++indent;
	for (size_t i = 0, e = s_terminal; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_terminal[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_numeric(o, indent, "udp_ctrl_port", m_udp_ctrl_port);
	ascii_indent(o,indent);
	size_t s_debugs = m_debugs.size();
	o << "debugs[" << s_debugs << "] = {";
	++indent;
	for (size_t i = 0, e = s_debugs; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,m_debugs[i].data(),m_debugs[i].size(),indent+2);
		o << ';';
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_FTP
	ascii_indent(o,indent,"ftpd");
	m_ftpd.toASCII(o,indent);
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	ascii_indent(o,indent,"httpd");
	m_httpd.toASCII(o,indent);
	#endif // CONFIG_HTTP
	ascii_indent(o,indent);
	size_t s_timefuses = m_timefuses.size();
	o << "timefuses[" << s_timefuses << "] = {";
	++indent;
	for (size_t i = 0, e = s_timefuses; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_timefuses[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_SIGNAL_PROC
	ascii_indent(o,indent);
	size_t s_signals = m_signals.size();
	o << "signals[" << s_signals << "] = {";
	++indent;
	for (size_t i = 0, e = s_signals; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_signals[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	ascii_indent(o,indent);
	size_t s_functions = m_functions.size();
	o << "functions[" << s_functions << "] = {";
	++indent;
	for (size_t i = 0, e = s_functions; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_functions[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_SIGNAL_PROC
	ascii_numeric(o, indent, "max_on_time", m_max_on_time);
	ascii_numeric(o, indent, "threshold_off", m_threshold_off);
	ascii_numeric(o, indent, "threshold_on", m_threshold_on);
	ascii_numeric(o, indent, "dim_step", m_dim_step);
	ascii_indent(o,indent,"lightctrl");
	o << (m_lightctrl ? "true" : "false") << ';';
	ascii_numeric(o, indent, "pwm_freq", m_pwm_freq);
	#ifdef CONFIG_APP_PARAMS
	ascii_indent(o,indent);
	size_t s_app_params = m_app_params.size();
	o << "app_params[" << s_app_params << "] = {";
	++indent;
	for (size_t i = 0, e = s_app_params; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_app_params[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_ONEWIRE
	ascii_indent(o,indent);
	size_t s_owdevices = m_owdevices.size();
	o << "owdevices[" << s_owdevices << "] = {";
	++indent;
	for (size_t i = 0, e = s_owdevices; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_owdevices[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_ONEWIRE
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t NodeConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -192;
		a += x;
		switch (fid) {
		case 0x5:	// magic id 0, type uint32_t, coding 32bit
			set_magic(ud.u32);
			break;
		case 0xa:	// nodename id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -193;
			}
			m_nodename.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x12:	// pass_hash id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -194;
			}
			m_pass_hash.assign((const char*)a,ud.vi);
			p_validbits |= ((uint32_t)1U << 1);
			a += ud.vi;
			break;
		case 0x18:	// cpu_freq id 3, type uint32_t, coding varint
			set_cpu_freq((uint32_t)ud.u32);
			break;
		case 0x22:	// station id 4, type WifiConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_station.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -195;
				a += ud.vi;
			}
			p_validbits |= ((uint32_t)1U << 3);
			break;
		case 0x2a:	// softap id 5, type WifiConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_softap.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -196;
				a += ud.vi;
			}
			p_validbits |= ((uint32_t)1U << 4);
			break;
		case 0x32:	// dns_server id 6, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -197;
			}
			m_dns_server.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x3a:	// syslog_host id 7, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -198;
			}
			m_syslog_host.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x42:	// sntp_server id 8, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -199;
			}
			m_sntp_server.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x4a:	// timezone id 9, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -200;
			}
			m_timezone.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
			#ifdef CONFIG_MQTT
		case 0x52:	// mqtt id 10, type MQTT, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_mqtt.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -201;
				a += ud.vi;
			}
			p_validbits |= ((uint32_t)1U << 5);
			break;
			#endif // CONFIG_MQTT
		case 0x5c:	// dmesg_size id 11, type uint16_t, coding 16bit
			set_dmesg_size(ud.u16);
			break;
			#ifdef CONFIG_INFLUX
		case 0x62:	// influx id 12, type Influx, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_influx.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -202;
				a += ud.vi;
			}
			p_validbits |= ((uint32_t)1U << 7);
			break;
			#endif // CONFIG_INFLUX
		case 0x68:	// station2ap_time id 13, type uint32_t, coding varint
			set_station2ap_time((uint32_t)ud.u32);
			break;
		case 0x7a:	// domainname id 15, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -203;
			}
			m_domainname.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x82:	// holidays id 16, type Date, coding byte[]
			m_holidays.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_holidays.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -204;
				a += ud.vi;
			}
			break;
		case 0x8a:	// at_actions id 17, type AtAction, coding byte[]
			m_at_actions.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_at_actions.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -205;
				a += ud.vi;
			}
			break;
		case 0x90:	// actions_enable id 18, type uint32_t, coding varint
			set_actions_enable((uint32_t)ud.u32);
			break;
		case 0x9a:	// triggers id 19, type Trigger, coding byte[]
			m_triggers.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_triggers.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -206;
				a += ud.vi;
			}
			break;
		case 0xa2:	// uart id 20, type UartSettings, coding byte[]
			m_uart.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_uart.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -207;
				a += ud.vi;
			}
			break;
		case 0xaa:	// terminal id 21, type TerminalConfig, coding byte[]
			m_terminal.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_terminal.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -208;
				a += ud.vi;
			}
			break;
		case 0xb4:	// udp_ctrl_port id 22, type uint16_t, coding 16bit
			set_udp_ctrl_port(ud.u16);
			break;
		case 0xba:	// debugs id 23, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -209;
			}
			m_debugs.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
			#ifdef CONFIG_FTP
		case 0xc2:	// ftpd id 24, type FtpHttpConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_ftpd.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -210;
				a += ud.vi;
			}
			p_validbits |= ((uint32_t)1U << 11);
			break;
			#endif // CONFIG_FTP
			#ifdef CONFIG_HTTP
		case 0xca:	// httpd id 25, type FtpHttpConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_httpd.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -211;
				a += ud.vi;
			}
			p_validbits |= ((uint32_t)1U << 12);
			break;
			#endif // CONFIG_HTTP
		case 0xf2:	// timefuses id 30, type EventTimer, coding byte[]
			m_timefuses.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_timefuses.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -212;
				a += ud.vi;
			}
			break;
			#ifdef CONFIG_SIGNAL_PROC
		case 0xfa:	// signals id 31, type SignalConfig, coding byte[]
			m_signals.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_signals.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -213;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_SIGNAL_PROC
			#ifdef CONFIG_SIGNAL_PROC
		case 0x102:	// functions id 32, type FunctionConfig, coding byte[]
			m_functions.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_functions.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -214;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_SIGNAL_PROC
		case 0x110:	// max_on_time id 34, type uint32_t, coding varint
			set_max_on_time((uint32_t)ud.u32);
			break;
		case 0x118:	// threshold_off id 35, type uint32_t, coding varint
			set_threshold_off((uint32_t)ud.u32);
			break;
		case 0x120:	// threshold_on id 36, type uint32_t, coding varint
			set_threshold_on((uint32_t)ud.u32);
			break;
		case 0x128:	// dim_step id 37, type uint32_t, coding varint
			set_dim_step((uint32_t)ud.u32);
			break;
		case 0x133:	// lightctrl id 38, type bool, coding 8bit
			set_lightctrl(ud.u8);
			break;
		case 0x138:	// pwm_freq id 39, type uint32_t, coding varint
			set_pwm_freq((uint32_t)ud.u32);
			break;
			#ifdef CONFIG_APP_PARAMS
		case 0x142:	// app_params id 40, type AppParam, coding byte[]
			m_app_params.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_app_params.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -215;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_APP_PARAMS
			#ifdef CONFIG_ONEWIRE
		case 0x192:	// owdevices id 50, type OwDeviceConfig, coding byte[]
			m_owdevices.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_owdevices.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -216;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_ONEWIRE
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -217;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -218;
	return a-(const uint8_t *)b;
}

ssize_t NodeConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has magic?
	if (0 != (p_validbits & ((uint32_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		if (5 > (e-a))
			return -219;
		*a++ = 0x5;
		if ((e-a) < 4)
			return -220;
		write_u32(a,(uint32_t)m_magic);
		a += 4;
	}
	// has nodename?
	if (!m_nodename.empty()) {
		// 'nodename': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -221;
		*a++ = 0xa;
		n = encode_bytes(m_nodename,a,e);
		if (n < 0)
			return -222;
		a += n;
	}
	// has pass_hash?
	if (0 != (p_validbits & ((uint32_t)1U << 1))) {
		// 'pass_hash': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -223;
		*a++ = 0x12;
		n = encode_bytes(m_pass_hash,a,e);
		if (n < 0)
			return -224;
		a += n;
	}
	// has cpu_freq?
	if (0 != (p_validbits & ((uint32_t)1U << 2))) {
		// 'cpu_freq': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -225;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_cpu_freq);
		if (n <= 0)
			return -226;
		a += n;
	}
	// has station?
	if (0 != (p_validbits & ((uint32_t)1U << 3))) {
		// 'station': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -227;
		*a++ = 0x22;
		ssize_t station_ws = m_station.calcSize();
		n = write_varint(a,e-a,station_ws);
		a += n;
		if ((n <= 0) || (station_ws > (e-a)))
			return -228;
		n = m_station.toMemory(a,e-a);
		a += n;
		assert(n == station_ws);
	}
	// has softap?
	if (0 != (p_validbits & ((uint32_t)1U << 4))) {
		// 'softap': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -229;
		*a++ = 0x2a;
		ssize_t softap_ws = m_softap.calcSize();
		n = write_varint(a,e-a,softap_ws);
		a += n;
		if ((n <= 0) || (softap_ws > (e-a)))
			return -230;
		n = m_softap.toMemory(a,e-a);
		a += n;
		assert(n == softap_ws);
	}
	for (const auto &x : m_dns_server) {
		// 'dns_server': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -231;
		*a++ = 0x32;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -232;
		a += n;
	}
	// has syslog_host?
	if (!m_syslog_host.empty()) {
		// 'syslog_host': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -233;
		*a++ = 0x3a;
		n = encode_bytes(m_syslog_host,a,e);
		if (n < 0)
			return -234;
		a += n;
	}
	// has sntp_server?
	if (!m_sntp_server.empty()) {
		// 'sntp_server': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -235;
		*a++ = 0x42;
		n = encode_bytes(m_sntp_server,a,e);
		if (n < 0)
			return -236;
		a += n;
	}
	// has timezone?
	if (!m_timezone.empty()) {
		// 'timezone': id=9, encoding=lenpfx, tag=0x4a
		if (a >= e)
			return -237;
		*a++ = 0x4a;
		n = encode_bytes(m_timezone,a,e);
		if (n < 0)
			return -238;
		a += n;
	}
	#ifdef CONFIG_MQTT
	// has mqtt?
	if (0 != (p_validbits & ((uint32_t)1U << 5))) {
		// 'mqtt': id=10, encoding=lenpfx, tag=0x52
		if (a >= e)
			return -239;
		*a++ = 0x52;
		ssize_t mqtt_ws = m_mqtt.calcSize();
		n = write_varint(a,e-a,mqtt_ws);
		a += n;
		if ((n <= 0) || (mqtt_ws > (e-a)))
			return -240;
		n = m_mqtt.toMemory(a,e-a);
		a += n;
		assert(n == mqtt_ws);
	}
	#endif // CONFIG_MQTT
	// has dmesg_size?
	if (0 != (p_validbits & ((uint32_t)1U << 6))) {
		// 'dmesg_size': id=11, encoding=16bit, tag=0x5c
		if (3 > (e-a))
			return -241;
		*a++ = 0x5c;
		write_u16(a,m_dmesg_size);
		a += 2;
	}
	#ifdef CONFIG_INFLUX
	// has influx?
	if (0 != (p_validbits & ((uint32_t)1U << 7))) {
		// 'influx': id=12, encoding=lenpfx, tag=0x62
		if (a >= e)
			return -242;
		*a++ = 0x62;
		ssize_t influx_ws = m_influx.calcSize();
		n = write_varint(a,e-a,influx_ws);
		a += n;
		if ((n <= 0) || (influx_ws > (e-a)))
			return -243;
		n = m_influx.toMemory(a,e-a);
		a += n;
		assert(n == influx_ws);
	}
	#endif // CONFIG_INFLUX
	// has station2ap_time?
	if (0 != (p_validbits & ((uint32_t)1U << 8))) {
		// 'station2ap_time': id=13, encoding=varint, tag=0x68
		if (a >= e)
			return -244;
		*a++ = 0x68;
		n = write_varint(a,e-a,m_station2ap_time);
		if (n <= 0)
			return -245;
		a += n;
	}
	// has domainname?
	if (!m_domainname.empty()) {
		// 'domainname': id=15, encoding=lenpfx, tag=0x7a
		if (a >= e)
			return -246;
		*a++ = 0x7a;
		n = encode_bytes(m_domainname,a,e);
		if (n < 0)
			return -247;
		a += n;
	}
	for (const auto &x : m_holidays) {
		// 'holidays': id=16, encoding=lenpfx, tag=0x82
		if (2 > (e-a))
			return -248;
		*a++ = 0x82;
		*a++ = 0x1;
		ssize_t holidays_ws = x.calcSize();
		n = write_varint(a,e-a,holidays_ws);
		a += n;
		if ((n <= 0) || (holidays_ws > (e-a)))
			return -249;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == holidays_ws);
	}
	for (const auto &x : m_at_actions) {
		// 'at_actions': id=17, encoding=lenpfx, tag=0x8a
		if (2 > (e-a))
			return -250;
		*a++ = 0x8a;
		*a++ = 0x1;
		ssize_t at_actions_ws = x.calcSize();
		n = write_varint(a,e-a,at_actions_ws);
		a += n;
		if ((n <= 0) || (at_actions_ws > (e-a)))
			return -251;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == at_actions_ws);
	}
	// has actions_enable?
	if (0 != (p_validbits & ((uint32_t)1U << 9))) {
		// 'actions_enable': id=18, encoding=varint, tag=0x90
		if (2 > (e-a))
			return -252;
		*a++ = 0x90;
		*a++ = 0x1;
		n = write_varint(a,e-a,m_actions_enable);
		if (n <= 0)
			return -253;
		a += n;
	}
	for (const auto &x : m_triggers) {
		// 'triggers': id=19, encoding=lenpfx, tag=0x9a
		if (2 > (e-a))
			return -254;
		*a++ = 0x9a;
		*a++ = 0x1;
		ssize_t triggers_ws = x.calcSize();
		n = write_varint(a,e-a,triggers_ws);
		a += n;
		if ((n <= 0) || (triggers_ws > (e-a)))
			return -255;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == triggers_ws);
	}
	for (const auto &x : m_uart) {
		// 'uart': id=20, encoding=lenpfx, tag=0xa2
		if (2 > (e-a))
			return -256;
		*a++ = 0xa2;
		*a++ = 0x1;
		ssize_t uart_ws = x.calcSize();
		n = write_varint(a,e-a,uart_ws);
		a += n;
		if ((n <= 0) || (uart_ws > (e-a)))
			return -257;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == uart_ws);
	}
	for (const auto &x : m_terminal) {
		// 'terminal': id=21, encoding=lenpfx, tag=0xaa
		if (2 > (e-a))
			return -258;
		*a++ = 0xaa;
		*a++ = 0x1;
		ssize_t terminal_ws = x.calcSize();
		n = write_varint(a,e-a,terminal_ws);
		a += n;
		if ((n <= 0) || (terminal_ws > (e-a)))
			return -259;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == terminal_ws);
	}
	// has udp_ctrl_port?
	if (0 != (p_validbits & ((uint32_t)1U << 10))) {
		// 'udp_ctrl_port': id=22, encoding=16bit, tag=0xb4
		if (4 > (e-a))
			return -260;
		a += write_varint(a,e-a,0xb4);	// 'udp_ctrl_port': id=22
		write_u16(a,m_udp_ctrl_port);
		a += 2;
	}
	for (const auto &x : m_debugs) {
		// 'debugs': id=23, encoding=lenpfx, tag=0xba
		if (2 > (e-a))
			return -261;
		*a++ = 0xba;
		*a++ = 0x1;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -262;
		a += n;
	}
	#ifdef CONFIG_FTP
	// has ftpd?
	if (0 != (p_validbits & ((uint32_t)1U << 11))) {
		// 'ftpd': id=24, encoding=lenpfx, tag=0xc2
		if (2 > (e-a))
			return -263;
		*a++ = 0xc2;
		*a++ = 0x1;
		ssize_t ftpd_ws = m_ftpd.calcSize();
		n = write_varint(a,e-a,ftpd_ws);
		a += n;
		if ((n <= 0) || (ftpd_ws > (e-a)))
			return -264;
		n = m_ftpd.toMemory(a,e-a);
		a += n;
		assert(n == ftpd_ws);
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	// has httpd?
	if (0 != (p_validbits & ((uint32_t)1U << 12))) {
		// 'httpd': id=25, encoding=lenpfx, tag=0xca
		if (2 > (e-a))
			return -265;
		*a++ = 0xca;
		*a++ = 0x1;
		ssize_t httpd_ws = m_httpd.calcSize();
		n = write_varint(a,e-a,httpd_ws);
		a += n;
		if ((n <= 0) || (httpd_ws > (e-a)))
			return -266;
		n = m_httpd.toMemory(a,e-a);
		a += n;
		assert(n == httpd_ws);
	}
	#endif // CONFIG_HTTP
	for (const auto &x : m_timefuses) {
		// 'timefuses': id=30, encoding=lenpfx, tag=0xf2
		if (2 > (e-a))
			return -267;
		*a++ = 0xf2;
		*a++ = 0x1;
		ssize_t timefuses_ws = x.calcSize();
		n = write_varint(a,e-a,timefuses_ws);
		a += n;
		if ((n <= 0) || (timefuses_ws > (e-a)))
			return -268;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == timefuses_ws);
	}
	#ifdef CONFIG_SIGNAL_PROC
	for (const auto &x : m_signals) {
		// 'signals': id=31, encoding=lenpfx, tag=0xfa
		if (2 > (e-a))
			return -269;
		*a++ = 0xfa;
		*a++ = 0x1;
		ssize_t signals_ws = x.calcSize();
		n = write_varint(a,e-a,signals_ws);
		a += n;
		if ((n <= 0) || (signals_ws > (e-a)))
			return -270;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == signals_ws);
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	for (const auto &x : m_functions) {
		// 'functions': id=32, encoding=lenpfx, tag=0x102
		if (2 > (e-a))
			return -271;
		*a++ = 0x82;
		*a++ = 0x2;
		ssize_t functions_ws = x.calcSize();
		n = write_varint(a,e-a,functions_ws);
		a += n;
		if ((n <= 0) || (functions_ws > (e-a)))
			return -272;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == functions_ws);
	}
	#endif // CONFIG_SIGNAL_PROC
	// 'max_on_time' is deprecated. Therefore no data will be written.
	// has threshold_off?
	if (0 != (p_validbits & ((uint32_t)1U << 13))) {
		// 'threshold_off': id=35, encoding=varint, tag=0x118
		if (2 > (e-a))
			return -273;
		*a++ = 0x98;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_threshold_off);
		if (n <= 0)
			return -274;
		a += n;
	}
	// has threshold_on?
	if (0 != (p_validbits & ((uint32_t)1U << 14))) {
		// 'threshold_on': id=36, encoding=varint, tag=0x120
		if (2 > (e-a))
			return -275;
		*a++ = 0xa0;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_threshold_on);
		if (n <= 0)
			return -276;
		a += n;
	}
	// has dim_step?
	if (0 != (p_validbits & ((uint32_t)1U << 15))) {
		// 'dim_step': id=37, encoding=varint, tag=0x128
		if (2 > (e-a))
			return -277;
		*a++ = 0xa8;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_dim_step);
		if (n <= 0)
			return -278;
		a += n;
	}
	// has lightctrl?
	if (0 != (p_validbits & ((uint32_t)1U << 16))) {
		// 'lightctrl': id=38, encoding=8bit, tag=0x133
		if (3 > (e-a))
			return -279;
		a += write_varint(a,e-a,0x133);	// 'lightctrl': id=38
		*a++ = m_lightctrl;
	}
	// has pwm_freq?
	if (0 != (p_validbits & ((uint32_t)1U << 17))) {
		// 'pwm_freq': id=39, encoding=varint, tag=0x138
		if (2 > (e-a))
			return -280;
		*a++ = 0xb8;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_pwm_freq);
		if (n <= 0)
			return -281;
		a += n;
	}
	#ifdef CONFIG_APP_PARAMS
	for (const auto &x : m_app_params) {
		// 'app_params': id=40, encoding=lenpfx, tag=0x142
		if (2 > (e-a))
			return -282;
		*a++ = 0xc2;
		*a++ = 0x2;
		ssize_t app_params_ws = x.calcSize();
		n = write_varint(a,e-a,app_params_ws);
		a += n;
		if ((n <= 0) || (app_params_ws > (e-a)))
			return -283;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == app_params_ws);
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_ONEWIRE
	for (const auto &x : m_owdevices) {
		// 'owdevices': id=50, encoding=lenpfx, tag=0x192
		if (2 > (e-a))
			return -284;
		*a++ = 0x92;
		*a++ = 0x3;
		ssize_t owdevices_ws = x.calcSize();
		n = write_varint(a,e-a,owdevices_ws);
		a += n;
		if ((n <= 0) || (owdevices_ws > (e-a)))
			return -285;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == owdevices_ws);
	}
	#endif // CONFIG_ONEWIRE
	assert(a <= e);
	return a-b;
}

void NodeConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_magic()) {
		fsep = json_indent(json,indLvl,fsep,"magic");
		to_decstr(json,m_magic);
	}
	if (has_nodename()) {
		fsep = json_indent(json,indLvl,fsep,"nodename");
		json_cstr(json,m_nodename.c_str());
	}
	if (has_pass_hash()) {
		fsep = json_indent(json,indLvl,fsep,"pass_hash");
		json_string(json,m_pass_hash);
	}
	if (has_cpu_freq()) {
		fsep = json_indent(json,indLvl,fsep,"cpu_freq");
		to_decstr(json,m_cpu_freq);
	}
	if (has_station()) {
		fsep = json_indent(json,indLvl,fsep,"station");
		m_station.toJSON(json,indLvl);
	}
	if (has_softap()) {
		fsep = json_indent(json,indLvl,fsep,"softap");
		m_softap.toJSON(json,indLvl);
	}
	if (size_t s = m_dns_server.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"dns_server\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_dns_server[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (has_syslog_host()) {
		fsep = json_indent(json,indLvl,fsep,"syslog_host");
		json_cstr(json,m_syslog_host.c_str());
	}
	if (has_sntp_server()) {
		fsep = json_indent(json,indLvl,fsep,"sntp_server");
		json_cstr(json,m_sntp_server.c_str());
	}
	if (has_timezone()) {
		fsep = json_indent(json,indLvl,fsep,"timezone");
		json_cstr(json,m_timezone.c_str());
	}
	#ifdef CONFIG_MQTT
	if (has_mqtt()) {
		fsep = json_indent(json,indLvl,fsep,"mqtt");
		m_mqtt.toJSON(json,indLvl);
	}
	#endif // CONFIG_MQTT
	if (has_dmesg_size()) {
		fsep = json_indent(json,indLvl,fsep,"dmesg_size");
		to_decstr(json,m_dmesg_size);
	}
	#ifdef CONFIG_INFLUX
	if (has_influx()) {
		fsep = json_indent(json,indLvl,fsep,"influx");
		m_influx.toJSON(json,indLvl);
	}
	#endif // CONFIG_INFLUX
	if (has_station2ap_time()) {
		fsep = json_indent(json,indLvl,fsep,"station2ap_time");
		to_decstr(json,m_station2ap_time);
	}
	if (has_domainname()) {
		fsep = json_indent(json,indLvl,fsep,"domainname");
		json_cstr(json,m_domainname.c_str());
	}
	if (size_t s = m_holidays.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"holidays\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_holidays[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_at_actions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"at_actions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_at_actions[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (has_actions_enable()) {
		fsep = json_indent(json,indLvl,fsep,"actions_enable");
		to_decstr(json,m_actions_enable);
	}
	if (size_t s = m_triggers.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"triggers\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_triggers[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_uart.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"uart\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_uart[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_terminal.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"terminal\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_terminal[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (has_udp_ctrl_port()) {
		fsep = json_indent(json,indLvl,fsep,"udp_ctrl_port");
		to_decstr(json,m_udp_ctrl_port);
	}
	if (size_t s = m_debugs.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"debugs\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_debugs[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_FTP
	if (has_ftpd()) {
		fsep = json_indent(json,indLvl,fsep,"ftpd");
		m_ftpd.toJSON(json,indLvl);
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (has_httpd()) {
		fsep = json_indent(json,indLvl,fsep,"httpd");
		m_httpd.toJSON(json,indLvl);
	}
	#endif // CONFIG_HTTP
	if (size_t s = m_timefuses.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"timefuses\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_timefuses[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_SIGNAL_PROC
	if (size_t s = m_signals.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"signals\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_signals[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	if (size_t s = m_functions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"functions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_functions[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_SIGNAL_PROC
	if (has_max_on_time()) {
		fsep = json_indent(json,indLvl,fsep,"max_on_time");
		to_decstr(json,m_max_on_time);
	}
	if (has_threshold_off()) {
		fsep = json_indent(json,indLvl,fsep,"threshold_off");
		to_decstr(json,m_threshold_off);
	}
	if (has_threshold_on()) {
		fsep = json_indent(json,indLvl,fsep,"threshold_on");
		to_decstr(json,m_threshold_on);
	}
	if (has_dim_step()) {
		fsep = json_indent(json,indLvl,fsep,"dim_step");
		to_decstr(json,m_dim_step);
	}
	if (has_lightctrl()) {
		fsep = json_indent(json,indLvl,fsep,"lightctrl");
		json << (m_lightctrl ? "true" : "false");
	}
	if (has_pwm_freq()) {
		fsep = json_indent(json,indLvl,fsep,"pwm_freq");
		to_decstr(json,m_pwm_freq);
	}
	#ifdef CONFIG_APP_PARAMS
	if (size_t s = m_app_params.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"app_params\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_app_params[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_ONEWIRE
	if (size_t s = m_owdevices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"owdevices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_owdevices[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_ONEWIRE
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t NodeConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed32 magic, id 0
	if (has_magic()) {
		r += 5;
	}
	// optional string nodename, id 1
	if (has_nodename()) {
		size_t nodename_s = m_nodename.size();
		r += nodename_s + wiresize(nodename_s) + 1 /* tag(nodename) 0x8 */;
	}
	// optional bytes pass_hash, id 2
	if (has_pass_hash()) {
		size_t pass_hash_s = m_pass_hash.size();
		r += pass_hash_s + wiresize(pass_hash_s) + 1 /* tag(pass_hash) 0x10 */;
	}
	// optional unsigned cpu_freq, id 3
	if (has_cpu_freq()) {
		r += wiresize((varint_t)m_cpu_freq) + 1 /* tag(cpu_freq) 0x18 */;
	}
	// optional WifiConfig station, id 4
	if (has_station()) {
		size_t station_s = m_station.calcSize();
		r += station_s + wiresize(station_s) + 1 /* tag(station) 0x20 */;
	}
	// optional WifiConfig softap, id 5
	if (has_softap()) {
		size_t softap_s = m_softap.calcSize();
		r += softap_s + wiresize(softap_s) + 1 /* tag(softap) 0x28 */;
	}
	// repeated string dns_server, id 6
	if (!m_dns_server.empty()) {
		// dns_server: repeated estring
		for (size_t x = 0, y = m_dns_server.size(); x < y; ++x) {
			size_t s = m_dns_server[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(dns_server) 0x30 */;
		}
	}
	// optional string syslog_host, id 7
	if (has_syslog_host()) {
		size_t syslog_host_s = m_syslog_host.size();
		r += syslog_host_s + wiresize(syslog_host_s) + 1 /* tag(syslog_host) 0x38 */;
	}
	// optional string sntp_server, id 8
	if (has_sntp_server()) {
		size_t sntp_server_s = m_sntp_server.size();
		r += sntp_server_s + wiresize(sntp_server_s) + 1 /* tag(sntp_server) 0x40 */;
	}
	// optional string timezone, id 9
	if (has_timezone()) {
		size_t timezone_s = m_timezone.size();
		r += timezone_s + wiresize(timezone_s) + 1 /* tag(timezone) 0x48 */;
	}
	#ifdef CONFIG_MQTT
	// optional MQTT mqtt, id 10
	if (has_mqtt()) {
		size_t mqtt_s = m_mqtt.calcSize();
		r += mqtt_s + wiresize(mqtt_s) + 1 /* tag(mqtt) 0x50 */;
	}
	#endif // CONFIG_MQTT
	// optional fixed16 dmesg_size, id 11
	if (has_dmesg_size()) {
		r += 3;
	}
	#ifdef CONFIG_INFLUX
	// optional Influx influx, id 12
	if (has_influx()) {
		size_t influx_s = m_influx.calcSize();
		r += influx_s + wiresize(influx_s) + 1 /* tag(influx) 0x60 */;
	}
	#endif // CONFIG_INFLUX
	// optional unsigned station2ap_time, id 13
	if (has_station2ap_time()) {
		r += wiresize((varint_t)m_station2ap_time) + 1 /* tag(station2ap_time) 0x68 */;
	}
	// optional string domainname, id 15
	if (has_domainname()) {
		size_t domainname_s = m_domainname.size();
		r += domainname_s + wiresize(domainname_s) + 1 /* tag(domainname) 0x78 */;
	}
	// repeated Date holidays, id 16
	// repeated message holidays
	for (size_t x = 0, y = m_holidays.size(); x < y; ++x) {
		size_t s = m_holidays[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(holidays) 0x80 */;
	}
	// repeated AtAction at_actions, id 17
	// repeated message at_actions
	for (size_t x = 0, y = m_at_actions.size(); x < y; ++x) {
		size_t s = m_at_actions[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(at_actions) 0x88 */;
	}
	// optional unsigned actions_enable, id 18
	if (has_actions_enable()) {
		r += wiresize((varint_t)m_actions_enable) + 2 /* tag(actions_enable) 0x90 */;
	}
	// repeated Trigger triggers, id 19
	// repeated message triggers
	for (size_t x = 0, y = m_triggers.size(); x < y; ++x) {
		size_t s = m_triggers[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(triggers) 0x98 */;
	}
	// repeated UartSettings uart, id 20
	// repeated message uart
	for (size_t x = 0, y = m_uart.size(); x < y; ++x) {
		size_t s = m_uart[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(uart) 0xa0 */;
	}
	// repeated TerminalConfig terminal, id 21
	// repeated message terminal
	for (size_t x = 0, y = m_terminal.size(); x < y; ++x) {
		size_t s = m_terminal[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(terminal) 0xa8 */;
	}
	// optional fixed16 udp_ctrl_port, id 22
	if (has_udp_ctrl_port()) {
		r += 4;
	}
	// repeated string debugs, id 23
	if (!m_debugs.empty()) {
		// debugs: repeated estring
		for (size_t x = 0, y = m_debugs.size(); x < y; ++x) {
			size_t s = m_debugs[x].size();
			r += wiresize(s);
			r += s + 2 /* tag(debugs) 0xb8 */;
		}
	}
	#ifdef CONFIG_FTP
	// optional FtpHttpConfig ftpd, id 24
	if (has_ftpd()) {
		size_t ftpd_s = m_ftpd.calcSize();
		r += ftpd_s + wiresize(ftpd_s) + 2 /* tag(ftpd) 0xc0 */;
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	// optional FtpHttpConfig httpd, id 25
	if (has_httpd()) {
		size_t httpd_s = m_httpd.calcSize();
		r += httpd_s + wiresize(httpd_s) + 2 /* tag(httpd) 0xc8 */;
	}
	#endif // CONFIG_HTTP
	// repeated EventTimer timefuses, id 30
	// repeated message timefuses
	for (size_t x = 0, y = m_timefuses.size(); x < y; ++x) {
		size_t s = m_timefuses[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(timefuses) 0xf0 */;
	}
	#ifdef CONFIG_SIGNAL_PROC
	// repeated SignalConfig signals, id 31
	// repeated message signals
	for (size_t x = 0, y = m_signals.size(); x < y; ++x) {
		size_t s = m_signals[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(signals) 0xf8 */;
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	// repeated FunctionConfig functions, id 32
	// repeated message functions
	for (size_t x = 0, y = m_functions.size(); x < y; ++x) {
		size_t s = m_functions[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(functions) 0x100 */;
	}
	#endif // CONFIG_SIGNAL_PROC
	// deprecated optional unsigned max_on_time, id 34
	// optional unsigned threshold_off, id 35
	if (has_threshold_off()) {
		r += wiresize((varint_t)m_threshold_off) + 2 /* tag(threshold_off) 0x118 */;
	}
	// optional unsigned threshold_on, id 36
	if (has_threshold_on()) {
		r += wiresize((varint_t)m_threshold_on) + 2 /* tag(threshold_on) 0x120 */;
	}
	// optional unsigned dim_step, id 37
	if (has_dim_step()) {
		r += wiresize((varint_t)m_dim_step) + 2 /* tag(dim_step) 0x128 */;
	}
	// optional bool lightctrl, id 38
	if (has_lightctrl()) {
		r += 3;
	}
	// optional unsigned pwm_freq, id 39
	if (has_pwm_freq()) {
		r += wiresize((varint_t)m_pwm_freq) + 2 /* tag(pwm_freq) 0x138 */;
	}
	#ifdef CONFIG_APP_PARAMS
	// repeated AppParam app_params, id 40
	// repeated message app_params
	for (size_t x = 0, y = m_app_params.size(); x < y; ++x) {
		size_t s = m_app_params[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(app_params) 0x140 */;
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_ONEWIRE
	// repeated OwDeviceConfig owdevices, id 50
	// repeated message owdevices
	for (size_t x = 0, y = m_owdevices.size(); x < y; ++x) {
		size_t s = m_owdevices[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(owdevices) 0x190 */;
	}
	#endif // CONFIG_ONEWIRE
	return r;
}

bool NodeConfig::operator == (const NodeConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_magic() && (!(m_magic == r.m_magic)))
		return false;
	if (has_nodename() && (!(m_nodename == r.m_nodename)))
		return false;
	if (has_pass_hash() && (!(m_pass_hash == r.m_pass_hash)))
		return false;
	if (has_cpu_freq() && (!(m_cpu_freq == r.m_cpu_freq)))
		return false;
	if (has_station() && (!(m_station == r.m_station)))
		return false;
	if (has_softap() && (!(m_softap == r.m_softap)))
		return false;
	if (!(m_dns_server == r.m_dns_server))
		return false;
	if (has_syslog_host() && (!(m_syslog_host == r.m_syslog_host)))
		return false;
	if (has_sntp_server() && (!(m_sntp_server == r.m_sntp_server)))
		return false;
	if (has_timezone() && (!(m_timezone == r.m_timezone)))
		return false;
	#ifdef CONFIG_MQTT
	if (has_mqtt() && (!(m_mqtt == r.m_mqtt)))
		return false;
	#endif // CONFIG_MQTT
	if (has_dmesg_size() && (!(m_dmesg_size == r.m_dmesg_size)))
		return false;
	#ifdef CONFIG_INFLUX
	if (has_influx() && (!(m_influx == r.m_influx)))
		return false;
	#endif // CONFIG_INFLUX
	if (has_station2ap_time() && (!(m_station2ap_time == r.m_station2ap_time)))
		return false;
	if (has_domainname() && (!(m_domainname == r.m_domainname)))
		return false;
	if (!(m_holidays == r.m_holidays))
		return false;
	if (!(m_at_actions == r.m_at_actions))
		return false;
	if (has_actions_enable() && (!(m_actions_enable == r.m_actions_enable)))
		return false;
	if (!(m_triggers == r.m_triggers))
		return false;
	if (!(m_uart == r.m_uart))
		return false;
	if (!(m_terminal == r.m_terminal))
		return false;
	if (has_udp_ctrl_port() && (!(m_udp_ctrl_port == r.m_udp_ctrl_port)))
		return false;
	if (!(m_debugs == r.m_debugs))
		return false;
	#ifdef CONFIG_FTP
	if (has_ftpd() && (!(m_ftpd == r.m_ftpd)))
		return false;
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (has_httpd() && (!(m_httpd == r.m_httpd)))
		return false;
	#endif // CONFIG_HTTP
	if (!(m_timefuses == r.m_timefuses))
		return false;
	#ifdef CONFIG_SIGNAL_PROC
	if (!(m_signals == r.m_signals))
		return false;
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	if (!(m_functions == r.m_functions))
		return false;
	#endif // CONFIG_SIGNAL_PROC
	if (has_max_on_time() && (!(m_max_on_time == r.m_max_on_time)))
		return false;
	if (has_threshold_off() && (!(m_threshold_off == r.m_threshold_off)))
		return false;
	if (has_threshold_on() && (!(m_threshold_on == r.m_threshold_on)))
		return false;
	if (has_dim_step() && (!(m_dim_step == r.m_dim_step)))
		return false;
	if (has_lightctrl() && (!(m_lightctrl == r.m_lightctrl)))
		return false;
	if (has_pwm_freq() && (!(m_pwm_freq == r.m_pwm_freq)))
		return false;
	#ifdef CONFIG_APP_PARAMS
	if (!(m_app_params == r.m_app_params))
		return false;
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_ONEWIRE
	if (!(m_owdevices == r.m_owdevices))
		return false;
	#endif // CONFIG_ONEWIRE
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int NodeConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"magic")) {
		if (value == 0) {
			clear_magic();
			return 0;
		}
		int r = parse_ascii_u32(&m_magic,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"nodename")) {
		if (value == 0) {
			clear_nodename();
			return 0;
		}
		m_nodename = value;
		int r = m_nodename.size();
		return r;
	}
	if (0 == strcmp(name,"pass_hash")) {
		if (value == 0) {
			clear_pass_hash();
			return 0;
		}
		int r = parse_ascii_bytes(m_pass_hash,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"cpu_freq")) {
		if (value == 0) {
			clear_cpu_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_cpu_freq,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 2);
		return r;
	}
	if (0 == memcmp(name,"station",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_station();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint32_t)1U << 3);
			return m_station.setByName(name+8,value);
		}
	}
	if (0 == memcmp(name,"softap",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_softap();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint32_t)1U << 4);
			return m_softap.setByName(name+7,value);
		}
	}
	if (0 == memcmp(name,"dns_server",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_dns_server();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_dns_server.size();
				m_dns_server.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -286;
				if (m_dns_server.size() <= x)
					return -287;
				if ((idxe[1] == 0) && (value == 0)) {
					m_dns_server.erase(m_dns_server.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -288;
			m_dns_server[x] = value;
			return m_dns_server[x].size();
		}
	}
	if (0 == strcmp(name,"syslog_host")) {
		if (value == 0) {
			clear_syslog_host();
			return 0;
		}
		m_syslog_host = value;
		int r = m_syslog_host.size();
		return r;
	}
	if (0 == strcmp(name,"sntp_server")) {
		if (value == 0) {
			clear_sntp_server();
			return 0;
		}
		m_sntp_server = value;
		int r = m_sntp_server.size();
		return r;
	}
	if (0 == strcmp(name,"timezone")) {
		if (value == 0) {
			clear_timezone();
			return 0;
		}
		m_timezone = value;
		int r = m_timezone.size();
		return r;
	}
	#ifdef CONFIG_MQTT
	if (0 == memcmp(name,"mqtt",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_mqtt();
			return 0;
		} else if (name[4] == '.') {
			p_validbits |= ((uint32_t)1U << 5);
			return m_mqtt.setByName(name+5,value);
		}
	}
	#endif // CONFIG_MQTT
	if (0 == strcmp(name,"dmesg_size")) {
		if (value == 0) {
			clear_dmesg_size();
			return 0;
		}
		int r = parse_ascii_u16(&m_dmesg_size,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 6);
		return r;
	}
	#ifdef CONFIG_INFLUX
	if (0 == memcmp(name,"influx",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_influx();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint32_t)1U << 7);
			return m_influx.setByName(name+7,value);
		}
	}
	#endif // CONFIG_INFLUX
	if (0 == strcmp(name,"station2ap_time")) {
		if (value == 0) {
			clear_station2ap_time();
			return 0;
		}
		int r = parse_ascii_u32(&m_station2ap_time,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 8);
		return r;
	}
	if (0 == strcmp(name,"domainname")) {
		if (value == 0) {
			clear_domainname();
			return 0;
		}
		m_domainname = value;
		int r = m_domainname.size();
		return r;
	}
	if (0 == memcmp(name,"holidays",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_holidays();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_holidays.size();
				m_holidays.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -289;
				if (m_holidays.size() <= x)
					return -290;
				if ((idxe[1] == 0) && (value == 0)) {
					m_holidays.erase(m_holidays.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -291;
			return m_holidays[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"at_actions",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_at_actions();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_at_actions.size();
				m_at_actions.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -292;
				if (m_at_actions.size() <= x)
					return -293;
				if ((idxe[1] == 0) && (value == 0)) {
					m_at_actions.erase(m_at_actions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -294;
			return m_at_actions[x].setByName(idxe+2,value);
		}
	}
	if (0 == strcmp(name,"actions_enable")) {
		if (value == 0) {
			clear_actions_enable();
			return 0;
		}
		int r = parse_ascii_u32(&m_actions_enable,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 9);
		return r;
	}
	if (0 == memcmp(name,"triggers",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_triggers();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_triggers.size();
				m_triggers.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -295;
				if (m_triggers.size() <= x)
					return -296;
				if ((idxe[1] == 0) && (value == 0)) {
					m_triggers.erase(m_triggers.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -297;
			return m_triggers[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"uart",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_uart();
			return 0;
		} else if (name[4] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[5] == '+') && (name[6] == ']')) {
				x = m_uart.size();
				m_uart.resize(x+1);
				idxe = (char*)(name + 6);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+5,&idxe,0);
				if (idxe[0] != ']')
					return -298;
				if (m_uart.size() <= x)
					return -299;
				if ((idxe[1] == 0) && (value == 0)) {
					m_uart.erase(m_uart.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -300;
			return m_uart[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"terminal",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_terminal();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_terminal.size();
				m_terminal.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -301;
				if (m_terminal.size() <= x)
					return -302;
				if ((idxe[1] == 0) && (value == 0)) {
					m_terminal.erase(m_terminal.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -303;
			return m_terminal[x].setByName(idxe+2,value);
		}
	}
	if (0 == strcmp(name,"udp_ctrl_port")) {
		if (value == 0) {
			clear_udp_ctrl_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_udp_ctrl_port,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 10);
		return r;
	}
	if (0 == memcmp(name,"debugs",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_debugs();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_debugs.size();
				m_debugs.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -304;
				if (m_debugs.size() <= x)
					return -305;
				if ((idxe[1] == 0) && (value == 0)) {
					m_debugs.erase(m_debugs.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -306;
			m_debugs[x] = value;
			return m_debugs[x].size();
		}
	}
	#ifdef CONFIG_FTP
	if (0 == memcmp(name,"ftpd",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_ftpd();
			return 0;
		} else if (name[4] == '.') {
			p_validbits |= ((uint32_t)1U << 11);
			return m_ftpd.setByName(name+5,value);
		}
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (0 == memcmp(name,"httpd",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_httpd();
			return 0;
		} else if (name[5] == '.') {
			p_validbits |= ((uint32_t)1U << 12);
			return m_httpd.setByName(name+6,value);
		}
	}
	#endif // CONFIG_HTTP
	if (0 == memcmp(name,"timefuses",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_timefuses();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_timefuses.size();
				m_timefuses.resize(x+1);
				idxe = (char*)(name + 11);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if (idxe[0] != ']')
					return -307;
				if (m_timefuses.size() <= x)
					return -308;
				if ((idxe[1] == 0) && (value == 0)) {
					m_timefuses.erase(m_timefuses.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -309;
			return m_timefuses[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_SIGNAL_PROC
	if (0 == memcmp(name,"signals",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_signals();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_signals.size();
				m_signals.resize(x+1);
				idxe = (char*)(name + 9);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if (idxe[0] != ']')
					return -310;
				if (m_signals.size() <= x)
					return -311;
				if ((idxe[1] == 0) && (value == 0)) {
					m_signals.erase(m_signals.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -312;
			return m_signals[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	if (0 == memcmp(name,"functions",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_functions();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_functions.size();
				m_functions.resize(x+1);
				idxe = (char*)(name + 11);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if (idxe[0] != ']')
					return -313;
				if (m_functions.size() <= x)
					return -314;
				if ((idxe[1] == 0) && (value == 0)) {
					m_functions.erase(m_functions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -315;
			return m_functions[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_SIGNAL_PROC
	if (0 == strcmp(name,"max_on_time")) {
		if (value == 0) {
			clear_max_on_time();
			return 0;
		}
		int r = parse_ascii_u32(&m_max_on_time,value);
		return r;
	}
	if (0 == strcmp(name,"threshold_off")) {
		if (value == 0) {
			clear_threshold_off();
			return 0;
		}
		int r = parse_ascii_u32(&m_threshold_off,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 13);
		return r;
	}
	if (0 == strcmp(name,"threshold_on")) {
		if (value == 0) {
			clear_threshold_on();
			return 0;
		}
		int r = parse_ascii_u32(&m_threshold_on,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 14);
		return r;
	}
	if (0 == strcmp(name,"dim_step")) {
		if (value == 0) {
			clear_dim_step();
			return 0;
		}
		int r = parse_ascii_u32(&m_dim_step,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 15);
		return r;
	}
	if (0 == strcmp(name,"lightctrl")) {
		if (value == 0) {
			clear_lightctrl();
			return 0;
		}
		int r = parse_ascii_bool(&m_lightctrl,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 16);
		return r;
	}
	if (0 == strcmp(name,"pwm_freq")) {
		if (value == 0) {
			clear_pwm_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_pwm_freq,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 17);
		return r;
	}
	#ifdef CONFIG_APP_PARAMS
	if (0 == memcmp(name,"app_params",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_app_params();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_app_params.size();
				m_app_params.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -316;
				if (m_app_params.size() <= x)
					return -317;
				if ((idxe[1] == 0) && (value == 0)) {
					m_app_params.erase(m_app_params.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -318;
			return m_app_params[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_ONEWIRE
	if (0 == memcmp(name,"owdevices",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_owdevices();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_owdevices.size();
				m_owdevices.resize(x+1);
				idxe = (char*)(name + 11);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if (idxe[0] != ']')
					return -319;
				if (m_owdevices.size() <= x)
					return -320;
				if ((idxe[1] == 0) && (value == 0)) {
					m_owdevices.erase(m_owdevices.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -321;
			return m_owdevices[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_ONEWIRE
	return -322;
}

