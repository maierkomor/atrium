/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: R2104.15 (hg:403/b1f5b8e6c836)
 * WFC is Copyright 2015-2021, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : swcfg.wfc
 * Copyright: 2018-2021
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2021-06-27, 23:06:09 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from pc:
 * Optimize        : "speed"
 * toASCII         : "toASCII"
 * toSink          : ""
 * 
 * options from common:
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * BaseClass       : ""
 * bytestype       : "std::string"
 * calcSize        : "calcSize"
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * copyright       : ""
 * email           : ""
 * endian          : "unknown"
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * IntSize         : 64
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * SortMembers     : "id"
 * stringtype      : "std::string"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * toString        : "toString"
 * toWire          : "toWire"
 * UnknownField    : "skip"
 * VarIntBits      : 64
 * wireput         : ""
 * wiresize        : ""
 * 
 * enabled flags from commandline:
 * 	enumnames
 * enabled flags from pc:
 * 	enummap
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux, withEqual, withUnequal
 */

#ifndef SWCFG_H
#define SWCFG_H

#include <assert.h>
#define OUTPUT_TO_ASCII 1
#include <iosfwd>
#include <ostream>
#include <string>
#include <map>
#include <vector>
/* array support not needed */
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>

/* user requested header files */
#include "pcconfig.h"
#include "support.h"
#ifdef WFC_ENDIAN
#if WFC_ENDIAN != 0
#error WFC generated code incompatible due to endian
#endif
#else
#define WFC_ENDIAN     0 // unknown endian
#endif

#define HAVE_TO_MEMORY 1
#define HAVE_TO_STRING 1
#define HAVE_TO_WIRE 1
#define HAVE_TO_ASCII 1
#define HAVE_TO_JSON 1
#define HAVE_FROM_MEMORY 1
#define ON_ERROR_CANCEL 1
#define HAVE_ENUM_MAP 1
#define HAVE_ENUM_NAMES 1

/* wfc support functions not needed */

typedef uint64_t varint_t;

typedef int64_t varsint_t;


typedef enum {
	unknown = 0,
	powerup = 1,
	external = 2,
	software = 3,
	panic = 4,
	internal_wdt = 5,
	task_wdt = 6,
	watchdog = 7,
	deepsleep = 8,
	brownout = 9,
	sdio = 10,
} rstrsn_t;
const char *strReset(rstrsn_t e);
size_t parse_ascii_rstrsn_t(rstrsn_t *, const char *);

typedef enum {
	Sunday = 0,
	Monday = 1,
	Tuesday = 2,
	Wednesday = 3,
	Thursday = 4,
	Friday = 5,
	Saturday = 6,
	WorkDay = 7,
	WeekEnd = 8,
	EveryDay = 9,
	Holiday = 10,
} WeekDay;
const char *WeekDay_str(WeekDay e);
size_t parse_ascii_WeekDay(WeekDay *, const char *);

typedef enum {
	uart_wl_5 = 0,
	uart_wl_6 = 1,
	uart_wl_7 = 2,
	uart_wl_8 = 3,
} uart_wl_t;
const char *uart_wl_t_str(uart_wl_t e);
size_t parse_ascii_uart_wl_t(uart_wl_t *, const char *);

typedef enum {
	uart_sb_none = 0,
	uart_sb_1 = 1,
	uart_sb_1_5 = 2,
	uart_sb_2 = 3,
} uart_sb_t;
const char *uart_sb_t_str(uart_sb_t e);
size_t parse_ascii_uart_sb_t(uart_sb_t *, const char *);

typedef enum {
	uart_p_n = 0,
	uart_p_e = 2,
	uart_p_o = 3,
} uart_p_t;
const char *uart_p_t_str(uart_p_t e);
size_t parse_ascii_uart_p_t(uart_p_t *, const char *);

typedef enum {
	st_invalid = 0,
	st_int = 1,
	st_float = 2,
	st_string = 3,
} sigtype_t;
const char *sigtype_t_str(sigtype_t e);
size_t parse_ascii_sigtype_t(sigtype_t *, const char *);

typedef uint16_t uartcfg_t;
class WifiConfig
{
	public:
	WifiConfig();
	
	bool operator != (const WifiConfig &r) const;
	bool operator == (const WifiConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string ssid, id 1
	bool has_ssid() const;
	void clear_ssid();
	const std::string &ssid() const;
	void set_ssid(const void *data, size_t s);
	void set_ssid(const std::string & v);
	void set_ssid(const char *);
	std::string *mutable_ssid();
	
	// string pass, id 2
	bool has_pass() const;
	void clear_pass();
	const std::string &pass() const;
	void set_pass(const void *data, size_t s);
	void set_pass(const std::string & v);
	void set_pass(const char *);
	std::string *mutable_pass();
	
	// bytes mac, id 3
	bool has_mac() const;
	void clear_mac();
	const std::string &mac() const;
	void set_mac(const void *data, size_t s);
	void set_mac(const std::string & v);
	std::string *mutable_mac();
	
	// bool activate, id 4
	bool activate() const;
	void set_activate(bool  v);
	bool *mutable_activate();
	
	// fixed32 addr4, id 5
	bool has_addr4() const;
	void clear_addr4();
	uint32_t addr4() const;
	void set_addr4(uint32_t  v);
	uint32_t *mutable_addr4();
	
	// fixed8 netmask4, id 6
	bool has_netmask4() const;
	void clear_netmask4();
	uint8_t netmask4() const;
	void set_netmask4(uint8_t  v);
	uint8_t *mutable_netmask4();
	
	// fixed32 gateway4, id 7
	bool has_gateway4() const;
	void clear_gateway4();
	uint32_t gateway4() const;
	void set_gateway4(uint32_t  v);
	uint32_t *mutable_gateway4();
	
	
	protected:
	// string ssid, id 1
	std::string m_ssid;
	// string pass, id 2
	std::string m_pass;
	// bytes mac, id 3
	std::string m_mac;
	// bool activate, id 4
	bool m_activate;
	// fixed32 addr4, id 5
	uint32_t m_addr4;
	// fixed8 netmask4, id 6
	uint8_t m_netmask4;
	// fixed32 gateway4, id 7
	uint32_t m_gateway4;
	
	private:
	uint8_t p_validbits;
};


class MQTT
{
	public:
	MQTT();
	
	bool operator != (const MQTT &r) const;
	bool operator == (const MQTT &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string uri, id 1
	bool has_uri() const;
	void clear_uri();
	const std::string &uri() const;
	void set_uri(const void *data, size_t s);
	void set_uri(const std::string & v);
	void set_uri(const char *);
	std::string *mutable_uri();
	
	// bool enable, id 2
	bool has_enable() const;
	void clear_enable();
	bool enable() const;
	void set_enable(bool  v);
	bool *mutable_enable();
	
	// string username, id 3
	bool has_username() const;
	void clear_username();
	const std::string &username() const;
	void set_username(const void *data, size_t s);
	void set_username(const std::string & v);
	void set_username(const char *);
	std::string *mutable_username();
	
	// string password, id 4
	bool has_password() const;
	void clear_password();
	const std::string &password() const;
	void set_password(const void *data, size_t s);
	void set_password(const std::string & v);
	void set_password(const char *);
	std::string *mutable_password();
	
	// string subscribtions, id 5
	const std::vector<std::string> &subscribtions() const;
	size_t subscribtions_size() const;
	void add_subscribtions(const std::string &v);
	void add_subscribtions(const char*);
	void clear_subscribtions();
	const std::string &subscribtions(unsigned x) const;
	void set_subscribtions(unsigned x, const std::string &v);
	std::string *mutable_subscribtions(unsigned x);
	std::vector<std::string> *mutable_subscribtions();
	
	
	protected:
	// string uri, id 1
	std::string m_uri;
	// bool enable, id 2
	bool m_enable;
	// string username, id 3
	std::string m_username;
	// string password, id 4
	std::string m_password;
	// string subscribtions, id 5
	std::vector<std::string> m_subscribtions;
};


class Date
{
	public:
	Date();
	
	bool operator != (const Date &r) const;
	bool operator == (const Date &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// fixed8 day, id 1
	bool has_day() const;
	void clear_day();
	uint8_t day() const;
	void set_day(uint8_t  v);
	uint8_t *mutable_day();
	
	// fixed8 month, id 2
	bool has_month() const;
	void clear_month();
	uint8_t month() const;
	void set_month(uint8_t  v);
	uint8_t *mutable_month();
	
	// fixed16 year, id 3
	bool has_year() const;
	void clear_year();
	uint16_t year() const;
	void set_year(uint16_t  v);
	uint16_t *mutable_year();
	
	// fixed8 endday, id 4
	bool has_endday() const;
	void clear_endday();
	uint8_t endday() const;
	void set_endday(uint8_t  v);
	uint8_t *mutable_endday();
	
	// fixed8 endmonth, id 5
	bool has_endmonth() const;
	void clear_endmonth();
	uint8_t endmonth() const;
	void set_endmonth(uint8_t  v);
	uint8_t *mutable_endmonth();
	
	// fixed8 endyear, id 6
	bool has_endyear() const;
	void clear_endyear();
	uint8_t endyear() const;
	void set_endyear(uint8_t  v);
	uint8_t *mutable_endyear();
	
	
	protected:
	// fixed8 day, id 1
	uint8_t m_day;
	// fixed8 month, id 2
	uint8_t m_month;
	// fixed16 year, id 3
	uint16_t m_year;
	// fixed8 endday, id 4
	uint8_t m_endday;
	// fixed8 endmonth, id 5
	uint8_t m_endmonth;
	// fixed8 endyear, id 6
	uint8_t m_endyear;
};


class AtAction
{
	public:
	AtAction();
	
	bool operator != (const AtAction &r) const;
	bool operator == (const AtAction &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// WeekDay day, id 1
	bool has_day() const;
	void clear_day();
	WeekDay day() const;
	void set_day(WeekDay  v);
	WeekDay *mutable_day();
	
	// unsigned min_of_day, id 2
	bool has_min_of_day() const;
	void clear_min_of_day();
	uint64_t min_of_day() const;
	void set_min_of_day(uint64_t  v);
	uint64_t *mutable_min_of_day();
	
	// string action, id 3
	bool has_action() const;
	void clear_action();
	const std::string &action() const;
	void set_action(const void *data, size_t s);
	void set_action(const std::string & v);
	void set_action(const char *);
	std::string *mutable_action();
	
	// bool enable, id 4
	bool enable() const;
	void set_enable(bool  v);
	bool *mutable_enable();
	
	
	protected:
	// WeekDay day, id 1
	WeekDay m_day;
	// unsigned min_of_day, id 2
	uint64_t m_min_of_day;
	// string action, id 3
	std::string m_action;
	// bool enable, id 4
	bool m_enable;
	
	private:
	uint8_t p_validbits;
};


class Influx
{
	public:
	Influx();
	
	bool operator != (const Influx &r) const;
	bool operator == (const Influx &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string hostname, id 1
	bool has_hostname() const;
	void clear_hostname();
	const std::string &hostname() const;
	void set_hostname(const void *data, size_t s);
	void set_hostname(const std::string & v);
	void set_hostname(const char *);
	std::string *mutable_hostname();
	
	// fixed16 port, id 2
	bool has_port() const;
	void clear_port();
	uint16_t port() const;
	void set_port(uint16_t  v);
	uint16_t *mutable_port();
	
	// string measurement, id 3
	bool has_measurement() const;
	void clear_measurement();
	const std::string &measurement() const;
	void set_measurement(const void *data, size_t s);
	void set_measurement(const std::string & v);
	void set_measurement(const char *);
	std::string *mutable_measurement();
	
	// obsolete unsigned interval, id 4
	// string database, id 5
	bool has_database() const;
	void clear_database();
	const std::string &database() const;
	void set_database(const void *data, size_t s);
	void set_database(const std::string & v);
	void set_database(const char *);
	std::string *mutable_database();
	
	
	protected:
	// string hostname, id 1
	std::string m_hostname;
	// fixed16 port, id 2
	uint16_t m_port;
	// string measurement, id 3
	std::string m_measurement;
	// omitted obsolete member interval
	// string database, id 5
	std::string m_database;
};


class UartSettings
{
	public:
	UartSettings();
	
	bool operator != (const UartSettings &r) const;
	bool operator == (const UartSettings &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// uint8 port, id 1
	bool has_port() const;
	void clear_port();
	uint8_t port() const;
	void set_port(uint8_t  v);
	uint8_t *mutable_port();
	
	// unsigned baudrate, id 2
	bool has_baudrate() const;
	void clear_baudrate();
	uint64_t baudrate() const;
	void set_baudrate(uint64_t  v);
	uint64_t *mutable_baudrate();
	
	// uartcfg_t config, id 3
	bool has_config() const;
	void clear_config();
	uartcfg_t config() const;
	uart_wl_t config_wl() const;
	void set_config_wl(uart_wl_t);
	uart_sb_t config_sb() const;
	void set_config_sb(uart_sb_t);
	bool config_rts() const;
	void set_config_rts(bool);
	bool config_cts() const;
	void set_config_cts(bool);
	uart_p_t config_p() const;
	void set_config_p(uart_p_t);
	bool config_ref_tick() const;
	void set_config_ref_tick(bool);
	void set_config(uartcfg_t  v);
	uartcfg_t *mutable_config();
	
	// fixed8 rx_thresh, id 4
	bool has_rx_thresh() const;
	void clear_rx_thresh();
	uint8_t rx_thresh() const;
	void set_rx_thresh(uint8_t  v);
	uint8_t *mutable_rx_thresh();
	
	// unsigned tx_bufsize, id 6
	bool has_tx_bufsize() const;
	void clear_tx_bufsize();
	uint64_t tx_bufsize() const;
	void set_tx_bufsize(uint64_t  v);
	uint64_t *mutable_tx_bufsize();
	
	// unsigned rx_bufsize, id 7
	bool has_rx_bufsize() const;
	void clear_rx_bufsize();
	uint64_t rx_bufsize() const;
	void set_rx_bufsize(uint64_t  v);
	uint64_t *mutable_rx_bufsize();
	
	
	protected:
	// uint8 port, id 1
	uint8_t m_port;
	// unsigned baudrate, id 2
	uint64_t m_baudrate;
	// uartcfg_t config, id 3
	uartcfg_t m_config;
	// fixed8 rx_thresh, id 4
	uint8_t m_rx_thresh;
	// unsigned tx_bufsize, id 6
	uint64_t m_tx_bufsize;
	// unsigned rx_bufsize, id 7
	uint64_t m_rx_bufsize;
	
	private:
	uint8_t p_validbits;
};


class FtpHttpConfig
{
	public:
	FtpHttpConfig();
	
	bool operator != (const FtpHttpConfig &r) const;
	bool operator == (const FtpHttpConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// fixed16 port, id 1
	bool has_port() const;
	void clear_port();
	uint16_t port() const;
	void set_port(uint16_t  v);
	uint16_t *mutable_port();
	
	// bool start, id 2
	bool has_start() const;
	void clear_start();
	bool start() const;
	void set_start(bool  v);
	bool *mutable_start();
	
	// string root, id 3
	bool has_root() const;
	void clear_root();
	const std::string &root() const;
	void set_root(const void *data, size_t s);
	void set_root(const std::string & v);
	void set_root(const char *);
	std::string *mutable_root();
	
	// string uploaddir, id 4
	bool has_uploaddir() const;
	void clear_uploaddir();
	const std::string &uploaddir() const;
	void set_uploaddir(const void *data, size_t s);
	void set_uploaddir(const std::string & v);
	void set_uploaddir(const char *);
	std::string *mutable_uploaddir();
	
	
	protected:
	// fixed16 port, id 1
	uint16_t m_port;
	// bool start, id 2
	bool m_start;
	// string root, id 3
	std::string m_root;
	// string uploaddir, id 4
	std::string m_uploaddir;
	
	private:
	uint8_t p_validbits;
};


class TerminalConfig
{
	public:
	TerminalConfig();
	
	bool operator != (const TerminalConfig &r) const;
	bool operator == (const TerminalConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// sint8 uart_rx, id 1
	bool has_uart_rx() const;
	void clear_uart_rx();
	int8_t uart_rx() const;
	void set_uart_rx(int8_t  v);
	int8_t *mutable_uart_rx();
	
	// sint8 uart_tx, id 2
	bool has_uart_tx() const;
	void clear_uart_tx();
	int8_t uart_tx() const;
	void set_uart_tx(int8_t  v);
	int8_t *mutable_uart_tx();
	
	// string name, id 3
	bool has_name() const;
	void clear_name();
	const std::string &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const std::string & v);
	void set_name(const char *);
	std::string *mutable_name();
	
	
	protected:
	// sint8 uart_rx, id 1
	int8_t m_uart_rx;
	// sint8 uart_tx, id 2
	int8_t m_uart_tx;
	// string name, id 3
	std::string m_name;
	
	private:
	uint8_t p_validbits;
};


class Trigger
{
	public:
	Trigger();
	
	bool operator != (const Trigger &r) const;
	bool operator == (const Trigger &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string event, id 1
	bool has_event() const;
	void clear_event();
	const std::string &event() const;
	void set_event(const void *data, size_t s);
	void set_event(const std::string & v);
	void set_event(const char *);
	std::string *mutable_event();
	
	// string action, id 2
	const std::vector<std::string> &action() const;
	size_t action_size() const;
	void add_action(const std::string &v);
	void add_action(const char*);
	void clear_action();
	const std::string &action(unsigned x) const;
	void set_action(unsigned x, const std::string &v);
	std::string *mutable_action(unsigned x);
	std::vector<std::string> *mutable_action();
	
	
	protected:
	// string event, id 1
	std::string m_event;
	// string action, id 2
	std::vector<std::string> m_action;
	
	private:
	uint8_t p_validbits;
};


class AppParam
{
	public:
	AppParam();
	
	bool operator != (const AppParam &r) const;
	bool operator == (const AppParam &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string key, id 1
	bool has_key() const;
	void clear_key();
	const std::string &key() const;
	void set_key(const void *data, size_t s);
	void set_key(const std::string & v);
	void set_key(const char *);
	std::string *mutable_key();
	
	// unsigned uValue, id 2
	bool has_uValue() const;
	void clear_uValue();
	uint64_t uValue() const;
	void set_uValue(uint64_t  v);
	uint64_t *mutable_uValue();
	
	// string sValue, id 3
	bool has_sValue() const;
	void clear_sValue();
	const std::string &sValue() const;
	void set_sValue(const void *data, size_t s);
	void set_sValue(const std::string & v);
	void set_sValue(const char *);
	std::string *mutable_sValue();
	
	// signed dValue, id 4
	bool has_dValue() const;
	void clear_dValue();
	int64_t dValue() const;
	void set_dValue(int64_t  v);
	int64_t *mutable_dValue();
	
	// double fValue, id 5
	bool has_fValue() const;
	void clear_fValue();
	double fValue() const;
	void set_fValue(double  v);
	double *mutable_fValue();
	
	
	protected:
	// string key, id 1
	std::string m_key;
	// unsigned uValue, id 2
	uint64_t m_uValue;
	// string sValue, id 3
	std::string m_sValue;
	// signed dValue, id 4
	int64_t m_dValue;
	// double fValue, id 5
	double m_fValue;
	
	private:
	uint8_t p_validbits;
};


class EventTimer
{
	public:
	EventTimer();
	
	bool operator != (const EventTimer &r) const;
	bool operator == (const EventTimer &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string name, id 1
	bool has_name() const;
	void clear_name();
	const std::string &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const std::string & v);
	void set_name(const char *);
	std::string *mutable_name();
	
	// unsigned time, id 2
	bool has_time() const;
	void clear_time();
	uint64_t time() const;
	void set_time(uint64_t  v);
	uint64_t *mutable_time();
	
	// unsigned config, id 3
	bool has_config() const;
	void clear_config();
	uint64_t config() const;
	void set_config(uint64_t  v);
	uint64_t *mutable_config();
	
	
	protected:
	// string name, id 1
	std::string m_name;
	// unsigned time, id 2
	uint64_t m_time;
	// unsigned config, id 3
	uint64_t m_config;
	
	private:
	uint8_t p_validbits;
};


class FunctionConfig
{
	public:
	FunctionConfig();
	
	bool operator != (const FunctionConfig &r) const;
	bool operator == (const FunctionConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string name, id 1
	bool has_name() const;
	void clear_name();
	const std::string &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const std::string & v);
	void set_name(const char *);
	std::string *mutable_name();
	
	// string func, id 2
	bool has_func() const;
	void clear_func();
	const std::string &func() const;
	void set_func(const void *data, size_t s);
	void set_func(const std::string & v);
	void set_func(const char *);
	std::string *mutable_func();
	
	// string params, id 3
	const std::vector<std::string> &params() const;
	size_t params_size() const;
	void add_params(const std::string &v);
	void add_params(const char*);
	void clear_params();
	const std::string &params(unsigned x) const;
	void set_params(unsigned x, const std::string &v);
	std::string *mutable_params(unsigned x);
	std::vector<std::string> *mutable_params();
	
	
	protected:
	// string name, id 1
	std::string m_name;
	// string func, id 2
	std::string m_func;
	// string params, id 3
	std::vector<std::string> m_params;
	
	private:
	uint8_t p_validbits;
};


class SignalConfig
{
	public:
	SignalConfig();
	
	bool operator != (const SignalConfig &r) const;
	bool operator == (const SignalConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string name, id 1
	bool has_name() const;
	void clear_name();
	const std::string &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const std::string & v);
	void set_name(const char *);
	std::string *mutable_name();
	
	// sigtype_t type, id 2
	bool has_type() const;
	void clear_type();
	sigtype_t type() const;
	void set_type(sigtype_t  v);
	sigtype_t *mutable_type();
	
	// string iv, id 3
	bool has_iv() const;
	void clear_iv();
	const std::string &iv() const;
	void set_iv(const void *data, size_t s);
	void set_iv(const std::string & v);
	void set_iv(const char *);
	std::string *mutable_iv();
	
	
	protected:
	// string name, id 1
	std::string m_name;
	// sigtype_t type, id 2
	sigtype_t m_type;
	// string iv, id 3
	std::string m_iv;
};


class OwDeviceConfig
{
	public:
	OwDeviceConfig();
	
	bool operator != (const OwDeviceConfig &r) const;
	bool operator == (const OwDeviceConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// fixed64 id, id 1
	bool has_id() const;
	void clear_id();
	uint64_t id() const;
	void set_id(uint64_t  v);
	uint64_t *mutable_id();
	
	// string name, id 2
	bool has_name() const;
	void clear_name();
	const std::string &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const std::string & v);
	void set_name(const char *);
	std::string *mutable_name();
	
	
	protected:
	// fixed64 id, id 1
	uint64_t m_id;
	// string name, id 2
	std::string m_name;
	
	private:
	uint8_t p_validbits;
};


class NodeConfig
{
	public:
	NodeConfig();
	
	bool operator != (const NodeConfig &r) const;
	bool operator == (const NodeConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Serialize the object using a function for transmitting individual bytes.
	//! @param put function to put individual bytes for transmission on the wire
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// fixed32 magic, id 0
	bool has_magic() const;
	void clear_magic();
	uint32_t magic() const;
	void set_magic(uint32_t  v);
	uint32_t *mutable_magic();
	
	// string nodename, id 1
	bool has_nodename() const;
	void clear_nodename();
	const std::string &nodename() const;
	void set_nodename(const void *data, size_t s);
	void set_nodename(const std::string & v);
	void set_nodename(const char *);
	std::string *mutable_nodename();
	
	// bytes pass_hash, id 2
	bool has_pass_hash() const;
	void clear_pass_hash();
	const std::string &pass_hash() const;
	void set_pass_hash(const void *data, size_t s);
	void set_pass_hash(const std::string & v);
	std::string *mutable_pass_hash();
	
	// unsigned cpu_freq, id 3
	bool has_cpu_freq() const;
	void clear_cpu_freq();
	uint64_t cpu_freq() const;
	void set_cpu_freq(uint64_t  v);
	uint64_t *mutable_cpu_freq();
	
	// WifiConfig station, id 4
	bool has_station() const;
	void clear_station();
	const WifiConfig &station() const;
	void set_station(const void *data, size_t s);
	void set_station(const WifiConfig & v);
	WifiConfig *mutable_station();
	
	// WifiConfig softap, id 5
	bool has_softap() const;
	void clear_softap();
	const WifiConfig &softap() const;
	void set_softap(const void *data, size_t s);
	void set_softap(const WifiConfig & v);
	WifiConfig *mutable_softap();
	
	// string dns_server, id 6
	bool has_dns_server() const;
	void clear_dns_server();
	const std::string &dns_server() const;
	void set_dns_server(const void *data, size_t s);
	void set_dns_server(const std::string & v);
	void set_dns_server(const char *);
	std::string *mutable_dns_server();
	
	// string syslog_host, id 7
	bool has_syslog_host() const;
	void clear_syslog_host();
	const std::string &syslog_host() const;
	void set_syslog_host(const void *data, size_t s);
	void set_syslog_host(const std::string & v);
	void set_syslog_host(const char *);
	std::string *mutable_syslog_host();
	
	// string sntp_server, id 8
	bool has_sntp_server() const;
	void clear_sntp_server();
	const std::string &sntp_server() const;
	void set_sntp_server(const void *data, size_t s);
	void set_sntp_server(const std::string & v);
	void set_sntp_server(const char *);
	std::string *mutable_sntp_server();
	
	// string timezone, id 9
	bool has_timezone() const;
	void clear_timezone();
	const std::string &timezone() const;
	void set_timezone(const void *data, size_t s);
	void set_timezone(const std::string & v);
	void set_timezone(const char *);
	std::string *mutable_timezone();
	
	// MQTT mqtt, id 10
	#ifdef CONFIG_MQTT
	bool has_mqtt() const;
	void clear_mqtt();
	const MQTT &mqtt() const;
	void set_mqtt(const void *data, size_t s);
	void set_mqtt(const MQTT & v);
	MQTT *mutable_mqtt();
	#endif //CONFIG_MQTT
	
	// fixed16 dmesg_size, id 11
	bool has_dmesg_size() const;
	void clear_dmesg_size();
	uint16_t dmesg_size() const;
	void set_dmesg_size(uint16_t  v);
	uint16_t *mutable_dmesg_size();
	
	// Influx influx, id 12
	#ifdef CONFIG_INFLUX
	bool has_influx() const;
	void clear_influx();
	const Influx &influx() const;
	void set_influx(const void *data, size_t s);
	void set_influx(const Influx & v);
	Influx *mutable_influx();
	#endif //CONFIG_INFLUX
	
	// unsigned station2ap_time, id 13
	bool has_station2ap_time() const;
	void clear_station2ap_time();
	uint64_t station2ap_time() const;
	void set_station2ap_time(uint64_t  v);
	uint64_t *mutable_station2ap_time();
	
	// string domainname, id 15
	bool has_domainname() const;
	void clear_domainname();
	const std::string &domainname() const;
	void set_domainname(const void *data, size_t s);
	void set_domainname(const std::string & v);
	void set_domainname(const char *);
	std::string *mutable_domainname();
	
	// Date holidays, id 16
	const std::vector<Date> &holidays() const;
	size_t holidays_size() const;
	Date* add_holidays();
	void clear_holidays();
	const Date &holidays(unsigned x) const;
	void set_holidays(unsigned x, const Date &v);
	Date *mutable_holidays(unsigned x);
	std::vector<Date> *mutable_holidays();
	
	// AtAction at_actions, id 17
	const std::vector<AtAction> &at_actions() const;
	size_t at_actions_size() const;
	AtAction* add_at_actions();
	void clear_at_actions();
	const AtAction &at_actions(unsigned x) const;
	void set_at_actions(unsigned x, const AtAction &v);
	AtAction *mutable_at_actions(unsigned x);
	std::vector<AtAction> *mutable_at_actions();
	
	// unsigned actions_enable, id 18
	bool has_actions_enable() const;
	void clear_actions_enable();
	uint64_t actions_enable() const;
	void set_actions_enable(uint64_t  v);
	uint64_t *mutable_actions_enable();
	
	// Trigger triggers, id 19
	const std::vector<Trigger> &triggers() const;
	size_t triggers_size() const;
	Trigger* add_triggers();
	void clear_triggers();
	const Trigger &triggers(unsigned x) const;
	void set_triggers(unsigned x, const Trigger &v);
	Trigger *mutable_triggers(unsigned x);
	std::vector<Trigger> *mutable_triggers();
	
	// UartSettings uart, id 20
	const std::vector<UartSettings> &uart() const;
	size_t uart_size() const;
	UartSettings* add_uart();
	void clear_uart();
	const UartSettings &uart(unsigned x) const;
	void set_uart(unsigned x, const UartSettings &v);
	UartSettings *mutable_uart(unsigned x);
	std::vector<UartSettings> *mutable_uart();
	
	// TerminalConfig terminal, id 21
	const std::vector<TerminalConfig> &terminal() const;
	size_t terminal_size() const;
	TerminalConfig* add_terminal();
	void clear_terminal();
	const TerminalConfig &terminal(unsigned x) const;
	void set_terminal(unsigned x, const TerminalConfig &v);
	TerminalConfig *mutable_terminal(unsigned x);
	std::vector<TerminalConfig> *mutable_terminal();
	
	// fixed16 udp_ctrl_port, id 22
	bool has_udp_ctrl_port() const;
	void clear_udp_ctrl_port();
	uint16_t udp_ctrl_port() const;
	void set_udp_ctrl_port(uint16_t  v);
	uint16_t *mutable_udp_ctrl_port();
	
	// string debugs, id 23
	const std::vector<std::string> &debugs() const;
	size_t debugs_size() const;
	void add_debugs(const std::string &v);
	void add_debugs(const char*);
	void clear_debugs();
	const std::string &debugs(unsigned x) const;
	void set_debugs(unsigned x, const std::string &v);
	std::string *mutable_debugs(unsigned x);
	std::vector<std::string> *mutable_debugs();
	
	// FtpHttpConfig ftpd, id 24
	#ifdef CONFIG_FTP
	bool has_ftpd() const;
	void clear_ftpd();
	const FtpHttpConfig &ftpd() const;
	void set_ftpd(const void *data, size_t s);
	void set_ftpd(const FtpHttpConfig & v);
	FtpHttpConfig *mutable_ftpd();
	#endif //CONFIG_FTP
	
	// FtpHttpConfig httpd, id 25
	bool has_httpd() const;
	void clear_httpd();
	const FtpHttpConfig &httpd() const;
	void set_httpd(const void *data, size_t s);
	void set_httpd(const FtpHttpConfig & v);
	FtpHttpConfig *mutable_httpd();
	
	// EventTimer timefuses, id 30
	const std::vector<EventTimer> &timefuses() const;
	size_t timefuses_size() const;
	EventTimer* add_timefuses();
	void clear_timefuses();
	const EventTimer &timefuses(unsigned x) const;
	void set_timefuses(unsigned x, const EventTimer &v);
	EventTimer *mutable_timefuses(unsigned x);
	std::vector<EventTimer> *mutable_timefuses();
	
	// SignalConfig signals, id 31
	#ifdef CONFIG_SIGNAL_PROC
	const std::vector<SignalConfig> &signals() const;
	size_t signals_size() const;
	SignalConfig* add_signals();
	void clear_signals();
	const SignalConfig &signals(unsigned x) const;
	void set_signals(unsigned x, const SignalConfig &v);
	SignalConfig *mutable_signals(unsigned x);
	std::vector<SignalConfig> *mutable_signals();
	#endif //CONFIG_SIGNAL_PROC
	
	// FunctionConfig functions, id 32
	#ifdef CONFIG_SIGNAL_PROC
	const std::vector<FunctionConfig> &functions() const;
	size_t functions_size() const;
	FunctionConfig* add_functions();
	void clear_functions();
	const FunctionConfig &functions(unsigned x) const;
	void set_functions(unsigned x, const FunctionConfig &v);
	FunctionConfig *mutable_functions(unsigned x);
	std::vector<FunctionConfig> *mutable_functions();
	#endif //CONFIG_SIGNAL_PROC
	
	// deprecated unsigned max_on_time, id 34
	bool has_max_on_time() const;
	void clear_max_on_time();
	uint64_t max_on_time() const __attribute__ ((deprecated));
	
	// unsigned threshold_off, id 35
	bool has_threshold_off() const;
	void clear_threshold_off();
	uint64_t threshold_off() const;
	void set_threshold_off(uint64_t  v);
	uint64_t *mutable_threshold_off();
	
	// unsigned threshold_on, id 36
	bool has_threshold_on() const;
	void clear_threshold_on();
	uint64_t threshold_on() const;
	void set_threshold_on(uint64_t  v);
	uint64_t *mutable_threshold_on();
	
	// unsigned dim_step, id 37
	bool has_dim_step() const;
	void clear_dim_step();
	uint64_t dim_step() const;
	void set_dim_step(uint64_t  v);
	uint64_t *mutable_dim_step();
	
	// bool lightctrl, id 38
	bool has_lightctrl() const;
	void clear_lightctrl();
	bool lightctrl() const;
	void set_lightctrl(bool  v);
	bool *mutable_lightctrl();
	
	// unsigned pwm_freq, id 39
	bool has_pwm_freq() const;
	void clear_pwm_freq();
	uint64_t pwm_freq() const;
	void set_pwm_freq(uint64_t  v);
	uint64_t *mutable_pwm_freq();
	
	// AppParam app_params, id 40
	#ifdef CONFIG_SIGNAL_PROC
	const std::vector<AppParam> &app_params() const;
	size_t app_params_size() const;
	AppParam* add_app_params();
	void clear_app_params();
	const AppParam &app_params(unsigned x) const;
	void set_app_params(unsigned x, const AppParam &v);
	AppParam *mutable_app_params(unsigned x);
	std::vector<AppParam> *mutable_app_params();
	#endif //CONFIG_SIGNAL_PROC
	
	// OwDeviceConfig owdevices, id 50
	#ifdef CONFIG_ONEWIRE
	const std::vector<OwDeviceConfig> &owdevices() const;
	size_t owdevices_size() const;
	OwDeviceConfig* add_owdevices();
	void clear_owdevices();
	const OwDeviceConfig &owdevices(unsigned x) const;
	void set_owdevices(unsigned x, const OwDeviceConfig &v);
	OwDeviceConfig *mutable_owdevices(unsigned x);
	std::vector<OwDeviceConfig> *mutable_owdevices();
	#endif //CONFIG_ONEWIRE
	
	
	protected:
	// deprecated unsigned max_on_time, id 34
	void set_max_on_time(uint64_t  v);
	// fixed32 magic, id 0
	uint32_t m_magic;
	// string nodename, id 1
	std::string m_nodename;
	// bytes pass_hash, id 2
	std::string m_pass_hash;
	// unsigned cpu_freq, id 3
	uint64_t m_cpu_freq;
	// WifiConfig station, id 4
	WifiConfig m_station;
	// WifiConfig softap, id 5
	WifiConfig m_softap;
	// string dns_server, id 6
	std::string m_dns_server;
	// string syslog_host, id 7
	std::string m_syslog_host;
	// string sntp_server, id 8
	std::string m_sntp_server;
	// string timezone, id 9
	std::string m_timezone;
	#ifdef CONFIG_MQTT
	// MQTT mqtt, id 10
	MQTT m_mqtt;
	#endif //CONFIG_MQTT
	// fixed16 dmesg_size, id 11
	uint16_t m_dmesg_size;
	#ifdef CONFIG_INFLUX
	// Influx influx, id 12
	Influx m_influx;
	#endif //CONFIG_INFLUX
	// unsigned station2ap_time, id 13
	uint64_t m_station2ap_time;
	// string domainname, id 15
	std::string m_domainname;
	// Date holidays, id 16
	std::vector<Date> m_holidays;
	// AtAction at_actions, id 17
	std::vector<AtAction> m_at_actions;
	// unsigned actions_enable, id 18
	uint64_t m_actions_enable;
	// Trigger triggers, id 19
	std::vector<Trigger> m_triggers;
	// UartSettings uart, id 20
	std::vector<UartSettings> m_uart;
	// TerminalConfig terminal, id 21
	std::vector<TerminalConfig> m_terminal;
	// fixed16 udp_ctrl_port, id 22
	uint16_t m_udp_ctrl_port;
	// string debugs, id 23
	std::vector<std::string> m_debugs;
	#ifdef CONFIG_FTP
	// FtpHttpConfig ftpd, id 24
	FtpHttpConfig m_ftpd;
	#endif //CONFIG_FTP
	// FtpHttpConfig httpd, id 25
	FtpHttpConfig m_httpd;
	// EventTimer timefuses, id 30
	std::vector<EventTimer> m_timefuses;
	#ifdef CONFIG_SIGNAL_PROC
	// SignalConfig signals, id 31
	std::vector<SignalConfig> m_signals;
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	// FunctionConfig functions, id 32
	std::vector<FunctionConfig> m_functions;
	#endif //CONFIG_SIGNAL_PROC
	// unsigned max_on_time, id 34
	uint64_t m_max_on_time;
	// unsigned threshold_off, id 35
	uint64_t m_threshold_off;
	// unsigned threshold_on, id 36
	uint64_t m_threshold_on;
	// unsigned dim_step, id 37
	uint64_t m_dim_step;
	// bool lightctrl, id 38
	bool m_lightctrl;
	// unsigned pwm_freq, id 39
	uint64_t m_pwm_freq;
	#ifdef CONFIG_SIGNAL_PROC
	// AppParam app_params, id 40
	std::vector<AppParam> m_app_params;
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_ONEWIRE
	// OwDeviceConfig owdevices, id 50
	std::vector<OwDeviceConfig> m_owdevices;
	#endif //CONFIG_ONEWIRE
	
	private:
	uint32_t p_validbits;
};


inline size_t WifiConfig::getMaxSize()
{
	// ssid has unlimited size
	// pass has unlimited size
	// mac has unlimited size
	// activate has maximum size 2
	// addr4 has maximum size 5
	// netmask4 has maximum size 2
	// gateway4 has maximum size 5
	return SIZE_MAX;
}

inline const std::string &WifiConfig::ssid() const
{
	return m_ssid;
}

inline bool WifiConfig::has_ssid() const
{
	return !m_ssid.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_ssid()
{
	m_ssid = "";
}

inline std::string *WifiConfig::mutable_ssid()
{
	return &m_ssid;
}

inline void WifiConfig::set_ssid(const void *data, size_t s)
{
	m_ssid.assign((const char *)data,s);
}

inline void WifiConfig::set_ssid(const char *data)
{
	m_ssid = data;
}

inline void WifiConfig::set_ssid(const std::string & v)
{
	m_ssid = v;
}

inline const std::string &WifiConfig::pass() const
{
	return m_pass;
}

inline bool WifiConfig::has_pass() const
{
	return !m_pass.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_pass()
{
	m_pass = "";
}

inline std::string *WifiConfig::mutable_pass()
{
	return &m_pass;
}

inline void WifiConfig::set_pass(const void *data, size_t s)
{
	m_pass.assign((const char *)data,s);
}

inline void WifiConfig::set_pass(const char *data)
{
	m_pass = data;
}

inline void WifiConfig::set_pass(const std::string & v)
{
	m_pass = v;
}

inline const std::string &WifiConfig::mac() const
{
	return m_mac;
}

inline bool WifiConfig::has_mac() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_mac()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_mac.clear();
}

inline std::string *WifiConfig::mutable_mac()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_mac.clear();
	}
	return &m_mac;
}

inline void WifiConfig::set_mac(const void *data, size_t s)
{
	m_mac.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void WifiConfig::set_mac(const std::string & v)
{
	m_mac = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline bool WifiConfig::activate() const
{
	return m_activate;
}

inline bool *WifiConfig::mutable_activate()
{
	return &m_activate;
}

inline void WifiConfig::set_activate(bool v)
{
	m_activate = v;
}

inline uint32_t WifiConfig::addr4() const
{
	return m_addr4;
}

inline bool WifiConfig::has_addr4() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_addr4()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_addr4 = 0;
}

inline uint32_t *WifiConfig::mutable_addr4()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_addr4 = 0;
	}
	return &m_addr4;
}

inline void WifiConfig::set_addr4(uint32_t  v)
{
	m_addr4 = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline uint8_t WifiConfig::netmask4() const
{
	return m_netmask4;
}

inline bool WifiConfig::has_netmask4() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_netmask4()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_netmask4 = 0;
}

inline uint8_t *WifiConfig::mutable_netmask4()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_netmask4 = 0;
	}
	return &m_netmask4;
}

inline void WifiConfig::set_netmask4(uint8_t  v)
{
	m_netmask4 = v;
	p_validbits |= ((uint8_t)1U << 2);
}

inline uint32_t WifiConfig::gateway4() const
{
	return m_gateway4;
}

inline bool WifiConfig::has_gateway4() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 3));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_gateway4()
{
	p_validbits &= ~((uint8_t)1U << 3);
	m_gateway4 = 0;
}

inline uint32_t *WifiConfig::mutable_gateway4()
{
	if (0 == (p_validbits & ((uint8_t)1U << 3))) {
		p_validbits |= ((uint8_t)1U << 3);
		m_gateway4 = 0;
	}
	return &m_gateway4;
}

inline void WifiConfig::set_gateway4(uint32_t  v)
{
	m_gateway4 = v;
	p_validbits |= ((uint8_t)1U << 3);
}

inline size_t MQTT::getMaxSize()
{
	// uri has unlimited size
	// enable has maximum size 2
	// username has unlimited size
	// password has unlimited size
	// subscribtions has unlimited size
	return SIZE_MAX;
}

inline const std::string &MQTT::uri() const
{
	return m_uri;
}

inline bool MQTT::has_uri() const
{
	return !m_uri.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_uri()
{
	m_uri = "";
}

inline std::string *MQTT::mutable_uri()
{
	return &m_uri;
}

inline void MQTT::set_uri(const void *data, size_t s)
{
	m_uri.assign((const char *)data,s);
}

inline void MQTT::set_uri(const char *data)
{
	m_uri = data;
}

inline void MQTT::set_uri(const std::string & v)
{
	m_uri = v;
}

inline bool MQTT::enable() const
{
	return m_enable;
}

inline bool MQTT::has_enable() const
{
	return m_enable != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_enable()
{
	m_enable = false;
}

inline bool *MQTT::mutable_enable()
{
	return &m_enable;
}

inline void MQTT::set_enable(bool  v)
{
	m_enable = v;
}

inline const std::string &MQTT::username() const
{
	return m_username;
}

inline bool MQTT::has_username() const
{
	return !m_username.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_username()
{
	m_username = "";
}

inline std::string *MQTT::mutable_username()
{
	return &m_username;
}

inline void MQTT::set_username(const void *data, size_t s)
{
	m_username.assign((const char *)data,s);
}

inline void MQTT::set_username(const char *data)
{
	m_username = data;
}

inline void MQTT::set_username(const std::string & v)
{
	m_username = v;
}

inline const std::string &MQTT::password() const
{
	return m_password;
}

inline bool MQTT::has_password() const
{
	return !m_password.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_password()
{
	m_password = "";
}

inline std::string *MQTT::mutable_password()
{
	return &m_password;
}

inline void MQTT::set_password(const void *data, size_t s)
{
	m_password.assign((const char *)data,s);
}

inline void MQTT::set_password(const char *data)
{
	m_password = data;
}

inline void MQTT::set_password(const std::string & v)
{
	m_password = v;
}

inline const std::string &MQTT::subscribtions(unsigned x) const
{
	return m_subscribtions[x];
}

inline const std::vector<std::string> &MQTT::subscribtions() const
{
	return m_subscribtions;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_subscribtions()
{
	m_subscribtions.clear();
}

inline std::string *MQTT::mutable_subscribtions(unsigned x)
{
	if (x >= m_subscribtions.size())
		m_subscribtions.resize(x+1);
	return &m_subscribtions[x];
}

inline std::vector<std::string> *MQTT::mutable_subscribtions()
{
	return &m_subscribtions;
}

inline void MQTT::add_subscribtions(const std::string &v)
{
	m_subscribtions.push_back(v);
}

inline void MQTT::add_subscribtions(const char *s)
{
	m_subscribtions.push_back(s);
}

inline void MQTT::set_subscribtions(unsigned x, const std::string &v)
{
	assert(x < m_subscribtions.size());
	m_subscribtions[x] = v;
}

inline size_t MQTT::subscribtions_size() const
{
	return m_subscribtions.size();
}

inline size_t Date::getMaxSize()
{
	// day has maximum size 2
	// month has maximum size 2
	// year has maximum size 3
	// endday has maximum size 2
	// endmonth has maximum size 2
	// endyear has maximum size 2
	return 13;
}

inline uint8_t Date::day() const
{
	return m_day;
}

inline bool Date::has_day() const
{
	return m_day != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_day()
{
	m_day = 0;
}

inline uint8_t *Date::mutable_day()
{
	return &m_day;
}

inline void Date::set_day(uint8_t  v)
{
	m_day = v;
}

inline uint8_t Date::month() const
{
	return m_month;
}

inline bool Date::has_month() const
{
	return m_month != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_month()
{
	m_month = 0;
}

inline uint8_t *Date::mutable_month()
{
	return &m_month;
}

inline void Date::set_month(uint8_t  v)
{
	m_month = v;
}

inline uint16_t Date::year() const
{
	return m_year;
}

inline bool Date::has_year() const
{
	return m_year != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_year()
{
	m_year = 0;
}

inline uint16_t *Date::mutable_year()
{
	return &m_year;
}

inline void Date::set_year(uint16_t  v)
{
	m_year = v;
}

inline uint8_t Date::endday() const
{
	return m_endday;
}

inline bool Date::has_endday() const
{
	return m_endday != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_endday()
{
	m_endday = 0;
}

inline uint8_t *Date::mutable_endday()
{
	return &m_endday;
}

inline void Date::set_endday(uint8_t  v)
{
	m_endday = v;
}

inline uint8_t Date::endmonth() const
{
	return m_endmonth;
}

inline bool Date::has_endmonth() const
{
	return m_endmonth != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_endmonth()
{
	m_endmonth = 0;
}

inline uint8_t *Date::mutable_endmonth()
{
	return &m_endmonth;
}

inline void Date::set_endmonth(uint8_t  v)
{
	m_endmonth = v;
}

inline uint8_t Date::endyear() const
{
	return m_endyear;
}

inline bool Date::has_endyear() const
{
	return m_endyear != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_endyear()
{
	m_endyear = 0;
}

inline uint8_t *Date::mutable_endyear()
{
	return &m_endyear;
}

inline void Date::set_endyear(uint8_t  v)
{
	m_endyear = v;
}

inline size_t AtAction::getMaxSize()
{
	// day has maximum size 2
	// min_of_day has maximum size 11
	// action has unlimited size
	// enable has maximum size 2
	return SIZE_MAX;
}

inline WeekDay AtAction::day() const
{
	return m_day;
}

inline bool AtAction::has_day() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AtAction::clear_day()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_day = Sunday;
}

inline WeekDay *AtAction::mutable_day()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_day = Sunday;
	}
	return &m_day;
}

inline void AtAction::set_day(WeekDay  v)
{
	m_day = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline uint64_t AtAction::min_of_day() const
{
	return m_min_of_day;
}

inline bool AtAction::has_min_of_day() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AtAction::clear_min_of_day()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_min_of_day = 0;
}

inline uint64_t *AtAction::mutable_min_of_day()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_min_of_day = 0;
	}
	return &m_min_of_day;
}

inline void AtAction::set_min_of_day(uint64_t  v)
{
	m_min_of_day = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline const std::string &AtAction::action() const
{
	return m_action;
}

inline bool AtAction::has_action() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AtAction::clear_action()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_action.clear();
}

inline std::string *AtAction::mutable_action()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_action.clear();
	}
	return &m_action;
}

inline void AtAction::set_action(const void *data, size_t s)
{
	m_action.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 2);
}

inline void AtAction::set_action(const char *data)
{
	m_action = data;
	p_validbits |= ((uint8_t)1U << 2);
}

inline void AtAction::set_action(const std::string & v)
{
	m_action = v;
	p_validbits |= ((uint8_t)1U << 2);
}

inline bool AtAction::enable() const
{
	return m_enable;
}

inline bool *AtAction::mutable_enable()
{
	return &m_enable;
}

inline void AtAction::set_enable(bool v)
{
	m_enable = v;
}

inline size_t Influx::getMaxSize()
{
	// hostname has unlimited size
	// port has maximum size 3
	// measurement has unlimited size
	// interval is obsolete
	// database has unlimited size
	return SIZE_MAX;
}

inline const std::string &Influx::hostname() const
{
	return m_hostname;
}

inline bool Influx::has_hostname() const
{
	return !m_hostname.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Influx::clear_hostname()
{
	m_hostname = "";
}

inline std::string *Influx::mutable_hostname()
{
	return &m_hostname;
}

inline void Influx::set_hostname(const void *data, size_t s)
{
	m_hostname.assign((const char *)data,s);
}

inline void Influx::set_hostname(const char *data)
{
	m_hostname = data;
}

inline void Influx::set_hostname(const std::string & v)
{
	m_hostname = v;
}

inline uint16_t Influx::port() const
{
	return m_port;
}

inline bool Influx::has_port() const
{
	return m_port != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Influx::clear_port()
{
	m_port = 0;
}

inline uint16_t *Influx::mutable_port()
{
	return &m_port;
}

inline void Influx::set_port(uint16_t  v)
{
	m_port = v;
}

inline const std::string &Influx::measurement() const
{
	return m_measurement;
}

inline bool Influx::has_measurement() const
{
	return !m_measurement.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Influx::clear_measurement()
{
	m_measurement = "";
}

inline std::string *Influx::mutable_measurement()
{
	return &m_measurement;
}

inline void Influx::set_measurement(const void *data, size_t s)
{
	m_measurement.assign((const char *)data,s);
}

inline void Influx::set_measurement(const char *data)
{
	m_measurement = data;
}

inline void Influx::set_measurement(const std::string & v)
{
	m_measurement = v;
}

inline const std::string &Influx::database() const
{
	return m_database;
}

inline bool Influx::has_database() const
{
	return !m_database.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Influx::clear_database()
{
	m_database = "";
}

inline std::string *Influx::mutable_database()
{
	return &m_database;
}

inline void Influx::set_database(const void *data, size_t s)
{
	m_database.assign((const char *)data,s);
}

inline void Influx::set_database(const char *data)
{
	m_database = data;
}

inline void Influx::set_database(const std::string & v)
{
	m_database = v;
}

inline size_t UartSettings::getMaxSize()
{
	// port has maximum size 3
	// baudrate has maximum size 11
	// config has maximum size 3
	// rx_thresh has maximum size 2
	// tx_bufsize has maximum size 11
	// rx_bufsize has maximum size 11
	return 41;
}

inline uint8_t UartSettings::port() const
{
	return m_port;
}

inline bool UartSettings::has_port() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_port()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_port = 0;
}

inline uint8_t *UartSettings::mutable_port()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_port = 0;
	}
	return &m_port;
}

inline void UartSettings::set_port(uint8_t  v)
{
	m_port = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline uint64_t UartSettings::baudrate() const
{
	return m_baudrate;
}

inline bool UartSettings::has_baudrate() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_baudrate()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_baudrate = 0;
}

inline uint64_t *UartSettings::mutable_baudrate()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_baudrate = 0;
	}
	return &m_baudrate;
}

inline void UartSettings::set_baudrate(uint64_t  v)
{
	m_baudrate = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline uartcfg_t UartSettings::config() const
{
	return m_config;
}

inline uart_wl_t UartSettings::config_wl() const
{
	return (uart_wl_t)((m_config >> 0) & 0x3);
}

inline uart_sb_t UartSettings::config_sb() const
{
	return (uart_sb_t)((m_config >> 2) & 0x3);
}

inline bool UartSettings::config_rts() const
{
	return (bool)((m_config >> 4) & 0x1);
}

inline bool UartSettings::config_cts() const
{
	return (bool)((m_config >> 5) & 0x1);
}

inline uart_p_t UartSettings::config_p() const
{
	return (uart_p_t)((m_config >> 6) & 0x3);
}

inline bool UartSettings::config_ref_tick() const
{
	return (bool)((m_config >> 10) & 0x1);
}

inline bool UartSettings::has_config() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_config()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_config = 0;
}

inline uartcfg_t *UartSettings::mutable_config()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_config = 0;
	}
	return &m_config;
}

inline void UartSettings::set_config_wl(uart_wl_t v)
{
	m_config &= ~(0x3 << 0);
	m_config |= ((uint16_t) v << 0);
	p_validbits |= ((uint8_t)1U << 2);
}

inline void UartSettings::set_config_sb(uart_sb_t v)
{
	m_config &= ~(0x3 << 2);
	m_config |= ((uint16_t) v << 2);
	p_validbits |= ((uint8_t)1U << 2);
}

inline void UartSettings::set_config_rts(bool v)
{
	m_config &= ~(0x1 << 4);
	m_config |= ((uint16_t) v << 4);
	p_validbits |= ((uint8_t)1U << 2);
}

inline void UartSettings::set_config_cts(bool v)
{
	m_config &= ~(0x1 << 5);
	m_config |= ((uint16_t) v << 5);
	p_validbits |= ((uint8_t)1U << 2);
}

inline void UartSettings::set_config_p(uart_p_t v)
{
	m_config &= ~(0x3 << 6);
	m_config |= ((uint16_t) v << 6);
	p_validbits |= ((uint8_t)1U << 2);
}

inline void UartSettings::set_config_ref_tick(bool v)
{
	m_config &= ~(0x1 << 10);
	m_config |= ((uint16_t) v << 10);
	p_validbits |= ((uint8_t)1U << 2);
}

inline void UartSettings::set_config(uartcfg_t  v)
{
	m_config = v;
	p_validbits |= ((uint8_t)1U << 2);
}

inline uint8_t UartSettings::rx_thresh() const
{
	return m_rx_thresh;
}

inline bool UartSettings::has_rx_thresh() const
{
	return m_rx_thresh != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_rx_thresh()
{
	m_rx_thresh = 0;
}

inline uint8_t *UartSettings::mutable_rx_thresh()
{
	return &m_rx_thresh;
}

inline void UartSettings::set_rx_thresh(uint8_t  v)
{
	m_rx_thresh = v;
}

inline uint64_t UartSettings::tx_bufsize() const
{
	return m_tx_bufsize;
}

inline bool UartSettings::has_tx_bufsize() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 3));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_tx_bufsize()
{
	p_validbits &= ~((uint8_t)1U << 3);
	m_tx_bufsize = 0;
}

inline uint64_t *UartSettings::mutable_tx_bufsize()
{
	if (0 == (p_validbits & ((uint8_t)1U << 3))) {
		p_validbits |= ((uint8_t)1U << 3);
		m_tx_bufsize = 0;
	}
	return &m_tx_bufsize;
}

inline void UartSettings::set_tx_bufsize(uint64_t  v)
{
	m_tx_bufsize = v;
	p_validbits |= ((uint8_t)1U << 3);
}

inline uint64_t UartSettings::rx_bufsize() const
{
	return m_rx_bufsize;
}

inline bool UartSettings::has_rx_bufsize() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 4));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_rx_bufsize()
{
	p_validbits &= ~((uint8_t)1U << 4);
	m_rx_bufsize = 0;
}

inline uint64_t *UartSettings::mutable_rx_bufsize()
{
	if (0 == (p_validbits & ((uint8_t)1U << 4))) {
		p_validbits |= ((uint8_t)1U << 4);
		m_rx_bufsize = 0;
	}
	return &m_rx_bufsize;
}

inline void UartSettings::set_rx_bufsize(uint64_t  v)
{
	m_rx_bufsize = v;
	p_validbits |= ((uint8_t)1U << 4);
}

inline size_t FtpHttpConfig::getMaxSize()
{
	// port has maximum size 3
	// start has maximum size 2
	// root has unlimited size
	// uploaddir has unlimited size
	return SIZE_MAX;
}

inline uint16_t FtpHttpConfig::port() const
{
	return m_port;
}

inline bool FtpHttpConfig::has_port() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FtpHttpConfig::clear_port()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_port = 80;
}

inline uint16_t *FtpHttpConfig::mutable_port()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_port = 80;
	}
	return &m_port;
}

inline void FtpHttpConfig::set_port(uint16_t  v)
{
	m_port = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline bool FtpHttpConfig::start() const
{
	return m_start;
}

inline bool FtpHttpConfig::has_start() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FtpHttpConfig::clear_start()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_start = true;
}

inline bool *FtpHttpConfig::mutable_start()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_start = true;
	}
	return &m_start;
}

inline void FtpHttpConfig::set_start(bool  v)
{
	m_start = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline const std::string &FtpHttpConfig::root() const
{
	return m_root;
}

inline bool FtpHttpConfig::has_root() const
{
	return !m_root.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FtpHttpConfig::clear_root()
{
	m_root = "";
}

inline std::string *FtpHttpConfig::mutable_root()
{
	return &m_root;
}

inline void FtpHttpConfig::set_root(const void *data, size_t s)
{
	m_root.assign((const char *)data,s);
}

inline void FtpHttpConfig::set_root(const char *data)
{
	m_root = data;
}

inline void FtpHttpConfig::set_root(const std::string & v)
{
	m_root = v;
}

inline const std::string &FtpHttpConfig::uploaddir() const
{
	return m_uploaddir;
}

inline bool FtpHttpConfig::has_uploaddir() const
{
	return !m_uploaddir.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FtpHttpConfig::clear_uploaddir()
{
	m_uploaddir = "";
}

inline std::string *FtpHttpConfig::mutable_uploaddir()
{
	return &m_uploaddir;
}

inline void FtpHttpConfig::set_uploaddir(const void *data, size_t s)
{
	m_uploaddir.assign((const char *)data,s);
}

inline void FtpHttpConfig::set_uploaddir(const char *data)
{
	m_uploaddir = data;
}

inline void FtpHttpConfig::set_uploaddir(const std::string & v)
{
	m_uploaddir = v;
}

inline size_t TerminalConfig::getMaxSize()
{
	// uart_rx has maximum size 3
	// uart_tx has maximum size 3
	// name has unlimited size
	return SIZE_MAX;
}

inline int8_t TerminalConfig::uart_rx() const
{
	return m_uart_rx;
}

inline bool TerminalConfig::has_uart_rx() const
{
	return m_uart_rx != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TerminalConfig::clear_uart_rx()
{
	m_uart_rx = -1;
}

inline int8_t *TerminalConfig::mutable_uart_rx()
{
	return &m_uart_rx;
}

inline void TerminalConfig::set_uart_rx(int8_t  v)
{
	m_uart_rx = v;
}

inline int8_t TerminalConfig::uart_tx() const
{
	return m_uart_tx;
}

inline bool TerminalConfig::has_uart_tx() const
{
	return m_uart_tx != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TerminalConfig::clear_uart_tx()
{
	m_uart_tx = -1;
}

inline int8_t *TerminalConfig::mutable_uart_tx()
{
	return &m_uart_tx;
}

inline void TerminalConfig::set_uart_tx(int8_t  v)
{
	m_uart_tx = v;
}

inline const std::string &TerminalConfig::name() const
{
	return m_name;
}

inline bool TerminalConfig::has_name() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TerminalConfig::clear_name()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_name.clear();
}

inline std::string *TerminalConfig::mutable_name()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_name.clear();
	}
	return &m_name;
}

inline void TerminalConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void TerminalConfig::set_name(const char *data)
{
	m_name = data;
	p_validbits |= ((uint8_t)1U << 0);
}

inline void TerminalConfig::set_name(const std::string & v)
{
	m_name = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline size_t Trigger::getMaxSize()
{
	// event has unlimited size
	// action has unlimited size
	return SIZE_MAX;
}

inline const std::string &Trigger::event() const
{
	return m_event;
}

inline bool Trigger::has_event() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Trigger::clear_event()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_event.clear();
}

inline std::string *Trigger::mutable_event()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_event.clear();
	}
	return &m_event;
}

inline void Trigger::set_event(const void *data, size_t s)
{
	m_event.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void Trigger::set_event(const char *data)
{
	m_event = data;
	p_validbits |= ((uint8_t)1U << 0);
}

inline void Trigger::set_event(const std::string & v)
{
	m_event = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline const std::string &Trigger::action(unsigned x) const
{
	return m_action[x];
}

inline const std::vector<std::string> &Trigger::action() const
{
	return m_action;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Trigger::clear_action()
{
	m_action.clear();
}

inline std::string *Trigger::mutable_action(unsigned x)
{
	if (x >= m_action.size())
		m_action.resize(x+1);
	return &m_action[x];
}

inline std::vector<std::string> *Trigger::mutable_action()
{
	return &m_action;
}

inline void Trigger::add_action(const std::string &v)
{
	m_action.push_back(v);
}

inline void Trigger::add_action(const char *s)
{
	m_action.push_back(s);
}

inline void Trigger::set_action(unsigned x, const std::string &v)
{
	assert(x < m_action.size());
	m_action[x] = v;
}

inline size_t Trigger::action_size() const
{
	return m_action.size();
}

inline size_t AppParam::getMaxSize()
{
	// key has unlimited size
	// uValue has maximum size 11
	// sValue has unlimited size
	// dValue has maximum size 11
	// fValue has maximum size 9
	return SIZE_MAX;
}

inline const std::string &AppParam::key() const
{
	return m_key;
}

inline bool AppParam::has_key() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AppParam::clear_key()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_key.clear();
}

inline std::string *AppParam::mutable_key()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_key.clear();
	}
	return &m_key;
}

inline void AppParam::set_key(const void *data, size_t s)
{
	m_key.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void AppParam::set_key(const char *data)
{
	m_key = data;
	p_validbits |= ((uint8_t)1U << 0);
}

inline void AppParam::set_key(const std::string & v)
{
	m_key = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline uint64_t AppParam::uValue() const
{
	return m_uValue;
}

inline bool AppParam::has_uValue() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AppParam::clear_uValue()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_uValue = 0;
}

inline uint64_t *AppParam::mutable_uValue()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_uValue = 0;
	}
	return &m_uValue;
}

inline void AppParam::set_uValue(uint64_t  v)
{
	m_uValue = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline const std::string &AppParam::sValue() const
{
	return m_sValue;
}

inline bool AppParam::has_sValue() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AppParam::clear_sValue()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_sValue.clear();
}

inline std::string *AppParam::mutable_sValue()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_sValue.clear();
	}
	return &m_sValue;
}

inline void AppParam::set_sValue(const void *data, size_t s)
{
	m_sValue.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 2);
}

inline void AppParam::set_sValue(const char *data)
{
	m_sValue = data;
	p_validbits |= ((uint8_t)1U << 2);
}

inline void AppParam::set_sValue(const std::string & v)
{
	m_sValue = v;
	p_validbits |= ((uint8_t)1U << 2);
}

inline int64_t AppParam::dValue() const
{
	return m_dValue;
}

inline bool AppParam::has_dValue() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 3));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AppParam::clear_dValue()
{
	p_validbits &= ~((uint8_t)1U << 3);
	m_dValue = 0;
}

inline int64_t *AppParam::mutable_dValue()
{
	if (0 == (p_validbits & ((uint8_t)1U << 3))) {
		p_validbits |= ((uint8_t)1U << 3);
		m_dValue = 0;
	}
	return &m_dValue;
}

inline void AppParam::set_dValue(int64_t  v)
{
	m_dValue = v;
	p_validbits |= ((uint8_t)1U << 3);
}

inline double AppParam::fValue() const
{
	return m_fValue;
}

inline bool AppParam::has_fValue() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 4));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AppParam::clear_fValue()
{
	p_validbits &= ~((uint8_t)1U << 4);
	m_fValue = 0;
}

inline double *AppParam::mutable_fValue()
{
	if (0 == (p_validbits & ((uint8_t)1U << 4))) {
		p_validbits |= ((uint8_t)1U << 4);
		m_fValue = 0;
	}
	return &m_fValue;
}

inline void AppParam::set_fValue(double  v)
{
	m_fValue = v;
	p_validbits |= ((uint8_t)1U << 4);
}

inline size_t EventTimer::getMaxSize()
{
	// name has unlimited size
	// time has maximum size 11
	// config has maximum size 11
	return SIZE_MAX;
}

inline const std::string &EventTimer::name() const
{
	return m_name;
}

inline bool EventTimer::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void EventTimer::clear_name()
{
	m_name = "";
}

inline std::string *EventTimer::mutable_name()
{
	return &m_name;
}

inline void EventTimer::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void EventTimer::set_name(const char *data)
{
	m_name = data;
}

inline void EventTimer::set_name(const std::string & v)
{
	m_name = v;
}

inline uint64_t EventTimer::time() const
{
	return m_time;
}

inline bool EventTimer::has_time() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void EventTimer::clear_time()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_time = 0;
}

inline uint64_t *EventTimer::mutable_time()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_time = 0;
	}
	return &m_time;
}

inline void EventTimer::set_time(uint64_t  v)
{
	m_time = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline uint64_t EventTimer::config() const
{
	return m_config;
}

inline bool EventTimer::has_config() const
{
	return m_config != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void EventTimer::clear_config()
{
	m_config = 0;
}

inline uint64_t *EventTimer::mutable_config()
{
	return &m_config;
}

inline void EventTimer::set_config(uint64_t  v)
{
	m_config = v;
}

inline size_t FunctionConfig::getMaxSize()
{
	// name has unlimited size
	// func has unlimited size
	// params has unlimited size
	return SIZE_MAX;
}

inline const std::string &FunctionConfig::name() const
{
	return m_name;
}

inline bool FunctionConfig::has_name() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FunctionConfig::clear_name()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_name.clear();
}

inline std::string *FunctionConfig::mutable_name()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_name.clear();
	}
	return &m_name;
}

inline void FunctionConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void FunctionConfig::set_name(const char *data)
{
	m_name = data;
	p_validbits |= ((uint8_t)1U << 0);
}

inline void FunctionConfig::set_name(const std::string & v)
{
	m_name = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline const std::string &FunctionConfig::func() const
{
	return m_func;
}

inline bool FunctionConfig::has_func() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FunctionConfig::clear_func()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_func.clear();
}

inline std::string *FunctionConfig::mutable_func()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_func.clear();
	}
	return &m_func;
}

inline void FunctionConfig::set_func(const void *data, size_t s)
{
	m_func.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 1);
}

inline void FunctionConfig::set_func(const char *data)
{
	m_func = data;
	p_validbits |= ((uint8_t)1U << 1);
}

inline void FunctionConfig::set_func(const std::string & v)
{
	m_func = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline const std::string &FunctionConfig::params(unsigned x) const
{
	return m_params[x];
}

inline const std::vector<std::string> &FunctionConfig::params() const
{
	return m_params;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FunctionConfig::clear_params()
{
	m_params.clear();
}

inline std::string *FunctionConfig::mutable_params(unsigned x)
{
	if (x >= m_params.size())
		m_params.resize(x+1);
	return &m_params[x];
}

inline std::vector<std::string> *FunctionConfig::mutable_params()
{
	return &m_params;
}

inline void FunctionConfig::add_params(const std::string &v)
{
	m_params.push_back(v);
}

inline void FunctionConfig::add_params(const char *s)
{
	m_params.push_back(s);
}

inline void FunctionConfig::set_params(unsigned x, const std::string &v)
{
	assert(x < m_params.size());
	m_params[x] = v;
}

inline size_t FunctionConfig::params_size() const
{
	return m_params.size();
}

inline size_t SignalConfig::getMaxSize()
{
	// name has unlimited size
	// type has maximum size 2
	// iv has unlimited size
	return SIZE_MAX;
}

inline const std::string &SignalConfig::name() const
{
	return m_name;
}

inline bool SignalConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SignalConfig::clear_name()
{
	m_name = "";
}

inline std::string *SignalConfig::mutable_name()
{
	return &m_name;
}

inline void SignalConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void SignalConfig::set_name(const char *data)
{
	m_name = data;
}

inline void SignalConfig::set_name(const std::string & v)
{
	m_name = v;
}

inline sigtype_t SignalConfig::type() const
{
	return m_type;
}

inline bool SignalConfig::has_type() const
{
	return m_type != st_invalid;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SignalConfig::clear_type()
{
	m_type = st_invalid;
}

inline sigtype_t *SignalConfig::mutable_type()
{
	return &m_type;
}

inline void SignalConfig::set_type(sigtype_t  v)
{
	m_type = v;
}

inline const std::string &SignalConfig::iv() const
{
	return m_iv;
}

inline bool SignalConfig::has_iv() const
{
	return !m_iv.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SignalConfig::clear_iv()
{
	m_iv = "";
}

inline std::string *SignalConfig::mutable_iv()
{
	return &m_iv;
}

inline void SignalConfig::set_iv(const void *data, size_t s)
{
	m_iv.assign((const char *)data,s);
}

inline void SignalConfig::set_iv(const char *data)
{
	m_iv = data;
}

inline void SignalConfig::set_iv(const std::string & v)
{
	m_iv = v;
}

inline size_t OwDeviceConfig::getMaxSize()
{
	// id has maximum size 9
	// name has unlimited size
	return SIZE_MAX;
}

inline uint64_t OwDeviceConfig::id() const
{
	return m_id;
}

inline bool OwDeviceConfig::has_id() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void OwDeviceConfig::clear_id()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_id = 0;
}

inline uint64_t *OwDeviceConfig::mutable_id()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_id = 0;
	}
	return &m_id;
}

inline void OwDeviceConfig::set_id(uint64_t  v)
{
	m_id = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline const std::string &OwDeviceConfig::name() const
{
	return m_name;
}

inline bool OwDeviceConfig::has_name() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void OwDeviceConfig::clear_name()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_name.clear();
}

inline std::string *OwDeviceConfig::mutable_name()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_name.clear();
	}
	return &m_name;
}

inline void OwDeviceConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 1);
}

inline void OwDeviceConfig::set_name(const char *data)
{
	m_name = data;
	p_validbits |= ((uint8_t)1U << 1);
}

inline void OwDeviceConfig::set_name(const std::string & v)
{
	m_name = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline size_t NodeConfig::getMaxSize()
{
	// magic has maximum size 5
	// nodename has unlimited size
	// pass_hash has unlimited size
	// cpu_freq has maximum size 11
	// station has maximum size 12
	// softap has maximum size 12
	// dns_server has unlimited size
	// syslog_host has unlimited size
	// sntp_server has unlimited size
	// timezone has unlimited size
	// mqtt has maximum size 4294967295
	// dmesg_size has maximum size 3
	// influx has maximum size 12
	// station2ap_time has maximum size 11
	// domainname has unlimited size
	// holidays has unlimited size
	// at_actions has unlimited size
	// actions_enable has maximum size 12
	// triggers has unlimited size
	// uart has unlimited size
	// terminal has unlimited size
	// udp_ctrl_port has maximum size 4
	// debugs has unlimited size
	// ftpd has maximum size 5
	// httpd has maximum size 5
	// timefuses has unlimited size
	// signals has unlimited size
	// functions has unlimited size
	// max_on_time has maximum size 12
	// threshold_off has maximum size 12
	// threshold_on has maximum size 12
	// dim_step has maximum size 12
	// lightctrl has maximum size 3
	// pwm_freq has maximum size 12
	// app_params has unlimited size
	// owdevices has unlimited size
	return SIZE_MAX;
}

inline uint32_t NodeConfig::magic() const
{
	return m_magic;
}

inline bool NodeConfig::has_magic() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_magic()
{
	p_validbits &= ~((uint32_t)1U << 0);
	m_magic = 0;
}

inline uint32_t *NodeConfig::mutable_magic()
{
	if (0 == (p_validbits & ((uint32_t)1U << 0))) {
		p_validbits |= ((uint32_t)1U << 0);
		m_magic = 0;
	}
	return &m_magic;
}

inline void NodeConfig::set_magic(uint32_t  v)
{
	m_magic = v;
	p_validbits |= ((uint32_t)1U << 0);
}

inline const std::string &NodeConfig::nodename() const
{
	return m_nodename;
}

inline bool NodeConfig::has_nodename() const
{
	return !m_nodename.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_nodename()
{
	m_nodename = "";
}

inline std::string *NodeConfig::mutable_nodename()
{
	return &m_nodename;
}

inline void NodeConfig::set_nodename(const void *data, size_t s)
{
	m_nodename.assign((const char *)data,s);
}

inline void NodeConfig::set_nodename(const char *data)
{
	m_nodename = data;
}

inline void NodeConfig::set_nodename(const std::string & v)
{
	m_nodename = v;
}

inline const std::string &NodeConfig::pass_hash() const
{
	return m_pass_hash;
}

inline bool NodeConfig::has_pass_hash() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_pass_hash()
{
	p_validbits &= ~((uint32_t)1U << 1);
	m_pass_hash.clear();
}

inline std::string *NodeConfig::mutable_pass_hash()
{
	if (0 == (p_validbits & ((uint32_t)1U << 1))) {
		p_validbits |= ((uint32_t)1U << 1);
		m_pass_hash.clear();
	}
	return &m_pass_hash;
}

inline void NodeConfig::set_pass_hash(const void *data, size_t s)
{
	m_pass_hash.assign((const char *)data,s);
	p_validbits |= ((uint32_t)1U << 1);
}

inline void NodeConfig::set_pass_hash(const std::string & v)
{
	m_pass_hash = v;
	p_validbits |= ((uint32_t)1U << 1);
}

inline uint64_t NodeConfig::cpu_freq() const
{
	return m_cpu_freq;
}

inline bool NodeConfig::has_cpu_freq() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_cpu_freq()
{
	p_validbits &= ~((uint32_t)1U << 2);
	m_cpu_freq = 0;
}

inline uint64_t *NodeConfig::mutable_cpu_freq()
{
	if (0 == (p_validbits & ((uint32_t)1U << 2))) {
		p_validbits |= ((uint32_t)1U << 2);
		m_cpu_freq = 0;
	}
	return &m_cpu_freq;
}

inline void NodeConfig::set_cpu_freq(uint64_t  v)
{
	m_cpu_freq = v;
	p_validbits |= ((uint32_t)1U << 2);
}

inline const WifiConfig &NodeConfig::station() const
{
	return m_station;
}

inline bool NodeConfig::has_station() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 3));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_station()
{
	p_validbits &= ~((uint32_t)1U << 3);
	m_station.clear();
}

inline WifiConfig *NodeConfig::mutable_station()
{
	if (0 == (p_validbits & ((uint32_t)1U << 3))) {
		p_validbits |= ((uint32_t)1U << 3);
		m_station.clear();
	}
	return &m_station;
}

inline void NodeConfig::set_station(const void *data, size_t s)
{
	m_station.fromMemory((const char *)data,s);
	p_validbits |= ((uint32_t)1U << 3);
}

inline void NodeConfig::set_station(const WifiConfig & v)
{
	m_station = v;
	p_validbits |= ((uint32_t)1U << 3);
}

inline const WifiConfig &NodeConfig::softap() const
{
	return m_softap;
}

inline bool NodeConfig::has_softap() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 4));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_softap()
{
	p_validbits &= ~((uint32_t)1U << 4);
	m_softap.clear();
}

inline WifiConfig *NodeConfig::mutable_softap()
{
	if (0 == (p_validbits & ((uint32_t)1U << 4))) {
		p_validbits |= ((uint32_t)1U << 4);
		m_softap.clear();
	}
	return &m_softap;
}

inline void NodeConfig::set_softap(const void *data, size_t s)
{
	m_softap.fromMemory((const char *)data,s);
	p_validbits |= ((uint32_t)1U << 4);
}

inline void NodeConfig::set_softap(const WifiConfig & v)
{
	m_softap = v;
	p_validbits |= ((uint32_t)1U << 4);
}

inline const std::string &NodeConfig::dns_server() const
{
	return m_dns_server;
}

inline bool NodeConfig::has_dns_server() const
{
	return !m_dns_server.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_dns_server()
{
	m_dns_server = "";
}

inline std::string *NodeConfig::mutable_dns_server()
{
	return &m_dns_server;
}

inline void NodeConfig::set_dns_server(const void *data, size_t s)
{
	m_dns_server.assign((const char *)data,s);
}

inline void NodeConfig::set_dns_server(const char *data)
{
	m_dns_server = data;
}

inline void NodeConfig::set_dns_server(const std::string & v)
{
	m_dns_server = v;
}

inline const std::string &NodeConfig::syslog_host() const
{
	return m_syslog_host;
}

inline bool NodeConfig::has_syslog_host() const
{
	return !m_syslog_host.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_syslog_host()
{
	m_syslog_host = "";
}

inline std::string *NodeConfig::mutable_syslog_host()
{
	return &m_syslog_host;
}

inline void NodeConfig::set_syslog_host(const void *data, size_t s)
{
	m_syslog_host.assign((const char *)data,s);
}

inline void NodeConfig::set_syslog_host(const char *data)
{
	m_syslog_host = data;
}

inline void NodeConfig::set_syslog_host(const std::string & v)
{
	m_syslog_host = v;
}

inline const std::string &NodeConfig::sntp_server() const
{
	return m_sntp_server;
}

inline bool NodeConfig::has_sntp_server() const
{
	return !m_sntp_server.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_sntp_server()
{
	m_sntp_server = "";
}

inline std::string *NodeConfig::mutable_sntp_server()
{
	return &m_sntp_server;
}

inline void NodeConfig::set_sntp_server(const void *data, size_t s)
{
	m_sntp_server.assign((const char *)data,s);
}

inline void NodeConfig::set_sntp_server(const char *data)
{
	m_sntp_server = data;
}

inline void NodeConfig::set_sntp_server(const std::string & v)
{
	m_sntp_server = v;
}

inline const std::string &NodeConfig::timezone() const
{
	return m_timezone;
}

inline bool NodeConfig::has_timezone() const
{
	return !m_timezone.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_timezone()
{
	m_timezone = "";
}

inline std::string *NodeConfig::mutable_timezone()
{
	return &m_timezone;
}

inline void NodeConfig::set_timezone(const void *data, size_t s)
{
	m_timezone.assign((const char *)data,s);
}

inline void NodeConfig::set_timezone(const char *data)
{
	m_timezone = data;
}

inline void NodeConfig::set_timezone(const std::string & v)
{
	m_timezone = v;
}

#ifdef CONFIG_MQTT
inline const MQTT &NodeConfig::mqtt() const
{
	return m_mqtt;
}

inline bool NodeConfig::has_mqtt() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 5));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_mqtt()
{
	p_validbits &= ~((uint32_t)1U << 5);
	m_mqtt.clear();
}

inline MQTT *NodeConfig::mutable_mqtt()
{
	if (0 == (p_validbits & ((uint32_t)1U << 5))) {
		p_validbits |= ((uint32_t)1U << 5);
		m_mqtt.clear();
	}
	return &m_mqtt;
}

inline void NodeConfig::set_mqtt(const void *data, size_t s)
{
	m_mqtt.fromMemory((const char *)data,s);
	p_validbits |= ((uint32_t)1U << 5);
}

inline void NodeConfig::set_mqtt(const MQTT & v)
{
	m_mqtt = v;
	p_validbits |= ((uint32_t)1U << 5);
}

#endif // CONFIG_MQTT
inline uint16_t NodeConfig::dmesg_size() const
{
	return m_dmesg_size;
}

inline bool NodeConfig::has_dmesg_size() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 6));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_dmesg_size()
{
	p_validbits &= ~((uint32_t)1U << 6);
	m_dmesg_size = 1024;
}

inline uint16_t *NodeConfig::mutable_dmesg_size()
{
	if (0 == (p_validbits & ((uint32_t)1U << 6))) {
		p_validbits |= ((uint32_t)1U << 6);
		m_dmesg_size = 1024;
	}
	return &m_dmesg_size;
}

inline void NodeConfig::set_dmesg_size(uint16_t  v)
{
	m_dmesg_size = v;
	p_validbits |= ((uint32_t)1U << 6);
}

#ifdef CONFIG_INFLUX
inline const Influx &NodeConfig::influx() const
{
	return m_influx;
}

inline bool NodeConfig::has_influx() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 7));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_influx()
{
	p_validbits &= ~((uint32_t)1U << 7);
	m_influx.clear();
}

inline Influx *NodeConfig::mutable_influx()
{
	if (0 == (p_validbits & ((uint32_t)1U << 7))) {
		p_validbits |= ((uint32_t)1U << 7);
		m_influx.clear();
	}
	return &m_influx;
}

inline void NodeConfig::set_influx(const void *data, size_t s)
{
	m_influx.fromMemory((const char *)data,s);
	p_validbits |= ((uint32_t)1U << 7);
}

inline void NodeConfig::set_influx(const Influx & v)
{
	m_influx = v;
	p_validbits |= ((uint32_t)1U << 7);
}

#endif // CONFIG_INFLUX
inline uint64_t NodeConfig::station2ap_time() const
{
	return m_station2ap_time;
}

inline bool NodeConfig::has_station2ap_time() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 8));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_station2ap_time()
{
	p_validbits &= ~((uint32_t)1U << 8);
	m_station2ap_time = 0;
}

inline uint64_t *NodeConfig::mutable_station2ap_time()
{
	if (0 == (p_validbits & ((uint32_t)1U << 8))) {
		p_validbits |= ((uint32_t)1U << 8);
		m_station2ap_time = 0;
	}
	return &m_station2ap_time;
}

inline void NodeConfig::set_station2ap_time(uint64_t  v)
{
	m_station2ap_time = v;
	p_validbits |= ((uint32_t)1U << 8);
}

inline const std::string &NodeConfig::domainname() const
{
	return m_domainname;
}

inline bool NodeConfig::has_domainname() const
{
	return !m_domainname.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_domainname()
{
	m_domainname = "";
}

inline std::string *NodeConfig::mutable_domainname()
{
	return &m_domainname;
}

inline void NodeConfig::set_domainname(const void *data, size_t s)
{
	m_domainname.assign((const char *)data,s);
}

inline void NodeConfig::set_domainname(const char *data)
{
	m_domainname = data;
}

inline void NodeConfig::set_domainname(const std::string & v)
{
	m_domainname = v;
}

inline const Date &NodeConfig::holidays(unsigned x) const
{
	return m_holidays[x];
}

inline const std::vector<Date> &NodeConfig::holidays() const
{
	return m_holidays;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_holidays()
{
	m_holidays.clear();
}

inline Date *NodeConfig::mutable_holidays(unsigned x)
{
	if (x >= m_holidays.size())
		m_holidays.resize(x+1);
	return &m_holidays[x];
}

inline std::vector<Date> *NodeConfig::mutable_holidays()
{
	return &m_holidays;
}

inline Date *NodeConfig::add_holidays()
{
	m_holidays.resize(m_holidays.size()+1);
	return &m_holidays.back();
}

inline void NodeConfig::set_holidays(unsigned x, const Date &v)
{
	assert(x < m_holidays.size());
	m_holidays[x] = v;
}

inline size_t NodeConfig::holidays_size() const
{
	return m_holidays.size();
}

inline const AtAction &NodeConfig::at_actions(unsigned x) const
{
	return m_at_actions[x];
}

inline const std::vector<AtAction> &NodeConfig::at_actions() const
{
	return m_at_actions;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_at_actions()
{
	m_at_actions.clear();
}

inline AtAction *NodeConfig::mutable_at_actions(unsigned x)
{
	if (x >= m_at_actions.size())
		m_at_actions.resize(x+1);
	return &m_at_actions[x];
}

inline std::vector<AtAction> *NodeConfig::mutable_at_actions()
{
	return &m_at_actions;
}

inline AtAction *NodeConfig::add_at_actions()
{
	m_at_actions.resize(m_at_actions.size()+1);
	return &m_at_actions.back();
}

inline void NodeConfig::set_at_actions(unsigned x, const AtAction &v)
{
	assert(x < m_at_actions.size());
	m_at_actions[x] = v;
}

inline size_t NodeConfig::at_actions_size() const
{
	return m_at_actions.size();
}

inline uint64_t NodeConfig::actions_enable() const
{
	return m_actions_enable;
}

inline bool NodeConfig::has_actions_enable() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 9));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_actions_enable()
{
	p_validbits &= ~((uint32_t)1U << 9);
	m_actions_enable = 1;
}

inline uint64_t *NodeConfig::mutable_actions_enable()
{
	if (0 == (p_validbits & ((uint32_t)1U << 9))) {
		p_validbits |= ((uint32_t)1U << 9);
		m_actions_enable = 1;
	}
	return &m_actions_enable;
}

inline void NodeConfig::set_actions_enable(uint64_t  v)
{
	m_actions_enable = v;
	p_validbits |= ((uint32_t)1U << 9);
}

inline const Trigger &NodeConfig::triggers(unsigned x) const
{
	return m_triggers[x];
}

inline const std::vector<Trigger> &NodeConfig::triggers() const
{
	return m_triggers;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_triggers()
{
	m_triggers.clear();
}

inline Trigger *NodeConfig::mutable_triggers(unsigned x)
{
	if (x >= m_triggers.size())
		m_triggers.resize(x+1);
	return &m_triggers[x];
}

inline std::vector<Trigger> *NodeConfig::mutable_triggers()
{
	return &m_triggers;
}

inline Trigger *NodeConfig::add_triggers()
{
	m_triggers.resize(m_triggers.size()+1);
	return &m_triggers.back();
}

inline void NodeConfig::set_triggers(unsigned x, const Trigger &v)
{
	assert(x < m_triggers.size());
	m_triggers[x] = v;
}

inline size_t NodeConfig::triggers_size() const
{
	return m_triggers.size();
}

inline const UartSettings &NodeConfig::uart(unsigned x) const
{
	return m_uart[x];
}

inline const std::vector<UartSettings> &NodeConfig::uart() const
{
	return m_uart;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_uart()
{
	m_uart.clear();
}

inline UartSettings *NodeConfig::mutable_uart(unsigned x)
{
	if (x >= m_uart.size())
		m_uart.resize(x+1);
	return &m_uart[x];
}

inline std::vector<UartSettings> *NodeConfig::mutable_uart()
{
	return &m_uart;
}

inline UartSettings *NodeConfig::add_uart()
{
	m_uart.resize(m_uart.size()+1);
	return &m_uart.back();
}

inline void NodeConfig::set_uart(unsigned x, const UartSettings &v)
{
	assert(x < m_uart.size());
	m_uart[x] = v;
}

inline size_t NodeConfig::uart_size() const
{
	return m_uart.size();
}

inline const TerminalConfig &NodeConfig::terminal(unsigned x) const
{
	return m_terminal[x];
}

inline const std::vector<TerminalConfig> &NodeConfig::terminal() const
{
	return m_terminal;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_terminal()
{
	m_terminal.clear();
}

inline TerminalConfig *NodeConfig::mutable_terminal(unsigned x)
{
	if (x >= m_terminal.size())
		m_terminal.resize(x+1);
	return &m_terminal[x];
}

inline std::vector<TerminalConfig> *NodeConfig::mutable_terminal()
{
	return &m_terminal;
}

inline TerminalConfig *NodeConfig::add_terminal()
{
	m_terminal.resize(m_terminal.size()+1);
	return &m_terminal.back();
}

inline void NodeConfig::set_terminal(unsigned x, const TerminalConfig &v)
{
	assert(x < m_terminal.size());
	m_terminal[x] = v;
}

inline size_t NodeConfig::terminal_size() const
{
	return m_terminal.size();
}

inline uint16_t NodeConfig::udp_ctrl_port() const
{
	return m_udp_ctrl_port;
}

inline bool NodeConfig::has_udp_ctrl_port() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 10));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_udp_ctrl_port()
{
	p_validbits &= ~((uint32_t)1U << 10);
	m_udp_ctrl_port = 12719;
}

inline uint16_t *NodeConfig::mutable_udp_ctrl_port()
{
	if (0 == (p_validbits & ((uint32_t)1U << 10))) {
		p_validbits |= ((uint32_t)1U << 10);
		m_udp_ctrl_port = 12719;
	}
	return &m_udp_ctrl_port;
}

inline void NodeConfig::set_udp_ctrl_port(uint16_t  v)
{
	m_udp_ctrl_port = v;
	p_validbits |= ((uint32_t)1U << 10);
}

inline const std::string &NodeConfig::debugs(unsigned x) const
{
	return m_debugs[x];
}

inline const std::vector<std::string> &NodeConfig::debugs() const
{
	return m_debugs;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_debugs()
{
	m_debugs.clear();
}

inline std::string *NodeConfig::mutable_debugs(unsigned x)
{
	if (x >= m_debugs.size())
		m_debugs.resize(x+1);
	return &m_debugs[x];
}

inline std::vector<std::string> *NodeConfig::mutable_debugs()
{
	return &m_debugs;
}

inline void NodeConfig::add_debugs(const std::string &v)
{
	m_debugs.push_back(v);
}

inline void NodeConfig::add_debugs(const char *s)
{
	m_debugs.push_back(s);
}

inline void NodeConfig::set_debugs(unsigned x, const std::string &v)
{
	assert(x < m_debugs.size());
	m_debugs[x] = v;
}

inline size_t NodeConfig::debugs_size() const
{
	return m_debugs.size();
}

#ifdef CONFIG_FTP
inline const FtpHttpConfig &NodeConfig::ftpd() const
{
	return m_ftpd;
}

inline bool NodeConfig::has_ftpd() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 11));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_ftpd()
{
	p_validbits &= ~((uint32_t)1U << 11);
	m_ftpd.clear();
}

inline FtpHttpConfig *NodeConfig::mutable_ftpd()
{
	if (0 == (p_validbits & ((uint32_t)1U << 11))) {
		p_validbits |= ((uint32_t)1U << 11);
		m_ftpd.clear();
	}
	return &m_ftpd;
}

inline void NodeConfig::set_ftpd(const void *data, size_t s)
{
	m_ftpd.fromMemory((const char *)data,s);
	p_validbits |= ((uint32_t)1U << 11);
}

inline void NodeConfig::set_ftpd(const FtpHttpConfig & v)
{
	m_ftpd = v;
	p_validbits |= ((uint32_t)1U << 11);
}

#endif // CONFIG_FTP
inline const FtpHttpConfig &NodeConfig::httpd() const
{
	return m_httpd;
}

inline bool NodeConfig::has_httpd() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 12));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_httpd()
{
	p_validbits &= ~((uint32_t)1U << 12);
	m_httpd.clear();
}

inline FtpHttpConfig *NodeConfig::mutable_httpd()
{
	if (0 == (p_validbits & ((uint32_t)1U << 12))) {
		p_validbits |= ((uint32_t)1U << 12);
		m_httpd.clear();
	}
	return &m_httpd;
}

inline void NodeConfig::set_httpd(const void *data, size_t s)
{
	m_httpd.fromMemory((const char *)data,s);
	p_validbits |= ((uint32_t)1U << 12);
}

inline void NodeConfig::set_httpd(const FtpHttpConfig & v)
{
	m_httpd = v;
	p_validbits |= ((uint32_t)1U << 12);
}

inline const EventTimer &NodeConfig::timefuses(unsigned x) const
{
	return m_timefuses[x];
}

inline const std::vector<EventTimer> &NodeConfig::timefuses() const
{
	return m_timefuses;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_timefuses()
{
	m_timefuses.clear();
}

inline EventTimer *NodeConfig::mutable_timefuses(unsigned x)
{
	if (x >= m_timefuses.size())
		m_timefuses.resize(x+1);
	return &m_timefuses[x];
}

inline std::vector<EventTimer> *NodeConfig::mutable_timefuses()
{
	return &m_timefuses;
}

inline EventTimer *NodeConfig::add_timefuses()
{
	m_timefuses.resize(m_timefuses.size()+1);
	return &m_timefuses.back();
}

inline void NodeConfig::set_timefuses(unsigned x, const EventTimer &v)
{
	assert(x < m_timefuses.size());
	m_timefuses[x] = v;
}

inline size_t NodeConfig::timefuses_size() const
{
	return m_timefuses.size();
}

#ifdef CONFIG_SIGNAL_PROC
inline const SignalConfig &NodeConfig::signals(unsigned x) const
{
	return m_signals[x];
}

inline const std::vector<SignalConfig> &NodeConfig::signals() const
{
	return m_signals;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_signals()
{
	m_signals.clear();
}

inline SignalConfig *NodeConfig::mutable_signals(unsigned x)
{
	if (x >= m_signals.size())
		m_signals.resize(x+1);
	return &m_signals[x];
}

inline std::vector<SignalConfig> *NodeConfig::mutable_signals()
{
	return &m_signals;
}

inline SignalConfig *NodeConfig::add_signals()
{
	m_signals.resize(m_signals.size()+1);
	return &m_signals.back();
}

inline void NodeConfig::set_signals(unsigned x, const SignalConfig &v)
{
	assert(x < m_signals.size());
	m_signals[x] = v;
}

inline size_t NodeConfig::signals_size() const
{
	return m_signals.size();
}

#endif // CONFIG_SIGNAL_PROC
#ifdef CONFIG_SIGNAL_PROC
inline const FunctionConfig &NodeConfig::functions(unsigned x) const
{
	return m_functions[x];
}

inline const std::vector<FunctionConfig> &NodeConfig::functions() const
{
	return m_functions;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_functions()
{
	m_functions.clear();
}

inline FunctionConfig *NodeConfig::mutable_functions(unsigned x)
{
	if (x >= m_functions.size())
		m_functions.resize(x+1);
	return &m_functions[x];
}

inline std::vector<FunctionConfig> *NodeConfig::mutable_functions()
{
	return &m_functions;
}

inline FunctionConfig *NodeConfig::add_functions()
{
	m_functions.resize(m_functions.size()+1);
	return &m_functions.back();
}

inline void NodeConfig::set_functions(unsigned x, const FunctionConfig &v)
{
	assert(x < m_functions.size());
	m_functions[x] = v;
}

inline size_t NodeConfig::functions_size() const
{
	return m_functions.size();
}

#endif // CONFIG_SIGNAL_PROC
inline uint64_t NodeConfig::max_on_time() const
{
	return m_max_on_time;
}

inline bool NodeConfig::has_max_on_time() const
{
	return m_max_on_time != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_max_on_time()
{
	m_max_on_time = 0;
}

inline void NodeConfig::set_max_on_time(uint64_t  v)
{
	m_max_on_time = v;
}

inline uint64_t NodeConfig::threshold_off() const
{
	return m_threshold_off;
}

inline bool NodeConfig::has_threshold_off() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 13));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_threshold_off()
{
	p_validbits &= ~((uint32_t)1U << 13);
	m_threshold_off = 0;
}

inline uint64_t *NodeConfig::mutable_threshold_off()
{
	if (0 == (p_validbits & ((uint32_t)1U << 13))) {
		p_validbits |= ((uint32_t)1U << 13);
		m_threshold_off = 0;
	}
	return &m_threshold_off;
}

inline void NodeConfig::set_threshold_off(uint64_t  v)
{
	m_threshold_off = v;
	p_validbits |= ((uint32_t)1U << 13);
}

inline uint64_t NodeConfig::threshold_on() const
{
	return m_threshold_on;
}

inline bool NodeConfig::has_threshold_on() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 14));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_threshold_on()
{
	p_validbits &= ~((uint32_t)1U << 14);
	m_threshold_on = 0;
}

inline uint64_t *NodeConfig::mutable_threshold_on()
{
	if (0 == (p_validbits & ((uint32_t)1U << 14))) {
		p_validbits |= ((uint32_t)1U << 14);
		m_threshold_on = 0;
	}
	return &m_threshold_on;
}

inline void NodeConfig::set_threshold_on(uint64_t  v)
{
	m_threshold_on = v;
	p_validbits |= ((uint32_t)1U << 14);
}

inline uint64_t NodeConfig::dim_step() const
{
	return m_dim_step;
}

inline bool NodeConfig::has_dim_step() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 15));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_dim_step()
{
	p_validbits &= ~((uint32_t)1U << 15);
	m_dim_step = 0;
}

inline uint64_t *NodeConfig::mutable_dim_step()
{
	if (0 == (p_validbits & ((uint32_t)1U << 15))) {
		p_validbits |= ((uint32_t)1U << 15);
		m_dim_step = 0;
	}
	return &m_dim_step;
}

inline void NodeConfig::set_dim_step(uint64_t  v)
{
	m_dim_step = v;
	p_validbits |= ((uint32_t)1U << 15);
}

inline bool NodeConfig::lightctrl() const
{
	return m_lightctrl;
}

inline bool NodeConfig::has_lightctrl() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 16));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_lightctrl()
{
	p_validbits &= ~((uint32_t)1U << 16);
	m_lightctrl = 0;
}

inline bool *NodeConfig::mutable_lightctrl()
{
	if (0 == (p_validbits & ((uint32_t)1U << 16))) {
		p_validbits |= ((uint32_t)1U << 16);
		m_lightctrl = 0;
	}
	return &m_lightctrl;
}

inline void NodeConfig::set_lightctrl(bool  v)
{
	m_lightctrl = v;
	p_validbits |= ((uint32_t)1U << 16);
}

inline uint64_t NodeConfig::pwm_freq() const
{
	return m_pwm_freq;
}

inline bool NodeConfig::has_pwm_freq() const
{
	return 0 != (p_validbits & ((uint32_t)1U << 17));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_pwm_freq()
{
	p_validbits &= ~((uint32_t)1U << 17);
	m_pwm_freq = 0;
}

inline uint64_t *NodeConfig::mutable_pwm_freq()
{
	if (0 == (p_validbits & ((uint32_t)1U << 17))) {
		p_validbits |= ((uint32_t)1U << 17);
		m_pwm_freq = 0;
	}
	return &m_pwm_freq;
}

inline void NodeConfig::set_pwm_freq(uint64_t  v)
{
	m_pwm_freq = v;
	p_validbits |= ((uint32_t)1U << 17);
}

#ifdef CONFIG_SIGNAL_PROC
inline const AppParam &NodeConfig::app_params(unsigned x) const
{
	return m_app_params[x];
}

inline const std::vector<AppParam> &NodeConfig::app_params() const
{
	return m_app_params;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_app_params()
{
	m_app_params.clear();
}

inline AppParam *NodeConfig::mutable_app_params(unsigned x)
{
	if (x >= m_app_params.size())
		m_app_params.resize(x+1);
	return &m_app_params[x];
}

inline std::vector<AppParam> *NodeConfig::mutable_app_params()
{
	return &m_app_params;
}

inline AppParam *NodeConfig::add_app_params()
{
	m_app_params.resize(m_app_params.size()+1);
	return &m_app_params.back();
}

inline void NodeConfig::set_app_params(unsigned x, const AppParam &v)
{
	assert(x < m_app_params.size());
	m_app_params[x] = v;
}

inline size_t NodeConfig::app_params_size() const
{
	return m_app_params.size();
}

#endif // CONFIG_SIGNAL_PROC
#ifdef CONFIG_ONEWIRE
inline const OwDeviceConfig &NodeConfig::owdevices(unsigned x) const
{
	return m_owdevices[x];
}

inline const std::vector<OwDeviceConfig> &NodeConfig::owdevices() const
{
	return m_owdevices;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_owdevices()
{
	m_owdevices.clear();
}

inline OwDeviceConfig *NodeConfig::mutable_owdevices(unsigned x)
{
	if (x >= m_owdevices.size())
		m_owdevices.resize(x+1);
	return &m_owdevices[x];
}

inline std::vector<OwDeviceConfig> *NodeConfig::mutable_owdevices()
{
	return &m_owdevices;
}

inline OwDeviceConfig *NodeConfig::add_owdevices()
{
	m_owdevices.resize(m_owdevices.size()+1);
	return &m_owdevices.back();
}

inline void NodeConfig::set_owdevices(unsigned x, const OwDeviceConfig &v)
{
	assert(x < m_owdevices.size());
	m_owdevices[x] = v;
}

inline size_t NodeConfig::owdevices_size() const
{
	return m_owdevices.size();
}

#endif // CONFIG_ONEWIRE
#endif
