/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: P2304 (hg:456/095c4982cbea)
 * WFC is Copyright 2015-2022, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : hwcfg.wfc
 * Copyright: 2018-2023
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2023-10-24, 21:26:42 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from pc:
 * Optimize        : "speed"
 * toASCII         : "toASCII"
 * toSink          : ""
 * 
 * options from common:
 * BaseClass       : "Message"
 * getMember       : "getMember"
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bool      : "ascii_bool"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * bytestype       : "std::string"
 * calcSize        : "calcSize"
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * copyright       : ""
 * email           : ""
 * endian          : "unknown"
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * IntSize         : 64
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * SortMembers     : "id"
 * stringtype      : "std::string"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * toString        : "toString"
 * toWire          : "toWire"
 * UnknownField    : "skip"
 * VarIntBits      : 64
 * wireput         : ""
 * wiresize        : ""
 * 
 * enabled flags from commandline:
 * 	enumnames
 * enabled flags from pc:
 * 	enummap
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux, withEqual, withUnequal
 */

#include <ostream>
#include <map>
#include <stdlib.h>
#include <string.h>
#include "hwcfg.h"

#include "wfccore.h"

#if !defined(WFC_ENDIAN) || (WFC_ENDIAN != 0)
#error wfc: incompatible settings concerning endian
#endif


static const char *pull_mode_e_names[] = {
	"pull_dir",
	"pull_down",
	"pull_en",
	"pull_none",
	"pull_up",
};

static pull_mode_e pull_mode_e_values[] = {
	pull_dir,
	pull_down,
	pull_en,
	pull_none,
	pull_up,
};

size_t parse_ascii_pull_mode_e(pull_mode_e *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (pull_mode_e)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(pull_mode_e_names)/sizeof(pull_mode_e_names[0]); ++i) {
		if (0 == strcmp(pull_mode_e_names[i],s)) {
			*v = pull_mode_e_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *pull_mode_e_str(pull_mode_e e)
{
	for (size_t i = 0; i < sizeof(pull_mode_e_values)/sizeof(pull_mode_e_values[0]); ++i) {
		if (e == pull_mode_e_values[i])
			return pull_mode_e_names[i];
	}
	return 0;
}

static const char *dht_model_t_names[] = {
	"AM2301",
	"AM2302",
	"DHT11",
	"DHT21",
	"DHT22",
	"DHT_NONE",
	"RHT03",
};

static dht_model_t dht_model_t_values[] = {
	AM2301,
	AM2302,
	DHT11,
	DHT21,
	DHT22,
	DHT_NONE,
	RHT03,
};

size_t parse_ascii_dht_model_t(dht_model_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (dht_model_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(dht_model_t_names)/sizeof(dht_model_t_names[0]); ++i) {
		if (0 == strcmp(dht_model_t_names[i],s)) {
			*v = dht_model_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *dht_model_t_str(dht_model_t e)
{
	for (size_t i = 0; i < sizeof(dht_model_t_values)/sizeof(dht_model_t_values[0]); ++i) {
		if (e == dht_model_t_values[i])
			return dht_model_t_names[i];
	}
	return 0;
}

static const char *i2cdrv_t_names[] = {
	"i2cdrv_ht16k33",
	"i2cdrv_ina219",
	"i2cdrv_invalid",
	"i2cdrv_mcp2300x",
	"i2cdrv_mcp2301x",
	"i2cdrv_pca9685",
	"i2cdrv_pca9685_npn",
	"i2cdrv_pca9685_pnp",
	"i2cdrv_pca9685_xclk",
	"i2cdrv_pca9685_xclk_npn",
	"i2cdrv_pca9685_xclk_pnp",
	"i2cdrv_pcf8574",
	"i2cdrv_sh1106",
	"i2cdrv_si7021",
	"i2cdrv_ssd1306",
	"i2cdrv_tca9555",
};

static i2cdrv_t i2cdrv_t_values[] = {
	i2cdrv_ht16k33,
	i2cdrv_ina219,
	i2cdrv_invalid,
	i2cdrv_mcp2300x,
	i2cdrv_mcp2301x,
	i2cdrv_pca9685,
	i2cdrv_pca9685_npn,
	i2cdrv_pca9685_pnp,
	i2cdrv_pca9685_xclk,
	i2cdrv_pca9685_xclk_npn,
	i2cdrv_pca9685_xclk_pnp,
	i2cdrv_pcf8574,
	i2cdrv_sh1106,
	i2cdrv_si7021,
	i2cdrv_ssd1306,
	i2cdrv_tca9555,
};

size_t parse_ascii_i2cdrv_t(i2cdrv_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (i2cdrv_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(i2cdrv_t_names)/sizeof(i2cdrv_t_names[0]); ++i) {
		if (0 == strcmp(i2cdrv_t_names[i],s)) {
			*v = i2cdrv_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *i2cdrv_t_str(i2cdrv_t e)
{
	for (size_t i = 0; i < sizeof(i2cdrv_t_values)/sizeof(i2cdrv_t_values[0]); ++i) {
		if (e == i2cdrv_t_values[i])
			return i2cdrv_t_names[i];
	}
	return 0;
}

static const char *disp_t_names[] = {
	"dt_ili9341",
	"dt_none",
	"dt_pcf8574_hd44780u",
	"dt_sd_14seg",
	"dt_sd_7seg",
	"dt_sh1106",
	"dt_ssd1306",
	"dt_ssd1309",
};

static disp_t disp_t_values[] = {
	dt_ili9341,
	dt_none,
	dt_pcf8574_hd44780u,
	dt_sd_14seg,
	dt_sd_7seg,
	dt_sh1106,
	dt_ssd1306,
	dt_ssd1309,
};

size_t parse_ascii_disp_t(disp_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (disp_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(disp_t_names)/sizeof(disp_t_names[0]); ++i) {
		if (0 == strcmp(disp_t_names[i],s)) {
			*v = disp_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *disp_t_str(disp_t e)
{
	for (size_t i = 0; i < sizeof(disp_t_values)/sizeof(disp_t_values[0]); ++i) {
		if (e == disp_t_values[i])
			return disp_t_names[i];
	}
	return 0;
}

static const char *spidrv_t_names[] = {
	"spidrv_ili9341",
	"spidrv_invalid",
	"spidrv_sdcard",
	"spidrv_ssd1309",
	"spidrv_sx1276",
	"spidrv_xpt2046",
};

static spidrv_t spidrv_t_values[] = {
	spidrv_ili9341,
	spidrv_invalid,
	spidrv_sdcard,
	spidrv_ssd1309,
	spidrv_sx1276,
	spidrv_xpt2046,
};

size_t parse_ascii_spidrv_t(spidrv_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (spidrv_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(spidrv_t_names)/sizeof(spidrv_t_names[0]); ++i) {
		if (0 == strcmp(spidrv_t_names[i],s)) {
			*v = spidrv_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *spidrv_t_str(spidrv_t e)
{
	for (size_t i = 0; i < sizeof(spidrv_t_values)/sizeof(spidrv_t_values[0]); ++i) {
		if (e == spidrv_t_values[i])
			return spidrv_t_names[i];
	}
	return 0;
}

void SystemConfig::clear()
{
	m_manufacturer.clear();
	m_board_name.clear();
	m_board_rev.clear();
	m_diag_uart = 0;
	m_console_rx = 0;
	m_console_tx = 0;
	m_model_name.clear();
	m_model_number.clear();
	#ifdef CONFIG_USB_DIAGLOG
	m_usb_diag = true;
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	m_usb_con = true;
	#endif // CONFIG_USB_CONSOLE
	p_validbits = 0;
}

void SystemConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "SystemConfig {";
	++indent;
	ascii_string(o,indent,m_manufacturer.data(),m_manufacturer.size(),"manufacturer");
	ascii_string(o,indent,m_board_name.data(),m_board_name.size(),"board_name");
	ascii_string(o,indent,m_board_rev.data(),m_board_rev.size(),"board_rev");
	ascii_numeric(o, indent, "diag_uart", (signed) m_diag_uart);
	ascii_numeric(o, indent, "console_rx", (signed) m_console_rx);
	ascii_numeric(o, indent, "console_tx", (signed) m_console_tx);
	ascii_string(o,indent,m_model_name.data(),m_model_name.size(),"model_name");
	ascii_string(o,indent,m_model_number.data(),m_model_number.size(),"model_number");
	#ifdef CONFIG_USB_DIAGLOG
	ascii_bool(o, indent, "usb_diag", m_usb_diag);
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	ascii_bool(o, indent, "usb_con", m_usb_con);
	#endif // CONFIG_USB_CONSOLE
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SystemConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -1;
		a += fn;
		switch (fid) {
		case 0xa:	// manufacturer id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -2;
				m_manufacturer.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x12:	// board_name id 2, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -3;
				m_board_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x1a:	// board_rev id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -4;
				m_board_rev.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x20:	// diag_uart id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -5;
				a += n;
				set_diag_uart(varint_sint(v));
			}
			break;
		case 0x28:	// console_rx id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -6;
				a += n;
				set_console_rx(varint_sint(v));
			}
			break;
		case 0x30:	// console_tx id 6, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -7;
				a += n;
				set_console_tx(varint_sint(v));
			}
			break;
		case 0x3a:	// model_name id 7, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -8;
				m_model_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x42:	// model_number id 8, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -9;
				m_model_number.assign((const char*)a,v);
				a += v;
			}
			break;
			#ifdef CONFIG_USB_DIAGLOG
		case 0x4b:	// usb_diag id 9, type bool, coding 8bit
			if (a >= e)
				return -10;
			set_usb_diag(*a++);
			break;
			#endif // CONFIG_USB_DIAGLOG
			#ifdef CONFIG_USB_CONSOLE
		case 0x53:	// usb_con id 10, type bool, coding 8bit
			if (a >= e)
				return -11;
			set_usb_con(*a++);
			break;
			#endif // CONFIG_USB_CONSOLE
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -12;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -13;
	return a-(const uint8_t *)b;
}

ssize_t SystemConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has manufacturer?
	if (!m_manufacturer.empty()) {
		// 'manufacturer': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -14;
		*a++ = 0xa;
		ssize_t manufacturer_s = m_manufacturer.size();
		n = write_varint(a,e-a,manufacturer_s);
		a += n;
		if ((n <= 0) || ((e-a) < manufacturer_s))
			return -15;
		memcpy(a,m_manufacturer.data(),manufacturer_s);
		a += manufacturer_s;
	}
	// has board_name?
	if (!m_board_name.empty()) {
		// 'board_name': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -16;
		*a++ = 0x12;
		ssize_t board_name_s = m_board_name.size();
		n = write_varint(a,e-a,board_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < board_name_s))
			return -17;
		memcpy(a,m_board_name.data(),board_name_s);
		a += board_name_s;
	}
	// has board_rev?
	if (!m_board_rev.empty()) {
		// 'board_rev': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -18;
		*a++ = 0x1a;
		ssize_t board_rev_s = m_board_rev.size();
		n = write_varint(a,e-a,board_rev_s);
		a += n;
		if ((n <= 0) || ((e-a) < board_rev_s))
			return -19;
		memcpy(a,m_board_rev.data(),board_rev_s);
		a += board_rev_s;
	}
	// has diag_uart?
	if (m_diag_uart != 0) {
		// 'diag_uart': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -20;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_diag_uart));
		if (n <= 0)
			return -21;
		a += n;
	}
	// has console_rx?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'console_rx': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -22;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_console_rx));
		if (n <= 0)
			return -23;
		a += n;
	}
	// has console_tx?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'console_tx': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -24;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_console_tx));
		if (n <= 0)
			return -25;
		a += n;
	}
	// has model_name?
	if (!m_model_name.empty()) {
		// 'model_name': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -26;
		*a++ = 0x3a;
		ssize_t model_name_s = m_model_name.size();
		n = write_varint(a,e-a,model_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < model_name_s))
			return -27;
		memcpy(a,m_model_name.data(),model_name_s);
		a += model_name_s;
	}
	// has model_number?
	if (!m_model_number.empty()) {
		// 'model_number': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -28;
		*a++ = 0x42;
		ssize_t model_number_s = m_model_number.size();
		n = write_varint(a,e-a,model_number_s);
		a += n;
		if ((n <= 0) || ((e-a) < model_number_s))
			return -29;
		memcpy(a,m_model_number.data(),model_number_s);
		a += model_number_s;
	}
	#ifdef CONFIG_USB_DIAGLOG
	// has usb_diag?
	if (m_usb_diag != true) {
		// 'usb_diag': id=9, encoding=8bit, tag=0x4b
		if (2 > (e-a))
			return -30;
		*a++ = 0x4b;
		*a++ = m_usb_diag;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	// has usb_con?
	if (m_usb_con != true) {
		// 'usb_con': id=10, encoding=8bit, tag=0x53
		if (2 > (e-a))
			return -31;
		*a++ = 0x53;
		*a++ = m_usb_con;
	}
	#endif // CONFIG_USB_CONSOLE
	assert(a <= e);
	return a-b;
}

void SystemConfig::toWire(void (*put)(uint8_t)) const
{
	if (!m_manufacturer.empty()) {
		// 'manufacturer': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'manufacturer': id=1
		size_t manufacturer_s = m_manufacturer.size();
		send_varint(put,manufacturer_s);
		send_bytes(put,(const uint8_t*) m_manufacturer.data(),manufacturer_s);
	}
	if (!m_board_name.empty()) {
		// 'board_name': id=2, encoding=lenpfx, tag=0x12
		put(0x12);	// 'board_name': id=2
		size_t board_name_s = m_board_name.size();
		send_varint(put,board_name_s);
		send_bytes(put,(const uint8_t*) m_board_name.data(),board_name_s);
	}
	if (!m_board_rev.empty()) {
		// 'board_rev': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'board_rev': id=3
		size_t board_rev_s = m_board_rev.size();
		send_varint(put,board_rev_s);
		send_bytes(put,(const uint8_t*) m_board_rev.data(),board_rev_s);
	}
	if (m_diag_uart != 0) {
		// 'diag_uart': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'diag_uart': id=4
		send_varint(put,sint_varint(m_diag_uart));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'console_rx': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'console_rx': id=5
		send_varint(put,sint_varint(m_console_rx));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'console_tx': id=6, encoding=varint, tag=0x30
		put(0x30);	// 'console_tx': id=6
		send_varint(put,sint_varint(m_console_tx));
	}
	if (!m_model_name.empty()) {
		// 'model_name': id=7, encoding=lenpfx, tag=0x3a
		put(0x3a);	// 'model_name': id=7
		size_t model_name_s = m_model_name.size();
		send_varint(put,model_name_s);
		send_bytes(put,(const uint8_t*) m_model_name.data(),model_name_s);
	}
	if (!m_model_number.empty()) {
		// 'model_number': id=8, encoding=lenpfx, tag=0x42
		put(0x42);	// 'model_number': id=8
		size_t model_number_s = m_model_number.size();
		send_varint(put,model_number_s);
		send_bytes(put,(const uint8_t*) m_model_number.data(),model_number_s);
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (m_usb_diag != true) {
		// 'usb_diag': id=9, encoding=8bit, tag=0x4b
		put(0x4b);	// 'usb_diag': id=9
		put(m_usb_diag);
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (m_usb_con != true) {
		// 'usb_con': id=10, encoding=8bit, tag=0x53
		put(0x53);	// 'usb_con': id=10
		put(m_usb_con);
	}
	#endif // CONFIG_USB_CONSOLE
}

void SystemConfig::toString(std::string &put) const
{
	if (!m_manufacturer.empty()) {
		// 'manufacturer': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'manufacturer': id=1
		size_t manufacturer_s = m_manufacturer.size();
		send_varint(put,manufacturer_s);
		put.append((const char *)(const uint8_t*) m_manufacturer.data(),manufacturer_s);
	}
	if (!m_board_name.empty()) {
		// 'board_name': id=2, encoding=lenpfx, tag=0x12
		put.push_back(0x12);	// 'board_name': id=2
		size_t board_name_s = m_board_name.size();
		send_varint(put,board_name_s);
		put.append((const char *)(const uint8_t*) m_board_name.data(),board_name_s);
	}
	if (!m_board_rev.empty()) {
		// 'board_rev': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'board_rev': id=3
		size_t board_rev_s = m_board_rev.size();
		send_varint(put,board_rev_s);
		put.append((const char *)(const uint8_t*) m_board_rev.data(),board_rev_s);
	}
	if (m_diag_uart != 0) {
		// 'diag_uart': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'diag_uart': id=4
		send_varint(put,sint_varint(m_diag_uart));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'console_rx': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'console_rx': id=5
		send_varint(put,sint_varint(m_console_rx));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'console_tx': id=6, encoding=varint, tag=0x30
		put.push_back(0x30);	// 'console_tx': id=6
		send_varint(put,sint_varint(m_console_tx));
	}
	if (!m_model_name.empty()) {
		// 'model_name': id=7, encoding=lenpfx, tag=0x3a
		put.push_back(0x3a);	// 'model_name': id=7
		size_t model_name_s = m_model_name.size();
		send_varint(put,model_name_s);
		put.append((const char *)(const uint8_t*) m_model_name.data(),model_name_s);
	}
	if (!m_model_number.empty()) {
		// 'model_number': id=8, encoding=lenpfx, tag=0x42
		put.push_back(0x42);	// 'model_number': id=8
		size_t model_number_s = m_model_number.size();
		send_varint(put,model_number_s);
		put.append((const char *)(const uint8_t*) m_model_number.data(),model_number_s);
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (m_usb_diag != true) {
		// 'usb_diag': id=9, encoding=8bit, tag=0x4b
		put.push_back(0x4b);	// 'usb_diag': id=9
		put.push_back(m_usb_diag);
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (m_usb_con != true) {
		// 'usb_con': id=10, encoding=8bit, tag=0x53
		put.push_back(0x53);	// 'usb_con': id=10
		put.push_back(m_usb_con);
	}
	#endif // CONFIG_USB_CONSOLE
}

void SystemConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_manufacturer()) {
		fsep = json_indent(json,indLvl,fsep,"manufacturer");
		json_cstr(json,m_manufacturer.c_str());
	}
	if (has_board_name()) {
		fsep = json_indent(json,indLvl,fsep,"board_name");
		json_cstr(json,m_board_name.c_str());
	}
	if (has_board_rev()) {
		fsep = json_indent(json,indLvl,fsep,"board_rev");
		json_cstr(json,m_board_rev.c_str());
	}
	if (has_diag_uart()) {
		fsep = json_indent(json,indLvl,fsep,"diag_uart");
		json << (int) m_diag_uart;
	}
	if (has_console_rx()) {
		fsep = json_indent(json,indLvl,fsep,"console_rx");
		json << (int) m_console_rx;
	}
	if (has_console_tx()) {
		fsep = json_indent(json,indLvl,fsep,"console_tx");
		json << (int) m_console_tx;
	}
	if (has_model_name()) {
		fsep = json_indent(json,indLvl,fsep,"model_name");
		json_cstr(json,m_model_name.c_str());
	}
	if (has_model_number()) {
		fsep = json_indent(json,indLvl,fsep,"model_number");
		json_cstr(json,m_model_number.c_str());
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (has_usb_diag()) {
		fsep = json_indent(json,indLvl,fsep,"usb_diag");
		json << (m_usb_diag ? "true" : "false");
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (has_usb_con()) {
		fsep = json_indent(json,indLvl,fsep,"usb_con");
		json << (m_usb_con ? "true" : "false");
	}
	#endif // CONFIG_USB_CONSOLE
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SystemConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string manufacturer, id 1
	if (!m_manufacturer.empty()) {
		size_t manufacturer_s = m_manufacturer.size();
		r += manufacturer_s + wiresize(manufacturer_s) + 1 /* tag(manufacturer) 0x8 */;
	}
	// optional string board_name, id 2
	if (!m_board_name.empty()) {
		size_t board_name_s = m_board_name.size();
		r += board_name_s + wiresize(board_name_s) + 1 /* tag(board_name) 0x10 */;
	}
	// optional string board_rev, id 3
	if (!m_board_rev.empty()) {
		size_t board_rev_s = m_board_rev.size();
		r += board_rev_s + wiresize(board_rev_s) + 1 /* tag(board_rev) 0x18 */;
	}
	// optional sint8 diag_uart, id 4
	if (m_diag_uart != 0) {
		r += wiresize_s((varint_t)m_diag_uart) + 1 /* tag(diag_uart) 0x20 */;
	}
	// optional sint8 console_rx, id 5
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize_s((varint_t)m_console_rx) + 1 /* tag(console_rx) 0x28 */;
	}
	// optional sint8 console_tx, id 6
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize_s((varint_t)m_console_tx) + 1 /* tag(console_tx) 0x30 */;
	}
	// optional string model_name, id 7
	if (!m_model_name.empty()) {
		size_t model_name_s = m_model_name.size();
		r += model_name_s + wiresize(model_name_s) + 1 /* tag(model_name) 0x38 */;
	}
	// optional string model_number, id 8
	if (!m_model_number.empty()) {
		size_t model_number_s = m_model_number.size();
		r += model_number_s + wiresize(model_number_s) + 1 /* tag(model_number) 0x40 */;
	}
	#ifdef CONFIG_USB_DIAGLOG
	// optional bool usb_diag, id 9
	if (m_usb_diag != true) {
		r += 2;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	// optional bool usb_con, id 10
	if (m_usb_con != true) {
		r += 2;
	}
	#endif // CONFIG_USB_CONSOLE
	return r;
}

bool SystemConfig::operator != (const SystemConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_manufacturer() && (m_manufacturer != r.m_manufacturer))
		return true;
	if (has_board_name() && (m_board_name != r.m_board_name))
		return true;
	if (has_board_rev() && (m_board_rev != r.m_board_rev))
		return true;
	if (has_diag_uart() && (m_diag_uart != r.m_diag_uart))
		return true;
	if (has_console_rx() && (m_console_rx != r.m_console_rx))
		return true;
	if (has_console_tx() && (m_console_tx != r.m_console_tx))
		return true;
	if (has_model_name() && (m_model_name != r.m_model_name))
		return true;
	if (has_model_number() && (m_model_number != r.m_model_number))
		return true;
	#ifdef CONFIG_USB_DIAGLOG
	if (has_usb_diag() && (m_usb_diag != r.m_usb_diag))
		return true;
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (has_usb_con() && (m_usb_con != r.m_usb_con))
		return true;
	#endif // CONFIG_USB_CONSOLE
	return false;
}


bool SystemConfig::operator == (const SystemConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SystemConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"manufacturer")) {
		if (value == 0) {
			clear_manufacturer();
			return 0;
		}
		m_manufacturer = value;
		int r = m_manufacturer.size();
		return r;
	}
	if (0 == strcmp(name,"board_name")) {
		if (value == 0) {
			clear_board_name();
			return 0;
		}
		m_board_name = value;
		int r = m_board_name.size();
		return r;
	}
	if (0 == strcmp(name,"board_rev")) {
		if (value == 0) {
			clear_board_rev();
			return 0;
		}
		m_board_rev = value;
		int r = m_board_rev.size();
		return r;
	}
	if (0 == strcmp(name,"diag_uart")) {
		if (value == 0) {
			clear_diag_uart();
			return 0;
		}
		int r = parse_ascii_s8(&m_diag_uart,value);
		return r;
	}
	if (0 == strcmp(name,"console_rx")) {
		if (value == 0) {
			clear_console_rx();
			return 0;
		}
		int r = parse_ascii_s8(&m_console_rx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"console_tx")) {
		if (value == 0) {
			clear_console_tx();
			return 0;
		}
		int r = parse_ascii_s8(&m_console_tx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"model_name")) {
		if (value == 0) {
			clear_model_name();
			return 0;
		}
		m_model_name = value;
		int r = m_model_name.size();
		return r;
	}
	if (0 == strcmp(name,"model_number")) {
		if (value == 0) {
			clear_model_number();
			return 0;
		}
		m_model_number = value;
		int r = m_model_number.size();
		return r;
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (0 == strcmp(name,"usb_diag")) {
		if (value == 0) {
			clear_usb_diag();
			return 0;
		}
		int r = parse_ascii_bool(&m_usb_diag,value);
		return r;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (0 == strcmp(name,"usb_con")) {
		if (value == 0) {
			clear_usb_con();
			return 0;
		}
		int r = parse_ascii_bool(&m_usb_con,value);
		return r;
	}
	#endif // CONFIG_USB_CONSOLE
	return -32;
}

Message *SystemConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *SystemConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void TouchpadConfig::clear()
{
	m_fsm_mode = false;
	m_lvolt = -1;
	m_hvolt = -1;
	m_atten = -1;
	m_interval = 0;
	p_validbits = 0;
}

void TouchpadConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "TouchpadConfig {";
	++indent;
	ascii_bool(o, indent, "fsm_mode", m_fsm_mode);
	ascii_numeric(o, indent, "lvolt", (signed) m_lvolt);
	ascii_numeric(o, indent, "hvolt", (signed) m_hvolt);
	ascii_numeric(o, indent, "atten", (signed) m_atten);
	ascii_numeric(o, indent, "interval", m_interval);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t TouchpadConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -33;
		a += fn;
		switch (fid) {
		case 0xb:	// fsm_mode id 1, type bool, coding 8bit
			if (a >= e)
				return -34;
			set_fsm_mode(*a++);
			break;
		case 0x10:	// lvolt id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -35;
				a += n;
				set_lvolt(varint_sint(v));
			}
			break;
		case 0x18:	// hvolt id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -36;
				a += n;
				set_hvolt(varint_sint(v));
			}
			break;
		case 0x20:	// atten id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -37;
				a += n;
				set_atten(varint_sint(v));
			}
			break;
		case 0x38:	// interval id 7, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -38;
				a += n;
				set_interval(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -39;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -40;
	return a-(const uint8_t *)b;
}

ssize_t TouchpadConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has fsm_mode?
	if (m_fsm_mode != false) {
		// 'fsm_mode': id=1, encoding=8bit, tag=0xb
		if (2 > (e-a))
			return -41;
		*a++ = 0xb;
		*a++ = m_fsm_mode;
	}
	// has lvolt?
	if (m_lvolt != -1) {
		// 'lvolt': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -42;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_lvolt));
		if (n <= 0)
			return -43;
		a += n;
	}
	// has hvolt?
	if (m_hvolt != -1) {
		// 'hvolt': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -44;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_hvolt));
		if (n <= 0)
			return -45;
		a += n;
	}
	// has atten?
	if (m_atten != -1) {
		// 'atten': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -46;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_atten));
		if (n <= 0)
			return -47;
		a += n;
	}
	// has interval?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'interval': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -48;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_interval);
		if (n <= 0)
			return -49;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void TouchpadConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_fsm_mode != false) {
		// 'fsm_mode': id=1, encoding=8bit, tag=0xb
		put(0xb);	// 'fsm_mode': id=1
		put(m_fsm_mode);
	}
	if (m_lvolt != -1) {
		// 'lvolt': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'lvolt': id=2
		send_varint(put,sint_varint(m_lvolt));
	}
	if (m_hvolt != -1) {
		// 'hvolt': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'hvolt': id=3
		send_varint(put,sint_varint(m_hvolt));
	}
	if (m_atten != -1) {
		// 'atten': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'atten': id=4
		send_varint(put,sint_varint(m_atten));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'interval': id=7, encoding=varint, tag=0x38
		put(0x38);	// 'interval': id=7
		send_varint(put,m_interval);
	}
}

void TouchpadConfig::toString(std::string &put) const
{
	if (m_fsm_mode != false) {
		// 'fsm_mode': id=1, encoding=8bit, tag=0xb
		put.push_back(0xb);	// 'fsm_mode': id=1
		put.push_back(m_fsm_mode);
	}
	if (m_lvolt != -1) {
		// 'lvolt': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'lvolt': id=2
		send_varint(put,sint_varint(m_lvolt));
	}
	if (m_hvolt != -1) {
		// 'hvolt': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'hvolt': id=3
		send_varint(put,sint_varint(m_hvolt));
	}
	if (m_atten != -1) {
		// 'atten': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'atten': id=4
		send_varint(put,sint_varint(m_atten));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'interval': id=7, encoding=varint, tag=0x38
		put.push_back(0x38);	// 'interval': id=7
		send_varint(put,m_interval);
	}
}

void TouchpadConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_fsm_mode()) {
		fsep = json_indent(json,indLvl,fsep,"fsm_mode");
		json << (m_fsm_mode ? "true" : "false");
	}
	if (has_lvolt()) {
		fsep = json_indent(json,indLvl,fsep,"lvolt");
		json << (int) m_lvolt;
	}
	if (has_hvolt()) {
		fsep = json_indent(json,indLvl,fsep,"hvolt");
		json << (int) m_hvolt;
	}
	if (has_atten()) {
		fsep = json_indent(json,indLvl,fsep,"atten");
		json << (int) m_atten;
	}
	if (has_interval()) {
		fsep = json_indent(json,indLvl,fsep,"interval");
		json << m_interval;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TouchpadConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional bool fsm_mode, id 1
	if (m_fsm_mode != false) {
		r += 2;
	}
	// optional sint8 lvolt, id 2
	if (m_lvolt != -1) {
		r += wiresize_s((varint_t)m_lvolt) + 1 /* tag(lvolt) 0x10 */;
	}
	// optional sint8 hvolt, id 3
	if (m_hvolt != -1) {
		r += wiresize_s((varint_t)m_hvolt) + 1 /* tag(hvolt) 0x18 */;
	}
	// optional sint8 atten, id 4
	if (m_atten != -1) {
		r += wiresize_s((varint_t)m_atten) + 1 /* tag(atten) 0x20 */;
	}
	// optional unsigned interval, id 7
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_interval) + 1 /* tag(interval) 0x38 */;
	}
	return r;
}

bool TouchpadConfig::operator != (const TouchpadConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_fsm_mode() && (m_fsm_mode != r.m_fsm_mode))
		return true;
	if (has_lvolt() && (m_lvolt != r.m_lvolt))
		return true;
	if (has_hvolt() && (m_hvolt != r.m_hvolt))
		return true;
	if (has_atten() && (m_atten != r.m_atten))
		return true;
	if (has_interval() && (m_interval != r.m_interval))
		return true;
	return false;
}


bool TouchpadConfig::operator == (const TouchpadConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TouchpadConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"fsm_mode")) {
		if (value == 0) {
			clear_fsm_mode();
			return 0;
		}
		int r = parse_ascii_bool(&m_fsm_mode,value);
		return r;
	}
	if (0 == strcmp(name,"lvolt")) {
		if (value == 0) {
			clear_lvolt();
			return 0;
		}
		int r = parse_ascii_s8(&m_lvolt,value);
		return r;
	}
	if (0 == strcmp(name,"hvolt")) {
		if (value == 0) {
			clear_hvolt();
			return 0;
		}
		int r = parse_ascii_s8(&m_hvolt,value);
		return r;
	}
	if (0 == strcmp(name,"atten")) {
		if (value == 0) {
			clear_atten();
			return 0;
		}
		int r = parse_ascii_s8(&m_atten,value);
		return r;
	}
	if (0 == strcmp(name,"interval")) {
		if (value == 0) {
			clear_interval();
			return 0;
		}
		int r = parse_ascii_u64(&m_interval,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	return -50;
}

Message *TouchpadConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *TouchpadConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void TouchChannelConfig::clear()
{
	m_name.clear();
	m_channel = -1;
	m_threshold = 0;
	m_slope = 0;
	m_tieopt = 0;
	p_validbits = 0;
}

void TouchChannelConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "TouchChannelConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "channel", (signed) m_channel);
	ascii_numeric(o, indent, "threshold", m_threshold);
	ascii_numeric(o, indent, "slope", (unsigned) m_slope);
	ascii_numeric(o, indent, "tieopt", (unsigned) m_tieopt);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t TouchChannelConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -51;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -52;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// channel id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -53;
				a += n;
				set_channel(varint_sint(v));
			}
			break;
		case 0x1c:	// threshold id 3, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -54;
			set_threshold((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x20:	// slope id 4, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -55;
				a += n;
				set_slope(v);
			}
			break;
		case 0x28:	// tieopt id 5, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -56;
				a += n;
				set_tieopt(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -57;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -58;
	return a-(const uint8_t *)b;
}

ssize_t TouchChannelConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -59;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -60;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has channel?
	if (m_channel != -1) {
		// 'channel': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -61;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_channel));
		if (n <= 0)
			return -62;
		a += n;
	}
	// has threshold?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'threshold': id=3, encoding=16bit, tag=0x1c
		if (3 > (e-a))
			return -63;
		*a++ = 0x1c;
		write_u16(a,m_threshold);
		a += 2;
	}
	// has slope?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'slope': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -64;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_slope);
		if (n <= 0)
			return -65;
		a += n;
	}
	// has tieopt?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'tieopt': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -66;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_tieopt);
		if (n <= 0)
			return -67;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void TouchChannelConfig::toWire(void (*put)(uint8_t)) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (m_channel != -1) {
		// 'channel': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'channel': id=2
		send_varint(put,sint_varint(m_channel));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'threshold': id=3, encoding=16bit, tag=0x1c
		put(0x1c);	// 'threshold': id=3
		send_u16(put,m_threshold);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'slope': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'slope': id=4
		send_varint(put,m_slope);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'tieopt': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'tieopt': id=5
		send_varint(put,m_tieopt);
	}
}

void TouchChannelConfig::toString(std::string &put) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (m_channel != -1) {
		// 'channel': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'channel': id=2
		send_varint(put,sint_varint(m_channel));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'threshold': id=3, encoding=16bit, tag=0x1c
		put.push_back(0x1c);	// 'threshold': id=3
		send_u16(put,m_threshold);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'slope': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'slope': id=4
		send_varint(put,m_slope);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'tieopt': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'tieopt': id=5
		send_varint(put,m_tieopt);
	}
}

void TouchChannelConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_channel()) {
		fsep = json_indent(json,indLvl,fsep,"channel");
		json << (int) m_channel;
	}
	if (has_threshold()) {
		fsep = json_indent(json,indLvl,fsep,"threshold");
		json << m_threshold;
	}
	if (has_slope()) {
		fsep = json_indent(json,indLvl,fsep,"slope");
		json << (unsigned) m_slope;
	}
	if (has_tieopt()) {
		fsep = json_indent(json,indLvl,fsep,"tieopt");
		json << (unsigned) m_tieopt;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TouchChannelConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 channel, id 2
	if (m_channel != -1) {
		r += wiresize_s((varint_t)m_channel) + 1 /* tag(channel) 0x10 */;
	}
	// optional fixed16 threshold, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += 3;
	}
	// optional uint8 slope, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_slope) + 1 /* tag(slope) 0x20 */;
	}
	// optional uint8 tieopt, id 5
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += wiresize((varint_t)m_tieopt) + 1 /* tag(tieopt) 0x28 */;
	}
	return r;
}

bool TouchChannelConfig::operator != (const TouchChannelConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_channel() && (m_channel != r.m_channel))
		return true;
	if (has_threshold() && (m_threshold != r.m_threshold))
		return true;
	if (has_slope() && (m_slope != r.m_slope))
		return true;
	if (has_tieopt() && (m_tieopt != r.m_tieopt))
		return true;
	return false;
}


bool TouchChannelConfig::operator == (const TouchChannelConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TouchChannelConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"channel")) {
		if (value == 0) {
			clear_channel();
			return 0;
		}
		int r = parse_ascii_s8(&m_channel,value);
		return r;
	}
	if (0 == strcmp(name,"threshold")) {
		if (value == 0) {
			clear_threshold();
			return 0;
		}
		int r = parse_ascii_u16(&m_threshold,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"slope")) {
		if (value == 0) {
			clear_slope();
			return 0;
		}
		int r = parse_ascii_u8(&m_slope,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"tieopt")) {
		if (value == 0) {
			clear_tieopt();
			return 0;
		}
		int r = parse_ascii_u8(&m_tieopt,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	return -68;
}

Message *TouchChannelConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *TouchChannelConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void ButtonConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_presslvl = 0;
	m_pull_mode = pull_none;
	#ifdef CONFIG_ROTARYENCODER
	m_clk = -1;
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	m_dt = -1;
	#endif // CONFIG_ROTARYENCODER
}

void ButtonConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "ButtonConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_bool(o, indent, "presslvl", m_presslvl);
	ascii_numeric(o, indent, "pull_mode", (unsigned) m_pull_mode);
	++indent;
	ascii_indent(o,indent);
	o << ".enable";
	o << (pull_mode_enable() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".up";
	o << (pull_mode_up() ? " = true;" : " = false;");
	--indent;
	#ifdef CONFIG_ROTARYENCODER
	ascii_numeric(o, indent, "clk", (signed) m_clk);
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	ascii_numeric(o, indent, "dt", (signed) m_dt);
	#endif // CONFIG_ROTARYENCODER
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t ButtonConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -69;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -70;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -71;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x1b:	// presslvl id 3, type bool, coding 8bit
			if (a >= e)
				return -72;
			set_presslvl(*a++);
			break;
		case 0x20:	// pull_mode id 4, type pull_mode_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -73;
				a += n;
				set_pull_mode((pull_mode_t) v);
			}
			break;
			#ifdef CONFIG_ROTARYENCODER
		case 0x28:	// clk id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -74;
				a += n;
				set_clk(varint_sint(v));
			}
			break;
			#endif // CONFIG_ROTARYENCODER
			#ifdef CONFIG_ROTARYENCODER
		case 0x30:	// dt id 6, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -75;
				a += n;
				set_dt(varint_sint(v));
			}
			break;
			#endif // CONFIG_ROTARYENCODER
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -76;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -77;
	return a-(const uint8_t *)b;
}

ssize_t ButtonConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -78;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -79;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -80;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -81;
		a += n;
	}
	// has presslvl?
	if (m_presslvl != 0) {
		// 'presslvl': id=3, encoding=8bit, tag=0x1b
		if (2 > (e-a))
			return -82;
		*a++ = 0x1b;
		*a++ = m_presslvl;
	}
	// has pull_mode?
	if (m_pull_mode != pull_none) {
		// 'pull_mode': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -83;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_pull_mode);
		if (n <= 0)
			return -84;
		a += n;
	}
	#ifdef CONFIG_ROTARYENCODER
	// has clk?
	if (m_clk != -1) {
		// 'clk': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -85;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_clk));
		if (n <= 0)
			return -86;
		a += n;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	// has dt?
	if (m_dt != -1) {
		// 'dt': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -87;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_dt));
		if (n <= 0)
			return -88;
		a += n;
	}
	#endif // CONFIG_ROTARYENCODER
	assert(a <= e);
	return a-b;
}

void ButtonConfig::toWire(void (*put)(uint8_t)) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'gpio': id=2
		send_varint(put,sint_varint(m_gpio));
	}
	if (m_presslvl != 0) {
		// 'presslvl': id=3, encoding=8bit, tag=0x1b
		put(0x1b);	// 'presslvl': id=3
		put(m_presslvl);
	}
	if (m_pull_mode != pull_none) {
		// 'pull_mode': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'pull_mode': id=4
		send_varint(put,m_pull_mode);
	}
	#ifdef CONFIG_ROTARYENCODER
	if (m_clk != -1) {
		// 'clk': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'clk': id=5
		send_varint(put,sint_varint(m_clk));
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (m_dt != -1) {
		// 'dt': id=6, encoding=varint, tag=0x30
		put(0x30);	// 'dt': id=6
		send_varint(put,sint_varint(m_dt));
	}
	#endif // CONFIG_ROTARYENCODER
}

void ButtonConfig::toString(std::string &put) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'gpio': id=2
		send_varint(put,sint_varint(m_gpio));
	}
	if (m_presslvl != 0) {
		// 'presslvl': id=3, encoding=8bit, tag=0x1b
		put.push_back(0x1b);	// 'presslvl': id=3
		put.push_back(m_presslvl);
	}
	if (m_pull_mode != pull_none) {
		// 'pull_mode': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'pull_mode': id=4
		send_varint(put,m_pull_mode);
	}
	#ifdef CONFIG_ROTARYENCODER
	if (m_clk != -1) {
		// 'clk': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'clk': id=5
		send_varint(put,sint_varint(m_clk));
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (m_dt != -1) {
		// 'dt': id=6, encoding=varint, tag=0x30
		put.push_back(0x30);	// 'dt': id=6
		send_varint(put,sint_varint(m_dt));
	}
	#endif // CONFIG_ROTARYENCODER
}

void ButtonConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_presslvl()) {
		fsep = json_indent(json,indLvl,fsep,"presslvl");
		json << (m_presslvl ? "true" : "false");
	}
	if (has_pull_mode()) {
		fsep = json_indent(json,indLvl,fsep,"pull_mode");
		json << (unsigned) m_pull_mode;
	}
	#ifdef CONFIG_ROTARYENCODER
	if (has_clk()) {
		fsep = json_indent(json,indLvl,fsep,"clk");
		json << (int) m_clk;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (has_dt()) {
		fsep = json_indent(json,indLvl,fsep,"dt");
		json << (int) m_dt;
	}
	#endif // CONFIG_ROTARYENCODER
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t ButtonConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional bool presslvl, id 3
	if (m_presslvl != 0) {
		r += 2;
	}
	// optional pull_mode_t pull_mode, id 4
	if (m_pull_mode != pull_none) {
		r += wiresize((varint_t)m_pull_mode) + 1 /* tag(pull_mode) 0x20 */;
	}
	#ifdef CONFIG_ROTARYENCODER
	// optional sint8 clk, id 5
	if (m_clk != -1) {
		r += wiresize_s((varint_t)m_clk) + 1 /* tag(clk) 0x28 */;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	// optional sint8 dt, id 6
	if (m_dt != -1) {
		r += wiresize_s((varint_t)m_dt) + 1 /* tag(dt) 0x30 */;
	}
	#endif // CONFIG_ROTARYENCODER
	return r;
}

bool ButtonConfig::operator != (const ButtonConfig &r) const
{
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_presslvl() && (m_presslvl != r.m_presslvl))
		return true;
	if (has_pull_mode() && (m_pull_mode != r.m_pull_mode))
		return true;
	#ifdef CONFIG_ROTARYENCODER
	if (has_clk() && (m_clk != r.m_clk))
		return true;
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (has_dt() && (m_dt != r.m_dt))
		return true;
	#endif // CONFIG_ROTARYENCODER
	return false;
}


bool ButtonConfig::operator == (const ButtonConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int ButtonConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"presslvl")) {
		if (value == 0) {
			clear_presslvl();
			return 0;
		}
		int r = parse_ascii_bool(&m_presslvl,value);
		return r;
	}
	if ((0 == memcmp(name,"pull_mode",9)) && ((name[9] == 0) || name[9] == '.')) {
		name += 9;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_pull_mode((pull_mode_t)ull);
			else if (!strcmp(name,"enable"))
				set_pull_mode_enable((bool)ull);
			else if (!strcmp(name,"up"))
				set_pull_mode_up((bool)ull);
			return eptr - value;
		} else {
			return -89;
		}
	}
	#ifdef CONFIG_ROTARYENCODER
	if (0 == strcmp(name,"clk")) {
		if (value == 0) {
			clear_clk();
			return 0;
		}
		int r = parse_ascii_s8(&m_clk,value);
		return r;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (0 == strcmp(name,"dt")) {
		if (value == 0) {
			clear_dt();
			return 0;
		}
		int r = parse_ascii_s8(&m_dt,value);
		return r;
	}
	#endif // CONFIG_ROTARYENCODER
	return -90;
}

Message *ButtonConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *ButtonConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void RelayConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_config = 0;
	m_min_itv = 0;
	m_interlock = -1;
	p_validbits = 0;
}

void RelayConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "RelayConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", (unsigned) m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".active_high";
	o << (config_active_high() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".init_on";
	o << (config_init_on() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".persistent";
	o << (config_persistent() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".opendrain";
	o << (config_opendrain() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".mqtt";
	o << (config_mqtt() ? " = true;" : " = false;");
	--indent;
	ascii_numeric(o, indent, "min_itv", m_min_itv);
	ascii_numeric(o, indent, "interlock", (signed) m_interlock);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t RelayConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -91;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -92;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -93;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x18:	// config id 3, type relay_cfg_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -94;
				a += n;
				set_config((relay_cfg_t) v);
			}
			break;
		case 0x20:	// min_itv id 4, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -95;
				a += n;
				set_min_itv(v);
			}
			break;
		case 0x28:	// interlock id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -96;
				a += n;
				set_interlock(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -97;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -98;
	return a-(const uint8_t *)b;
}

ssize_t RelayConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -99;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -100;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -101;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -102;
		a += n;
	}
	// has config?
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -103;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -104;
		a += n;
	}
	// has min_itv?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'min_itv': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -105;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_min_itv);
		if (n <= 0)
			return -106;
		a += n;
	}
	// has interlock?
	if (m_interlock != -1) {
		// 'interlock': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -107;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_interlock));
		if (n <= 0)
			return -108;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void RelayConfig::toWire(void (*put)(uint8_t)) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'gpio': id=2
		send_varint(put,sint_varint(m_gpio));
	}
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'config': id=3
		send_varint(put,m_config);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'min_itv': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'min_itv': id=4
		send_varint(put,m_min_itv);
	}
	if (m_interlock != -1) {
		// 'interlock': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'interlock': id=5
		send_varint(put,sint_varint(m_interlock));
	}
}

void RelayConfig::toString(std::string &put) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'gpio': id=2
		send_varint(put,sint_varint(m_gpio));
	}
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'config': id=3
		send_varint(put,m_config);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'min_itv': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'min_itv': id=4
		send_varint(put,m_min_itv);
	}
	if (m_interlock != -1) {
		// 'interlock': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'interlock': id=5
		send_varint(put,sint_varint(m_interlock));
	}
}

void RelayConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (has_min_itv()) {
		fsep = json_indent(json,indLvl,fsep,"min_itv");
		json << m_min_itv;
	}
	if (has_interlock()) {
		fsep = json_indent(json,indLvl,fsep,"interlock");
		json << (int) m_interlock;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t RelayConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional relay_cfg_t config, id 3
	if (m_config != 0) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	// optional unsigned min_itv, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_min_itv) + 1 /* tag(min_itv) 0x20 */;
	}
	// optional sint8 interlock, id 5
	if (m_interlock != -1) {
		r += wiresize_s((varint_t)m_interlock) + 1 /* tag(interlock) 0x28 */;
	}
	return r;
}

bool RelayConfig::operator != (const RelayConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	if (has_min_itv() && (m_min_itv != r.m_min_itv))
		return true;
	if (has_interlock() && (m_interlock != r.m_interlock))
		return true;
	return false;
}


bool RelayConfig::operator == (const RelayConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int RelayConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((relay_cfg_t)ull);
			else if (!strcmp(name,"active_high"))
				set_config_active_high((bool)ull);
			else if (!strcmp(name,"init_on"))
				set_config_init_on((bool)ull);
			else if (!strcmp(name,"persistent"))
				set_config_persistent((bool)ull);
			else if (!strcmp(name,"opendrain"))
				set_config_opendrain((bool)ull);
			else if (!strcmp(name,"mqtt"))
				set_config_mqtt((bool)ull);
			return eptr - value;
		} else {
			return -109;
		}
	}
	if (0 == strcmp(name,"min_itv")) {
		if (value == 0) {
			clear_min_itv();
			return 0;
		}
		int r = parse_ascii_u64(&m_min_itv,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"interlock")) {
		if (value == 0) {
			clear_interlock();
			return 0;
		}
		int r = parse_ascii_s8(&m_interlock,value);
		return r;
	}
	return -110;
}

Message *RelayConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *RelayConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void Max7219Config::clear()
{
	m_clk = -1;
	m_dout = -1;
	m_cs = -1;
	m_odrain = false;
	m_digits = 0;
}

void Max7219Config::toASCII(std::ostream &o, size_t indent) const
{
	o << "Max7219Config {";
	++indent;
	ascii_numeric(o, indent, "clk", (signed) m_clk);
	ascii_numeric(o, indent, "dout", (signed) m_dout);
	ascii_numeric(o, indent, "cs", (signed) m_cs);
	ascii_bool(o, indent, "odrain", m_odrain);
	ascii_numeric(o, indent, "digits", (unsigned) m_digits);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Max7219Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -111;
		a += fn;
		switch (fid) {
		case 0x8:	// clk id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -112;
				a += n;
				set_clk(varint_sint(v));
			}
			break;
		case 0x10:	// dout id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -113;
				a += n;
				set_dout(varint_sint(v));
			}
			break;
		case 0x18:	// cs id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -114;
				a += n;
				set_cs(varint_sint(v));
			}
			break;
		case 0x23:	// odrain id 4, type bool, coding 8bit
			if (a >= e)
				return -115;
			set_odrain(*a++);
			break;
		case 0x28:	// digits id 5, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -116;
				a += n;
				set_digits(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -117;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -118;
	return a-(const uint8_t *)b;
}

ssize_t Max7219Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has clk?
	if (m_clk != -1) {
		// 'clk': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -119;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_clk));
		if (n <= 0)
			return -120;
		a += n;
	}
	// has dout?
	if (m_dout != -1) {
		// 'dout': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -121;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_dout));
		if (n <= 0)
			return -122;
		a += n;
	}
	// has cs?
	if (m_cs != -1) {
		// 'cs': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -123;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_cs));
		if (n <= 0)
			return -124;
		a += n;
	}
	// has odrain?
	if (m_odrain != false) {
		// 'odrain': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -125;
		*a++ = 0x23;
		*a++ = m_odrain;
	}
	// has digits?
	if (m_digits != 0) {
		// 'digits': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -126;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_digits);
		if (n <= 0)
			return -127;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Max7219Config::toWire(void (*put)(uint8_t)) const
{
	if (m_clk != -1) {
		// 'clk': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'clk': id=1
		send_varint(put,sint_varint(m_clk));
	}
	if (m_dout != -1) {
		// 'dout': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'dout': id=2
		send_varint(put,sint_varint(m_dout));
	}
	if (m_cs != -1) {
		// 'cs': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'cs': id=3
		send_varint(put,sint_varint(m_cs));
	}
	if (m_odrain != false) {
		// 'odrain': id=4, encoding=8bit, tag=0x23
		put(0x23);	// 'odrain': id=4
		put(m_odrain);
	}
	if (m_digits != 0) {
		// 'digits': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'digits': id=5
		send_varint(put,m_digits);
	}
}

void Max7219Config::toString(std::string &put) const
{
	if (m_clk != -1) {
		// 'clk': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'clk': id=1
		send_varint(put,sint_varint(m_clk));
	}
	if (m_dout != -1) {
		// 'dout': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'dout': id=2
		send_varint(put,sint_varint(m_dout));
	}
	if (m_cs != -1) {
		// 'cs': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'cs': id=3
		send_varint(put,sint_varint(m_cs));
	}
	if (m_odrain != false) {
		// 'odrain': id=4, encoding=8bit, tag=0x23
		put.push_back(0x23);	// 'odrain': id=4
		put.push_back(m_odrain);
	}
	if (m_digits != 0) {
		// 'digits': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'digits': id=5
		send_varint(put,m_digits);
	}
}

void Max7219Config::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_clk()) {
		fsep = json_indent(json,indLvl,fsep,"clk");
		json << (int) m_clk;
	}
	if (has_dout()) {
		fsep = json_indent(json,indLvl,fsep,"dout");
		json << (int) m_dout;
	}
	if (has_cs()) {
		fsep = json_indent(json,indLvl,fsep,"cs");
		json << (int) m_cs;
	}
	if (has_odrain()) {
		fsep = json_indent(json,indLvl,fsep,"odrain");
		json << (m_odrain ? "true" : "false");
	}
	if (has_digits()) {
		fsep = json_indent(json,indLvl,fsep,"digits");
		json << (unsigned) m_digits;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Max7219Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 clk, id 1
	if (m_clk != -1) {
		r += wiresize_s((varint_t)m_clk) + 1 /* tag(clk) 0x8 */;
	}
	// optional sint8 dout, id 2
	if (m_dout != -1) {
		r += wiresize_s((varint_t)m_dout) + 1 /* tag(dout) 0x10 */;
	}
	// optional sint8 cs, id 3
	if (m_cs != -1) {
		r += wiresize_s((varint_t)m_cs) + 1 /* tag(cs) 0x18 */;
	}
	// optional bool odrain, id 4
	if (m_odrain != false) {
		r += 2;
	}
	// optional uint8 digits, id 5
	if (m_digits != 0) {
		r += wiresize((varint_t)m_digits) + 1 /* tag(digits) 0x28 */;
	}
	return r;
}

bool Max7219Config::operator != (const Max7219Config &r) const
{
	if (has_clk() && (m_clk != r.m_clk))
		return true;
	if (has_dout() && (m_dout != r.m_dout))
		return true;
	if (has_cs() && (m_cs != r.m_cs))
		return true;
	if (has_odrain() && (m_odrain != r.m_odrain))
		return true;
	if (has_digits() && (m_digits != r.m_digits))
		return true;
	return false;
}


bool Max7219Config::operator == (const Max7219Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Max7219Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"clk")) {
		if (value == 0) {
			clear_clk();
			return 0;
		}
		int r = parse_ascii_s8(&m_clk,value);
		return r;
	}
	if (0 == strcmp(name,"dout")) {
		if (value == 0) {
			clear_dout();
			return 0;
		}
		int r = parse_ascii_s8(&m_dout,value);
		return r;
	}
	if (0 == strcmp(name,"cs")) {
		if (value == 0) {
			clear_cs();
			return 0;
		}
		int r = parse_ascii_s8(&m_cs,value);
		return r;
	}
	if (0 == strcmp(name,"odrain")) {
		if (value == 0) {
			clear_odrain();
			return 0;
		}
		int r = parse_ascii_bool(&m_odrain,value);
		return r;
	}
	if (0 == strcmp(name,"digits")) {
		if (value == 0) {
			clear_digits();
			return 0;
		}
		int r = parse_ascii_u8(&m_digits,value);
		return r;
	}
	return -128;
}

Message *Max7219Config::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *Max7219Config::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void Tlc5947Config::clear()
{
	m_sin = -1;
	m_sclk = -1;
	m_xlat = -1;
	m_blank = -1;
	m_ntlc = 0;
}

void Tlc5947Config::toASCII(std::ostream &o, size_t indent) const
{
	o << "Tlc5947Config {";
	++indent;
	ascii_numeric(o, indent, "sin", (signed) m_sin);
	ascii_numeric(o, indent, "sclk", (signed) m_sclk);
	ascii_numeric(o, indent, "xlat", (signed) m_xlat);
	ascii_numeric(o, indent, "blank", (signed) m_blank);
	ascii_numeric(o, indent, "ntlc", (unsigned) m_ntlc);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Tlc5947Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -129;
		a += fn;
		switch (fid) {
		case 0x8:	// sin id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -130;
				a += n;
				set_sin(varint_sint(v));
			}
			break;
		case 0x10:	// sclk id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -131;
				a += n;
				set_sclk(varint_sint(v));
			}
			break;
		case 0x18:	// xlat id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -132;
				a += n;
				set_xlat(varint_sint(v));
			}
			break;
		case 0x20:	// blank id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -133;
				a += n;
				set_blank(varint_sint(v));
			}
			break;
		case 0x28:	// ntlc id 5, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -134;
				a += n;
				set_ntlc(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -135;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -136;
	return a-(const uint8_t *)b;
}

ssize_t Tlc5947Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has sin?
	if (m_sin != -1) {
		// 'sin': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -137;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_sin));
		if (n <= 0)
			return -138;
		a += n;
	}
	// has sclk?
	if (m_sclk != -1) {
		// 'sclk': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -139;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sclk));
		if (n <= 0)
			return -140;
		a += n;
	}
	// has xlat?
	if (m_xlat != -1) {
		// 'xlat': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -141;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_xlat));
		if (n <= 0)
			return -142;
		a += n;
	}
	// has blank?
	if (m_blank != -1) {
		// 'blank': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -143;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_blank));
		if (n <= 0)
			return -144;
		a += n;
	}
	// has ntlc?
	if (m_ntlc != 0) {
		// 'ntlc': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -145;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_ntlc);
		if (n <= 0)
			return -146;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Tlc5947Config::toWire(void (*put)(uint8_t)) const
{
	if (m_sin != -1) {
		// 'sin': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'sin': id=1
		send_varint(put,sint_varint(m_sin));
	}
	if (m_sclk != -1) {
		// 'sclk': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'sclk': id=2
		send_varint(put,sint_varint(m_sclk));
	}
	if (m_xlat != -1) {
		// 'xlat': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'xlat': id=3
		send_varint(put,sint_varint(m_xlat));
	}
	if (m_blank != -1) {
		// 'blank': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'blank': id=4
		send_varint(put,sint_varint(m_blank));
	}
	if (m_ntlc != 0) {
		// 'ntlc': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'ntlc': id=5
		send_varint(put,m_ntlc);
	}
}

void Tlc5947Config::toString(std::string &put) const
{
	if (m_sin != -1) {
		// 'sin': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'sin': id=1
		send_varint(put,sint_varint(m_sin));
	}
	if (m_sclk != -1) {
		// 'sclk': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'sclk': id=2
		send_varint(put,sint_varint(m_sclk));
	}
	if (m_xlat != -1) {
		// 'xlat': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'xlat': id=3
		send_varint(put,sint_varint(m_xlat));
	}
	if (m_blank != -1) {
		// 'blank': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'blank': id=4
		send_varint(put,sint_varint(m_blank));
	}
	if (m_ntlc != 0) {
		// 'ntlc': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'ntlc': id=5
		send_varint(put,m_ntlc);
	}
}

void Tlc5947Config::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_sin()) {
		fsep = json_indent(json,indLvl,fsep,"sin");
		json << (int) m_sin;
	}
	if (has_sclk()) {
		fsep = json_indent(json,indLvl,fsep,"sclk");
		json << (int) m_sclk;
	}
	if (has_xlat()) {
		fsep = json_indent(json,indLvl,fsep,"xlat");
		json << (int) m_xlat;
	}
	if (has_blank()) {
		fsep = json_indent(json,indLvl,fsep,"blank");
		json << (int) m_blank;
	}
	if (has_ntlc()) {
		fsep = json_indent(json,indLvl,fsep,"ntlc");
		json << (unsigned) m_ntlc;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Tlc5947Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 sin, id 1
	if (m_sin != -1) {
		r += wiresize_s((varint_t)m_sin) + 1 /* tag(sin) 0x8 */;
	}
	// optional sint8 sclk, id 2
	if (m_sclk != -1) {
		r += wiresize_s((varint_t)m_sclk) + 1 /* tag(sclk) 0x10 */;
	}
	// optional sint8 xlat, id 3
	if (m_xlat != -1) {
		r += wiresize_s((varint_t)m_xlat) + 1 /* tag(xlat) 0x18 */;
	}
	// optional sint8 blank, id 4
	if (m_blank != -1) {
		r += wiresize_s((varint_t)m_blank) + 1 /* tag(blank) 0x20 */;
	}
	// optional uint8 ntlc, id 5
	if (m_ntlc != 0) {
		r += wiresize((varint_t)m_ntlc) + 1 /* tag(ntlc) 0x28 */;
	}
	return r;
}

bool Tlc5947Config::operator != (const Tlc5947Config &r) const
{
	if (has_sin() && (m_sin != r.m_sin))
		return true;
	if (has_sclk() && (m_sclk != r.m_sclk))
		return true;
	if (has_xlat() && (m_xlat != r.m_xlat))
		return true;
	if (has_blank() && (m_blank != r.m_blank))
		return true;
	if (has_ntlc() && (m_ntlc != r.m_ntlc))
		return true;
	return false;
}


bool Tlc5947Config::operator == (const Tlc5947Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Tlc5947Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"sin")) {
		if (value == 0) {
			clear_sin();
			return 0;
		}
		int r = parse_ascii_s8(&m_sin,value);
		return r;
	}
	if (0 == strcmp(name,"sclk")) {
		if (value == 0) {
			clear_sclk();
			return 0;
		}
		int r = parse_ascii_s8(&m_sclk,value);
		return r;
	}
	if (0 == strcmp(name,"xlat")) {
		if (value == 0) {
			clear_xlat();
			return 0;
		}
		int r = parse_ascii_s8(&m_xlat,value);
		return r;
	}
	if (0 == strcmp(name,"blank")) {
		if (value == 0) {
			clear_blank();
			return 0;
		}
		int r = parse_ascii_s8(&m_blank,value);
		return r;
	}
	if (0 == strcmp(name,"ntlc")) {
		if (value == 0) {
			clear_ntlc();
			return 0;
		}
		int r = parse_ascii_u8(&m_ntlc,value);
		return r;
	}
	return -147;
}

Message *Tlc5947Config::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *Tlc5947Config::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void Ws2812bConfig::clear()
{
	m_gpio = -1;
	m_ch = -1;
	m_nleds = 0;
	m_name.clear();
}

void Ws2812bConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "Ws2812bConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "ch", (signed) m_ch);
	ascii_numeric(o, indent, "nleds", (unsigned) m_nleds);
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Ws2812bConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -148;
		a += fn;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -149;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x10:	// ch id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -150;
				a += n;
				set_ch(varint_sint(v));
			}
			break;
		case 0x18:	// nleds id 3, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -151;
				a += n;
				set_nleds(v);
			}
			break;
		case 0x22:	// name id 4, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -152;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -153;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -154;
	return a-(const uint8_t *)b;
}

ssize_t Ws2812bConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -155;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -156;
		a += n;
	}
	// has ch?
	if (m_ch != -1) {
		// 'ch': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -157;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_ch));
		if (n <= 0)
			return -158;
		a += n;
	}
	// has nleds?
	if (m_nleds != 0) {
		// 'nleds': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -159;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_nleds);
		if (n <= 0)
			return -160;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -161;
		*a++ = 0x22;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -162;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	assert(a <= e);
	return a-b;
}

void Ws2812bConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'gpio': id=1
		send_varint(put,sint_varint(m_gpio));
	}
	if (m_ch != -1) {
		// 'ch': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'ch': id=2
		send_varint(put,sint_varint(m_ch));
	}
	if (m_nleds != 0) {
		// 'nleds': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'nleds': id=3
		send_varint(put,m_nleds);
	}
	if (!m_name.empty()) {
		// 'name': id=4, encoding=lenpfx, tag=0x22
		put(0x22);	// 'name': id=4
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
}

void Ws2812bConfig::toString(std::string &put) const
{
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'gpio': id=1
		send_varint(put,sint_varint(m_gpio));
	}
	if (m_ch != -1) {
		// 'ch': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'ch': id=2
		send_varint(put,sint_varint(m_ch));
	}
	if (m_nleds != 0) {
		// 'nleds': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'nleds': id=3
		send_varint(put,m_nleds);
	}
	if (!m_name.empty()) {
		// 'name': id=4, encoding=lenpfx, tag=0x22
		put.push_back(0x22);	// 'name': id=4
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
}

void Ws2812bConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_ch()) {
		fsep = json_indent(json,indLvl,fsep,"ch");
		json << (int) m_ch;
	}
	if (has_nleds()) {
		fsep = json_indent(json,indLvl,fsep,"nleds");
		json << (unsigned) m_nleds;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Ws2812bConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional sint8 ch, id 2
	if (m_ch != -1) {
		r += wiresize_s((varint_t)m_ch) + 1 /* tag(ch) 0x10 */;
	}
	// optional uint8 nleds, id 3
	if (m_nleds != 0) {
		r += wiresize((varint_t)m_nleds) + 1 /* tag(nleds) 0x18 */;
	}
	// optional string name, id 4
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x20 */;
	}
	return r;
}

bool Ws2812bConfig::operator != (const Ws2812bConfig &r) const
{
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_ch() && (m_ch != r.m_ch))
		return true;
	if (has_nleds() && (m_nleds != r.m_nleds))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	return false;
}


bool Ws2812bConfig::operator == (const Ws2812bConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Ws2812bConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"ch")) {
		if (value == 0) {
			clear_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_ch,value);
		return r;
	}
	if (0 == strcmp(name,"nleds")) {
		if (value == 0) {
			clear_nleds();
			return 0;
		}
		int r = parse_ascii_u8(&m_nleds,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	return -163;
}

Message *Ws2812bConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *Ws2812bConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void DhtConfig::clear()
{
	m_model = DHT_NONE;
	m_gpio = -1;
}

void DhtConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "DhtConfig {";
	++indent;
	ascii_indent(o,indent,"model");
	if (const char *v = dht_model_t_str(m_model))
		o << v;
	else
		o << m_model;
	o << ';';
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t DhtConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -164;
		a += fn;
		switch (fid) {
		case 0x8:	// model id 1, type dht_model_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -165;
				a += n;
				set_model((dht_model_t) v);
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -166;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -167;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -168;
	return a-(const uint8_t *)b;
}

ssize_t DhtConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has model?
	if (m_model != DHT_NONE) {
		// 'model': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -169;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_model);
		if (n <= 0)
			return -170;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -171;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -172;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void DhtConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_model != DHT_NONE) {
		// 'model': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'model': id=1
		send_varint(put,m_model);
	}
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'gpio': id=2
		send_varint(put,sint_varint(m_gpio));
	}
}

void DhtConfig::toString(std::string &put) const
{
	if (m_model != DHT_NONE) {
		// 'model': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'model': id=1
		send_varint(put,m_model);
	}
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'gpio': id=2
		send_varint(put,sint_varint(m_gpio));
	}
}

void DhtConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_model()) {
		fsep = json_indent(json,indLvl,fsep,"model");
		if (const char *v = dht_model_t_str(m_model)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_model;
		}
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t DhtConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional dht_model_t model, id 1
	if (m_model != DHT_NONE) {
		r += wiresize((varint_t)m_model) + 1 /* tag(model) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	return r;
}

bool DhtConfig::operator != (const DhtConfig &r) const
{
	if (has_model() && (m_model != r.m_model))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	return false;
}


bool DhtConfig::operator == (const DhtConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int DhtConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"model")) {
		if (value == 0) {
			clear_model();
			return 0;
		}
		dht_model_t v;
		size_t r = parse_ascii_dht_model_t(&v,value);
		if (r == 0)
			return -173;
		set_model(v);
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	return -174;
}

Message *DhtConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *DhtConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void I2CConfig::clear()
{
	m_port = 0;
	m_sda = -1;
	m_scl = -1;
	m_freq = 100000;
	m_xpullup = false;
	#ifdef CONFIG_I2C_XDEV
	m_devices.clear();
	#endif // CONFIG_I2C_XDEV
	p_validbits = 0;
}

void I2CConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "I2CConfig {";
	++indent;
	ascii_numeric(o, indent, "port", (unsigned) m_port);
	ascii_numeric(o, indent, "sda", (signed) m_sda);
	ascii_numeric(o, indent, "scl", (signed) m_scl);
	ascii_numeric(o, indent, "freq", m_freq);
	ascii_bool(o, indent, "xpullup", m_xpullup);
	#ifdef CONFIG_I2C_XDEV
	ascii_indent(o,indent);
	size_t s_devices = m_devices.size();
	o << "devices[" << s_devices << "] = {";
	++indent;
	for (size_t i = 0, e = s_devices; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_numeric(o, indent, 0, m_devices[i]);
		++indent;
		ascii_indent(o,indent);
		o << ".addr = " ;
		o << (unsigned) devices_addr(i);
		o << ';';
		ascii_indent(o,indent);
		o << ".drv = " ;
		o << i2cdrv_t_str(devices_drv(i));
		o << ';';
		ascii_indent(o,indent);
		o << ".intr = " ;
		o << (unsigned) devices_intr(i);
		o << ';';
		--indent;
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_I2C_XDEV
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t I2CConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -175;
		a += fn;
		switch (fid) {
		case 0x8:	// port id 1, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -176;
				a += n;
				set_port(v);
			}
			break;
		case 0x10:	// sda id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -177;
				a += n;
				set_sda(varint_sint(v));
			}
			break;
		case 0x18:	// scl id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -178;
				a += n;
				set_scl(varint_sint(v));
			}
			break;
		case 0x20:	// freq id 4, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -179;
				a += n;
				set_freq(v);
			}
			break;
		case 0x2b:	// xpullup id 5, type bool, coding 8bit
			if (a >= e)
				return -180;
			set_xpullup(*a++);
			break;
			#ifdef CONFIG_I2C_XDEV
		case 0x32: {	// devices id 6, packed i2cdev_t[] coding 2
				varint_t v;
				int n = read_varint(a,e-a,&v);	// length of packed
				if (n <= 0)
					return -181;
				a += n;
				const uint8_t *ae = a + v;
				do {
					varint_t v;
					int n = read_varint(a,e-a,&v);
					if (n <= 0)
						return -182;
					a += n;
					m_devices.push_back((i2cdev_t)v);
				} while (a < ae);
			} break;
			#endif // CONFIG_I2C_XDEV
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -183;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -184;
	return a-(const uint8_t *)b;
}

ssize_t I2CConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -185;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_port);
		if (n <= 0)
			return -186;
		a += n;
	}
	// has sda?
	if (m_sda != -1) {
		// 'sda': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -187;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sda));
		if (n <= 0)
			return -188;
		a += n;
	}
	// has scl?
	if (m_scl != -1) {
		// 'scl': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -189;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_scl));
		if (n <= 0)
			return -190;
		a += n;
	}
	// has freq?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'freq': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -191;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_freq);
		if (n <= 0)
			return -192;
		a += n;
	}
	// has xpullup?
	if (m_xpullup != false) {
		// 'xpullup': id=5, encoding=8bit, tag=0x2b
		if (2 > (e-a))
			return -193;
		*a++ = 0x2b;
		*a++ = m_xpullup;
	}
	#ifdef CONFIG_I2C_XDEV
	if (size_t devices_ne = m_devices.size()) {
		// 'devices': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -194;
		*a++ = 0x32;
		ssize_t devices_ws = 0;
		for (size_t x = 0; x != devices_ne; ++x)
			devices_ws += wiresize(m_devices[x]);
		n = write_varint(a,e-a,devices_ws);
		a += n;
		if ((n <= 0) || (devices_ws > (e-a)))
			return -195;
		for (size_t x = 0; x != devices_ne; ++x)
			a += write_varint(a,e-a,m_devices[x]);
	}
	#endif // CONFIG_I2C_XDEV
	assert(a <= e);
	return a-b;
}

void I2CConfig::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'port': id=1
		send_varint(put,m_port);
	}
	if (m_sda != -1) {
		// 'sda': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'sda': id=2
		send_varint(put,sint_varint(m_sda));
	}
	if (m_scl != -1) {
		// 'scl': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'scl': id=3
		send_varint(put,sint_varint(m_scl));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'freq': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'freq': id=4
		send_varint(put,m_freq);
	}
	if (m_xpullup != false) {
		// 'xpullup': id=5, encoding=8bit, tag=0x2b
		put(0x2b);	// 'xpullup': id=5
		put(m_xpullup);
	}
	#ifdef CONFIG_I2C_XDEV
	if (size_t devices_ne = m_devices.size()) {
		// 'devices': id=6, encoding=lenpfx, tag=0x32
		put(0x32);	// 'devices': id=6
		size_t devices_ws = 0;
		for (size_t x = 0; x != devices_ne; ++x)
			devices_ws += wiresize(m_devices[x]);
		send_varint(put,devices_ws);
		for (size_t x = 0; x != devices_ne; ++x)
			send_varint(put,m_devices[x]);
	}
	#endif // CONFIG_I2C_XDEV
}

void I2CConfig::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'port': id=1
		send_varint(put,m_port);
	}
	if (m_sda != -1) {
		// 'sda': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'sda': id=2
		send_varint(put,sint_varint(m_sda));
	}
	if (m_scl != -1) {
		// 'scl': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'scl': id=3
		send_varint(put,sint_varint(m_scl));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'freq': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'freq': id=4
		send_varint(put,m_freq);
	}
	if (m_xpullup != false) {
		// 'xpullup': id=5, encoding=8bit, tag=0x2b
		put.push_back(0x2b);	// 'xpullup': id=5
		put.push_back(m_xpullup);
	}
	#ifdef CONFIG_I2C_XDEV
	if (size_t devices_ne = m_devices.size()) {
		// 'devices': id=6, encoding=lenpfx, tag=0x32
		put.push_back(0x32);	// 'devices': id=6
		size_t devices_ws = 0;
		for (size_t x = 0; x != devices_ne; ++x)
			devices_ws += wiresize(m_devices[x]);
		send_varint(put,devices_ws);
		for (size_t x = 0; x != devices_ne; ++x)
			send_varint(put,m_devices[x]);
	}
	#endif // CONFIG_I2C_XDEV
}

void I2CConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << (unsigned) m_port;
	}
	if (has_sda()) {
		fsep = json_indent(json,indLvl,fsep,"sda");
		json << (int) m_sda;
	}
	if (has_scl()) {
		fsep = json_indent(json,indLvl,fsep,"scl");
		json << (int) m_scl;
	}
	if (has_freq()) {
		fsep = json_indent(json,indLvl,fsep,"freq");
		json << m_freq;
	}
	if (has_xpullup()) {
		fsep = json_indent(json,indLvl,fsep,"xpullup");
		json << (m_xpullup ? "true" : "false");
	}
	#ifdef CONFIG_I2C_XDEV
	if (size_t s = m_devices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"devices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json << m_devices[i];
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_I2C_XDEV
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t I2CConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional uint8 port, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional sint8 sda, id 2
	if (m_sda != -1) {
		r += wiresize_s((varint_t)m_sda) + 1 /* tag(sda) 0x10 */;
	}
	// optional sint8 scl, id 3
	if (m_scl != -1) {
		r += wiresize_s((varint_t)m_scl) + 1 /* tag(scl) 0x18 */;
	}
	// optional unsigned freq, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_freq) + 1 /* tag(freq) 0x20 */;
	}
	// optional bool xpullup, id 5
	if (m_xpullup != false) {
		r += 2;
	}
	#ifdef CONFIG_I2C_XDEV
	// repeated i2cdev_t devices, id 6
	if (!m_devices.empty()) {
		// devices: packed repeated i2cdev_t
		size_t devices_dl = 0;
		for (size_t x = 0, y = m_devices.size(); x < y; ++x)
			devices_dl += wiresize((varint_t)m_devices[x]);
		r += devices_dl + wiresize(devices_dl) /* data length */ + 1 /* tag(devices) 0x30 */;
	}
	#endif // CONFIG_I2C_XDEV
	return r;
}

bool I2CConfig::operator != (const I2CConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_sda() && (m_sda != r.m_sda))
		return true;
	if (has_scl() && (m_scl != r.m_scl))
		return true;
	if (has_freq() && (m_freq != r.m_freq))
		return true;
	if (has_xpullup() && (m_xpullup != r.m_xpullup))
		return true;
	#ifdef CONFIG_I2C_XDEV
	if (m_devices != r.m_devices)
		return true;
	#endif // CONFIG_I2C_XDEV
	return false;
}


bool I2CConfig::operator == (const I2CConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int I2CConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u8(&m_port,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"sda")) {
		if (value == 0) {
			clear_sda();
			return 0;
		}
		int r = parse_ascii_s8(&m_sda,value);
		return r;
	}
	if (0 == strcmp(name,"scl")) {
		if (value == 0) {
			clear_scl();
			return 0;
		}
		int r = parse_ascii_s8(&m_scl,value);
		return r;
	}
	if (0 == strcmp(name,"freq")) {
		if (value == 0) {
			clear_freq();
			return 0;
		}
		int r = parse_ascii_u64(&m_freq,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"xpullup")) {
		if (value == 0) {
			clear_xpullup();
			return 0;
		}
		int r = parse_ascii_bool(&m_xpullup,value);
		return r;
	}
	#ifdef CONFIG_I2C_XDEV
	if (0 == memcmp(name,"devices",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_devices();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_devices.size();
				m_devices.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -196;
				if (m_devices.size() <= x)
					return -197;
				if ((idxe[1] == 0) && (value == 0)) {
					m_devices.erase(m_devices.begin()+x);
					return 0;
				}
			}
			char *eptr = 0;
			unsigned long long ull = strtoull(value,&eptr,0);
			if (idxe[1] == 0) {
				m_devices[x] = (i2cdev_t) ull;
				return eptr - value;
			}
			if (idxe[1] != '.')
				return -198;
			idxe += 2;
			if (!strcmp("addr",idxe)) {
				if (eptr != value) {
					set_devices_addr(x,(uint8_t)ull);
					return 0;
				}
			}
			if (!strcmp("drv",idxe)) {
				if (eptr != value) {
					set_devices_drv(x,(i2cdrv_t)ull);
					return 0;
				}
			}
			if (!strcmp("intr",idxe)) {
				if (eptr != value) {
					set_devices_intr(x,(uint8_t)ull);
					return 0;
				}
			}
			return -199;
		}
	}
	#endif // CONFIG_I2C_XDEV
	return -200;
}

Message *I2CConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *I2CConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void HcSr04Config::clear()
{
	m_trigger = -1;
	m_echo = -1;
	m_name.clear();
}

void HcSr04Config::toASCII(std::ostream &o, size_t indent) const
{
	o << "HcSr04Config {";
	++indent;
	ascii_numeric(o, indent, "trigger", (signed) m_trigger);
	ascii_numeric(o, indent, "echo", (signed) m_echo);
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t HcSr04Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -201;
		a += fn;
		switch (fid) {
		case 0x8:	// trigger id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -202;
				a += n;
				set_trigger(varint_sint(v));
			}
			break;
		case 0x10:	// echo id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -203;
				a += n;
				set_echo(varint_sint(v));
			}
			break;
		case 0x1a:	// name id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -204;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -205;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -206;
	return a-(const uint8_t *)b;
}

ssize_t HcSr04Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has trigger?
	if (m_trigger != -1) {
		// 'trigger': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -207;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_trigger));
		if (n <= 0)
			return -208;
		a += n;
	}
	// has echo?
	if (m_echo != -1) {
		// 'echo': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -209;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_echo));
		if (n <= 0)
			return -210;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -211;
		*a++ = 0x1a;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -212;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	assert(a <= e);
	return a-b;
}

void HcSr04Config::toWire(void (*put)(uint8_t)) const
{
	if (m_trigger != -1) {
		// 'trigger': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'trigger': id=1
		send_varint(put,sint_varint(m_trigger));
	}
	if (m_echo != -1) {
		// 'echo': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'echo': id=2
		send_varint(put,sint_varint(m_echo));
	}
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'name': id=3
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
}

void HcSr04Config::toString(std::string &put) const
{
	if (m_trigger != -1) {
		// 'trigger': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'trigger': id=1
		send_varint(put,sint_varint(m_trigger));
	}
	if (m_echo != -1) {
		// 'echo': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'echo': id=2
		send_varint(put,sint_varint(m_echo));
	}
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'name': id=3
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
}

void HcSr04Config::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_trigger()) {
		fsep = json_indent(json,indLvl,fsep,"trigger");
		json << (int) m_trigger;
	}
	if (has_echo()) {
		fsep = json_indent(json,indLvl,fsep,"echo");
		json << (int) m_echo;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t HcSr04Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 trigger, id 1
	if (m_trigger != -1) {
		r += wiresize_s((varint_t)m_trigger) + 1 /* tag(trigger) 0x8 */;
	}
	// optional sint8 echo, id 2
	if (m_echo != -1) {
		r += wiresize_s((varint_t)m_echo) + 1 /* tag(echo) 0x10 */;
	}
	// optional string name, id 3
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	return r;
}

bool HcSr04Config::operator != (const HcSr04Config &r) const
{
	if (has_trigger() && (m_trigger != r.m_trigger))
		return true;
	if (has_echo() && (m_echo != r.m_echo))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	return false;
}


bool HcSr04Config::operator == (const HcSr04Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int HcSr04Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"trigger")) {
		if (value == 0) {
			clear_trigger();
			return 0;
		}
		int r = parse_ascii_s8(&m_trigger,value);
		return r;
	}
	if (0 == strcmp(name,"echo")) {
		if (value == 0) {
			clear_echo();
			return 0;
		}
		int r = parse_ascii_s8(&m_echo,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	return -213;
}

Message *HcSr04Config::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *HcSr04Config::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void LedConfig::clear()
{
	m_gpio = -1;
	m_config = 0;
	m_name.clear();
	m_pwm_ch = -1;
	p_validbits = 0;
}

void LedConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "LedConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", (unsigned) m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".active_high";
	o << (config_active_high() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".open_drain";
	o << (config_open_drain() ? " = true;" : " = false;");
	--indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "pwm_ch", (signed) m_pwm_ch);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t LedConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -214;
		a += fn;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -215;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x10:	// config id 2, type ledcfg_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -216;
				a += n;
				set_config((ledcfg_t) v);
			}
			break;
		case 0x1a:	// name id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -217;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x20:	// pwm_ch id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -218;
				a += n;
				set_pwm_ch(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -219;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -220;
	return a-(const uint8_t *)b;
}

ssize_t LedConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -221;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -222;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -223;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -224;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -225;
		*a++ = 0x1a;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -226;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has pwm_ch?
	if (m_pwm_ch != -1) {
		// 'pwm_ch': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -227;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_pwm_ch));
		if (n <= 0)
			return -228;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void LedConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'gpio': id=1
		send_varint(put,sint_varint(m_gpio));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'config': id=2
		send_varint(put,m_config);
	}
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'name': id=3
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (m_pwm_ch != -1) {
		// 'pwm_ch': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'pwm_ch': id=4
		send_varint(put,sint_varint(m_pwm_ch));
	}
}

void LedConfig::toString(std::string &put) const
{
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'gpio': id=1
		send_varint(put,sint_varint(m_gpio));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'config': id=2
		send_varint(put,m_config);
	}
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'name': id=3
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (m_pwm_ch != -1) {
		// 'pwm_ch': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'pwm_ch': id=4
		send_varint(put,sint_varint(m_pwm_ch));
	}
}

void LedConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_pwm_ch()) {
		fsep = json_indent(json,indLvl,fsep,"pwm_ch");
		json << (int) m_pwm_ch;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t LedConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional ledcfg_t config, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x10 */;
	}
	// optional string name, id 3
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	// optional sint8 pwm_ch, id 4
	if (m_pwm_ch != -1) {
		r += wiresize_s((varint_t)m_pwm_ch) + 1 /* tag(pwm_ch) 0x20 */;
	}
	return r;
}

bool LedConfig::operator != (const LedConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_pwm_ch() && (m_pwm_ch != r.m_pwm_ch))
		return true;
	return false;
}


bool LedConfig::operator == (const LedConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int LedConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((ledcfg_t)ull);
			else if (!strcmp(name,"active_high"))
				set_config_active_high((bool)ull);
			else if (!strcmp(name,"open_drain"))
				set_config_open_drain((bool)ull);
			return eptr - value;
		} else {
			return -229;
		}
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"pwm_ch")) {
		if (value == 0) {
			clear_pwm_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_pwm_ch,value);
		return r;
	}
	return -230;
}

Message *LedConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *LedConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void OneWireConfig::clear()
{
	m_gpio = -1;
	m_pullup = false;
	m_power = -1;
}

void OneWireConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "OneWireConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_bool(o, indent, "pullup", m_pullup);
	ascii_numeric(o, indent, "power", (signed) m_power);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t OneWireConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -231;
		a += fn;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -232;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x13:	// pullup id 2, type bool, coding 8bit
			if (a >= e)
				return -233;
			set_pullup(*a++);
			break;
		case 0x18:	// power id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -234;
				a += n;
				set_power(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -235;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -236;
	return a-(const uint8_t *)b;
}

ssize_t OneWireConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -237;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -238;
		a += n;
	}
	// has pullup?
	if (m_pullup != false) {
		// 'pullup': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -239;
		*a++ = 0x13;
		*a++ = m_pullup;
	}
	// has power?
	if (m_power != -1) {
		// 'power': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -240;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_power));
		if (n <= 0)
			return -241;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void OneWireConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'gpio': id=1
		send_varint(put,sint_varint(m_gpio));
	}
	if (m_pullup != false) {
		// 'pullup': id=2, encoding=8bit, tag=0x13
		put(0x13);	// 'pullup': id=2
		put(m_pullup);
	}
	if (m_power != -1) {
		// 'power': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'power': id=3
		send_varint(put,sint_varint(m_power));
	}
}

void OneWireConfig::toString(std::string &put) const
{
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'gpio': id=1
		send_varint(put,sint_varint(m_gpio));
	}
	if (m_pullup != false) {
		// 'pullup': id=2, encoding=8bit, tag=0x13
		put.push_back(0x13);	// 'pullup': id=2
		put.push_back(m_pullup);
	}
	if (m_power != -1) {
		// 'power': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'power': id=3
		send_varint(put,sint_varint(m_power));
	}
}

void OneWireConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_pullup()) {
		fsep = json_indent(json,indLvl,fsep,"pullup");
		json << (m_pullup ? "true" : "false");
	}
	if (has_power()) {
		fsep = json_indent(json,indLvl,fsep,"power");
		json << (int) m_power;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t OneWireConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional bool pullup, id 2
	if (m_pullup != false) {
		r += 2;
	}
	// optional sint8 power, id 3
	if (m_power != -1) {
		r += wiresize_s((varint_t)m_power) + 1 /* tag(power) 0x18 */;
	}
	return r;
}

bool OneWireConfig::operator != (const OneWireConfig &r) const
{
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_pullup() && (m_pullup != r.m_pullup))
		return true;
	if (has_power() && (m_power != r.m_power))
		return true;
	return false;
}


bool OneWireConfig::operator == (const OneWireConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int OneWireConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"pullup")) {
		if (value == 0) {
			clear_pullup();
			return 0;
		}
		int r = parse_ascii_bool(&m_pullup,value);
		return r;
	}
	if (0 == strcmp(name,"power")) {
		if (value == 0) {
			clear_power();
			return 0;
		}
		int r = parse_ascii_s8(&m_power,value);
		return r;
	}
	return -242;
}

Message *OneWireConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *OneWireConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void UartConfig::clear()
{
	m_port = -1;
	m_tx_gpio = -1;
	m_rx_gpio = -1;
	m_cts_gpio = -1;
	m_rts_gpio = -1;
}

void UartConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "UartConfig {";
	++indent;
	ascii_numeric(o, indent, "port", (signed) m_port);
	ascii_numeric(o, indent, "tx_gpio", (signed) m_tx_gpio);
	ascii_numeric(o, indent, "rx_gpio", (signed) m_rx_gpio);
	ascii_numeric(o, indent, "cts_gpio", (signed) m_cts_gpio);
	ascii_numeric(o, indent, "rts_gpio", (signed) m_rts_gpio);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t UartConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -243;
		a += fn;
		switch (fid) {
		case 0x8:	// port id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -244;
				a += n;
				set_port(varint_sint(v));
			}
			break;
		case 0x10:	// tx_gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -245;
				a += n;
				set_tx_gpio(varint_sint(v));
			}
			break;
		case 0x18:	// rx_gpio id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -246;
				a += n;
				set_rx_gpio(varint_sint(v));
			}
			break;
		case 0x20:	// cts_gpio id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -247;
				a += n;
				set_cts_gpio(varint_sint(v));
			}
			break;
		case 0x28:	// rts_gpio id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -248;
				a += n;
				set_rts_gpio(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -249;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -250;
	return a-(const uint8_t *)b;
}

ssize_t UartConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (m_port != -1) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -251;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_port));
		if (n <= 0)
			return -252;
		a += n;
	}
	// has tx_gpio?
	if (m_tx_gpio != -1) {
		// 'tx_gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -253;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_tx_gpio));
		if (n <= 0)
			return -254;
		a += n;
	}
	// has rx_gpio?
	if (m_rx_gpio != -1) {
		// 'rx_gpio': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -255;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_rx_gpio));
		if (n <= 0)
			return -256;
		a += n;
	}
	// has cts_gpio?
	if (m_cts_gpio != -1) {
		// 'cts_gpio': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -257;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_cts_gpio));
		if (n <= 0)
			return -258;
		a += n;
	}
	// has rts_gpio?
	if (m_rts_gpio != -1) {
		// 'rts_gpio': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -259;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_rts_gpio));
		if (n <= 0)
			return -260;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void UartConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_port != -1) {
		// 'port': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'port': id=1
		send_varint(put,sint_varint(m_port));
	}
	if (m_tx_gpio != -1) {
		// 'tx_gpio': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'tx_gpio': id=2
		send_varint(put,sint_varint(m_tx_gpio));
	}
	if (m_rx_gpio != -1) {
		// 'rx_gpio': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'rx_gpio': id=3
		send_varint(put,sint_varint(m_rx_gpio));
	}
	if (m_cts_gpio != -1) {
		// 'cts_gpio': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'cts_gpio': id=4
		send_varint(put,sint_varint(m_cts_gpio));
	}
	if (m_rts_gpio != -1) {
		// 'rts_gpio': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'rts_gpio': id=5
		send_varint(put,sint_varint(m_rts_gpio));
	}
}

void UartConfig::toString(std::string &put) const
{
	if (m_port != -1) {
		// 'port': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'port': id=1
		send_varint(put,sint_varint(m_port));
	}
	if (m_tx_gpio != -1) {
		// 'tx_gpio': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'tx_gpio': id=2
		send_varint(put,sint_varint(m_tx_gpio));
	}
	if (m_rx_gpio != -1) {
		// 'rx_gpio': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'rx_gpio': id=3
		send_varint(put,sint_varint(m_rx_gpio));
	}
	if (m_cts_gpio != -1) {
		// 'cts_gpio': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'cts_gpio': id=4
		send_varint(put,sint_varint(m_cts_gpio));
	}
	if (m_rts_gpio != -1) {
		// 'rts_gpio': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'rts_gpio': id=5
		send_varint(put,sint_varint(m_rts_gpio));
	}
}

void UartConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << (int) m_port;
	}
	if (has_tx_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"tx_gpio");
		json << (int) m_tx_gpio;
	}
	if (has_rx_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"rx_gpio");
		json << (int) m_rx_gpio;
	}
	if (has_cts_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"cts_gpio");
		json << (int) m_cts_gpio;
	}
	if (has_rts_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"rts_gpio");
		json << (int) m_rts_gpio;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t UartConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 port, id 1
	if (m_port != -1) {
		r += wiresize_s((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional sint8 tx_gpio, id 2
	if (m_tx_gpio != -1) {
		r += wiresize_s((varint_t)m_tx_gpio) + 1 /* tag(tx_gpio) 0x10 */;
	}
	// optional sint8 rx_gpio, id 3
	if (m_rx_gpio != -1) {
		r += wiresize_s((varint_t)m_rx_gpio) + 1 /* tag(rx_gpio) 0x18 */;
	}
	// optional sint8 cts_gpio, id 4
	if (m_cts_gpio != -1) {
		r += wiresize_s((varint_t)m_cts_gpio) + 1 /* tag(cts_gpio) 0x20 */;
	}
	// optional sint8 rts_gpio, id 5
	if (m_rts_gpio != -1) {
		r += wiresize_s((varint_t)m_rts_gpio) + 1 /* tag(rts_gpio) 0x28 */;
	}
	return r;
}

bool UartConfig::operator != (const UartConfig &r) const
{
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_tx_gpio() && (m_tx_gpio != r.m_tx_gpio))
		return true;
	if (has_rx_gpio() && (m_rx_gpio != r.m_rx_gpio))
		return true;
	if (has_cts_gpio() && (m_cts_gpio != r.m_cts_gpio))
		return true;
	if (has_rts_gpio() && (m_rts_gpio != r.m_rts_gpio))
		return true;
	return false;
}


bool UartConfig::operator == (const UartConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int UartConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_s8(&m_port,value);
		return r;
	}
	if (0 == strcmp(name,"tx_gpio")) {
		if (value == 0) {
			clear_tx_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_tx_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"rx_gpio")) {
		if (value == 0) {
			clear_rx_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_rx_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"cts_gpio")) {
		if (value == 0) {
			clear_cts_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_cts_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"rts_gpio")) {
		if (value == 0) {
			clear_rts_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_rts_gpio,value);
		return r;
	}
	return -261;
}

Message *UartConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *UartConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void AdcChannel::clear()
{
	m_name.clear();
	m_unit = 0;
	m_ch = -1;
	m_atten = 0;
	m_interval = 0;
	m_window = 0;
	m_scale = 1;
	m_offset = 0;
	m_dim.clear();
	p_validbits = 0;
}

void AdcChannel::toASCII(std::ostream &o, size_t indent) const
{
	o << "AdcChannel {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "unit", (unsigned) m_unit);
	ascii_numeric(o, indent, "ch", (signed) m_ch);
	ascii_numeric(o, indent, "atten", (unsigned) m_atten);
	ascii_numeric(o, indent, "interval", m_interval);
	ascii_numeric(o, indent, "window", (unsigned) m_window);
	ascii_numeric(o, indent, "scale", m_scale);
	ascii_numeric(o, indent, "offset", m_offset);
	ascii_string(o,indent,m_dim.data(),m_dim.size(),"dim");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AdcChannel::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -262;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -263;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// unit id 2, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -264;
				a += n;
				set_unit(v);
			}
			break;
		case 0x18:	// ch id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -265;
				a += n;
				set_ch(varint_sint(v));
			}
			break;
		case 0x20:	// atten id 4, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -266;
				a += n;
				set_atten(v);
			}
			break;
		case 0x28:	// interval id 5, type uint16_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -267;
				a += n;
				set_interval(v);
			}
			break;
		case 0x30:	// window id 6, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -268;
				a += n;
				set_window(v);
			}
			break;
		case 0x45:	// scale id 8, type float, coding 32bit
			if ((a+3) >= e)
				return -269;
			set_scale(read_float(a));
			a += 4;
			break;
		case 0x4d:	// offset id 9, type float, coding 32bit
			if ((a+3) >= e)
				return -270;
			set_offset(read_float(a));
			a += 4;
			break;
		case 0x52:	// dim id 10, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -271;
				m_dim.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -272;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -273;
	return a-(const uint8_t *)b;
}

ssize_t AdcChannel::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -274;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -275;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has unit?
	if (m_unit != 0) {
		// 'unit': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -276;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_unit);
		if (n <= 0)
			return -277;
		a += n;
	}
	// has ch?
	if (m_ch != -1) {
		// 'ch': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -278;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_ch));
		if (n <= 0)
			return -279;
		a += n;
	}
	// has atten?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'atten': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -280;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_atten);
		if (n <= 0)
			return -281;
		a += n;
	}
	// has interval?
	if (m_interval != 0) {
		// 'interval': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -282;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_interval);
		if (n <= 0)
			return -283;
		a += n;
	}
	// has window?
	if (m_window != 0) {
		// 'window': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -284;
		*a++ = 0x30;
		n = write_varint(a,e-a,m_window);
		if (n <= 0)
			return -285;
		a += n;
	}
	// has scale?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'scale': id=8, encoding=32bit, tag=0x45
		if (5 > (e-a))
			return -286;
		*a++ = 0x45;
		if ((e-a) < 4)
			return -287;
		write_u32(a,mangle_float(m_scale));
		a += 4;
	}
	// has offset?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'offset': id=9, encoding=32bit, tag=0x4d
		if (5 > (e-a))
			return -288;
		*a++ = 0x4d;
		if ((e-a) < 4)
			return -289;
		write_u32(a,mangle_float(m_offset));
		a += 4;
	}
	// has dim?
	if (!m_dim.empty()) {
		// 'dim': id=10, encoding=lenpfx, tag=0x52
		if (a >= e)
			return -290;
		*a++ = 0x52;
		ssize_t dim_s = m_dim.size();
		n = write_varint(a,e-a,dim_s);
		a += n;
		if ((n <= 0) || ((e-a) < dim_s))
			return -291;
		memcpy(a,m_dim.data(),dim_s);
		a += dim_s;
	}
	assert(a <= e);
	return a-b;
}

void AdcChannel::toWire(void (*put)(uint8_t)) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (m_unit != 0) {
		// 'unit': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'unit': id=2
		send_varint(put,m_unit);
	}
	if (m_ch != -1) {
		// 'ch': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'ch': id=3
		send_varint(put,sint_varint(m_ch));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'atten': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'atten': id=4
		send_varint(put,m_atten);
	}
	if (m_interval != 0) {
		// 'interval': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'interval': id=5
		send_varint(put,m_interval);
	}
	if (m_window != 0) {
		// 'window': id=6, encoding=varint, tag=0x30
		put(0x30);	// 'window': id=6
		send_varint(put,m_window);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'scale': id=8, encoding=32bit, tag=0x45
		put(0x45);	// 'scale': id=8
		send_u32(put,mangle_float(m_scale));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'offset': id=9, encoding=32bit, tag=0x4d
		put(0x4d);	// 'offset': id=9
		send_u32(put,mangle_float(m_offset));
	}
	if (!m_dim.empty()) {
		// 'dim': id=10, encoding=lenpfx, tag=0x52
		put(0x52);	// 'dim': id=10
		size_t dim_s = m_dim.size();
		send_varint(put,dim_s);
		send_bytes(put,(const uint8_t*) m_dim.data(),dim_s);
	}
}

void AdcChannel::toString(std::string &put) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (m_unit != 0) {
		// 'unit': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'unit': id=2
		send_varint(put,m_unit);
	}
	if (m_ch != -1) {
		// 'ch': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'ch': id=3
		send_varint(put,sint_varint(m_ch));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'atten': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'atten': id=4
		send_varint(put,m_atten);
	}
	if (m_interval != 0) {
		// 'interval': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'interval': id=5
		send_varint(put,m_interval);
	}
	if (m_window != 0) {
		// 'window': id=6, encoding=varint, tag=0x30
		put.push_back(0x30);	// 'window': id=6
		send_varint(put,m_window);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'scale': id=8, encoding=32bit, tag=0x45
		put.push_back(0x45);	// 'scale': id=8
		send_u32(put,mangle_float(m_scale));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'offset': id=9, encoding=32bit, tag=0x4d
		put.push_back(0x4d);	// 'offset': id=9
		send_u32(put,mangle_float(m_offset));
	}
	if (!m_dim.empty()) {
		// 'dim': id=10, encoding=lenpfx, tag=0x52
		put.push_back(0x52);	// 'dim': id=10
		size_t dim_s = m_dim.size();
		send_varint(put,dim_s);
		put.append((const char *)(const uint8_t*) m_dim.data(),dim_s);
	}
}

void AdcChannel::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_unit()) {
		fsep = json_indent(json,indLvl,fsep,"unit");
		json << (unsigned) m_unit;
	}
	if (has_ch()) {
		fsep = json_indent(json,indLvl,fsep,"ch");
		json << (int) m_ch;
	}
	if (has_atten()) {
		fsep = json_indent(json,indLvl,fsep,"atten");
		json << (unsigned) m_atten;
	}
	if (has_interval()) {
		fsep = json_indent(json,indLvl,fsep,"interval");
		json << m_interval;
	}
	if (has_window()) {
		fsep = json_indent(json,indLvl,fsep,"window");
		json << (unsigned) m_window;
	}
	if (has_scale()) {
		fsep = json_indent(json,indLvl,fsep,"scale");
		to_dblstr(json,m_scale);
	}
	if (has_offset()) {
		fsep = json_indent(json,indLvl,fsep,"offset");
		to_dblstr(json,m_offset);
	}
	if (has_dim()) {
		fsep = json_indent(json,indLvl,fsep,"dim");
		json_cstr(json,m_dim.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AdcChannel::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional uint8 unit, id 2
	if (m_unit != 0) {
		r += wiresize((varint_t)m_unit) + 1 /* tag(unit) 0x10 */;
	}
	// optional sint8 ch, id 3
	if (m_ch != -1) {
		r += wiresize_s((varint_t)m_ch) + 1 /* tag(ch) 0x18 */;
	}
	// optional uint8 atten, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_atten) + 1 /* tag(atten) 0x20 */;
	}
	// optional uint16 interval, id 5
	if (m_interval != 0) {
		r += wiresize((varint_t)m_interval) + 1 /* tag(interval) 0x28 */;
	}
	// optional uint8 window, id 6
	if (m_window != 0) {
		r += wiresize((varint_t)m_window) + 1 /* tag(window) 0x30 */;
	}
	// optional float scale, id 8
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += 5;
	}
	// optional float offset, id 9
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += 5;
	}
	// optional string dim, id 10
	if (!m_dim.empty()) {
		size_t dim_s = m_dim.size();
		r += dim_s + wiresize(dim_s) + 1 /* tag(dim) 0x50 */;
	}
	return r;
}

bool AdcChannel::operator != (const AdcChannel &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_unit() && (m_unit != r.m_unit))
		return true;
	if (has_ch() && (m_ch != r.m_ch))
		return true;
	if (has_atten() && (m_atten != r.m_atten))
		return true;
	if (has_interval() && (m_interval != r.m_interval))
		return true;
	if (has_window() && (m_window != r.m_window))
		return true;
	if (has_scale() && (m_scale != r.m_scale))
		return true;
	if (has_offset() && (m_offset != r.m_offset))
		return true;
	if (has_dim() && (m_dim != r.m_dim))
		return true;
	return false;
}


bool AdcChannel::operator == (const AdcChannel &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AdcChannel::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"unit")) {
		if (value == 0) {
			clear_unit();
			return 0;
		}
		int r = parse_ascii_u8(&m_unit,value);
		return r;
	}
	if (0 == strcmp(name,"ch")) {
		if (value == 0) {
			clear_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_ch,value);
		return r;
	}
	if (0 == strcmp(name,"atten")) {
		if (value == 0) {
			clear_atten();
			return 0;
		}
		int r = parse_ascii_u8(&m_atten,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"interval")) {
		if (value == 0) {
			clear_interval();
			return 0;
		}
		int r = parse_ascii_u16(&m_interval,value);
		return r;
	}
	if (0 == strcmp(name,"window")) {
		if (value == 0) {
			clear_window();
			return 0;
		}
		int r = parse_ascii_u8(&m_window,value);
		return r;
	}
	if (0 == strcmp(name,"scale")) {
		if (value == 0) {
			clear_scale();
			return 0;
		}
		int r = parse_ascii_flt(&m_scale,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"offset")) {
		if (value == 0) {
			clear_offset();
			return 0;
		}
		int r = parse_ascii_flt(&m_offset,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"dim")) {
		if (value == 0) {
			clear_dim();
			return 0;
		}
		m_dim = value;
		int r = m_dim.size();
		return r;
	}
	return -292;
}

Message *AdcChannel::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *AdcChannel::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void AdcConfig::clear()
{
	m_adc_name.clear();
	m_adc1_bits = 0;
	m_adc2_bits = 0;
	m_mode = 0;
	m_clk_div = 0;
	m_hall_name.clear();
	m_channels.clear();
	p_validbits = 0;
}

void AdcConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "AdcConfig {";
	++indent;
	ascii_string(o,indent,m_adc_name.data(),m_adc_name.size(),"adc_name");
	ascii_numeric(o, indent, "adc1_bits", (unsigned) m_adc1_bits);
	ascii_numeric(o, indent, "adc2_bits", (unsigned) m_adc2_bits);
	ascii_numeric(o, indent, "mode", (unsigned) m_mode);
	ascii_numeric(o, indent, "clk_div", (unsigned) m_clk_div);
	ascii_string(o,indent,m_hall_name.data(),m_hall_name.size(),"hall_name");
	ascii_indent(o,indent);
	size_t s_channels = m_channels.size();
	o << "channels[" << s_channels << "] = {";
	++indent;
	for (size_t i = 0, e = s_channels; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_channels[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AdcConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -293;
		a += fn;
		switch (fid) {
		case 0xa:	// adc_name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -294;
				m_adc_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// adc1_bits id 2, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -295;
				a += n;
				set_adc1_bits(v);
			}
			break;
		case 0x18:	// adc2_bits id 3, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -296;
				a += n;
				set_adc2_bits(v);
			}
			break;
		case 0x20:	// mode id 4, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -297;
				a += n;
				set_mode(v);
			}
			break;
		case 0x28:	// clk_div id 5, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -298;
				a += n;
				set_clk_div(v);
			}
			break;
		case 0x32:	// hall_name id 6, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -299;
				m_hall_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x3a:	// channels id 7, type AdcChannel, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -300;
				m_channels.emplace_back();
				if (v != 0) {
					n = m_channels.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -301;
					a += v;
				}
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -302;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -303;
	return a-(const uint8_t *)b;
}

ssize_t AdcConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has adc_name?
	if (!m_adc_name.empty()) {
		// 'adc_name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -304;
		*a++ = 0xa;
		ssize_t adc_name_s = m_adc_name.size();
		n = write_varint(a,e-a,adc_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < adc_name_s))
			return -305;
		memcpy(a,m_adc_name.data(),adc_name_s);
		a += adc_name_s;
	}
	// has adc1_bits?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'adc1_bits': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -306;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_adc1_bits);
		if (n <= 0)
			return -307;
		a += n;
	}
	// has adc2_bits?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'adc2_bits': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -308;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_adc2_bits);
		if (n <= 0)
			return -309;
		a += n;
	}
	// has mode?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'mode': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -310;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_mode);
		if (n <= 0)
			return -311;
		a += n;
	}
	// has clk_div?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'clk_div': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -312;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_clk_div);
		if (n <= 0)
			return -313;
		a += n;
	}
	// has hall_name?
	if (!m_hall_name.empty()) {
		// 'hall_name': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -314;
		*a++ = 0x32;
		ssize_t hall_name_s = m_hall_name.size();
		n = write_varint(a,e-a,hall_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < hall_name_s))
			return -315;
		memcpy(a,m_hall_name.data(),hall_name_s);
		a += hall_name_s;
	}
	for (const auto &x : m_channels) {
		// 'channels': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -316;
		*a++ = 0x3a;
		ssize_t channels_ws = x.calcSize();
		n = write_varint(a,e-a,channels_ws);
		a += n;
		if ((n <= 0) || (channels_ws > (e-a)))
			return -317;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == channels_ws);
	}
	assert(a <= e);
	return a-b;
}

void AdcConfig::toWire(void (*put)(uint8_t)) const
{
	if (!m_adc_name.empty()) {
		// 'adc_name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'adc_name': id=1
		size_t adc_name_s = m_adc_name.size();
		send_varint(put,adc_name_s);
		send_bytes(put,(const uint8_t*) m_adc_name.data(),adc_name_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'adc1_bits': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'adc1_bits': id=2
		send_varint(put,m_adc1_bits);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'adc2_bits': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'adc2_bits': id=3
		send_varint(put,m_adc2_bits);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'mode': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'mode': id=4
		send_varint(put,m_mode);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'clk_div': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'clk_div': id=5
		send_varint(put,m_clk_div);
	}
	if (!m_hall_name.empty()) {
		// 'hall_name': id=6, encoding=lenpfx, tag=0x32
		put(0x32);	// 'hall_name': id=6
		size_t hall_name_s = m_hall_name.size();
		send_varint(put,hall_name_s);
		send_bytes(put,(const uint8_t*) m_hall_name.data(),hall_name_s);
	}
	for (size_t x = 0, y = m_channels.size(); x != y; ++x) {
		// 'channels': id=7, encoding=lenpfx, tag=0x3a
		put(0x3a);	// 'channels': id=7
		send_varint(put,m_channels[x].calcSize());
		m_channels[x].toWire(put);
	}
}

void AdcConfig::toString(std::string &put) const
{
	if (!m_adc_name.empty()) {
		// 'adc_name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'adc_name': id=1
		size_t adc_name_s = m_adc_name.size();
		send_varint(put,adc_name_s);
		put.append((const char *)(const uint8_t*) m_adc_name.data(),adc_name_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'adc1_bits': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'adc1_bits': id=2
		send_varint(put,m_adc1_bits);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'adc2_bits': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'adc2_bits': id=3
		send_varint(put,m_adc2_bits);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'mode': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'mode': id=4
		send_varint(put,m_mode);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'clk_div': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'clk_div': id=5
		send_varint(put,m_clk_div);
	}
	if (!m_hall_name.empty()) {
		// 'hall_name': id=6, encoding=lenpfx, tag=0x32
		put.push_back(0x32);	// 'hall_name': id=6
		size_t hall_name_s = m_hall_name.size();
		send_varint(put,hall_name_s);
		put.append((const char *)(const uint8_t*) m_hall_name.data(),hall_name_s);
	}
	for (size_t x = 0, y = m_channels.size(); x != y; ++x) {
		// 'channels': id=7, encoding=lenpfx, tag=0x3a
		put.push_back(0x3a);	// 'channels': id=7
		send_varint(put,m_channels[x].calcSize());
		m_channels[x].toString(put);
	}
}

void AdcConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_adc_name()) {
		fsep = json_indent(json,indLvl,fsep,"adc_name");
		json_cstr(json,m_adc_name.c_str());
	}
	if (has_adc1_bits()) {
		fsep = json_indent(json,indLvl,fsep,"adc1_bits");
		json << (unsigned) m_adc1_bits;
	}
	if (has_adc2_bits()) {
		fsep = json_indent(json,indLvl,fsep,"adc2_bits");
		json << (unsigned) m_adc2_bits;
	}
	if (has_mode()) {
		fsep = json_indent(json,indLvl,fsep,"mode");
		json << (unsigned) m_mode;
	}
	if (has_clk_div()) {
		fsep = json_indent(json,indLvl,fsep,"clk_div");
		json << (unsigned) m_clk_div;
	}
	if (has_hall_name()) {
		fsep = json_indent(json,indLvl,fsep,"hall_name");
		json_cstr(json,m_hall_name.c_str());
	}
	if (size_t s = m_channels.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"channels\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_channels[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AdcConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string adc_name, id 1
	if (!m_adc_name.empty()) {
		size_t adc_name_s = m_adc_name.size();
		r += adc_name_s + wiresize(adc_name_s) + 1 /* tag(adc_name) 0x8 */;
	}
	// optional uint8 adc1_bits, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_adc1_bits) + 1 /* tag(adc1_bits) 0x10 */;
	}
	// optional uint8 adc2_bits, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_adc2_bits) + 1 /* tag(adc2_bits) 0x18 */;
	}
	// optional uint8 mode, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += wiresize((varint_t)m_mode) + 1 /* tag(mode) 0x20 */;
	}
	// optional uint8 clk_div, id 5
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		r += wiresize((varint_t)m_clk_div) + 1 /* tag(clk_div) 0x28 */;
	}
	// optional string hall_name, id 6
	if (!m_hall_name.empty()) {
		size_t hall_name_s = m_hall_name.size();
		r += hall_name_s + wiresize(hall_name_s) + 1 /* tag(hall_name) 0x30 */;
	}
	// repeated AdcChannel channels, id 7
	// repeated message channels
	for (size_t x = 0, y = m_channels.size(); x < y; ++x) {
		size_t s = m_channels[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(channels) 0x38 */;
	}
	return r;
}

bool AdcConfig::operator != (const AdcConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_adc_name() && (m_adc_name != r.m_adc_name))
		return true;
	if (has_adc1_bits() && (m_adc1_bits != r.m_adc1_bits))
		return true;
	if (has_adc2_bits() && (m_adc2_bits != r.m_adc2_bits))
		return true;
	if (has_mode() && (m_mode != r.m_mode))
		return true;
	if (has_clk_div() && (m_clk_div != r.m_clk_div))
		return true;
	if (has_hall_name() && (m_hall_name != r.m_hall_name))
		return true;
	if (m_channels != r.m_channels)
		return true;
	return false;
}


bool AdcConfig::operator == (const AdcConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AdcConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"adc_name")) {
		if (value == 0) {
			clear_adc_name();
			return 0;
		}
		m_adc_name = value;
		int r = m_adc_name.size();
		return r;
	}
	if (0 == strcmp(name,"adc1_bits")) {
		if (value == 0) {
			clear_adc1_bits();
			return 0;
		}
		int r = parse_ascii_u8(&m_adc1_bits,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"adc2_bits")) {
		if (value == 0) {
			clear_adc2_bits();
			return 0;
		}
		int r = parse_ascii_u8(&m_adc2_bits,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"mode")) {
		if (value == 0) {
			clear_mode();
			return 0;
		}
		int r = parse_ascii_u8(&m_mode,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"clk_div")) {
		if (value == 0) {
			clear_clk_div();
			return 0;
		}
		int r = parse_ascii_u8(&m_clk_div,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	if (0 == strcmp(name,"hall_name")) {
		if (value == 0) {
			clear_hall_name();
			return 0;
		}
		m_hall_name = value;
		int r = m_hall_name.size();
		return r;
	}
	if (0 == memcmp(name,"channels",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_channels();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_channels.size();
				m_channels.resize(x+1);
				idxe = (char*)(name + 10);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+9)))
					return -318;
				if (m_channels.size() <= x)
					return -319;
				if ((idxe[1] == 0) && (value == 0)) {
					m_channels.erase(m_channels.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -320;
			return m_channels[x].setByName(idxe+2,value);
		}
	}
	return -321;
}

Message *AdcConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *AdcConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	if ((n == 8) && (0 == memcmp("channels",s,8))) {
		if (x < m_channels.size())
			return &m_channels[x];
	}
	return 0;
}

void GpioConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_config = 0;
	p_validbits = 0;
}

void GpioConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "GpioConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".mode = " ;
	o << (unsigned) config_mode();
	o << ';';
	ascii_indent(o,indent);
	o << ".intrtype = " ;
	o << (unsigned) config_intrtype();
	o << ';';
	ascii_indent(o,indent);
	o << ".setinit";
	o << (config_setinit() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".initlvl";
	o << (config_initlvl() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pullup";
	o << (config_pullup() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pulldown";
	o << (config_pulldown() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".cap_freq_r2r";
	o << (config_cap_freq_r2r() ? " = true;" : " = false;");
	--indent;
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t GpioConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -322;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -323;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -324;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x18:	// config id 3, type gpiocfg_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -325;
				a += n;
				set_config((gpiocfg_t) v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -326;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -327;
	return a-(const uint8_t *)b;
}

ssize_t GpioConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -328;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -329;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -330;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -331;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -332;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -333;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void GpioConfig::toWire(void (*put)(uint8_t)) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'gpio': id=2
		send_varint(put,sint_varint(m_gpio));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'config': id=3
		send_varint(put,m_config);
	}
}

void GpioConfig::toString(std::string &put) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'gpio': id=2
		send_varint(put,sint_varint(m_gpio));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'config': id=3
		send_varint(put,m_config);
	}
}

void GpioConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t GpioConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional gpiocfg_t config, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	return r;
}

bool GpioConfig::operator != (const GpioConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	return false;
}


bool GpioConfig::operator == (const GpioConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int GpioConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((gpiocfg_t)ull);
			else if (!strcmp(name,"mode"))
				set_config_mode((uint8_t)ull);
			else if (!strcmp(name,"intrtype"))
				set_config_intrtype((uint8_t)ull);
			else if (!strcmp(name,"setinit"))
				set_config_setinit((bool)ull);
			else if (!strcmp(name,"initlvl"))
				set_config_initlvl((bool)ull);
			else if (!strcmp(name,"pullup"))
				set_config_pullup((bool)ull);
			else if (!strcmp(name,"pulldown"))
				set_config_pulldown((bool)ull);
			else if (!strcmp(name,"cap_freq_r2r"))
				set_config_cap_freq_r2r((bool)ull);
			return eptr - value;
		} else {
			return -334;
		}
	}
	return -335;
}

Message *GpioConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *GpioConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void DisplayConfig::clear()
{
	m_type = dt_none;
	m_options = 0;
	m_maxx = 0;
	m_maxy = 1;
	p_validbits = 0;
}

void DisplayConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "DisplayConfig {";
	++indent;
	ascii_indent(o,indent,"type");
	if (const char *v = disp_t_str(m_type))
		o << v;
	else
		o << m_type;
	o << ';';
	ascii_numeric(o, indent, "options", m_options);
	ascii_numeric(o, indent, "maxx", m_maxx);
	ascii_numeric(o, indent, "maxy", m_maxy);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t DisplayConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -336;
		a += fn;
		switch (fid) {
		case 0x8:	// type id 1, type disp_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -337;
				a += n;
				set_type((disp_t) v);
			}
			break;
		case 0x10:	// options id 2, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -338;
				a += n;
				set_options(v);
			}
			break;
		case 0x18:	// maxx id 3, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -339;
				a += n;
				set_maxx(v);
			}
			break;
		case 0x20:	// maxy id 4, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -340;
				a += n;
				set_maxy(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -341;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -342;
	return a-(const uint8_t *)b;
}

ssize_t DisplayConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has type?
	if (m_type != dt_none) {
		// 'type': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -343;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_type);
		if (n <= 0)
			return -344;
		a += n;
	}
	// has options?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'options': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -345;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_options);
		if (n <= 0)
			return -346;
		a += n;
	}
	// has maxx?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'maxx': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -347;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_maxx);
		if (n <= 0)
			return -348;
		a += n;
	}
	// has maxy?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'maxy': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -349;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_maxy);
		if (n <= 0)
			return -350;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void DisplayConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_type != dt_none) {
		// 'type': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'type': id=1
		send_varint(put,m_type);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'options': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'options': id=2
		send_varint(put,m_options);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'maxx': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'maxx': id=3
		send_varint(put,m_maxx);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'maxy': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'maxy': id=4
		send_varint(put,m_maxy);
	}
}

void DisplayConfig::toString(std::string &put) const
{
	if (m_type != dt_none) {
		// 'type': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'type': id=1
		send_varint(put,m_type);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'options': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'options': id=2
		send_varint(put,m_options);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'maxx': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'maxx': id=3
		send_varint(put,m_maxx);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'maxy': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'maxy': id=4
		send_varint(put,m_maxy);
	}
}

void DisplayConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_type()) {
		fsep = json_indent(json,indLvl,fsep,"type");
		if (const char *v = disp_t_str(m_type)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_type;
		}
	}
	if (has_options()) {
		fsep = json_indent(json,indLvl,fsep,"options");
		json << m_options;
	}
	if (has_maxx()) {
		fsep = json_indent(json,indLvl,fsep,"maxx");
		json << m_maxx;
	}
	if (has_maxy()) {
		fsep = json_indent(json,indLvl,fsep,"maxy");
		json << m_maxy;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t DisplayConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional disp_t type, id 1
	if (m_type != dt_none) {
		r += wiresize((varint_t)m_type) + 1 /* tag(type) 0x8 */;
	}
	// optional unsigned options, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_options) + 1 /* tag(options) 0x10 */;
	}
	// optional unsigned maxx, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_maxx) + 1 /* tag(maxx) 0x18 */;
	}
	// optional unsigned maxy, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += wiresize((varint_t)m_maxy) + 1 /* tag(maxy) 0x20 */;
	}
	return r;
}

bool DisplayConfig::operator != (const DisplayConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_type() && (m_type != r.m_type))
		return true;
	if (has_options() && (m_options != r.m_options))
		return true;
	if (has_maxx() && (m_maxx != r.m_maxx))
		return true;
	if (has_maxy() && (m_maxy != r.m_maxy))
		return true;
	return false;
}


bool DisplayConfig::operator == (const DisplayConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int DisplayConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"type")) {
		if (value == 0) {
			clear_type();
			return 0;
		}
		disp_t v;
		size_t r = parse_ascii_disp_t(&v,value);
		if (r == 0)
			return -351;
		set_type(v);
		return r;
	}
	if (0 == strcmp(name,"options")) {
		if (value == 0) {
			clear_options();
			return 0;
		}
		int r = parse_ascii_u64(&m_options,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"maxx")) {
		if (value == 0) {
			clear_maxx();
			return 0;
		}
		int r = parse_ascii_u64(&m_maxx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"maxy")) {
		if (value == 0) {
			clear_maxy();
			return 0;
		}
		int r = parse_ascii_u64(&m_maxy,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	return -352;
}

Message *DisplayConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *DisplayConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void SpiDeviceConfig::clear()
{
	m_drv = spidrv_invalid;
	m_cs = -1;
	m_intr = -1;
	m_reset = -1;
	m_cd = -1;
}

void SpiDeviceConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "SpiDeviceConfig {";
	++indent;
	ascii_indent(o,indent,"drv");
	if (const char *v = spidrv_t_str(m_drv))
		o << v;
	else
		o << m_drv;
	o << ';';
	ascii_numeric(o, indent, "cs", (signed) m_cs);
	ascii_numeric(o, indent, "intr", (signed) m_intr);
	ascii_numeric(o, indent, "reset", (signed) m_reset);
	ascii_numeric(o, indent, "cd", (signed) m_cd);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SpiDeviceConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -353;
		a += fn;
		switch (fid) {
		case 0x8:	// drv id 1, type spidrv_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -354;
				a += n;
				set_drv((spidrv_t) v);
			}
			break;
		case 0x10:	// cs id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -355;
				a += n;
				set_cs(varint_sint(v));
			}
			break;
		case 0x18:	// intr id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -356;
				a += n;
				set_intr(varint_sint(v));
			}
			break;
		case 0x20:	// reset id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -357;
				a += n;
				set_reset(varint_sint(v));
			}
			break;
		case 0x28:	// cd id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -358;
				a += n;
				set_cd(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -359;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -360;
	return a-(const uint8_t *)b;
}

ssize_t SpiDeviceConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has drv?
	if (m_drv != spidrv_invalid) {
		// 'drv': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -361;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_drv);
		if (n <= 0)
			return -362;
		a += n;
	}
	// has cs?
	if (m_cs != -1) {
		// 'cs': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -363;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_cs));
		if (n <= 0)
			return -364;
		a += n;
	}
	// has intr?
	if (m_intr != -1) {
		// 'intr': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -365;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_intr));
		if (n <= 0)
			return -366;
		a += n;
	}
	// has reset?
	if (m_reset != -1) {
		// 'reset': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -367;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_reset));
		if (n <= 0)
			return -368;
		a += n;
	}
	// has cd?
	if (m_cd != -1) {
		// 'cd': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -369;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_cd));
		if (n <= 0)
			return -370;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void SpiDeviceConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_drv != spidrv_invalid) {
		// 'drv': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'drv': id=1
		send_varint(put,m_drv);
	}
	if (m_cs != -1) {
		// 'cs': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'cs': id=2
		send_varint(put,sint_varint(m_cs));
	}
	if (m_intr != -1) {
		// 'intr': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'intr': id=3
		send_varint(put,sint_varint(m_intr));
	}
	if (m_reset != -1) {
		// 'reset': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'reset': id=4
		send_varint(put,sint_varint(m_reset));
	}
	if (m_cd != -1) {
		// 'cd': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'cd': id=5
		send_varint(put,sint_varint(m_cd));
	}
}

void SpiDeviceConfig::toString(std::string &put) const
{
	if (m_drv != spidrv_invalid) {
		// 'drv': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'drv': id=1
		send_varint(put,m_drv);
	}
	if (m_cs != -1) {
		// 'cs': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'cs': id=2
		send_varint(put,sint_varint(m_cs));
	}
	if (m_intr != -1) {
		// 'intr': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'intr': id=3
		send_varint(put,sint_varint(m_intr));
	}
	if (m_reset != -1) {
		// 'reset': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'reset': id=4
		send_varint(put,sint_varint(m_reset));
	}
	if (m_cd != -1) {
		// 'cd': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'cd': id=5
		send_varint(put,sint_varint(m_cd));
	}
}

void SpiDeviceConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_drv()) {
		fsep = json_indent(json,indLvl,fsep,"drv");
		if (const char *v = spidrv_t_str(m_drv)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_drv;
		}
	}
	if (has_cs()) {
		fsep = json_indent(json,indLvl,fsep,"cs");
		json << (int) m_cs;
	}
	if (has_intr()) {
		fsep = json_indent(json,indLvl,fsep,"intr");
		json << (int) m_intr;
	}
	if (has_reset()) {
		fsep = json_indent(json,indLvl,fsep,"reset");
		json << (int) m_reset;
	}
	if (has_cd()) {
		fsep = json_indent(json,indLvl,fsep,"cd");
		json << (int) m_cd;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SpiDeviceConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional spidrv_t drv, id 1
	if (m_drv != spidrv_invalid) {
		r += wiresize((varint_t)m_drv) + 1 /* tag(drv) 0x8 */;
	}
	// optional sint8 cs, id 2
	if (m_cs != -1) {
		r += wiresize_s((varint_t)m_cs) + 1 /* tag(cs) 0x10 */;
	}
	// optional sint8 intr, id 3
	if (m_intr != -1) {
		r += wiresize_s((varint_t)m_intr) + 1 /* tag(intr) 0x18 */;
	}
	// optional sint8 reset, id 4
	if (m_reset != -1) {
		r += wiresize_s((varint_t)m_reset) + 1 /* tag(reset) 0x20 */;
	}
	// optional sint8 cd, id 5
	if (m_cd != -1) {
		r += wiresize_s((varint_t)m_cd) + 1 /* tag(cd) 0x28 */;
	}
	return r;
}

bool SpiDeviceConfig::operator != (const SpiDeviceConfig &r) const
{
	if (has_drv() && (m_drv != r.m_drv))
		return true;
	if (has_cs() && (m_cs != r.m_cs))
		return true;
	if (has_intr() && (m_intr != r.m_intr))
		return true;
	if (has_reset() && (m_reset != r.m_reset))
		return true;
	if (has_cd() && (m_cd != r.m_cd))
		return true;
	return false;
}


bool SpiDeviceConfig::operator == (const SpiDeviceConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SpiDeviceConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"drv")) {
		if (value == 0) {
			clear_drv();
			return 0;
		}
		spidrv_t v;
		size_t r = parse_ascii_spidrv_t(&v,value);
		if (r == 0)
			return -371;
		set_drv(v);
		return r;
	}
	if (0 == strcmp(name,"cs")) {
		if (value == 0) {
			clear_cs();
			return 0;
		}
		int r = parse_ascii_s8(&m_cs,value);
		return r;
	}
	if (0 == strcmp(name,"intr")) {
		if (value == 0) {
			clear_intr();
			return 0;
		}
		int r = parse_ascii_s8(&m_intr,value);
		return r;
	}
	if (0 == strcmp(name,"reset")) {
		if (value == 0) {
			clear_reset();
			return 0;
		}
		int r = parse_ascii_s8(&m_reset,value);
		return r;
	}
	if (0 == strcmp(name,"cd")) {
		if (value == 0) {
			clear_cd();
			return 0;
		}
		int r = parse_ascii_s8(&m_cd,value);
		return r;
	}
	return -372;
}

Message *SpiDeviceConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *SpiDeviceConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void SpiBusConfig::clear()
{
	m_host = -1;
	m_mosi = -1;
	m_miso = -1;
	m_sclk = -1;
	m_wp = -1;
	m_hold = -1;
	m_options = 0;
	m_dma = -1;
	m_devices.clear();
	p_validbits = 0;
}

void SpiBusConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "SpiBusConfig {";
	++indent;
	ascii_numeric(o, indent, "host", (signed) m_host);
	ascii_numeric(o, indent, "mosi", (signed) m_mosi);
	ascii_numeric(o, indent, "miso", (signed) m_miso);
	ascii_numeric(o, indent, "sclk", (signed) m_sclk);
	ascii_numeric(o, indent, "wp", (signed) m_wp);
	ascii_numeric(o, indent, "hold", (signed) m_hold);
	ascii_numeric(o, indent, "options", (unsigned) m_options);
	++indent;
	ascii_indent(o,indent);
	o << ".txlsbfirst";
	o << (options_txlsbfirst() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".rxlsbfirst";
	o << (options_rxlsbfirst() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".mosi_as_miso";
	o << (options_mosi_as_miso() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".positive_cs";
	o << (options_positive_cs() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".full_duplex";
	o << (options_full_duplex() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pol_hi";
	o << (options_pol_hi() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pha_hi";
	o << (options_pha_hi() ? " = true;" : " = false;");
	--indent;
	ascii_numeric(o, indent, "dma", (signed) m_dma);
	ascii_indent(o,indent);
	size_t s_devices = m_devices.size();
	o << "devices[" << s_devices << "] = {";
	++indent;
	for (size_t i = 0, e = s_devices; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_devices[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SpiBusConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -373;
		a += fn;
		switch (fid) {
		case 0x8:	// host id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -374;
				a += n;
				set_host(varint_sint(v));
			}
			break;
		case 0x10:	// mosi id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -375;
				a += n;
				set_mosi(varint_sint(v));
			}
			break;
		case 0x18:	// miso id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -376;
				a += n;
				set_miso(varint_sint(v));
			}
			break;
		case 0x20:	// sclk id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -377;
				a += n;
				set_sclk(varint_sint(v));
			}
			break;
		case 0x28:	// wp id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -378;
				a += n;
				set_wp(varint_sint(v));
			}
			break;
		case 0x30:	// hold id 6, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -379;
				a += n;
				set_hold(varint_sint(v));
			}
			break;
		case 0x38:	// options id 7, type spiopt_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -380;
				a += n;
				set_options((spiopt_t) v);
			}
			break;
		case 0x40:	// dma id 8, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -381;
				a += n;
				set_dma(varint_sint(v));
			}
			break;
		case 0x4a:	// devices id 9, type SpiDeviceConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -382;
				m_devices.emplace_back();
				if (v != 0) {
					n = m_devices.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -383;
					a += v;
				}
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -384;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -385;
	return a-(const uint8_t *)b;
}

ssize_t SpiBusConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has host?
	if (m_host != -1) {
		// 'host': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -386;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_host));
		if (n <= 0)
			return -387;
		a += n;
	}
	// has mosi?
	if (m_mosi != -1) {
		// 'mosi': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -388;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_mosi));
		if (n <= 0)
			return -389;
		a += n;
	}
	// has miso?
	if (m_miso != -1) {
		// 'miso': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -390;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_miso));
		if (n <= 0)
			return -391;
		a += n;
	}
	// has sclk?
	if (m_sclk != -1) {
		// 'sclk': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -392;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_sclk));
		if (n <= 0)
			return -393;
		a += n;
	}
	// has wp?
	if (m_wp != -1) {
		// 'wp': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -394;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_wp));
		if (n <= 0)
			return -395;
		a += n;
	}
	// has hold?
	if (m_hold != -1) {
		// 'hold': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -396;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_hold));
		if (n <= 0)
			return -397;
		a += n;
	}
	// has options?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'options': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -398;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_options);
		if (n <= 0)
			return -399;
		a += n;
	}
	// has dma?
	if (m_dma != -1) {
		// 'dma': id=8, encoding=varint, tag=0x40
		if (a >= e)
			return -400;
		*a++ = 0x40;
		n = write_varint(a,e-a,sint_varint(m_dma));
		if (n <= 0)
			return -401;
		a += n;
	}
	for (const auto &x : m_devices) {
		// 'devices': id=9, encoding=lenpfx, tag=0x4a
		if (a >= e)
			return -402;
		*a++ = 0x4a;
		ssize_t devices_ws = x.calcSize();
		n = write_varint(a,e-a,devices_ws);
		a += n;
		if ((n <= 0) || (devices_ws > (e-a)))
			return -403;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == devices_ws);
	}
	assert(a <= e);
	return a-b;
}

void SpiBusConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_host != -1) {
		// 'host': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'host': id=1
		send_varint(put,sint_varint(m_host));
	}
	if (m_mosi != -1) {
		// 'mosi': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'mosi': id=2
		send_varint(put,sint_varint(m_mosi));
	}
	if (m_miso != -1) {
		// 'miso': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'miso': id=3
		send_varint(put,sint_varint(m_miso));
	}
	if (m_sclk != -1) {
		// 'sclk': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'sclk': id=4
		send_varint(put,sint_varint(m_sclk));
	}
	if (m_wp != -1) {
		// 'wp': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'wp': id=5
		send_varint(put,sint_varint(m_wp));
	}
	if (m_hold != -1) {
		// 'hold': id=6, encoding=varint, tag=0x30
		put(0x30);	// 'hold': id=6
		send_varint(put,sint_varint(m_hold));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'options': id=7, encoding=varint, tag=0x38
		put(0x38);	// 'options': id=7
		send_varint(put,m_options);
	}
	if (m_dma != -1) {
		// 'dma': id=8, encoding=varint, tag=0x40
		put(0x40);	// 'dma': id=8
		send_varint(put,sint_varint(m_dma));
	}
	for (size_t x = 0, y = m_devices.size(); x != y; ++x) {
		// 'devices': id=9, encoding=lenpfx, tag=0x4a
		put(0x4a);	// 'devices': id=9
		send_varint(put,m_devices[x].calcSize());
		m_devices[x].toWire(put);
	}
}

void SpiBusConfig::toString(std::string &put) const
{
	if (m_host != -1) {
		// 'host': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'host': id=1
		send_varint(put,sint_varint(m_host));
	}
	if (m_mosi != -1) {
		// 'mosi': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'mosi': id=2
		send_varint(put,sint_varint(m_mosi));
	}
	if (m_miso != -1) {
		// 'miso': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'miso': id=3
		send_varint(put,sint_varint(m_miso));
	}
	if (m_sclk != -1) {
		// 'sclk': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'sclk': id=4
		send_varint(put,sint_varint(m_sclk));
	}
	if (m_wp != -1) {
		// 'wp': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'wp': id=5
		send_varint(put,sint_varint(m_wp));
	}
	if (m_hold != -1) {
		// 'hold': id=6, encoding=varint, tag=0x30
		put.push_back(0x30);	// 'hold': id=6
		send_varint(put,sint_varint(m_hold));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'options': id=7, encoding=varint, tag=0x38
		put.push_back(0x38);	// 'options': id=7
		send_varint(put,m_options);
	}
	if (m_dma != -1) {
		// 'dma': id=8, encoding=varint, tag=0x40
		put.push_back(0x40);	// 'dma': id=8
		send_varint(put,sint_varint(m_dma));
	}
	for (size_t x = 0, y = m_devices.size(); x != y; ++x) {
		// 'devices': id=9, encoding=lenpfx, tag=0x4a
		put.push_back(0x4a);	// 'devices': id=9
		send_varint(put,m_devices[x].calcSize());
		m_devices[x].toString(put);
	}
}

void SpiBusConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_host()) {
		fsep = json_indent(json,indLvl,fsep,"host");
		json << (int) m_host;
	}
	if (has_mosi()) {
		fsep = json_indent(json,indLvl,fsep,"mosi");
		json << (int) m_mosi;
	}
	if (has_miso()) {
		fsep = json_indent(json,indLvl,fsep,"miso");
		json << (int) m_miso;
	}
	if (has_sclk()) {
		fsep = json_indent(json,indLvl,fsep,"sclk");
		json << (int) m_sclk;
	}
	if (has_wp()) {
		fsep = json_indent(json,indLvl,fsep,"wp");
		json << (int) m_wp;
	}
	if (has_hold()) {
		fsep = json_indent(json,indLvl,fsep,"hold");
		json << (int) m_hold;
	}
	if (has_options()) {
		fsep = json_indent(json,indLvl,fsep,"options");
		json << (unsigned) m_options;
	}
	if (has_dma()) {
		fsep = json_indent(json,indLvl,fsep,"dma");
		json << (int) m_dma;
	}
	if (size_t s = m_devices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"devices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_devices[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SpiBusConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 host, id 1
	if (m_host != -1) {
		r += wiresize_s((varint_t)m_host) + 1 /* tag(host) 0x8 */;
	}
	// optional sint8 mosi, id 2
	if (m_mosi != -1) {
		r += wiresize_s((varint_t)m_mosi) + 1 /* tag(mosi) 0x10 */;
	}
	// optional sint8 miso, id 3
	if (m_miso != -1) {
		r += wiresize_s((varint_t)m_miso) + 1 /* tag(miso) 0x18 */;
	}
	// optional sint8 sclk, id 4
	if (m_sclk != -1) {
		r += wiresize_s((varint_t)m_sclk) + 1 /* tag(sclk) 0x20 */;
	}
	// optional sint8 wp, id 5
	if (m_wp != -1) {
		r += wiresize_s((varint_t)m_wp) + 1 /* tag(wp) 0x28 */;
	}
	// optional sint8 hold, id 6
	if (m_hold != -1) {
		r += wiresize_s((varint_t)m_hold) + 1 /* tag(hold) 0x30 */;
	}
	// optional spiopt_t options, id 7
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_options) + 1 /* tag(options) 0x38 */;
	}
	// optional sint8 dma, id 8
	if (m_dma != -1) {
		r += wiresize_s((varint_t)m_dma) + 1 /* tag(dma) 0x40 */;
	}
	// repeated SpiDeviceConfig devices, id 9
	// repeated message devices
	for (size_t x = 0, y = m_devices.size(); x < y; ++x) {
		size_t s = m_devices[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(devices) 0x48 */;
	}
	return r;
}

bool SpiBusConfig::operator != (const SpiBusConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_host() && (m_host != r.m_host))
		return true;
	if (has_mosi() && (m_mosi != r.m_mosi))
		return true;
	if (has_miso() && (m_miso != r.m_miso))
		return true;
	if (has_sclk() && (m_sclk != r.m_sclk))
		return true;
	if (has_wp() && (m_wp != r.m_wp))
		return true;
	if (has_hold() && (m_hold != r.m_hold))
		return true;
	if (has_options() && (m_options != r.m_options))
		return true;
	if (has_dma() && (m_dma != r.m_dma))
		return true;
	if (m_devices != r.m_devices)
		return true;
	return false;
}


bool SpiBusConfig::operator == (const SpiBusConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SpiBusConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"host")) {
		if (value == 0) {
			clear_host();
			return 0;
		}
		int r = parse_ascii_s8(&m_host,value);
		return r;
	}
	if (0 == strcmp(name,"mosi")) {
		if (value == 0) {
			clear_mosi();
			return 0;
		}
		int r = parse_ascii_s8(&m_mosi,value);
		return r;
	}
	if (0 == strcmp(name,"miso")) {
		if (value == 0) {
			clear_miso();
			return 0;
		}
		int r = parse_ascii_s8(&m_miso,value);
		return r;
	}
	if (0 == strcmp(name,"sclk")) {
		if (value == 0) {
			clear_sclk();
			return 0;
		}
		int r = parse_ascii_s8(&m_sclk,value);
		return r;
	}
	if (0 == strcmp(name,"wp")) {
		if (value == 0) {
			clear_wp();
			return 0;
		}
		int r = parse_ascii_s8(&m_wp,value);
		return r;
	}
	if (0 == strcmp(name,"hold")) {
		if (value == 0) {
			clear_hold();
			return 0;
		}
		int r = parse_ascii_s8(&m_hold,value);
		return r;
	}
	if ((0 == memcmp(name,"options",7)) && ((name[7] == 0) || name[7] == '.')) {
		name += 7;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_options((spiopt_t)ull);
			else if (!strcmp(name,"txlsbfirst"))
				set_options_txlsbfirst((bool)ull);
			else if (!strcmp(name,"rxlsbfirst"))
				set_options_rxlsbfirst((bool)ull);
			else if (!strcmp(name,"mosi_as_miso"))
				set_options_mosi_as_miso((bool)ull);
			else if (!strcmp(name,"positive_cs"))
				set_options_positive_cs((bool)ull);
			else if (!strcmp(name,"full_duplex"))
				set_options_full_duplex((bool)ull);
			else if (!strcmp(name,"pol_hi"))
				set_options_pol_hi((bool)ull);
			else if (!strcmp(name,"pha_hi"))
				set_options_pha_hi((bool)ull);
			return eptr - value;
		} else {
			return -404;
		}
	}
	if (0 == strcmp(name,"dma")) {
		if (value == 0) {
			clear_dma();
			return 0;
		}
		int r = parse_ascii_s8(&m_dma,value);
		return r;
	}
	if (0 == memcmp(name,"devices",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_devices();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_devices.size();
				m_devices.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -405;
				if (m_devices.size() <= x)
					return -406;
				if ((idxe[1] == 0) && (value == 0)) {
					m_devices.erase(m_devices.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -407;
			return m_devices[x].setByName(idxe+2,value);
		}
	}
	return -408;
}

Message *SpiBusConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *SpiBusConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	if ((n == 7) && (0 == memcmp("devices",s,7))) {
		if (x < m_devices.size())
			return &m_devices[x];
	}
	return 0;
}

void GpioCluster::clear()
{
	m_name.clear();
	m_base = 0;
	m_numio = 0;
	m_int_a = -1;
	m_int_b = -1;
}

void GpioCluster::toASCII(std::ostream &o, size_t indent) const
{
	o << "GpioCluster {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "base", (unsigned) m_base);
	ascii_numeric(o, indent, "numio", (unsigned) m_numio);
	ascii_numeric(o, indent, "int_a", (signed) m_int_a);
	ascii_numeric(o, indent, "int_b", (signed) m_int_b);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t GpioCluster::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -409;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -410;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// base id 2, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -411;
				a += n;
				set_base(v);
			}
			break;
		case 0x18:	// numio id 3, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -412;
				a += n;
				set_numio(v);
			}
			break;
		case 0x20:	// int_a id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -413;
				a += n;
				set_int_a(varint_sint(v));
			}
			break;
		case 0x28:	// int_b id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -414;
				a += n;
				set_int_b(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -415;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -416;
	return a-(const uint8_t *)b;
}

ssize_t GpioCluster::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -417;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -418;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has base?
	if (m_base != 0) {
		// 'base': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -419;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_base);
		if (n <= 0)
			return -420;
		a += n;
	}
	// has numio?
	if (m_numio != 0) {
		// 'numio': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -421;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_numio);
		if (n <= 0)
			return -422;
		a += n;
	}
	// has int_a?
	if (m_int_a != -1) {
		// 'int_a': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -423;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_int_a));
		if (n <= 0)
			return -424;
		a += n;
	}
	// has int_b?
	if (m_int_b != -1) {
		// 'int_b': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -425;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_int_b));
		if (n <= 0)
			return -426;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void GpioCluster::toWire(void (*put)(uint8_t)) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (m_base != 0) {
		// 'base': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'base': id=2
		send_varint(put,m_base);
	}
	if (m_numio != 0) {
		// 'numio': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'numio': id=3
		send_varint(put,m_numio);
	}
	if (m_int_a != -1) {
		// 'int_a': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'int_a': id=4
		send_varint(put,sint_varint(m_int_a));
	}
	if (m_int_b != -1) {
		// 'int_b': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'int_b': id=5
		send_varint(put,sint_varint(m_int_b));
	}
}

void GpioCluster::toString(std::string &put) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (m_base != 0) {
		// 'base': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'base': id=2
		send_varint(put,m_base);
	}
	if (m_numio != 0) {
		// 'numio': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'numio': id=3
		send_varint(put,m_numio);
	}
	if (m_int_a != -1) {
		// 'int_a': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'int_a': id=4
		send_varint(put,sint_varint(m_int_a));
	}
	if (m_int_b != -1) {
		// 'int_b': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'int_b': id=5
		send_varint(put,sint_varint(m_int_b));
	}
}

void GpioCluster::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_base()) {
		fsep = json_indent(json,indLvl,fsep,"base");
		json << (unsigned) m_base;
	}
	if (has_numio()) {
		fsep = json_indent(json,indLvl,fsep,"numio");
		json << (unsigned) m_numio;
	}
	if (has_int_a()) {
		fsep = json_indent(json,indLvl,fsep,"int_a");
		json << (int) m_int_a;
	}
	if (has_int_b()) {
		fsep = json_indent(json,indLvl,fsep,"int_b");
		json << (int) m_int_b;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t GpioCluster::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional uint8 base, id 2
	if (m_base != 0) {
		r += wiresize((varint_t)m_base) + 1 /* tag(base) 0x10 */;
	}
	// optional uint8 numio, id 3
	if (m_numio != 0) {
		r += wiresize((varint_t)m_numio) + 1 /* tag(numio) 0x18 */;
	}
	// optional sint8 int_a, id 4
	if (m_int_a != -1) {
		r += wiresize_s((varint_t)m_int_a) + 1 /* tag(int_a) 0x20 */;
	}
	// optional sint8 int_b, id 5
	if (m_int_b != -1) {
		r += wiresize_s((varint_t)m_int_b) + 1 /* tag(int_b) 0x28 */;
	}
	return r;
}

bool GpioCluster::operator != (const GpioCluster &r) const
{
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_base() && (m_base != r.m_base))
		return true;
	if (has_numio() && (m_numio != r.m_numio))
		return true;
	if (has_int_a() && (m_int_a != r.m_int_a))
		return true;
	if (has_int_b() && (m_int_b != r.m_int_b))
		return true;
	return false;
}


bool GpioCluster::operator == (const GpioCluster &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int GpioCluster::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"base")) {
		if (value == 0) {
			clear_base();
			return 0;
		}
		int r = parse_ascii_u8(&m_base,value);
		return r;
	}
	if (0 == strcmp(name,"numio")) {
		if (value == 0) {
			clear_numio();
			return 0;
		}
		int r = parse_ascii_u8(&m_numio,value);
		return r;
	}
	if (0 == strcmp(name,"int_a")) {
		if (value == 0) {
			clear_int_a();
			return 0;
		}
		int r = parse_ascii_s8(&m_int_a,value);
		return r;
	}
	if (0 == strcmp(name,"int_b")) {
		if (value == 0) {
			clear_int_b();
			return 0;
		}
		int r = parse_ascii_s8(&m_int_b,value);
		return r;
	}
	return -427;
}

Message *GpioCluster::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *GpioCluster::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void Hlw8012Config::clear()
{
	m_sel = -1;
	m_cf = -1;
	m_cf1 = -1;
}

void Hlw8012Config::toASCII(std::ostream &o, size_t indent) const
{
	o << "Hlw8012Config {";
	++indent;
	ascii_numeric(o, indent, "sel", (signed) m_sel);
	ascii_numeric(o, indent, "cf", (signed) m_cf);
	ascii_numeric(o, indent, "cf1", (signed) m_cf1);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Hlw8012Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -428;
		a += fn;
		switch (fid) {
		case 0x10:	// sel id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -429;
				a += n;
				set_sel(varint_sint(v));
			}
			break;
		case 0x18:	// cf id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -430;
				a += n;
				set_cf(varint_sint(v));
			}
			break;
		case 0x20:	// cf1 id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -431;
				a += n;
				set_cf1(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -432;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -433;
	return a-(const uint8_t *)b;
}

ssize_t Hlw8012Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has sel?
	if (m_sel != -1) {
		// 'sel': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -434;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sel));
		if (n <= 0)
			return -435;
		a += n;
	}
	// has cf?
	if (m_cf != -1) {
		// 'cf': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -436;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_cf));
		if (n <= 0)
			return -437;
		a += n;
	}
	// has cf1?
	if (m_cf1 != -1) {
		// 'cf1': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -438;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_cf1));
		if (n <= 0)
			return -439;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Hlw8012Config::toWire(void (*put)(uint8_t)) const
{
	if (m_sel != -1) {
		// 'sel': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'sel': id=2
		send_varint(put,sint_varint(m_sel));
	}
	if (m_cf != -1) {
		// 'cf': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'cf': id=3
		send_varint(put,sint_varint(m_cf));
	}
	if (m_cf1 != -1) {
		// 'cf1': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'cf1': id=4
		send_varint(put,sint_varint(m_cf1));
	}
}

void Hlw8012Config::toString(std::string &put) const
{
	if (m_sel != -1) {
		// 'sel': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'sel': id=2
		send_varint(put,sint_varint(m_sel));
	}
	if (m_cf != -1) {
		// 'cf': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'cf': id=3
		send_varint(put,sint_varint(m_cf));
	}
	if (m_cf1 != -1) {
		// 'cf1': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'cf1': id=4
		send_varint(put,sint_varint(m_cf1));
	}
}

void Hlw8012Config::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_sel()) {
		fsep = json_indent(json,indLvl,fsep,"sel");
		json << (int) m_sel;
	}
	if (has_cf()) {
		fsep = json_indent(json,indLvl,fsep,"cf");
		json << (int) m_cf;
	}
	if (has_cf1()) {
		fsep = json_indent(json,indLvl,fsep,"cf1");
		json << (int) m_cf1;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Hlw8012Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 sel, id 2
	if (m_sel != -1) {
		r += wiresize_s((varint_t)m_sel) + 1 /* tag(sel) 0x10 */;
	}
	// optional sint8 cf, id 3
	if (m_cf != -1) {
		r += wiresize_s((varint_t)m_cf) + 1 /* tag(cf) 0x18 */;
	}
	// optional sint8 cf1, id 4
	if (m_cf1 != -1) {
		r += wiresize_s((varint_t)m_cf1) + 1 /* tag(cf1) 0x20 */;
	}
	return r;
}

bool Hlw8012Config::operator != (const Hlw8012Config &r) const
{
	if (has_sel() && (m_sel != r.m_sel))
		return true;
	if (has_cf() && (m_cf != r.m_cf))
		return true;
	if (has_cf1() && (m_cf1 != r.m_cf1))
		return true;
	return false;
}


bool Hlw8012Config::operator == (const Hlw8012Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Hlw8012Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"sel")) {
		if (value == 0) {
			clear_sel();
			return 0;
		}
		int r = parse_ascii_s8(&m_sel,value);
		return r;
	}
	if (0 == strcmp(name,"cf")) {
		if (value == 0) {
			clear_cf();
			return 0;
		}
		int r = parse_ascii_s8(&m_cf,value);
		return r;
	}
	if (0 == strcmp(name,"cf1")) {
		if (value == 0) {
			clear_cf1();
			return 0;
		}
		int r = parse_ascii_s8(&m_cf1,value);
		return r;
	}
	return -440;
}

Message *Hlw8012Config::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *Hlw8012Config::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void SX1276Config::clear()
{
	m_dio0 = -1;
	m_dio1 = -1;
	m_dio2 = -1;
	m_dio3 = -1;
	m_dio4 = -1;
	m_dio5 = -1;
}

void SX1276Config::toASCII(std::ostream &o, size_t indent) const
{
	o << "SX1276Config {";
	++indent;
	ascii_numeric(o, indent, "dio0", (signed) m_dio0);
	ascii_numeric(o, indent, "dio1", (signed) m_dio1);
	ascii_numeric(o, indent, "dio2", (signed) m_dio2);
	ascii_numeric(o, indent, "dio3", (signed) m_dio3);
	ascii_numeric(o, indent, "dio4", (signed) m_dio4);
	ascii_numeric(o, indent, "dio5", (signed) m_dio5);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SX1276Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -441;
		a += fn;
		switch (fid) {
		case 0x8:	// dio0 id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -442;
				a += n;
				set_dio0(varint_sint(v));
			}
			break;
		case 0x10:	// dio1 id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -443;
				a += n;
				set_dio1(varint_sint(v));
			}
			break;
		case 0x18:	// dio2 id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -444;
				a += n;
				set_dio2(varint_sint(v));
			}
			break;
		case 0x20:	// dio3 id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -445;
				a += n;
				set_dio3(varint_sint(v));
			}
			break;
		case 0x28:	// dio4 id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -446;
				a += n;
				set_dio4(varint_sint(v));
			}
			break;
		case 0x30:	// dio5 id 6, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -447;
				a += n;
				set_dio5(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -448;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -449;
	return a-(const uint8_t *)b;
}

ssize_t SX1276Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has dio0?
	if (m_dio0 != -1) {
		// 'dio0': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -450;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_dio0));
		if (n <= 0)
			return -451;
		a += n;
	}
	// has dio1?
	if (m_dio1 != -1) {
		// 'dio1': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -452;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_dio1));
		if (n <= 0)
			return -453;
		a += n;
	}
	// has dio2?
	if (m_dio2 != -1) {
		// 'dio2': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -454;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_dio2));
		if (n <= 0)
			return -455;
		a += n;
	}
	// has dio3?
	if (m_dio3 != -1) {
		// 'dio3': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -456;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_dio3));
		if (n <= 0)
			return -457;
		a += n;
	}
	// has dio4?
	if (m_dio4 != -1) {
		// 'dio4': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -458;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_dio4));
		if (n <= 0)
			return -459;
		a += n;
	}
	// has dio5?
	if (m_dio5 != -1) {
		// 'dio5': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -460;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_dio5));
		if (n <= 0)
			return -461;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void SX1276Config::toWire(void (*put)(uint8_t)) const
{
	if (m_dio0 != -1) {
		// 'dio0': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'dio0': id=1
		send_varint(put,sint_varint(m_dio0));
	}
	if (m_dio1 != -1) {
		// 'dio1': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'dio1': id=2
		send_varint(put,sint_varint(m_dio1));
	}
	if (m_dio2 != -1) {
		// 'dio2': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'dio2': id=3
		send_varint(put,sint_varint(m_dio2));
	}
	if (m_dio3 != -1) {
		// 'dio3': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'dio3': id=4
		send_varint(put,sint_varint(m_dio3));
	}
	if (m_dio4 != -1) {
		// 'dio4': id=5, encoding=varint, tag=0x28
		put(0x28);	// 'dio4': id=5
		send_varint(put,sint_varint(m_dio4));
	}
	if (m_dio5 != -1) {
		// 'dio5': id=6, encoding=varint, tag=0x30
		put(0x30);	// 'dio5': id=6
		send_varint(put,sint_varint(m_dio5));
	}
}

void SX1276Config::toString(std::string &put) const
{
	if (m_dio0 != -1) {
		// 'dio0': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'dio0': id=1
		send_varint(put,sint_varint(m_dio0));
	}
	if (m_dio1 != -1) {
		// 'dio1': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'dio1': id=2
		send_varint(put,sint_varint(m_dio1));
	}
	if (m_dio2 != -1) {
		// 'dio2': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'dio2': id=3
		send_varint(put,sint_varint(m_dio2));
	}
	if (m_dio3 != -1) {
		// 'dio3': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'dio3': id=4
		send_varint(put,sint_varint(m_dio3));
	}
	if (m_dio4 != -1) {
		// 'dio4': id=5, encoding=varint, tag=0x28
		put.push_back(0x28);	// 'dio4': id=5
		send_varint(put,sint_varint(m_dio4));
	}
	if (m_dio5 != -1) {
		// 'dio5': id=6, encoding=varint, tag=0x30
		put.push_back(0x30);	// 'dio5': id=6
		send_varint(put,sint_varint(m_dio5));
	}
}

void SX1276Config::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_dio0()) {
		fsep = json_indent(json,indLvl,fsep,"dio0");
		json << (int) m_dio0;
	}
	if (has_dio1()) {
		fsep = json_indent(json,indLvl,fsep,"dio1");
		json << (int) m_dio1;
	}
	if (has_dio2()) {
		fsep = json_indent(json,indLvl,fsep,"dio2");
		json << (int) m_dio2;
	}
	if (has_dio3()) {
		fsep = json_indent(json,indLvl,fsep,"dio3");
		json << (int) m_dio3;
	}
	if (has_dio4()) {
		fsep = json_indent(json,indLvl,fsep,"dio4");
		json << (int) m_dio4;
	}
	if (has_dio5()) {
		fsep = json_indent(json,indLvl,fsep,"dio5");
		json << (int) m_dio5;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SX1276Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 dio0, id 1
	if (m_dio0 != -1) {
		r += wiresize_s((varint_t)m_dio0) + 1 /* tag(dio0) 0x8 */;
	}
	// optional sint8 dio1, id 2
	if (m_dio1 != -1) {
		r += wiresize_s((varint_t)m_dio1) + 1 /* tag(dio1) 0x10 */;
	}
	// optional sint8 dio2, id 3
	if (m_dio2 != -1) {
		r += wiresize_s((varint_t)m_dio2) + 1 /* tag(dio2) 0x18 */;
	}
	// optional sint8 dio3, id 4
	if (m_dio3 != -1) {
		r += wiresize_s((varint_t)m_dio3) + 1 /* tag(dio3) 0x20 */;
	}
	// optional sint8 dio4, id 5
	if (m_dio4 != -1) {
		r += wiresize_s((varint_t)m_dio4) + 1 /* tag(dio4) 0x28 */;
	}
	// optional sint8 dio5, id 6
	if (m_dio5 != -1) {
		r += wiresize_s((varint_t)m_dio5) + 1 /* tag(dio5) 0x30 */;
	}
	return r;
}

bool SX1276Config::operator != (const SX1276Config &r) const
{
	if (has_dio0() && (m_dio0 != r.m_dio0))
		return true;
	if (has_dio1() && (m_dio1 != r.m_dio1))
		return true;
	if (has_dio2() && (m_dio2 != r.m_dio2))
		return true;
	if (has_dio3() && (m_dio3 != r.m_dio3))
		return true;
	if (has_dio4() && (m_dio4 != r.m_dio4))
		return true;
	if (has_dio5() && (m_dio5 != r.m_dio5))
		return true;
	return false;
}


bool SX1276Config::operator == (const SX1276Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SX1276Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"dio0")) {
		if (value == 0) {
			clear_dio0();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio0,value);
		return r;
	}
	if (0 == strcmp(name,"dio1")) {
		if (value == 0) {
			clear_dio1();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio1,value);
		return r;
	}
	if (0 == strcmp(name,"dio2")) {
		if (value == 0) {
			clear_dio2();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio2,value);
		return r;
	}
	if (0 == strcmp(name,"dio3")) {
		if (value == 0) {
			clear_dio3();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio3,value);
		return r;
	}
	if (0 == strcmp(name,"dio4")) {
		if (value == 0) {
			clear_dio4();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio4,value);
		return r;
	}
	if (0 == strcmp(name,"dio5")) {
		if (value == 0) {
			clear_dio5();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio5,value);
		return r;
	}
	return -462;
}

Message *SX1276Config::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *SX1276Config::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void HardwareConfig::clear()
{
	m_magic = 0;
	m_system.clear();
	m_uart.clear();
	m_adc.clear();
	#ifdef CONFIG_TOUCHPAD
	m_touchpad.clear();
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	m_tp_channel.clear();
	#endif // CONFIG_TOUCHPAD
	m_gpios.clear();
	#ifdef CONFIG_SPI
	m_spibus.clear();
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	m_button.clear();
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	m_relay.clear();
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	m_led.clear();
	#endif // CONFIG_LEDS
	#ifdef CONFIG_HLW8012
	m_hlw8012.clear();
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	m_max7219.clear();
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	m_tlc5947.clear();
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	m_ws2812b.clear();
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	m_dht.clear();
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	m_i2c.clear();
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	m_hcsr04.clear();
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	m_onewire.clear();
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	m_sx1276.clear();
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	m_iocluster.clear();
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	m_display.clear();
	#endif // CONFIG_DISPLAY
	p_validbits = 0;
}

void HardwareConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "HardwareConfig {";
	++indent;
	ascii_numeric(o, indent, "magic", m_magic);
	ascii_indent(o,indent,"system");
	m_system.toASCII(o,indent);
	ascii_indent(o,indent);
	size_t s_uart = m_uart.size();
	o << "uart[" << s_uart << "] = {";
	++indent;
	for (size_t i = 0, e = s_uart; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_uart[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent,"adc");
	m_adc.toASCII(o,indent);
	#ifdef CONFIG_TOUCHPAD
	ascii_indent(o,indent,"touchpad");
	m_touchpad.toASCII(o,indent);
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	ascii_indent(o,indent);
	size_t s_tp_channel = m_tp_channel.size();
	o << "tp_channel[" << s_tp_channel << "] = {";
	++indent;
	for (size_t i = 0, e = s_tp_channel; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_tp_channel[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_TOUCHPAD
	ascii_indent(o,indent);
	size_t s_gpios = m_gpios.size();
	o << "gpios[" << s_gpios << "] = {";
	++indent;
	for (size_t i = 0, e = s_gpios; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_gpios[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_SPI
	ascii_indent(o,indent);
	size_t s_spibus = m_spibus.size();
	o << "spibus[" << s_spibus << "] = {";
	++indent;
	for (size_t i = 0, e = s_spibus; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_spibus[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	ascii_indent(o,indent);
	size_t s_button = m_button.size();
	o << "button[" << s_button << "] = {";
	++indent;
	for (size_t i = 0, e = s_button; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_button[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	ascii_indent(o,indent);
	size_t s_relay = m_relay.size();
	o << "relay[" << s_relay << "] = {";
	++indent;
	for (size_t i = 0, e = s_relay; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_relay[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	ascii_indent(o,indent);
	size_t s_led = m_led.size();
	o << "led[" << s_led << "] = {";
	++indent;
	for (size_t i = 0, e = s_led; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_led[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_LEDS
	#ifdef CONFIG_HLW8012
	ascii_indent(o,indent,"hlw8012");
	m_hlw8012.toASCII(o,indent);
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	ascii_indent(o,indent,"max7219");
	m_max7219.toASCII(o,indent);
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	ascii_indent(o,indent,"tlc5947");
	m_tlc5947.toASCII(o,indent);
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	ascii_indent(o,indent);
	size_t s_ws2812b = m_ws2812b.size();
	o << "ws2812b[" << s_ws2812b << "] = {";
	++indent;
	for (size_t i = 0, e = s_ws2812b; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_ws2812b[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	ascii_indent(o,indent,"dht");
	m_dht.toASCII(o,indent);
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	ascii_indent(o,indent);
	size_t s_i2c = m_i2c.size();
	o << "i2c[" << s_i2c << "] = {";
	++indent;
	for (size_t i = 0, e = s_i2c; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_i2c[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	ascii_indent(o,indent);
	size_t s_hcsr04 = m_hcsr04.size();
	o << "hcsr04[" << s_hcsr04 << "] = {";
	++indent;
	for (size_t i = 0, e = s_hcsr04; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_hcsr04[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	ascii_indent(o,indent,"onewire");
	m_onewire.toASCII(o,indent);
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	ascii_indent(o,indent,"sx1276");
	m_sx1276.toASCII(o,indent);
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	ascii_indent(o,indent);
	size_t s_iocluster = m_iocluster.size();
	o << "iocluster[" << s_iocluster << "] = {";
	++indent;
	for (size_t i = 0, e = s_iocluster; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_iocluster[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	ascii_indent(o,indent,"display");
	m_display.toASCII(o,indent);
	#endif // CONFIG_DISPLAY
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t HardwareConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -463;
		a += fn;
		switch (fid) {
		case 0x5:	// magic id 0, type uint32_t, coding 32bit
			if ((a+3) >= e)
				return -464;
			set_magic((uint32_t) read_u32(a));
			a += 4;
			break;
		case 0xa:	// system id 1, type SystemConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -465;
				if (v != 0) {
					n = m_system.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -466;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 1);
			break;
		case 0x1a:	// uart id 3, type UartConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -467;
				m_uart.emplace_back();
				if (v != 0) {
					n = m_uart.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -468;
					a += v;
				}
			}
			break;
		case 0x22:	// adc id 4, type AdcConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -469;
				if (v != 0) {
					n = m_adc.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -470;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 2);
			break;
			#ifdef CONFIG_TOUCHPAD
		case 0x2a:	// touchpad id 5, type TouchpadConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -471;
				if (v != 0) {
					n = m_touchpad.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -472;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 3);
			break;
			#endif // CONFIG_TOUCHPAD
			#ifdef CONFIG_TOUCHPAD
		case 0x32:	// tp_channel id 6, type TouchChannelConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -473;
				m_tp_channel.emplace_back();
				if (v != 0) {
					n = m_tp_channel.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -474;
					a += v;
				}
			}
			break;
			#endif // CONFIG_TOUCHPAD
		case 0x3a:	// gpios id 7, type GpioConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -475;
				m_gpios.emplace_back();
				if (v != 0) {
					n = m_gpios.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -476;
					a += v;
				}
			}
			break;
			#ifdef CONFIG_SPI
		case 0x42:	// spibus id 8, type SpiBusConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -477;
				m_spibus.emplace_back();
				if (v != 0) {
					n = m_spibus.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -478;
					a += v;
				}
			}
			break;
			#endif // CONFIG_SPI
			#ifdef CONFIG_BUTTON
		case 0x82:	// button id 16, type ButtonConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -479;
				m_button.emplace_back();
				if (v != 0) {
					n = m_button.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -480;
					a += v;
				}
			}
			break;
			#endif // CONFIG_BUTTON
			#ifdef CONFIG_RELAY
		case 0x8a:	// relay id 17, type RelayConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -481;
				m_relay.emplace_back();
				if (v != 0) {
					n = m_relay.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -482;
					a += v;
				}
			}
			break;
			#endif // CONFIG_RELAY
			#ifdef CONFIG_LEDS
		case 0x92:	// led id 18, type LedConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -483;
				m_led.emplace_back();
				if (v != 0) {
					n = m_led.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -484;
					a += v;
				}
			}
			break;
			#endif // CONFIG_LEDS
			#ifdef CONFIG_HLW8012
		case 0xa2:	// hlw8012 id 20, type Hlw8012Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -485;
				if (v != 0) {
					n = m_hlw8012.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -486;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 4);
			break;
			#endif // CONFIG_HLW8012
			#ifdef CONFIG_MAX7219
		case 0x102:	// max7219 id 32, type Max7219Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -487;
				if (v != 0) {
					n = m_max7219.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -488;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 5);
			break;
			#endif // CONFIG_MAX7219
			#ifdef CONFIG_TLC5947
		case 0x10a:	// tlc5947 id 33, type Tlc5947Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -489;
				if (v != 0) {
					n = m_tlc5947.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -490;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 6);
			break;
			#endif // CONFIG_TLC5947
			#ifdef CONFIG_RGBLEDS
		case 0x112:	// ws2812b id 34, type Ws2812bConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -491;
				m_ws2812b.emplace_back();
				if (v != 0) {
					n = m_ws2812b.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -492;
					a += v;
				}
			}
			break;
			#endif // CONFIG_RGBLEDS
			#ifdef CONFIG_DHT
		case 0x11a:	// dht id 35, type DhtConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -493;
				if (v != 0) {
					n = m_dht.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -494;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 7);
			break;
			#endif // CONFIG_DHT
			#ifdef CONFIG_I2C
		case 0x122:	// i2c id 36, type I2CConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -495;
				m_i2c.emplace_back();
				if (v != 0) {
					n = m_i2c.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -496;
					a += v;
				}
			}
			break;
			#endif // CONFIG_I2C
			#ifdef CONFIG_HCSR04
		case 0x12a:	// hcsr04 id 37, type HcSr04Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -497;
				m_hcsr04.emplace_back();
				if (v != 0) {
					n = m_hcsr04.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -498;
					a += v;
				}
			}
			break;
			#endif // CONFIG_HCSR04
			#ifdef CONFIG_ONEWIRE
		case 0x132:	// onewire id 38, type OneWireConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -499;
				if (v != 0) {
					n = m_onewire.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -500;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 8);
			break;
			#endif // CONFIG_ONEWIRE
			#ifdef CONFIG_SX1276
		case 0x13a:	// sx1276 id 39, type SX1276Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -501;
				if (v != 0) {
					n = m_sx1276.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -502;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 9);
			break;
			#endif // CONFIG_SX1276
			#ifdef CONFIG_IOEXTENDERS
		case 0x142:	// iocluster id 40, type GpioCluster, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -503;
				m_iocluster.emplace_back();
				if (v != 0) {
					n = m_iocluster.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -504;
					a += v;
				}
			}
			break;
			#endif // CONFIG_IOEXTENDERS
			#ifdef CONFIG_DISPLAY
		case 0x192:	// display id 50, type DisplayConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -505;
				if (v != 0) {
					n = m_display.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -506;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 10);
			break;
			#endif // CONFIG_DISPLAY
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -507;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -508;
	return a-(const uint8_t *)b;
}

ssize_t HardwareConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has magic?
	if (0 != (p_validbits & ((uint16_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		if (5 > (e-a))
			return -509;
		*a++ = 0x5;
		if ((e-a) < 4)
			return -510;
		write_u32(a,(uint32_t)m_magic);
		a += 4;
	}
	// has system?
	if (0 != (p_validbits & ((uint16_t)1U << 1))) {
		// 'system': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -511;
		*a++ = 0xa;
		ssize_t system_ws = m_system.calcSize();
		n = write_varint(a,e-a,system_ws);
		a += n;
		if ((n <= 0) || (system_ws > (e-a)))
			return -512;
		n = m_system.toMemory(a,e-a);
		a += n;
		assert(n == system_ws);
	}
	for (const auto &x : m_uart) {
		// 'uart': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -513;
		*a++ = 0x1a;
		ssize_t uart_ws = x.calcSize();
		n = write_varint(a,e-a,uart_ws);
		a += n;
		if ((n <= 0) || (uart_ws > (e-a)))
			return -514;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == uart_ws);
	}
	// has adc?
	if (0 != (p_validbits & ((uint16_t)1U << 2))) {
		// 'adc': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -515;
		*a++ = 0x22;
		ssize_t adc_ws = m_adc.calcSize();
		n = write_varint(a,e-a,adc_ws);
		a += n;
		if ((n <= 0) || (adc_ws > (e-a)))
			return -516;
		n = m_adc.toMemory(a,e-a);
		a += n;
		assert(n == adc_ws);
	}
	#ifdef CONFIG_TOUCHPAD
	// has touchpad?
	if (0 != (p_validbits & ((uint16_t)1U << 3))) {
		// 'touchpad': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -517;
		*a++ = 0x2a;
		ssize_t touchpad_ws = m_touchpad.calcSize();
		n = write_varint(a,e-a,touchpad_ws);
		a += n;
		if ((n <= 0) || (touchpad_ws > (e-a)))
			return -518;
		n = m_touchpad.toMemory(a,e-a);
		a += n;
		assert(n == touchpad_ws);
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	for (const auto &x : m_tp_channel) {
		// 'tp_channel': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -519;
		*a++ = 0x32;
		ssize_t tp_channel_ws = x.calcSize();
		n = write_varint(a,e-a,tp_channel_ws);
		a += n;
		if ((n <= 0) || (tp_channel_ws > (e-a)))
			return -520;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == tp_channel_ws);
	}
	#endif // CONFIG_TOUCHPAD
	for (const auto &x : m_gpios) {
		// 'gpios': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -521;
		*a++ = 0x3a;
		ssize_t gpios_ws = x.calcSize();
		n = write_varint(a,e-a,gpios_ws);
		a += n;
		if ((n <= 0) || (gpios_ws > (e-a)))
			return -522;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == gpios_ws);
	}
	#ifdef CONFIG_SPI
	for (const auto &x : m_spibus) {
		// 'spibus': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -523;
		*a++ = 0x42;
		ssize_t spibus_ws = x.calcSize();
		n = write_varint(a,e-a,spibus_ws);
		a += n;
		if ((n <= 0) || (spibus_ws > (e-a)))
			return -524;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == spibus_ws);
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	for (const auto &x : m_button) {
		// 'button': id=16, encoding=lenpfx, tag=0x82
		if (2 > (e-a))
			return -525;
		*a++ = 0x82;
		*a++ = 0x1;
		ssize_t button_ws = x.calcSize();
		n = write_varint(a,e-a,button_ws);
		a += n;
		if ((n <= 0) || (button_ws > (e-a)))
			return -526;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == button_ws);
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	for (const auto &x : m_relay) {
		// 'relay': id=17, encoding=lenpfx, tag=0x8a
		if (2 > (e-a))
			return -527;
		*a++ = 0x8a;
		*a++ = 0x1;
		ssize_t relay_ws = x.calcSize();
		n = write_varint(a,e-a,relay_ws);
		a += n;
		if ((n <= 0) || (relay_ws > (e-a)))
			return -528;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == relay_ws);
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	for (const auto &x : m_led) {
		// 'led': id=18, encoding=lenpfx, tag=0x92
		if (2 > (e-a))
			return -529;
		*a++ = 0x92;
		*a++ = 0x1;
		ssize_t led_ws = x.calcSize();
		n = write_varint(a,e-a,led_ws);
		a += n;
		if ((n <= 0) || (led_ws > (e-a)))
			return -530;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == led_ws);
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_HLW8012
	// has hlw8012?
	if (0 != (p_validbits & ((uint16_t)1U << 4))) {
		// 'hlw8012': id=20, encoding=lenpfx, tag=0xa2
		if (2 > (e-a))
			return -531;
		*a++ = 0xa2;
		*a++ = 0x1;
		ssize_t hlw8012_ws = m_hlw8012.calcSize();
		n = write_varint(a,e-a,hlw8012_ws);
		a += n;
		if ((n <= 0) || (hlw8012_ws > (e-a)))
			return -532;
		n = m_hlw8012.toMemory(a,e-a);
		a += n;
		assert(n == hlw8012_ws);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	// has max7219?
	if (0 != (p_validbits & ((uint16_t)1U << 5))) {
		// 'max7219': id=32, encoding=lenpfx, tag=0x102
		if (2 > (e-a))
			return -533;
		*a++ = 0x82;
		*a++ = 0x2;
		ssize_t max7219_ws = m_max7219.calcSize();
		n = write_varint(a,e-a,max7219_ws);
		a += n;
		if ((n <= 0) || (max7219_ws > (e-a)))
			return -534;
		n = m_max7219.toMemory(a,e-a);
		a += n;
		assert(n == max7219_ws);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	// has tlc5947?
	if (0 != (p_validbits & ((uint16_t)1U << 6))) {
		// 'tlc5947': id=33, encoding=lenpfx, tag=0x10a
		if (2 > (e-a))
			return -535;
		*a++ = 0x8a;
		*a++ = 0x2;
		ssize_t tlc5947_ws = m_tlc5947.calcSize();
		n = write_varint(a,e-a,tlc5947_ws);
		a += n;
		if ((n <= 0) || (tlc5947_ws > (e-a)))
			return -536;
		n = m_tlc5947.toMemory(a,e-a);
		a += n;
		assert(n == tlc5947_ws);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	for (const auto &x : m_ws2812b) {
		// 'ws2812b': id=34, encoding=lenpfx, tag=0x112
		if (2 > (e-a))
			return -537;
		*a++ = 0x92;
		*a++ = 0x2;
		ssize_t ws2812b_ws = x.calcSize();
		n = write_varint(a,e-a,ws2812b_ws);
		a += n;
		if ((n <= 0) || (ws2812b_ws > (e-a)))
			return -538;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == ws2812b_ws);
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	// has dht?
	if (0 != (p_validbits & ((uint16_t)1U << 7))) {
		// 'dht': id=35, encoding=lenpfx, tag=0x11a
		if (2 > (e-a))
			return -539;
		*a++ = 0x9a;
		*a++ = 0x2;
		ssize_t dht_ws = m_dht.calcSize();
		n = write_varint(a,e-a,dht_ws);
		a += n;
		if ((n <= 0) || (dht_ws > (e-a)))
			return -540;
		n = m_dht.toMemory(a,e-a);
		a += n;
		assert(n == dht_ws);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	for (const auto &x : m_i2c) {
		// 'i2c': id=36, encoding=lenpfx, tag=0x122
		if (2 > (e-a))
			return -541;
		*a++ = 0xa2;
		*a++ = 0x2;
		ssize_t i2c_ws = x.calcSize();
		n = write_varint(a,e-a,i2c_ws);
		a += n;
		if ((n <= 0) || (i2c_ws > (e-a)))
			return -542;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == i2c_ws);
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	for (const auto &x : m_hcsr04) {
		// 'hcsr04': id=37, encoding=lenpfx, tag=0x12a
		if (2 > (e-a))
			return -543;
		*a++ = 0xaa;
		*a++ = 0x2;
		ssize_t hcsr04_ws = x.calcSize();
		n = write_varint(a,e-a,hcsr04_ws);
		a += n;
		if ((n <= 0) || (hcsr04_ws > (e-a)))
			return -544;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == hcsr04_ws);
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	// has onewire?
	if (0 != (p_validbits & ((uint16_t)1U << 8))) {
		// 'onewire': id=38, encoding=lenpfx, tag=0x132
		if (2 > (e-a))
			return -545;
		*a++ = 0xb2;
		*a++ = 0x2;
		ssize_t onewire_ws = m_onewire.calcSize();
		n = write_varint(a,e-a,onewire_ws);
		a += n;
		if ((n <= 0) || (onewire_ws > (e-a)))
			return -546;
		n = m_onewire.toMemory(a,e-a);
		a += n;
		assert(n == onewire_ws);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	// has sx1276?
	if (0 != (p_validbits & ((uint16_t)1U << 9))) {
		// 'sx1276': id=39, encoding=lenpfx, tag=0x13a
		if (2 > (e-a))
			return -547;
		*a++ = 0xba;
		*a++ = 0x2;
		ssize_t sx1276_ws = m_sx1276.calcSize();
		n = write_varint(a,e-a,sx1276_ws);
		a += n;
		if ((n <= 0) || (sx1276_ws > (e-a)))
			return -548;
		n = m_sx1276.toMemory(a,e-a);
		a += n;
		assert(n == sx1276_ws);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	for (const auto &x : m_iocluster) {
		// 'iocluster': id=40, encoding=lenpfx, tag=0x142
		if (2 > (e-a))
			return -549;
		*a++ = 0xc2;
		*a++ = 0x2;
		ssize_t iocluster_ws = x.calcSize();
		n = write_varint(a,e-a,iocluster_ws);
		a += n;
		if ((n <= 0) || (iocluster_ws > (e-a)))
			return -550;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == iocluster_ws);
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	// has display?
	if (0 != (p_validbits & ((uint16_t)1U << 10))) {
		// 'display': id=50, encoding=lenpfx, tag=0x192
		if (2 > (e-a))
			return -551;
		*a++ = 0x92;
		*a++ = 0x3;
		ssize_t display_ws = m_display.calcSize();
		n = write_varint(a,e-a,display_ws);
		a += n;
		if ((n <= 0) || (display_ws > (e-a)))
			return -552;
		n = m_display.toMemory(a,e-a);
		a += n;
		assert(n == display_ws);
	}
	#endif // CONFIG_DISPLAY
	assert(a <= e);
	return a-b;
}

void HardwareConfig::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint16_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		put(0x5);	// 'magic': id=0
		send_u32(put,(uint32_t)m_magic);
	}
	if (0 != (p_validbits & ((uint16_t)1U << 1))) {
		// 'system': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'system': id=1
		send_varint(put,m_system.calcSize());
		m_system.toWire(put);
	}
	for (size_t x = 0, y = m_uart.size(); x != y; ++x) {
		// 'uart': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'uart': id=3
		send_varint(put,m_uart[x].calcSize());
		m_uart[x].toWire(put);
	}
	if (0 != (p_validbits & ((uint16_t)1U << 2))) {
		// 'adc': id=4, encoding=lenpfx, tag=0x22
		put(0x22);	// 'adc': id=4
		send_varint(put,m_adc.calcSize());
		m_adc.toWire(put);
	}
	#ifdef CONFIG_TOUCHPAD
	if (0 != (p_validbits & ((uint16_t)1U << 3))) {
		// 'touchpad': id=5, encoding=lenpfx, tag=0x2a
		put(0x2a);	// 'touchpad': id=5
		send_varint(put,m_touchpad.calcSize());
		m_touchpad.toWire(put);
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	for (size_t x = 0, y = m_tp_channel.size(); x != y; ++x) {
		// 'tp_channel': id=6, encoding=lenpfx, tag=0x32
		put(0x32);	// 'tp_channel': id=6
		send_varint(put,m_tp_channel[x].calcSize());
		m_tp_channel[x].toWire(put);
	}
	#endif // CONFIG_TOUCHPAD
	for (size_t x = 0, y = m_gpios.size(); x != y; ++x) {
		// 'gpios': id=7, encoding=lenpfx, tag=0x3a
		put(0x3a);	// 'gpios': id=7
		send_varint(put,m_gpios[x].calcSize());
		m_gpios[x].toWire(put);
	}
	#ifdef CONFIG_SPI
	for (size_t x = 0, y = m_spibus.size(); x != y; ++x) {
		// 'spibus': id=8, encoding=lenpfx, tag=0x42
		put(0x42);	// 'spibus': id=8
		send_varint(put,m_spibus[x].calcSize());
		m_spibus[x].toWire(put);
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	for (size_t x = 0, y = m_button.size(); x != y; ++x) {
		// 'button': id=16, encoding=lenpfx, tag=0x82
		put(0x82);
		put(0x1);
		send_varint(put,m_button[x].calcSize());
		m_button[x].toWire(put);
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	for (size_t x = 0, y = m_relay.size(); x != y; ++x) {
		// 'relay': id=17, encoding=lenpfx, tag=0x8a
		put(0x8a);
		put(0x1);
		send_varint(put,m_relay[x].calcSize());
		m_relay[x].toWire(put);
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	for (size_t x = 0, y = m_led.size(); x != y; ++x) {
		// 'led': id=18, encoding=lenpfx, tag=0x92
		put(0x92);
		put(0x1);
		send_varint(put,m_led[x].calcSize());
		m_led[x].toWire(put);
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_HLW8012
	if (0 != (p_validbits & ((uint16_t)1U << 4))) {
		// 'hlw8012': id=20, encoding=lenpfx, tag=0xa2
		put(0xa2);
		put(0x1);
		send_varint(put,m_hlw8012.calcSize());
		m_hlw8012.toWire(put);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (0 != (p_validbits & ((uint16_t)1U << 5))) {
		// 'max7219': id=32, encoding=lenpfx, tag=0x102
		put(0x82);
		put(0x2);
		send_varint(put,m_max7219.calcSize());
		m_max7219.toWire(put);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (0 != (p_validbits & ((uint16_t)1U << 6))) {
		// 'tlc5947': id=33, encoding=lenpfx, tag=0x10a
		put(0x8a);
		put(0x2);
		send_varint(put,m_tlc5947.calcSize());
		m_tlc5947.toWire(put);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	for (size_t x = 0, y = m_ws2812b.size(); x != y; ++x) {
		// 'ws2812b': id=34, encoding=lenpfx, tag=0x112
		put(0x92);
		put(0x2);
		send_varint(put,m_ws2812b[x].calcSize());
		m_ws2812b[x].toWire(put);
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (0 != (p_validbits & ((uint16_t)1U << 7))) {
		// 'dht': id=35, encoding=lenpfx, tag=0x11a
		put(0x9a);
		put(0x2);
		send_varint(put,m_dht.calcSize());
		m_dht.toWire(put);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	for (size_t x = 0, y = m_i2c.size(); x != y; ++x) {
		// 'i2c': id=36, encoding=lenpfx, tag=0x122
		put(0xa2);
		put(0x2);
		send_varint(put,m_i2c[x].calcSize());
		m_i2c[x].toWire(put);
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	for (size_t x = 0, y = m_hcsr04.size(); x != y; ++x) {
		// 'hcsr04': id=37, encoding=lenpfx, tag=0x12a
		put(0xaa);
		put(0x2);
		send_varint(put,m_hcsr04[x].calcSize());
		m_hcsr04[x].toWire(put);
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (0 != (p_validbits & ((uint16_t)1U << 8))) {
		// 'onewire': id=38, encoding=lenpfx, tag=0x132
		put(0xb2);
		put(0x2);
		send_varint(put,m_onewire.calcSize());
		m_onewire.toWire(put);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (0 != (p_validbits & ((uint16_t)1U << 9))) {
		// 'sx1276': id=39, encoding=lenpfx, tag=0x13a
		put(0xba);
		put(0x2);
		send_varint(put,m_sx1276.calcSize());
		m_sx1276.toWire(put);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	for (size_t x = 0, y = m_iocluster.size(); x != y; ++x) {
		// 'iocluster': id=40, encoding=lenpfx, tag=0x142
		put(0xc2);
		put(0x2);
		send_varint(put,m_iocluster[x].calcSize());
		m_iocluster[x].toWire(put);
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (0 != (p_validbits & ((uint16_t)1U << 10))) {
		// 'display': id=50, encoding=lenpfx, tag=0x192
		put(0x92);
		put(0x3);
		send_varint(put,m_display.calcSize());
		m_display.toWire(put);
	}
	#endif // CONFIG_DISPLAY
}

void HardwareConfig::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint16_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		put.push_back(0x5);	// 'magic': id=0
		send_u32(put,(uint32_t)m_magic);
	}
	if (0 != (p_validbits & ((uint16_t)1U << 1))) {
		// 'system': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'system': id=1
		send_varint(put,m_system.calcSize());
		m_system.toString(put);
	}
	for (size_t x = 0, y = m_uart.size(); x != y; ++x) {
		// 'uart': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'uart': id=3
		send_varint(put,m_uart[x].calcSize());
		m_uart[x].toString(put);
	}
	if (0 != (p_validbits & ((uint16_t)1U << 2))) {
		// 'adc': id=4, encoding=lenpfx, tag=0x22
		put.push_back(0x22);	// 'adc': id=4
		send_varint(put,m_adc.calcSize());
		m_adc.toString(put);
	}
	#ifdef CONFIG_TOUCHPAD
	if (0 != (p_validbits & ((uint16_t)1U << 3))) {
		// 'touchpad': id=5, encoding=lenpfx, tag=0x2a
		put.push_back(0x2a);	// 'touchpad': id=5
		send_varint(put,m_touchpad.calcSize());
		m_touchpad.toString(put);
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	for (size_t x = 0, y = m_tp_channel.size(); x != y; ++x) {
		// 'tp_channel': id=6, encoding=lenpfx, tag=0x32
		put.push_back(0x32);	// 'tp_channel': id=6
		send_varint(put,m_tp_channel[x].calcSize());
		m_tp_channel[x].toString(put);
	}
	#endif // CONFIG_TOUCHPAD
	for (size_t x = 0, y = m_gpios.size(); x != y; ++x) {
		// 'gpios': id=7, encoding=lenpfx, tag=0x3a
		put.push_back(0x3a);	// 'gpios': id=7
		send_varint(put,m_gpios[x].calcSize());
		m_gpios[x].toString(put);
	}
	#ifdef CONFIG_SPI
	for (size_t x = 0, y = m_spibus.size(); x != y; ++x) {
		// 'spibus': id=8, encoding=lenpfx, tag=0x42
		put.push_back(0x42);	// 'spibus': id=8
		send_varint(put,m_spibus[x].calcSize());
		m_spibus[x].toString(put);
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	for (size_t x = 0, y = m_button.size(); x != y; ++x) {
		// 'button': id=16, encoding=lenpfx, tag=0x82
		put.push_back(0x82);
		put.push_back(0x1);
		send_varint(put,m_button[x].calcSize());
		m_button[x].toString(put);
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	for (size_t x = 0, y = m_relay.size(); x != y; ++x) {
		// 'relay': id=17, encoding=lenpfx, tag=0x8a
		put.push_back(0x8a);
		put.push_back(0x1);
		send_varint(put,m_relay[x].calcSize());
		m_relay[x].toString(put);
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	for (size_t x = 0, y = m_led.size(); x != y; ++x) {
		// 'led': id=18, encoding=lenpfx, tag=0x92
		put.push_back(0x92);
		put.push_back(0x1);
		send_varint(put,m_led[x].calcSize());
		m_led[x].toString(put);
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_HLW8012
	if (0 != (p_validbits & ((uint16_t)1U << 4))) {
		// 'hlw8012': id=20, encoding=lenpfx, tag=0xa2
		put.push_back(0xa2);
		put.push_back(0x1);
		send_varint(put,m_hlw8012.calcSize());
		m_hlw8012.toString(put);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (0 != (p_validbits & ((uint16_t)1U << 5))) {
		// 'max7219': id=32, encoding=lenpfx, tag=0x102
		put.push_back(0x82);
		put.push_back(0x2);
		send_varint(put,m_max7219.calcSize());
		m_max7219.toString(put);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (0 != (p_validbits & ((uint16_t)1U << 6))) {
		// 'tlc5947': id=33, encoding=lenpfx, tag=0x10a
		put.push_back(0x8a);
		put.push_back(0x2);
		send_varint(put,m_tlc5947.calcSize());
		m_tlc5947.toString(put);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	for (size_t x = 0, y = m_ws2812b.size(); x != y; ++x) {
		// 'ws2812b': id=34, encoding=lenpfx, tag=0x112
		put.push_back(0x92);
		put.push_back(0x2);
		send_varint(put,m_ws2812b[x].calcSize());
		m_ws2812b[x].toString(put);
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (0 != (p_validbits & ((uint16_t)1U << 7))) {
		// 'dht': id=35, encoding=lenpfx, tag=0x11a
		put.push_back(0x9a);
		put.push_back(0x2);
		send_varint(put,m_dht.calcSize());
		m_dht.toString(put);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	for (size_t x = 0, y = m_i2c.size(); x != y; ++x) {
		// 'i2c': id=36, encoding=lenpfx, tag=0x122
		put.push_back(0xa2);
		put.push_back(0x2);
		send_varint(put,m_i2c[x].calcSize());
		m_i2c[x].toString(put);
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	for (size_t x = 0, y = m_hcsr04.size(); x != y; ++x) {
		// 'hcsr04': id=37, encoding=lenpfx, tag=0x12a
		put.push_back(0xaa);
		put.push_back(0x2);
		send_varint(put,m_hcsr04[x].calcSize());
		m_hcsr04[x].toString(put);
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (0 != (p_validbits & ((uint16_t)1U << 8))) {
		// 'onewire': id=38, encoding=lenpfx, tag=0x132
		put.push_back(0xb2);
		put.push_back(0x2);
		send_varint(put,m_onewire.calcSize());
		m_onewire.toString(put);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (0 != (p_validbits & ((uint16_t)1U << 9))) {
		// 'sx1276': id=39, encoding=lenpfx, tag=0x13a
		put.push_back(0xba);
		put.push_back(0x2);
		send_varint(put,m_sx1276.calcSize());
		m_sx1276.toString(put);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	for (size_t x = 0, y = m_iocluster.size(); x != y; ++x) {
		// 'iocluster': id=40, encoding=lenpfx, tag=0x142
		put.push_back(0xc2);
		put.push_back(0x2);
		send_varint(put,m_iocluster[x].calcSize());
		m_iocluster[x].toString(put);
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (0 != (p_validbits & ((uint16_t)1U << 10))) {
		// 'display': id=50, encoding=lenpfx, tag=0x192
		put.push_back(0x92);
		put.push_back(0x3);
		send_varint(put,m_display.calcSize());
		m_display.toString(put);
	}
	#endif // CONFIG_DISPLAY
}

void HardwareConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_magic()) {
		fsep = json_indent(json,indLvl,fsep,"magic");
		json << m_magic;
	}
	if (has_system()) {
		fsep = json_indent(json,indLvl,fsep,"system");
		m_system.toJSON(json,indLvl);
	}
	if (size_t s = m_uart.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"uart\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_uart[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (has_adc()) {
		fsep = json_indent(json,indLvl,fsep,"adc");
		m_adc.toJSON(json,indLvl);
	}
	#ifdef CONFIG_TOUCHPAD
	if (has_touchpad()) {
		fsep = json_indent(json,indLvl,fsep,"touchpad");
		m_touchpad.toJSON(json,indLvl);
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	if (size_t s = m_tp_channel.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"tp_channel\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_tp_channel[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_TOUCHPAD
	if (size_t s = m_gpios.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"gpios\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_gpios[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_SPI
	if (size_t s = m_spibus.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"spibus\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_spibus[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (size_t s = m_button.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"button\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_button[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (size_t s = m_relay.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"relay\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_relay[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (size_t s = m_led.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"led\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_led[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_HLW8012
	if (has_hlw8012()) {
		fsep = json_indent(json,indLvl,fsep,"hlw8012");
		m_hlw8012.toJSON(json,indLvl);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (has_max7219()) {
		fsep = json_indent(json,indLvl,fsep,"max7219");
		m_max7219.toJSON(json,indLvl);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (has_tlc5947()) {
		fsep = json_indent(json,indLvl,fsep,"tlc5947");
		m_tlc5947.toJSON(json,indLvl);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (size_t s = m_ws2812b.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"ws2812b\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_ws2812b[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (has_dht()) {
		fsep = json_indent(json,indLvl,fsep,"dht");
		m_dht.toJSON(json,indLvl);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (size_t s = m_i2c.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"i2c\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_i2c[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (size_t s = m_hcsr04.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"hcsr04\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_hcsr04[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (has_onewire()) {
		fsep = json_indent(json,indLvl,fsep,"onewire");
		m_onewire.toJSON(json,indLvl);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (has_sx1276()) {
		fsep = json_indent(json,indLvl,fsep,"sx1276");
		m_sx1276.toJSON(json,indLvl);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (size_t s = m_iocluster.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"iocluster\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_iocluster[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (has_display()) {
		fsep = json_indent(json,indLvl,fsep,"display");
		m_display.toJSON(json,indLvl);
	}
	#endif // CONFIG_DISPLAY
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t HardwareConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed32 magic, id 0
	if (0 != (p_validbits & ((uint16_t)1U << 0))) {
		r += 5;
	}
	// optional SystemConfig system, id 1
	if (0 != (p_validbits & ((uint16_t)1U << 1))) {
		size_t system_s = m_system.calcSize();
		r += system_s + wiresize(system_s) + 1 /* tag(system) 0x8 */;
	}
	// repeated UartConfig uart, id 3
	// repeated message uart
	for (size_t x = 0, y = m_uart.size(); x < y; ++x) {
		size_t s = m_uart[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(uart) 0x18 */;
	}
	// optional AdcConfig adc, id 4
	if (0 != (p_validbits & ((uint16_t)1U << 2))) {
		size_t adc_s = m_adc.calcSize();
		r += adc_s + wiresize(adc_s) + 1 /* tag(adc) 0x20 */;
	}
	#ifdef CONFIG_TOUCHPAD
	// optional TouchpadConfig touchpad, id 5
	if (0 != (p_validbits & ((uint16_t)1U << 3))) {
		size_t touchpad_s = m_touchpad.calcSize();
		r += touchpad_s + wiresize(touchpad_s) + 1 /* tag(touchpad) 0x28 */;
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	// repeated TouchChannelConfig tp_channel, id 6
	// repeated message tp_channel
	for (size_t x = 0, y = m_tp_channel.size(); x < y; ++x) {
		size_t s = m_tp_channel[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(tp_channel) 0x30 */;
	}
	#endif // CONFIG_TOUCHPAD
	// repeated GpioConfig gpios, id 7
	// repeated message gpios
	for (size_t x = 0, y = m_gpios.size(); x < y; ++x) {
		size_t s = m_gpios[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(gpios) 0x38 */;
	}
	#ifdef CONFIG_SPI
	// repeated SpiBusConfig spibus, id 8
	// repeated message spibus
	for (size_t x = 0, y = m_spibus.size(); x < y; ++x) {
		size_t s = m_spibus[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(spibus) 0x40 */;
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	// repeated ButtonConfig button, id 16
	// repeated message button
	for (size_t x = 0, y = m_button.size(); x < y; ++x) {
		size_t s = m_button[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(button) 0x80 */;
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	// repeated RelayConfig relay, id 17
	// repeated message relay
	for (size_t x = 0, y = m_relay.size(); x < y; ++x) {
		size_t s = m_relay[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(relay) 0x88 */;
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	// repeated LedConfig led, id 18
	// repeated message led
	for (size_t x = 0, y = m_led.size(); x < y; ++x) {
		size_t s = m_led[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(led) 0x90 */;
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_HLW8012
	// optional Hlw8012Config hlw8012, id 20
	if (0 != (p_validbits & ((uint16_t)1U << 4))) {
		size_t hlw8012_s = m_hlw8012.calcSize();
		r += hlw8012_s + wiresize(hlw8012_s) + 2 /* tag(hlw8012) 0xa0 */;
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	// optional Max7219Config max7219, id 32
	if (0 != (p_validbits & ((uint16_t)1U << 5))) {
		size_t max7219_s = m_max7219.calcSize();
		r += max7219_s + wiresize(max7219_s) + 2 /* tag(max7219) 0x100 */;
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	// optional Tlc5947Config tlc5947, id 33
	if (0 != (p_validbits & ((uint16_t)1U << 6))) {
		size_t tlc5947_s = m_tlc5947.calcSize();
		r += tlc5947_s + wiresize(tlc5947_s) + 2 /* tag(tlc5947) 0x108 */;
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	// repeated Ws2812bConfig ws2812b, id 34
	// repeated message ws2812b
	for (size_t x = 0, y = m_ws2812b.size(); x < y; ++x) {
		size_t s = m_ws2812b[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(ws2812b) 0x110 */;
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	// optional DhtConfig dht, id 35
	if (0 != (p_validbits & ((uint16_t)1U << 7))) {
		size_t dht_s = m_dht.calcSize();
		r += dht_s + wiresize(dht_s) + 2 /* tag(dht) 0x118 */;
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	// repeated I2CConfig i2c, id 36
	// repeated message i2c
	for (size_t x = 0, y = m_i2c.size(); x < y; ++x) {
		size_t s = m_i2c[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(i2c) 0x120 */;
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	// repeated HcSr04Config hcsr04, id 37
	// repeated message hcsr04
	for (size_t x = 0, y = m_hcsr04.size(); x < y; ++x) {
		size_t s = m_hcsr04[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(hcsr04) 0x128 */;
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	// optional OneWireConfig onewire, id 38
	if (0 != (p_validbits & ((uint16_t)1U << 8))) {
		size_t onewire_s = m_onewire.calcSize();
		r += onewire_s + wiresize(onewire_s) + 2 /* tag(onewire) 0x130 */;
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	// optional SX1276Config sx1276, id 39
	if (0 != (p_validbits & ((uint16_t)1U << 9))) {
		size_t sx1276_s = m_sx1276.calcSize();
		r += sx1276_s + wiresize(sx1276_s) + 2 /* tag(sx1276) 0x138 */;
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	// repeated GpioCluster iocluster, id 40
	// repeated message iocluster
	for (size_t x = 0, y = m_iocluster.size(); x < y; ++x) {
		size_t s = m_iocluster[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(iocluster) 0x140 */;
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	// optional DisplayConfig display, id 50
	if (0 != (p_validbits & ((uint16_t)1U << 10))) {
		size_t display_s = m_display.calcSize();
		r += display_s + wiresize(display_s) + 2 /* tag(display) 0x190 */;
	}
	#endif // CONFIG_DISPLAY
	return r;
}

bool HardwareConfig::operator != (const HardwareConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_magic() && (m_magic != r.m_magic))
		return true;
	if (has_system() && (m_system != r.m_system))
		return true;
	if (m_uart != r.m_uart)
		return true;
	if (has_adc() && (m_adc != r.m_adc))
		return true;
	#ifdef CONFIG_TOUCHPAD
	if (has_touchpad() && (m_touchpad != r.m_touchpad))
		return true;
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	if (m_tp_channel != r.m_tp_channel)
		return true;
	#endif // CONFIG_TOUCHPAD
	if (m_gpios != r.m_gpios)
		return true;
	#ifdef CONFIG_SPI
	if (m_spibus != r.m_spibus)
		return true;
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (m_button != r.m_button)
		return true;
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (m_relay != r.m_relay)
		return true;
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (m_led != r.m_led)
		return true;
	#endif // CONFIG_LEDS
	#ifdef CONFIG_HLW8012
	if (has_hlw8012() && (m_hlw8012 != r.m_hlw8012))
		return true;
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (has_max7219() && (m_max7219 != r.m_max7219))
		return true;
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (has_tlc5947() && (m_tlc5947 != r.m_tlc5947))
		return true;
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (m_ws2812b != r.m_ws2812b)
		return true;
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (has_dht() && (m_dht != r.m_dht))
		return true;
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (m_i2c != r.m_i2c)
		return true;
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (m_hcsr04 != r.m_hcsr04)
		return true;
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (has_onewire() && (m_onewire != r.m_onewire))
		return true;
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (has_sx1276() && (m_sx1276 != r.m_sx1276))
		return true;
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (m_iocluster != r.m_iocluster)
		return true;
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (has_display() && (m_display != r.m_display))
		return true;
	#endif // CONFIG_DISPLAY
	return false;
}


bool HardwareConfig::operator == (const HardwareConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int HardwareConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"magic")) {
		if (value == 0) {
			clear_magic();
			return 0;
		}
		int r = parse_ascii_u32(&m_magic,value);
		if (r > 0)
			p_validbits |= ((uint16_t)1U << 0);
		return r;
	}
	if (0 == memcmp(name,"system",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_system();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 1);
			return m_system.setByName(name+7,value);
		}
	}
	if (0 == memcmp(name,"uart",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_uart();
			return 0;
		} else if (name[4] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[5] == '+') && (name[6] == ']')) {
				x = m_uart.size();
				m_uart.resize(x+1);
				idxe = (char*)(name + 6);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+5,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+5)))
					return -553;
				if (m_uart.size() <= x)
					return -554;
				if ((idxe[1] == 0) && (value == 0)) {
					m_uart.erase(m_uart.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -555;
			return m_uart[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"adc",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_adc();
			return 0;
		} else if (name[3] == '.') {
			p_validbits |= ((uint16_t)1U << 2);
			return m_adc.setByName(name+4,value);
		}
	}
	#ifdef CONFIG_TOUCHPAD
	if (0 == memcmp(name,"touchpad",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_touchpad();
			return 0;
		} else if (name[8] == '.') {
			p_validbits |= ((uint16_t)1U << 3);
			return m_touchpad.setByName(name+9,value);
		}
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	if (0 == memcmp(name,"tp_channel",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_tp_channel();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_tp_channel.size();
				m_tp_channel.resize(x+1);
				idxe = (char*)(name + 12);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+11)))
					return -556;
				if (m_tp_channel.size() <= x)
					return -557;
				if ((idxe[1] == 0) && (value == 0)) {
					m_tp_channel.erase(m_tp_channel.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -558;
			return m_tp_channel[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_TOUCHPAD
	if (0 == memcmp(name,"gpios",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_gpios();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_gpios.size();
				m_gpios.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -559;
				if (m_gpios.size() <= x)
					return -560;
				if ((idxe[1] == 0) && (value == 0)) {
					m_gpios.erase(m_gpios.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -561;
			return m_gpios[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_SPI
	if (0 == memcmp(name,"spibus",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_spibus();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_spibus.size();
				m_spibus.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -562;
				if (m_spibus.size() <= x)
					return -563;
				if ((idxe[1] == 0) && (value == 0)) {
					m_spibus.erase(m_spibus.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -564;
			return m_spibus[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (0 == memcmp(name,"button",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_button();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_button.size();
				m_button.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -565;
				if (m_button.size() <= x)
					return -566;
				if ((idxe[1] == 0) && (value == 0)) {
					m_button.erase(m_button.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -567;
			return m_button[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (0 == memcmp(name,"relay",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_relay();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_relay.size();
				m_relay.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -568;
				if (m_relay.size() <= x)
					return -569;
				if ((idxe[1] == 0) && (value == 0)) {
					m_relay.erase(m_relay.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -570;
			return m_relay[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (0 == memcmp(name,"led",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_led();
			return 0;
		} else if (name[3] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[4] == '+') && (name[5] == ']')) {
				x = m_led.size();
				m_led.resize(x+1);
				idxe = (char*)(name + 5);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+4,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+4)))
					return -571;
				if (m_led.size() <= x)
					return -572;
				if ((idxe[1] == 0) && (value == 0)) {
					m_led.erase(m_led.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -573;
			return m_led[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_HLW8012
	if (0 == memcmp(name,"hlw8012",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_hlw8012();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 4);
			return m_hlw8012.setByName(name+8,value);
		}
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (0 == memcmp(name,"max7219",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_max7219();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 5);
			return m_max7219.setByName(name+8,value);
		}
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (0 == memcmp(name,"tlc5947",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_tlc5947();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 6);
			return m_tlc5947.setByName(name+8,value);
		}
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (0 == memcmp(name,"ws2812b",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_ws2812b();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_ws2812b.size();
				m_ws2812b.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -574;
				if (m_ws2812b.size() <= x)
					return -575;
				if ((idxe[1] == 0) && (value == 0)) {
					m_ws2812b.erase(m_ws2812b.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -576;
			return m_ws2812b[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (0 == memcmp(name,"dht",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_dht();
			return 0;
		} else if (name[3] == '.') {
			p_validbits |= ((uint16_t)1U << 7);
			return m_dht.setByName(name+4,value);
		}
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (0 == memcmp(name,"i2c",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_i2c();
			return 0;
		} else if (name[3] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[4] == '+') && (name[5] == ']')) {
				x = m_i2c.size();
				m_i2c.resize(x+1);
				idxe = (char*)(name + 5);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+4,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+4)))
					return -577;
				if (m_i2c.size() <= x)
					return -578;
				if ((idxe[1] == 0) && (value == 0)) {
					m_i2c.erase(m_i2c.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -579;
			return m_i2c[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (0 == memcmp(name,"hcsr04",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_hcsr04();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_hcsr04.size();
				m_hcsr04.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -580;
				if (m_hcsr04.size() <= x)
					return -581;
				if ((idxe[1] == 0) && (value == 0)) {
					m_hcsr04.erase(m_hcsr04.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -582;
			return m_hcsr04[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (0 == memcmp(name,"onewire",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_onewire();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 8);
			return m_onewire.setByName(name+8,value);
		}
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (0 == memcmp(name,"sx1276",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_sx1276();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 9);
			return m_sx1276.setByName(name+7,value);
		}
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (0 == memcmp(name,"iocluster",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_iocluster();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_iocluster.size();
				m_iocluster.resize(x+1);
				idxe = (char*)(name + 11);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+10)))
					return -583;
				if (m_iocluster.size() <= x)
					return -584;
				if ((idxe[1] == 0) && (value == 0)) {
					m_iocluster.erase(m_iocluster.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -585;
			return m_iocluster[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (0 == memcmp(name,"display",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_display();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 10);
			return m_display.setByName(name+8,value);
		}
	}
	#endif // CONFIG_DISPLAY
	return -586;
}

Message *HardwareConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	if ((n == 6) && (0 == memcmp("system",s,6)))
		return &m_system;
	if ((n == 3) && (0 == memcmp("adc",s,3)))
		return &m_adc;
	#ifdef CONFIG_TOUCHPAD
	if ((n == 8) && (0 == memcmp("touchpad",s,8)))
		return &m_touchpad;
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_HLW8012
	if ((n == 7) && (0 == memcmp("hlw8012",s,7)))
		return &m_hlw8012;
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if ((n == 7) && (0 == memcmp("max7219",s,7)))
		return &m_max7219;
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if ((n == 7) && (0 == memcmp("tlc5947",s,7)))
		return &m_tlc5947;
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_DHT
	if ((n == 3) && (0 == memcmp("dht",s,3)))
		return &m_dht;
	#endif // CONFIG_DHT
	#ifdef CONFIG_ONEWIRE
	if ((n == 7) && (0 == memcmp("onewire",s,7)))
		return &m_onewire;
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if ((n == 6) && (0 == memcmp("sx1276",s,6)))
		return &m_sx1276;
	#endif // CONFIG_SX1276
	#ifdef CONFIG_DISPLAY
	if ((n == 7) && (0 == memcmp("display",s,7)))
		return &m_display;
	#endif // CONFIG_DISPLAY
	return 0;
}

Message *HardwareConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	if ((n == 4) && (0 == memcmp("uart",s,4))) {
		if (x < m_uart.size())
			return &m_uart[x];
		#ifdef CONFIG_TOUCHPAD
	} else if ((n == 10) && (0 == memcmp("tp_channel",s,10))) {
		if (x < m_tp_channel.size())
			return &m_tp_channel[x];
		#endif // CONFIG_TOUCHPAD
	} else if ((n == 5) && (0 == memcmp("gpios",s,5))) {
		if (x < m_gpios.size())
			return &m_gpios[x];
		#ifdef CONFIG_SPI
	} else if ((n == 6) && (0 == memcmp("spibus",s,6))) {
		if (x < m_spibus.size())
			return &m_spibus[x];
		#endif // CONFIG_SPI
		#ifdef CONFIG_BUTTON
	} else if ((n == 6) && (0 == memcmp("button",s,6))) {
		if (x < m_button.size())
			return &m_button[x];
		#endif // CONFIG_BUTTON
		#ifdef CONFIG_RELAY
	} else if ((n == 5) && (0 == memcmp("relay",s,5))) {
		if (x < m_relay.size())
			return &m_relay[x];
		#endif // CONFIG_RELAY
		#ifdef CONFIG_LEDS
	} else if ((n == 3) && (0 == memcmp("led",s,3))) {
		if (x < m_led.size())
			return &m_led[x];
		#endif // CONFIG_LEDS
		#ifdef CONFIG_RGBLEDS
	} else if ((n == 7) && (0 == memcmp("ws2812b",s,7))) {
		if (x < m_ws2812b.size())
			return &m_ws2812b[x];
		#endif // CONFIG_RGBLEDS
		#ifdef CONFIG_I2C
	} else if ((n == 3) && (0 == memcmp("i2c",s,3))) {
		if (x < m_i2c.size())
			return &m_i2c[x];
		#endif // CONFIG_I2C
		#ifdef CONFIG_HCSR04
	} else if ((n == 6) && (0 == memcmp("hcsr04",s,6))) {
		if (x < m_hcsr04.size())
			return &m_hcsr04[x];
		#endif // CONFIG_HCSR04
		#ifdef CONFIG_IOEXTENDERS
	} else if ((n == 9) && (0 == memcmp("iocluster",s,9))) {
		if (x < m_iocluster.size())
			return &m_iocluster[x];
		#endif // CONFIG_IOEXTENDERS
	}
	return 0;
}

