/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: P2304.3 (hg:459/5fefa02bc543)
 * WFC is Copyright 2015-2023, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : hwcfg.wfc
 * Copyright: 2018-2023
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2023-11-26, 14:29:43 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from pc:
 * Optimize        : "speed"
 * toASCII         : "toASCII"
 * toSink          : ""
 * 
 * options from common:
 * BaseClass       : "Message"
 * getMember       : "getMember"
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bool      : "ascii_bool"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * bytestype       : "std::string"
 * calcSize        : "calcSize"
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * copyright       : ""
 * email           : ""
 * endian          : "unknown"
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * IntSize         : 64
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * SortMembers     : "id"
 * stringtype      : "std::string"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * toString        : "toString"
 * toWire          : "toWire"
 * UnknownField    : "skip"
 * VarIntBits      : 64
 * wireput         : ""
 * wiresize        : ""
 * 
 * enabled flags from commandline:
 * 	enumnames
 * enabled flags from pc:
 * 	enummap
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux, withEqual, withUnequal
 */

#ifndef HWCFG_H
#define HWCFG_H

#include <assert.h>
#define OUTPUT_TO_ASCII 1
#include <iosfwd>
#include <ostream>
#include <string>
#include <map>
#include <vector>
/* array support not needed */
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>

/* user requested header files */
#include "pcconfig.h"
#include "support.h"
#ifdef WFC_ENDIAN
#if WFC_ENDIAN != 0
#error WFC generated code incompatible due to endian
#endif
#else
#define WFC_ENDIAN     0 // unknown endian
#endif

#define HAVE_TO_MEMORY 1
#define HAVE_TO_STRING 1
#define HAVE_TO_WIRE 1
#define HAVE_TO_ASCII 1
#define HAVE_TO_JSON 1
#define HAVE_GET_MEMBER 1
#define HAVE_FROM_MEMORY 1
#define ON_ERROR_CANCEL 1
#define HAVE_ENUM_MAP 1
#define HAVE_ENUM_NAMES 1

#include "wfccore.h"
/* wfc support functions not needed */

typedef uint64_t varint_t;

typedef int64_t varsint_t;


typedef enum {
	pull_none = 0,
	pull_en = 1,
	pull_down = 1,
	pull_dir = 2,
	pull_up = 3,
} pull_mode_e;
//! Function to get an ASCII string from a value of a pull_mode_e.
const char *pull_mode_e_str(pull_mode_e e);
//! Function to parse the value of pull_mode_e from an ASCII string.
size_t parse_ascii_pull_mode_e(pull_mode_e *, const char *);

typedef enum {
	DHT_NONE = 0,
	RHT03 = 3,
	DHT11 = 11,
	DHT21 = 21,
	DHT22 = 22,
	AM2301 = 2301,
	AM2302 = 2302,
} dht_model_t;
//! Function to get an ASCII string from a value of a dht_model_t.
const char *dht_model_t_str(dht_model_t e);
//! Function to parse the value of dht_model_t from an ASCII string.
size_t parse_ascii_dht_model_t(dht_model_t *, const char *);

typedef enum {
	i2cdrv_invalid = 0,
	i2cdrv_pcf8574 = 1,
	i2cdrv_mcp2300x = 2,
	i2cdrv_mcp2301x = 3,
	i2cdrv_pca9685 = 4,
	i2cdrv_pca9685_npn = 5,
	i2cdrv_pca9685_pnp = 6,
	i2cdrv_pca9685_xclk = 7,
	i2cdrv_pca9685_xclk_npn = 8,
	i2cdrv_pca9685_xclk_pnp = 9,
	i2cdrv_ht16k33 = 10,
	i2cdrv_ina219 = 11,
	i2cdrv_si7021 = 12,
	i2cdrv_tca9555 = 13,
	i2cdrv_ssd1306 = 14,
	i2cdrv_sh1106 = 15,
} i2cdrv_t;
//! Function to get an ASCII string from a value of a i2cdrv_t.
const char *i2cdrv_t_str(i2cdrv_t e);
//! Function to parse the value of i2cdrv_t from an ASCII string.
size_t parse_ascii_i2cdrv_t(i2cdrv_t *, const char *);

typedef enum {
	dt_none = 0,
	dt_sd_7seg = 1,
	dt_sd_14seg = 2,
	dt_pcf8574_hd44780u = 16,
	dt_ssd1306 = 32,
	dt_ssd1309 = 33,
	dt_sh1106 = 34,
	dt_ili9341 = 64,
} disp_t;
//! Function to get an ASCII string from a value of a disp_t.
const char *disp_t_str(disp_t e);
//! Function to parse the value of disp_t from an ASCII string.
size_t parse_ascii_disp_t(disp_t *, const char *);

typedef enum {
	spidrv_invalid = 0,
	spidrv_sx1276 = 1,
	spidrv_ssd1309 = 2,
	spidrv_ili9341 = 3,
	spidrv_xpt2046 = 4,
	spidrv_sdcard = 5,
} spidrv_t;
//! Function to get an ASCII string from a value of a spidrv_t.
const char *spidrv_t_str(spidrv_t e);
//! Function to parse the value of spidrv_t from an ASCII string.
size_t parse_ascii_spidrv_t(spidrv_t *, const char *);

typedef uint8_t pull_mode_t;
typedef uint8_t relay_cfg_t;
typedef uint32_t i2cdev_t;
typedef uint8_t ledcfg_t;
typedef uint16_t gpiocfg_t;
typedef uint8_t spiopt_t;


class SystemConfig : public Message
{
	public:
	SystemConfig()
	{
	}
	
	bool operator != (const SystemConfig &r) const;
	bool operator == (const SystemConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string manufacturer, id 1
	/*!
	* Function for querying if manufacturer has been set.
	* @return true if manufacturer is set.
	*/
	bool has_manufacturer() const;
	//! Function to reset manufacturer to its default/unset value.
	void clear_manufacturer();
	//! Get value of manufacturer.
	const std::string &manufacturer() const;
	/*!
	* Function for setting manufacturer using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_manufacturer(const void *data, size_t s);
	//! Set manufacturer using a constant reference
	void set_manufacturer(const std::string &v);
	//! Set manufacturer using a pointer to a null-terminated C-string.
	void set_manufacturer(const char *);
	/*!
	* Provide mutable access to manufacturer.
	* @return pointer to member variable of manufacturer.
	*/
	std::string *mutable_manufacturer();
	
	// optional string board_name, id 2
	/*!
	* Function for querying if board_name has been set.
	* @return true if board_name is set.
	*/
	bool has_board_name() const;
	//! Function to reset board_name to its default/unset value.
	void clear_board_name();
	//! Get value of board_name.
	const std::string &board_name() const;
	/*!
	* Function for setting board_name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_board_name(const void *data, size_t s);
	//! Set board_name using a constant reference
	void set_board_name(const std::string &v);
	//! Set board_name using a pointer to a null-terminated C-string.
	void set_board_name(const char *);
	/*!
	* Provide mutable access to board_name.
	* @return pointer to member variable of board_name.
	*/
	std::string *mutable_board_name();
	
	// optional string board_rev, id 3
	/*!
	* Function for querying if board_rev has been set.
	* @return true if board_rev is set.
	*/
	bool has_board_rev() const;
	//! Function to reset board_rev to its default/unset value.
	void clear_board_rev();
	//! Get value of board_rev.
	const std::string &board_rev() const;
	/*!
	* Function for setting board_rev using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_board_rev(const void *data, size_t s);
	//! Set board_rev using a constant reference
	void set_board_rev(const std::string &v);
	//! Set board_rev using a pointer to a null-terminated C-string.
	void set_board_rev(const char *);
	/*!
	* Provide mutable access to board_rev.
	* @return pointer to member variable of board_rev.
	*/
	std::string *mutable_board_rev();
	
	// optional sint8 diag_uart, id 4
	/*!
	* Function for querying if diag_uart has been set.
	* @return true if diag_uart is set.
	*/
	bool has_diag_uart() const;
	//! Function to reset diag_uart to its default/unset value.
	void clear_diag_uart();
	//! Get value of diag_uart.
	int8_t diag_uart() const;
	//! Set diag_uart using a constant reference
	void set_diag_uart(int8_t v);
	/*!
	* Provide mutable access to diag_uart.
	* @return pointer to member variable of diag_uart.
	*/
	int8_t *mutable_diag_uart();
	
	// optional sint8 console_rx, id 5
	/*!
	* Function for querying if console_rx has been set.
	* @return true if console_rx is set.
	*/
	bool has_console_rx() const;
	//! Function to reset console_rx to its default/unset value.
	void clear_console_rx();
	//! Get value of console_rx.
	int8_t console_rx() const;
	//! Set console_rx using a constant reference
	void set_console_rx(int8_t v);
	/*!
	* Provide mutable access to console_rx.
	* @return pointer to member variable of console_rx.
	*/
	int8_t *mutable_console_rx();
	
	// optional sint8 console_tx, id 6
	/*!
	* Function for querying if console_tx has been set.
	* @return true if console_tx is set.
	*/
	bool has_console_tx() const;
	//! Function to reset console_tx to its default/unset value.
	void clear_console_tx();
	//! Get value of console_tx.
	int8_t console_tx() const;
	//! Set console_tx using a constant reference
	void set_console_tx(int8_t v);
	/*!
	* Provide mutable access to console_tx.
	* @return pointer to member variable of console_tx.
	*/
	int8_t *mutable_console_tx();
	
	// optional string model_name, id 7
	/*!
	* Function for querying if model_name has been set.
	* @return true if model_name is set.
	*/
	bool has_model_name() const;
	//! Function to reset model_name to its default/unset value.
	void clear_model_name();
	//! Get value of model_name.
	const std::string &model_name() const;
	/*!
	* Function for setting model_name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_model_name(const void *data, size_t s);
	//! Set model_name using a constant reference
	void set_model_name(const std::string &v);
	//! Set model_name using a pointer to a null-terminated C-string.
	void set_model_name(const char *);
	/*!
	* Provide mutable access to model_name.
	* @return pointer to member variable of model_name.
	*/
	std::string *mutable_model_name();
	
	// optional string model_number, id 8
	/*!
	* Function for querying if model_number has been set.
	* @return true if model_number is set.
	*/
	bool has_model_number() const;
	//! Function to reset model_number to its default/unset value.
	void clear_model_number();
	//! Get value of model_number.
	const std::string &model_number() const;
	/*!
	* Function for setting model_number using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_model_number(const void *data, size_t s);
	//! Set model_number using a constant reference
	void set_model_number(const std::string &v);
	//! Set model_number using a pointer to a null-terminated C-string.
	void set_model_number(const char *);
	/*!
	* Provide mutable access to model_number.
	* @return pointer to member variable of model_number.
	*/
	std::string *mutable_model_number();
	
	#ifdef CONFIG_USB_DIAGLOG
	// optional bool usb_diag, id 9
	/*!
	* Function for querying if usb_diag has been set.
	* @return true if usb_diag is set.
	*/
	bool has_usb_diag() const;
	//! Function to reset usb_diag to its default/unset value.
	void clear_usb_diag();
	//! Get value of usb_diag.
	bool usb_diag() const;
	//! Set usb_diag using a constant reference
	void set_usb_diag(bool v);
	/*!
	* Provide mutable access to usb_diag.
	* @return pointer to member variable of usb_diag.
	*/
	bool *mutable_usb_diag();
	#endif // CONFIG_USB_DIAGLOG
	
	#ifdef CONFIG_USB_CONSOLE
	// optional bool usb_con, id 10
	/*!
	* Function for querying if usb_con has been set.
	* @return true if usb_con is set.
	*/
	bool has_usb_con() const;
	//! Function to reset usb_con to its default/unset value.
	void clear_usb_con();
	//! Get value of usb_con.
	bool usb_con() const;
	//! Set usb_con using a constant reference
	void set_usb_con(bool v);
	/*!
	* Provide mutable access to usb_con.
	* @return pointer to member variable of usb_con.
	*/
	bool *mutable_usb_con();
	#endif // CONFIG_USB_CONSOLE
	
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// optional sint8 cc1_gpio, id 11
	/*!
	* Function for querying if cc1_gpio has been set.
	* @return true if cc1_gpio is set.
	*/
	bool has_cc1_gpio() const;
	//! Function to reset cc1_gpio to its default/unset value.
	void clear_cc1_gpio();
	//! Get value of cc1_gpio.
	int8_t cc1_gpio() const;
	//! Set cc1_gpio using a constant reference
	void set_cc1_gpio(int8_t v);
	/*!
	* Provide mutable access to cc1_gpio.
	* @return pointer to member variable of cc1_gpio.
	*/
	int8_t *mutable_cc1_gpio();
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// optional sint8 cc2_gpio, id 12
	/*!
	* Function for querying if cc2_gpio has been set.
	* @return true if cc2_gpio is set.
	*/
	bool has_cc2_gpio() const;
	//! Function to reset cc2_gpio to its default/unset value.
	void clear_cc2_gpio();
	//! Get value of cc2_gpio.
	int8_t cc2_gpio() const;
	//! Set cc2_gpio using a constant reference
	void set_cc2_gpio(int8_t v);
	/*!
	* Provide mutable access to cc2_gpio.
	* @return pointer to member variable of cc2_gpio.
	*/
	int8_t *mutable_cc2_gpio();
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string manufacturer, id 1
	std::string m_manufacturer;
	//! string board_name, id 2
	std::string m_board_name;
	//! string board_rev, id 3
	std::string m_board_rev;
	//! sint8 diag_uart, id 4
	int8_t m_diag_uart = 0;
	//! sint8 console_rx, id 5
	int8_t m_console_rx = 0;
	//! sint8 console_tx, id 6
	int8_t m_console_tx = 0;
	//! string model_name, id 7
	std::string m_model_name;
	//! string model_number, id 8
	std::string m_model_number;
	#ifdef CONFIG_USB_DIAGLOG
	//! bool usb_diag, id 9
	bool m_usb_diag = true;
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	//! bool usb_con, id 10
	bool m_usb_con = true;
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	//! sint8 cc1_gpio, id 11
	int8_t m_cc1_gpio = -1;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	//! sint8 cc2_gpio, id 12
	int8_t m_cc2_gpio = -1;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	
	private:
	uint8_t p_validbits = 0;
};




class TouchpadConfig : public Message
{
	public:
	TouchpadConfig()
	{
	}
	
	bool operator != (const TouchpadConfig &r) const;
	bool operator == (const TouchpadConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional bool fsm_mode, id 1
	/*!
	* Function for querying if fsm_mode has been set.
	* @return true if fsm_mode is set.
	*/
	bool has_fsm_mode() const;
	//! Function to reset fsm_mode to its default/unset value.
	void clear_fsm_mode();
	//! Get value of fsm_mode.
	bool fsm_mode() const;
	//! Set fsm_mode using a constant reference
	void set_fsm_mode(bool v);
	/*!
	* Provide mutable access to fsm_mode.
	* @return pointer to member variable of fsm_mode.
	*/
	bool *mutable_fsm_mode();
	
	// optional sint8 lvolt, id 2
	/*!
	* Function for querying if lvolt has been set.
	* @return true if lvolt is set.
	*/
	bool has_lvolt() const;
	//! Function to reset lvolt to its default/unset value.
	void clear_lvolt();
	//! Get value of lvolt.
	int8_t lvolt() const;
	//! Set lvolt using a constant reference
	void set_lvolt(int8_t v);
	/*!
	* Provide mutable access to lvolt.
	* @return pointer to member variable of lvolt.
	*/
	int8_t *mutable_lvolt();
	
	// optional sint8 hvolt, id 3
	/*!
	* Function for querying if hvolt has been set.
	* @return true if hvolt is set.
	*/
	bool has_hvolt() const;
	//! Function to reset hvolt to its default/unset value.
	void clear_hvolt();
	//! Get value of hvolt.
	int8_t hvolt() const;
	//! Set hvolt using a constant reference
	void set_hvolt(int8_t v);
	/*!
	* Provide mutable access to hvolt.
	* @return pointer to member variable of hvolt.
	*/
	int8_t *mutable_hvolt();
	
	// optional sint8 atten, id 4
	/*!
	* Function for querying if atten has been set.
	* @return true if atten is set.
	*/
	bool has_atten() const;
	//! Function to reset atten to its default/unset value.
	void clear_atten();
	//! Get value of atten.
	int8_t atten() const;
	//! Set atten using a constant reference
	void set_atten(int8_t v);
	/*!
	* Provide mutable access to atten.
	* @return pointer to member variable of atten.
	*/
	int8_t *mutable_atten();
	
	// optional unsigned interval, id 7
	/*!
	* Function for querying if interval has been set.
	* @return true if interval is set.
	*/
	bool has_interval() const;
	//! Function to reset interval to its default/unset value.
	void clear_interval();
	//! Get value of interval.
	uint64_t interval() const;
	//! Set interval using a constant reference
	void set_interval(uint64_t v);
	/*!
	* Provide mutable access to interval.
	* @return pointer to member variable of interval.
	*/
	uint64_t *mutable_interval();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! bool fsm_mode, id 1
	bool m_fsm_mode = false;
	//! sint8 lvolt, id 2
	int8_t m_lvolt = -1;
	//! sint8 hvolt, id 3
	int8_t m_hvolt = -1;
	//! sint8 atten, id 4
	int8_t m_atten = -1;
	//! unsigned interval, id 7
	uint64_t m_interval = 0;
	
	private:
	uint8_t p_validbits = 0;
};




class TouchChannelConfig : public Message
{
	public:
	TouchChannelConfig()
	{
	}
	
	bool operator != (const TouchChannelConfig &r) const;
	bool operator == (const TouchChannelConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const std::string &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const std::string &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	std::string *mutable_name();
	
	// optional sint8 channel, id 2
	/*!
	* Function for querying if channel has been set.
	* @return true if channel is set.
	*/
	bool has_channel() const;
	//! Function to reset channel to its default/unset value.
	void clear_channel();
	//! Get value of channel.
	int8_t channel() const;
	//! Set channel using a constant reference
	void set_channel(int8_t v);
	/*!
	* Provide mutable access to channel.
	* @return pointer to member variable of channel.
	*/
	int8_t *mutable_channel();
	
	// optional fixed16 threshold, id 3
	/*!
	* Function for querying if threshold has been set.
	* @return true if threshold is set.
	*/
	bool has_threshold() const;
	//! Function to reset threshold to its default/unset value.
	void clear_threshold();
	//! Get value of threshold.
	uint16_t threshold() const;
	//! Set threshold using a constant reference
	void set_threshold(uint16_t v);
	/*!
	* Provide mutable access to threshold.
	* @return pointer to member variable of threshold.
	*/
	uint16_t *mutable_threshold();
	
	// optional uint8 slope, id 4
	/*!
	* Function for querying if slope has been set.
	* @return true if slope is set.
	*/
	bool has_slope() const;
	//! Function to reset slope to its default/unset value.
	void clear_slope();
	//! Get value of slope.
	uint8_t slope() const;
	//! Set slope using a constant reference
	void set_slope(uint8_t v);
	/*!
	* Provide mutable access to slope.
	* @return pointer to member variable of slope.
	*/
	uint8_t *mutable_slope();
	
	// optional uint8 tieopt, id 5
	/*!
	* Function for querying if tieopt has been set.
	* @return true if tieopt is set.
	*/
	bool has_tieopt() const;
	//! Function to reset tieopt to its default/unset value.
	void clear_tieopt();
	//! Get value of tieopt.
	uint8_t tieopt() const;
	//! Set tieopt using a constant reference
	void set_tieopt(uint8_t v);
	/*!
	* Provide mutable access to tieopt.
	* @return pointer to member variable of tieopt.
	*/
	uint8_t *mutable_tieopt();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	std::string m_name;
	//! sint8 channel, id 2
	int8_t m_channel = -1;
	//! fixed16 threshold, id 3
	uint16_t m_threshold = 0;
	//! uint8 slope, id 4
	uint8_t m_slope = 0;
	//! uint8 tieopt, id 5
	uint8_t m_tieopt = 0;
	
	private:
	uint8_t p_validbits = 0;
};




class ButtonConfig : public Message
{
	public:
	ButtonConfig()
	{
	}
	
	bool operator != (const ButtonConfig &r) const;
	bool operator == (const ButtonConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const std::string &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const std::string &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	std::string *mutable_name();
	
	// optional sint8 gpio, id 2
	/*!
	* Function for querying if gpio has been set.
	* @return true if gpio is set.
	*/
	bool has_gpio() const;
	//! Function to reset gpio to its default/unset value.
	void clear_gpio();
	//! Get value of gpio.
	int8_t gpio() const;
	//! Set gpio using a constant reference
	void set_gpio(int8_t v);
	/*!
	* Provide mutable access to gpio.
	* @return pointer to member variable of gpio.
	*/
	int8_t *mutable_gpio();
	
	// optional bool presslvl, id 3
	/*!
	* Function for querying if presslvl has been set.
	* @return true if presslvl is set.
	*/
	bool has_presslvl() const;
	//! Function to reset presslvl to its default/unset value.
	void clear_presslvl();
	//! Get value of presslvl.
	bool presslvl() const;
	//! Set presslvl using a constant reference
	void set_presslvl(bool v);
	/*!
	* Provide mutable access to presslvl.
	* @return pointer to member variable of presslvl.
	*/
	bool *mutable_presslvl();
	
	// optional pull_mode_t pull_mode, id 4
	/*!
	* Function for querying if pull_mode has been set.
	* @return true if pull_mode is set.
	*/
	bool has_pull_mode() const;
	//! Function to reset pull_mode to its default/unset value.
	void clear_pull_mode();
	//! Get value of pull_mode.
	pull_mode_t pull_mode() const;
	//! Function to get the enable part of bitset pull_mode.
	bool pull_mode_enable() const;
	//! Function to set the enable part of bitset pull_mode.
	void set_pull_mode_enable(bool);
	//! Function to get the up part of bitset pull_mode.
	bool pull_mode_up() const;
	//! Function to set the up part of bitset pull_mode.
	void set_pull_mode_up(bool);
	//! Set pull_mode using a constant reference
	void set_pull_mode(pull_mode_t v);
	/*!
	* Provide mutable access to pull_mode.
	* @return pointer to member variable of pull_mode.
	*/
	pull_mode_t *mutable_pull_mode();
	
	#ifdef CONFIG_ROTARYENCODER
	// optional sint8 clk, id 5
	/*!
	* Function for querying if clk has been set.
	* @return true if clk is set.
	*/
	bool has_clk() const;
	//! Function to reset clk to its default/unset value.
	void clear_clk();
	//! Get value of clk.
	int8_t clk() const;
	//! Set clk using a constant reference
	void set_clk(int8_t v);
	/*!
	* Provide mutable access to clk.
	* @return pointer to member variable of clk.
	*/
	int8_t *mutable_clk();
	#endif // CONFIG_ROTARYENCODER
	
	#ifdef CONFIG_ROTARYENCODER
	// optional sint8 dt, id 6
	/*!
	* Function for querying if dt has been set.
	* @return true if dt is set.
	*/
	bool has_dt() const;
	//! Function to reset dt to its default/unset value.
	void clear_dt();
	//! Get value of dt.
	int8_t dt() const;
	//! Set dt using a constant reference
	void set_dt(int8_t v);
	/*!
	* Provide mutable access to dt.
	* @return pointer to member variable of dt.
	*/
	int8_t *mutable_dt();
	#endif // CONFIG_ROTARYENCODER
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	std::string m_name;
	//! sint8 gpio, id 2
	int8_t m_gpio = -1;
	//! bool presslvl, id 3
	bool m_presslvl = 0;
	//! pull_mode_t pull_mode, id 4
	pull_mode_t m_pull_mode = pull_none;
	#ifdef CONFIG_ROTARYENCODER
	//! sint8 clk, id 5
	int8_t m_clk = -1;
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	//! sint8 dt, id 6
	int8_t m_dt = -1;
	#endif // CONFIG_ROTARYENCODER
};




class RelayConfig : public Message
{
	public:
	RelayConfig()
	{
	}
	
	bool operator != (const RelayConfig &r) const;
	bool operator == (const RelayConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const std::string &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const std::string &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	std::string *mutable_name();
	
	// optional sint8 gpio, id 2
	/*!
	* Function for querying if gpio has been set.
	* @return true if gpio is set.
	*/
	bool has_gpio() const;
	//! Function to reset gpio to its default/unset value.
	void clear_gpio();
	//! Get value of gpio.
	int8_t gpio() const;
	//! Set gpio using a constant reference
	void set_gpio(int8_t v);
	/*!
	* Provide mutable access to gpio.
	* @return pointer to member variable of gpio.
	*/
	int8_t *mutable_gpio();
	
	// optional relay_cfg_t config, id 3
	/*!
	* Function for querying if config has been set.
	* @return true if config is set.
	*/
	bool has_config() const;
	//! Function to reset config to its default/unset value.
	void clear_config();
	//! Get value of config.
	relay_cfg_t config() const;
	//! Function to get the active_high part of bitset config.
	bool config_active_high() const;
	//! Function to set the active_high part of bitset config.
	void set_config_active_high(bool);
	//! Function to get the init_on part of bitset config.
	bool config_init_on() const;
	//! Function to set the init_on part of bitset config.
	void set_config_init_on(bool);
	//! Function to get the persistent part of bitset config.
	bool config_persistent() const;
	//! Function to set the persistent part of bitset config.
	void set_config_persistent(bool);
	//! Function to get the opendrain part of bitset config.
	bool config_opendrain() const;
	//! Function to set the opendrain part of bitset config.
	void set_config_opendrain(bool);
	//! Function to get the mqtt part of bitset config.
	bool config_mqtt() const;
	//! Function to set the mqtt part of bitset config.
	void set_config_mqtt(bool);
	//! Set config using a constant reference
	void set_config(relay_cfg_t v);
	/*!
	* Provide mutable access to config.
	* @return pointer to member variable of config.
	*/
	relay_cfg_t *mutable_config();
	
	// optional unsigned min_itv, id 4
	/*!
	* Function for querying if min_itv has been set.
	* @return true if min_itv is set.
	*/
	bool has_min_itv() const;
	//! Function to reset min_itv to its default/unset value.
	void clear_min_itv();
	//! Get value of min_itv.
	uint64_t min_itv() const;
	//! Set min_itv using a constant reference
	void set_min_itv(uint64_t v);
	/*!
	* Provide mutable access to min_itv.
	* @return pointer to member variable of min_itv.
	*/
	uint64_t *mutable_min_itv();
	
	// optional sint8 interlock, id 5
	/*!
	* Function for querying if interlock has been set.
	* @return true if interlock is set.
	*/
	bool has_interlock() const;
	//! Function to reset interlock to its default/unset value.
	void clear_interlock();
	//! Get value of interlock.
	int8_t interlock() const;
	//! Set interlock using a constant reference
	void set_interlock(int8_t v);
	/*!
	* Provide mutable access to interlock.
	* @return pointer to member variable of interlock.
	*/
	int8_t *mutable_interlock();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	std::string m_name;
	//! sint8 gpio, id 2
	int8_t m_gpio = -1;
	//! relay_cfg_t config, id 3
	relay_cfg_t m_config = 0;
	//! unsigned min_itv, id 4
	uint64_t m_min_itv = 0;
	//! sint8 interlock, id 5
	int8_t m_interlock = -1;
	
	private:
	uint8_t p_validbits = 0;
};




class Max7219Config : public Message
{
	public:
	Max7219Config()
	{
	}
	
	bool operator != (const Max7219Config &r) const;
	bool operator == (const Max7219Config &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 clk, id 1
	/*!
	* Function for querying if clk has been set.
	* @return true if clk is set.
	*/
	bool has_clk() const;
	//! Function to reset clk to its default/unset value.
	void clear_clk();
	//! Get value of clk.
	int8_t clk() const;
	//! Set clk using a constant reference
	void set_clk(int8_t v);
	/*!
	* Provide mutable access to clk.
	* @return pointer to member variable of clk.
	*/
	int8_t *mutable_clk();
	
	// optional sint8 dout, id 2
	/*!
	* Function for querying if dout has been set.
	* @return true if dout is set.
	*/
	bool has_dout() const;
	//! Function to reset dout to its default/unset value.
	void clear_dout();
	//! Get value of dout.
	int8_t dout() const;
	//! Set dout using a constant reference
	void set_dout(int8_t v);
	/*!
	* Provide mutable access to dout.
	* @return pointer to member variable of dout.
	*/
	int8_t *mutable_dout();
	
	// optional sint8 cs, id 3
	/*!
	* Function for querying if cs has been set.
	* @return true if cs is set.
	*/
	bool has_cs() const;
	//! Function to reset cs to its default/unset value.
	void clear_cs();
	//! Get value of cs.
	int8_t cs() const;
	//! Set cs using a constant reference
	void set_cs(int8_t v);
	/*!
	* Provide mutable access to cs.
	* @return pointer to member variable of cs.
	*/
	int8_t *mutable_cs();
	
	// optional bool odrain, id 4
	/*!
	* Function for querying if odrain has been set.
	* @return true if odrain is set.
	*/
	bool has_odrain() const;
	//! Function to reset odrain to its default/unset value.
	void clear_odrain();
	//! Get value of odrain.
	bool odrain() const;
	//! Set odrain using a constant reference
	void set_odrain(bool v);
	/*!
	* Provide mutable access to odrain.
	* @return pointer to member variable of odrain.
	*/
	bool *mutable_odrain();
	
	// optional uint8 digits, id 5
	/*!
	* Function for querying if digits has been set.
	* @return true if digits is set.
	*/
	bool has_digits() const;
	//! Function to reset digits to its default/unset value.
	void clear_digits();
	//! Get value of digits.
	uint8_t digits() const;
	//! Set digits using a constant reference
	void set_digits(uint8_t v);
	/*!
	* Provide mutable access to digits.
	* @return pointer to member variable of digits.
	*/
	uint8_t *mutable_digits();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 clk, id 1
	int8_t m_clk = -1;
	//! sint8 dout, id 2
	int8_t m_dout = -1;
	//! sint8 cs, id 3
	int8_t m_cs = -1;
	//! bool odrain, id 4
	bool m_odrain = false;
	//! uint8 digits, id 5
	uint8_t m_digits = 0;
};




class Tlc5947Config : public Message
{
	public:
	Tlc5947Config()
	{
	}
	
	bool operator != (const Tlc5947Config &r) const;
	bool operator == (const Tlc5947Config &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 sin, id 1
	/*!
	* Function for querying if sin has been set.
	* @return true if sin is set.
	*/
	bool has_sin() const;
	//! Function to reset sin to its default/unset value.
	void clear_sin();
	//! Get value of sin.
	int8_t sin() const;
	//! Set sin using a constant reference
	void set_sin(int8_t v);
	/*!
	* Provide mutable access to sin.
	* @return pointer to member variable of sin.
	*/
	int8_t *mutable_sin();
	
	// optional sint8 sclk, id 2
	/*!
	* Function for querying if sclk has been set.
	* @return true if sclk is set.
	*/
	bool has_sclk() const;
	//! Function to reset sclk to its default/unset value.
	void clear_sclk();
	//! Get value of sclk.
	int8_t sclk() const;
	//! Set sclk using a constant reference
	void set_sclk(int8_t v);
	/*!
	* Provide mutable access to sclk.
	* @return pointer to member variable of sclk.
	*/
	int8_t *mutable_sclk();
	
	// optional sint8 xlat, id 3
	/*!
	* Function for querying if xlat has been set.
	* @return true if xlat is set.
	*/
	bool has_xlat() const;
	//! Function to reset xlat to its default/unset value.
	void clear_xlat();
	//! Get value of xlat.
	int8_t xlat() const;
	//! Set xlat using a constant reference
	void set_xlat(int8_t v);
	/*!
	* Provide mutable access to xlat.
	* @return pointer to member variable of xlat.
	*/
	int8_t *mutable_xlat();
	
	// optional sint8 blank, id 4
	/*!
	* Function for querying if blank has been set.
	* @return true if blank is set.
	*/
	bool has_blank() const;
	//! Function to reset blank to its default/unset value.
	void clear_blank();
	//! Get value of blank.
	int8_t blank() const;
	//! Set blank using a constant reference
	void set_blank(int8_t v);
	/*!
	* Provide mutable access to blank.
	* @return pointer to member variable of blank.
	*/
	int8_t *mutable_blank();
	
	// optional uint8 ntlc, id 5
	/*!
	* Function for querying if ntlc has been set.
	* @return true if ntlc is set.
	*/
	bool has_ntlc() const;
	//! Function to reset ntlc to its default/unset value.
	void clear_ntlc();
	//! Get value of ntlc.
	uint8_t ntlc() const;
	//! Set ntlc using a constant reference
	void set_ntlc(uint8_t v);
	/*!
	* Provide mutable access to ntlc.
	* @return pointer to member variable of ntlc.
	*/
	uint8_t *mutable_ntlc();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 sin, id 1
	int8_t m_sin = -1;
	//! sint8 sclk, id 2
	int8_t m_sclk = -1;
	//! sint8 xlat, id 3
	int8_t m_xlat = -1;
	//! sint8 blank, id 4
	int8_t m_blank = -1;
	//! uint8 ntlc, id 5
	uint8_t m_ntlc = 0;
};




class Ws2812bConfig : public Message
{
	public:
	Ws2812bConfig()
	{
	}
	
	bool operator != (const Ws2812bConfig &r) const;
	bool operator == (const Ws2812bConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 gpio, id 1
	/*!
	* Function for querying if gpio has been set.
	* @return true if gpio is set.
	*/
	bool has_gpio() const;
	//! Function to reset gpio to its default/unset value.
	void clear_gpio();
	//! Get value of gpio.
	int8_t gpio() const;
	//! Set gpio using a constant reference
	void set_gpio(int8_t v);
	/*!
	* Provide mutable access to gpio.
	* @return pointer to member variable of gpio.
	*/
	int8_t *mutable_gpio();
	
	// optional sint8 ch, id 2
	/*!
	* Function for querying if ch has been set.
	* @return true if ch is set.
	*/
	bool has_ch() const;
	//! Function to reset ch to its default/unset value.
	void clear_ch();
	//! Get value of ch.
	int8_t ch() const;
	//! Set ch using a constant reference
	void set_ch(int8_t v);
	/*!
	* Provide mutable access to ch.
	* @return pointer to member variable of ch.
	*/
	int8_t *mutable_ch();
	
	// optional uint8 nleds, id 3
	/*!
	* Function for querying if nleds has been set.
	* @return true if nleds is set.
	*/
	bool has_nleds() const;
	//! Function to reset nleds to its default/unset value.
	void clear_nleds();
	//! Get value of nleds.
	uint8_t nleds() const;
	//! Set nleds using a constant reference
	void set_nleds(uint8_t v);
	/*!
	* Provide mutable access to nleds.
	* @return pointer to member variable of nleds.
	*/
	uint8_t *mutable_nleds();
	
	// optional string name, id 4
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const std::string &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const std::string &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	std::string *mutable_name();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 gpio, id 1
	int8_t m_gpio = -1;
	//! sint8 ch, id 2
	int8_t m_ch = -1;
	//! uint8 nleds, id 3
	uint8_t m_nleds = 0;
	//! string name, id 4
	std::string m_name;
};




class DhtConfig : public Message
{
	public:
	DhtConfig()
	{
	}
	
	bool operator != (const DhtConfig &r) const;
	bool operator == (const DhtConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional dht_model_t model, id 1
	/*!
	* Function for querying if model has been set.
	* @return true if model is set.
	*/
	bool has_model() const;
	//! Function to reset model to its default/unset value.
	void clear_model();
	//! Get value of model.
	dht_model_t model() const;
	//! Set model using a constant reference
	void set_model(dht_model_t v);
	/*!
	* Provide mutable access to model.
	* @return pointer to member variable of model.
	*/
	dht_model_t *mutable_model();
	
	// optional sint8 gpio, id 2
	/*!
	* Function for querying if gpio has been set.
	* @return true if gpio is set.
	*/
	bool has_gpio() const;
	//! Function to reset gpio to its default/unset value.
	void clear_gpio();
	//! Get value of gpio.
	int8_t gpio() const;
	//! Set gpio using a constant reference
	void set_gpio(int8_t v);
	/*!
	* Provide mutable access to gpio.
	* @return pointer to member variable of gpio.
	*/
	int8_t *mutable_gpio();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! dht_model_t model, id 1
	dht_model_t m_model = DHT_NONE;
	//! sint8 gpio, id 2
	int8_t m_gpio = -1;
};




class I2CConfig : public Message
{
	public:
	I2CConfig()
	{
	}
	
	bool operator != (const I2CConfig &r) const;
	bool operator == (const I2CConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional uint8 port, id 1
	/*!
	* Function for querying if port has been set.
	* @return true if port is set.
	*/
	bool has_port() const;
	//! Function to reset port to its default/unset value.
	void clear_port();
	//! Get value of port.
	uint8_t port() const;
	//! Set port using a constant reference
	void set_port(uint8_t v);
	/*!
	* Provide mutable access to port.
	* @return pointer to member variable of port.
	*/
	uint8_t *mutable_port();
	
	// optional sint8 sda, id 2
	/*!
	* Function for querying if sda has been set.
	* @return true if sda is set.
	*/
	bool has_sda() const;
	//! Function to reset sda to its default/unset value.
	void clear_sda();
	//! Get value of sda.
	int8_t sda() const;
	//! Set sda using a constant reference
	void set_sda(int8_t v);
	/*!
	* Provide mutable access to sda.
	* @return pointer to member variable of sda.
	*/
	int8_t *mutable_sda();
	
	// optional sint8 scl, id 3
	/*!
	* Function for querying if scl has been set.
	* @return true if scl is set.
	*/
	bool has_scl() const;
	//! Function to reset scl to its default/unset value.
	void clear_scl();
	//! Get value of scl.
	int8_t scl() const;
	//! Set scl using a constant reference
	void set_scl(int8_t v);
	/*!
	* Provide mutable access to scl.
	* @return pointer to member variable of scl.
	*/
	int8_t *mutable_scl();
	
	// optional unsigned freq, id 4
	/*!
	* Function for querying if freq has been set.
	* @return true if freq is set.
	*/
	bool has_freq() const;
	//! Function to reset freq to its default/unset value.
	void clear_freq();
	//! Get value of freq.
	uint64_t freq() const;
	//! Set freq using a constant reference
	void set_freq(uint64_t v);
	/*!
	* Provide mutable access to freq.
	* @return pointer to member variable of freq.
	*/
	uint64_t *mutable_freq();
	
	// optional bool xpullup, id 5
	/*!
	* Function for querying if xpullup has been set.
	* @return true if xpullup is set.
	*/
	bool has_xpullup() const;
	//! Function to reset xpullup to its default/unset value.
	void clear_xpullup();
	//! Get value of xpullup.
	bool xpullup() const;
	//! Set xpullup using a constant reference
	void set_xpullup(bool v);
	/*!
	* Provide mutable access to xpullup.
	* @return pointer to member variable of xpullup.
	*/
	bool *mutable_xpullup();
	
	#ifdef CONFIG_I2C_XDEV
	// repeated i2cdev_t devices, id 6
	//! Function get const-access to the elements of devices.
	const std::vector<i2cdev_t> &devices() const;
	//! Function to get the number of elements in devices.
	size_t devices_size() const;
	/*!
	* Function to append a element to devices.
	* @return point to newly added element.
	*/
	void add_devices(i2cdev_t v);
	//! Function to reset devices to its default/unset value.
	void clear_devices();
	//! Get value of element x of devices.
	i2cdev_t devices(unsigned x) const;
	//! Function to get the addr part of bitset devices.
	uint8_t devices_addr(unsigned x) const;
	//! Function to set the addr part of bitset devices.
	void set_devices_addr(unsigned x, uint8_t);
	//! Function to get the drv part of bitset devices.
	i2cdrv_t devices_drv(unsigned x) const;
	//! Function to set the drv part of bitset devices.
	void set_devices_drv(unsigned x, i2cdrv_t);
	//! Function to get the intr part of bitset devices.
	uint8_t devices_intr(unsigned x) const;
	//! Function to set the intr part of bitset devices.
	void set_devices_intr(unsigned x, uint8_t);
	//! Set devices using a constant reference
	void set_devices(unsigned x, i2cdev_t v);
	/*!
	* Provide mutable access to devices.
	* @return pointer to member variable of devices.
	*/
	i2cdev_t *mutable_devices(unsigned x);
	//! Function to get mutable access to all elements of devices.
	std::vector<i2cdev_t> *mutable_devices();
	#endif // CONFIG_I2C_XDEV
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! uint8 port, id 1
	uint8_t m_port = 0;
	//! sint8 sda, id 2
	int8_t m_sda = -1;
	//! sint8 scl, id 3
	int8_t m_scl = -1;
	//! unsigned freq, id 4
	uint64_t m_freq = 100000;
	//! bool xpullup, id 5
	bool m_xpullup = false;
	#ifdef CONFIG_I2C_XDEV
	//! i2cdev_t devices, id 6
	std::vector<i2cdev_t> m_devices;
	#endif // CONFIG_I2C_XDEV
	
	private:
	uint8_t p_validbits = 0;
};




class HcSr04Config : public Message
{
	public:
	HcSr04Config()
	{
	}
	
	bool operator != (const HcSr04Config &r) const;
	bool operator == (const HcSr04Config &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 trigger, id 1
	/*!
	* Function for querying if trigger has been set.
	* @return true if trigger is set.
	*/
	bool has_trigger() const;
	//! Function to reset trigger to its default/unset value.
	void clear_trigger();
	//! Get value of trigger.
	int8_t trigger() const;
	//! Set trigger using a constant reference
	void set_trigger(int8_t v);
	/*!
	* Provide mutable access to trigger.
	* @return pointer to member variable of trigger.
	*/
	int8_t *mutable_trigger();
	
	// optional sint8 echo, id 2
	/*!
	* Function for querying if echo has been set.
	* @return true if echo is set.
	*/
	bool has_echo() const;
	//! Function to reset echo to its default/unset value.
	void clear_echo();
	//! Get value of echo.
	int8_t echo() const;
	//! Set echo using a constant reference
	void set_echo(int8_t v);
	/*!
	* Provide mutable access to echo.
	* @return pointer to member variable of echo.
	*/
	int8_t *mutable_echo();
	
	// optional string name, id 3
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const std::string &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const std::string &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	std::string *mutable_name();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 trigger, id 1
	int8_t m_trigger = -1;
	//! sint8 echo, id 2
	int8_t m_echo = -1;
	//! string name, id 3
	std::string m_name;
};




class LedConfig : public Message
{
	public:
	LedConfig()
	{
	}
	
	bool operator != (const LedConfig &r) const;
	bool operator == (const LedConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 gpio, id 1
	/*!
	* Function for querying if gpio has been set.
	* @return true if gpio is set.
	*/
	bool has_gpio() const;
	//! Function to reset gpio to its default/unset value.
	void clear_gpio();
	//! Get value of gpio.
	int8_t gpio() const;
	//! Set gpio using a constant reference
	void set_gpio(int8_t v);
	/*!
	* Provide mutable access to gpio.
	* @return pointer to member variable of gpio.
	*/
	int8_t *mutable_gpio();
	
	// optional ledcfg_t config, id 2
	/*!
	* Function for querying if config has been set.
	* @return true if config is set.
	*/
	bool has_config() const;
	//! Function to reset config to its default/unset value.
	void clear_config();
	//! Get value of config.
	ledcfg_t config() const;
	//! Function to get the active_high part of bitset config.
	bool config_active_high() const;
	//! Function to set the active_high part of bitset config.
	void set_config_active_high(bool);
	//! Function to get the open_drain part of bitset config.
	bool config_open_drain() const;
	//! Function to set the open_drain part of bitset config.
	void set_config_open_drain(bool);
	//! Function to get the init_high part of bitset config.
	bool config_init_high() const;
	//! Function to set the init_high part of bitset config.
	void set_config_init_high(bool);
	//! Set config using a constant reference
	void set_config(ledcfg_t v);
	/*!
	* Provide mutable access to config.
	* @return pointer to member variable of config.
	*/
	ledcfg_t *mutable_config();
	
	// optional string name, id 3
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const std::string &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const std::string &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	std::string *mutable_name();
	
	// optional sint8 pwm_ch, id 4
	/*!
	* Function for querying if pwm_ch has been set.
	* @return true if pwm_ch is set.
	*/
	bool has_pwm_ch() const;
	//! Function to reset pwm_ch to its default/unset value.
	void clear_pwm_ch();
	//! Get value of pwm_ch.
	int8_t pwm_ch() const;
	//! Set pwm_ch using a constant reference
	void set_pwm_ch(int8_t v);
	/*!
	* Provide mutable access to pwm_ch.
	* @return pointer to member variable of pwm_ch.
	*/
	int8_t *mutable_pwm_ch();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 gpio, id 1
	int8_t m_gpio = -1;
	//! ledcfg_t config, id 2
	ledcfg_t m_config = 0;
	//! string name, id 3
	std::string m_name;
	//! sint8 pwm_ch, id 4
	int8_t m_pwm_ch = -1;
	
	private:
	uint8_t p_validbits = 0;
};




class OneWireConfig : public Message
{
	public:
	OneWireConfig()
	{
	}
	
	bool operator != (const OneWireConfig &r) const;
	bool operator == (const OneWireConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 gpio, id 1
	/*!
	* Function for querying if gpio has been set.
	* @return true if gpio is set.
	*/
	bool has_gpio() const;
	//! Function to reset gpio to its default/unset value.
	void clear_gpio();
	//! Get value of gpio.
	int8_t gpio() const;
	//! Set gpio using a constant reference
	void set_gpio(int8_t v);
	/*!
	* Provide mutable access to gpio.
	* @return pointer to member variable of gpio.
	*/
	int8_t *mutable_gpio();
	
	// optional bool pullup, id 2
	/*!
	* Function for querying if pullup has been set.
	* @return true if pullup is set.
	*/
	bool has_pullup() const;
	//! Function to reset pullup to its default/unset value.
	void clear_pullup();
	//! Get value of pullup.
	bool pullup() const;
	//! Set pullup using a constant reference
	void set_pullup(bool v);
	/*!
	* Provide mutable access to pullup.
	* @return pointer to member variable of pullup.
	*/
	bool *mutable_pullup();
	
	// optional sint8 power, id 3
	/*!
	* Function for querying if power has been set.
	* @return true if power is set.
	*/
	bool has_power() const;
	//! Function to reset power to its default/unset value.
	void clear_power();
	//! Get value of power.
	int8_t power() const;
	//! Set power using a constant reference
	void set_power(int8_t v);
	/*!
	* Provide mutable access to power.
	* @return pointer to member variable of power.
	*/
	int8_t *mutable_power();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 gpio, id 1
	int8_t m_gpio = -1;
	//! bool pullup, id 2
	bool m_pullup = false;
	//! sint8 power, id 3
	int8_t m_power = -1;
};




class UartConfig : public Message
{
	public:
	UartConfig()
	{
	}
	
	bool operator != (const UartConfig &r) const;
	bool operator == (const UartConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 port, id 1
	/*!
	* Function for querying if port has been set.
	* @return true if port is set.
	*/
	bool has_port() const;
	//! Function to reset port to its default/unset value.
	void clear_port();
	//! Get value of port.
	int8_t port() const;
	//! Set port using a constant reference
	void set_port(int8_t v);
	/*!
	* Provide mutable access to port.
	* @return pointer to member variable of port.
	*/
	int8_t *mutable_port();
	
	// optional sint8 tx_gpio, id 2
	/*!
	* Function for querying if tx_gpio has been set.
	* @return true if tx_gpio is set.
	*/
	bool has_tx_gpio() const;
	//! Function to reset tx_gpio to its default/unset value.
	void clear_tx_gpio();
	//! Get value of tx_gpio.
	int8_t tx_gpio() const;
	//! Set tx_gpio using a constant reference
	void set_tx_gpio(int8_t v);
	/*!
	* Provide mutable access to tx_gpio.
	* @return pointer to member variable of tx_gpio.
	*/
	int8_t *mutable_tx_gpio();
	
	// optional sint8 rx_gpio, id 3
	/*!
	* Function for querying if rx_gpio has been set.
	* @return true if rx_gpio is set.
	*/
	bool has_rx_gpio() const;
	//! Function to reset rx_gpio to its default/unset value.
	void clear_rx_gpio();
	//! Get value of rx_gpio.
	int8_t rx_gpio() const;
	//! Set rx_gpio using a constant reference
	void set_rx_gpio(int8_t v);
	/*!
	* Provide mutable access to rx_gpio.
	* @return pointer to member variable of rx_gpio.
	*/
	int8_t *mutable_rx_gpio();
	
	// optional sint8 cts_gpio, id 4
	/*!
	* Function for querying if cts_gpio has been set.
	* @return true if cts_gpio is set.
	*/
	bool has_cts_gpio() const;
	//! Function to reset cts_gpio to its default/unset value.
	void clear_cts_gpio();
	//! Get value of cts_gpio.
	int8_t cts_gpio() const;
	//! Set cts_gpio using a constant reference
	void set_cts_gpio(int8_t v);
	/*!
	* Provide mutable access to cts_gpio.
	* @return pointer to member variable of cts_gpio.
	*/
	int8_t *mutable_cts_gpio();
	
	// optional sint8 rts_gpio, id 5
	/*!
	* Function for querying if rts_gpio has been set.
	* @return true if rts_gpio is set.
	*/
	bool has_rts_gpio() const;
	//! Function to reset rts_gpio to its default/unset value.
	void clear_rts_gpio();
	//! Get value of rts_gpio.
	int8_t rts_gpio() const;
	//! Set rts_gpio using a constant reference
	void set_rts_gpio(int8_t v);
	/*!
	* Provide mutable access to rts_gpio.
	* @return pointer to member variable of rts_gpio.
	*/
	int8_t *mutable_rts_gpio();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 port, id 1
	int8_t m_port = -1;
	//! sint8 tx_gpio, id 2
	int8_t m_tx_gpio = -1;
	//! sint8 rx_gpio, id 3
	int8_t m_rx_gpio = -1;
	//! sint8 cts_gpio, id 4
	int8_t m_cts_gpio = -1;
	//! sint8 rts_gpio, id 5
	int8_t m_rts_gpio = -1;
};




class AdcChannel : public Message
{
	public:
	AdcChannel()
	{
	}
	
	bool operator != (const AdcChannel &r) const;
	bool operator == (const AdcChannel &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const std::string &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const std::string &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	std::string *mutable_name();
	
	// optional uint8 unit, id 2
	/*!
	* Function for querying if unit has been set.
	* @return true if unit is set.
	*/
	bool has_unit() const;
	//! Function to reset unit to its default/unset value.
	void clear_unit();
	//! Get value of unit.
	uint8_t unit() const;
	//! Set unit using a constant reference
	void set_unit(uint8_t v);
	/*!
	* Provide mutable access to unit.
	* @return pointer to member variable of unit.
	*/
	uint8_t *mutable_unit();
	
	// optional sint8 ch, id 3
	/*!
	* Function for querying if ch has been set.
	* @return true if ch is set.
	*/
	bool has_ch() const;
	//! Function to reset ch to its default/unset value.
	void clear_ch();
	//! Get value of ch.
	int8_t ch() const;
	//! Set ch using a constant reference
	void set_ch(int8_t v);
	/*!
	* Provide mutable access to ch.
	* @return pointer to member variable of ch.
	*/
	int8_t *mutable_ch();
	
	// optional uint8 atten, id 4
	/*!
	* Function for querying if atten has been set.
	* @return true if atten is set.
	*/
	bool has_atten() const;
	//! Function to reset atten to its default/unset value.
	void clear_atten();
	//! Get value of atten.
	uint8_t atten() const;
	//! Set atten using a constant reference
	void set_atten(uint8_t v);
	/*!
	* Provide mutable access to atten.
	* @return pointer to member variable of atten.
	*/
	uint8_t *mutable_atten();
	
	// optional uint16 interval, id 5
	/*!
	* Function for querying if interval has been set.
	* @return true if interval is set.
	*/
	bool has_interval() const;
	//! Function to reset interval to its default/unset value.
	void clear_interval();
	//! Get value of interval.
	uint16_t interval() const;
	//! Set interval using a constant reference
	void set_interval(uint16_t v);
	/*!
	* Provide mutable access to interval.
	* @return pointer to member variable of interval.
	*/
	uint16_t *mutable_interval();
	
	// optional uint8 window, id 6
	/*!
	* Function for querying if window has been set.
	* @return true if window is set.
	*/
	bool has_window() const;
	//! Function to reset window to its default/unset value.
	void clear_window();
	//! Get value of window.
	uint8_t window() const;
	//! Set window using a constant reference
	void set_window(uint8_t v);
	/*!
	* Provide mutable access to window.
	* @return pointer to member variable of window.
	*/
	uint8_t *mutable_window();
	
	// optional float scale, id 8
	/*!
	* Function for querying if scale has been set.
	* @return true if scale is set.
	*/
	bool has_scale() const;
	//! Function to reset scale to its default/unset value.
	void clear_scale();
	//! Get value of scale.
	float scale() const;
	//! Set scale using a constant reference
	void set_scale(float v);
	/*!
	* Provide mutable access to scale.
	* @return pointer to member variable of scale.
	*/
	float *mutable_scale();
	
	// optional float offset, id 9
	/*!
	* Function for querying if offset has been set.
	* @return true if offset is set.
	*/
	bool has_offset() const;
	//! Function to reset offset to its default/unset value.
	void clear_offset();
	//! Get value of offset.
	float offset() const;
	//! Set offset using a constant reference
	void set_offset(float v);
	/*!
	* Provide mutable access to offset.
	* @return pointer to member variable of offset.
	*/
	float *mutable_offset();
	
	// optional string dim, id 10
	/*!
	* Function for querying if dim has been set.
	* @return true if dim is set.
	*/
	bool has_dim() const;
	//! Function to reset dim to its default/unset value.
	void clear_dim();
	//! Get value of dim.
	const std::string &dim() const;
	/*!
	* Function for setting dim using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_dim(const void *data, size_t s);
	//! Set dim using a constant reference
	void set_dim(const std::string &v);
	//! Set dim using a pointer to a null-terminated C-string.
	void set_dim(const char *);
	/*!
	* Provide mutable access to dim.
	* @return pointer to member variable of dim.
	*/
	std::string *mutable_dim();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	std::string m_name;
	//! uint8 unit, id 2
	uint8_t m_unit = 0;
	//! sint8 ch, id 3
	int8_t m_ch = -1;
	//! uint8 atten, id 4
	uint8_t m_atten = 0;
	//! uint16 interval, id 5
	uint16_t m_interval = 0;
	//! uint8 window, id 6
	uint8_t m_window = 0;
	//! float scale, id 8
	float m_scale = 1;
	//! float offset, id 9
	float m_offset = 0;
	//! string dim, id 10
	std::string m_dim;
	
	private:
	uint8_t p_validbits = 0;
};




class AdcConfig : public Message
{
	public:
	AdcConfig()
	{
	}
	
	bool operator != (const AdcConfig &r) const;
	bool operator == (const AdcConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string adc_name, id 1
	/*!
	* Function for querying if adc_name has been set.
	* @return true if adc_name is set.
	*/
	bool has_adc_name() const;
	//! Function to reset adc_name to its default/unset value.
	void clear_adc_name();
	//! Get value of adc_name.
	const std::string &adc_name() const;
	/*!
	* Function for setting adc_name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_adc_name(const void *data, size_t s);
	//! Set adc_name using a constant reference
	void set_adc_name(const std::string &v);
	//! Set adc_name using a pointer to a null-terminated C-string.
	void set_adc_name(const char *);
	/*!
	* Provide mutable access to adc_name.
	* @return pointer to member variable of adc_name.
	*/
	std::string *mutable_adc_name();
	
	// optional uint8 adc1_bits, id 2
	/*!
	* Function for querying if adc1_bits has been set.
	* @return true if adc1_bits is set.
	*/
	bool has_adc1_bits() const;
	//! Function to reset adc1_bits to its default/unset value.
	void clear_adc1_bits();
	//! Get value of adc1_bits.
	uint8_t adc1_bits() const;
	//! Set adc1_bits using a constant reference
	void set_adc1_bits(uint8_t v);
	/*!
	* Provide mutable access to adc1_bits.
	* @return pointer to member variable of adc1_bits.
	*/
	uint8_t *mutable_adc1_bits();
	
	// optional uint8 adc2_bits, id 3
	/*!
	* Function for querying if adc2_bits has been set.
	* @return true if adc2_bits is set.
	*/
	bool has_adc2_bits() const;
	//! Function to reset adc2_bits to its default/unset value.
	void clear_adc2_bits();
	//! Get value of adc2_bits.
	uint8_t adc2_bits() const;
	//! Set adc2_bits using a constant reference
	void set_adc2_bits(uint8_t v);
	/*!
	* Provide mutable access to adc2_bits.
	* @return pointer to member variable of adc2_bits.
	*/
	uint8_t *mutable_adc2_bits();
	
	// optional uint8 mode, id 4
	/*!
	* Function for querying if mode has been set.
	* @return true if mode is set.
	*/
	bool has_mode() const;
	//! Function to reset mode to its default/unset value.
	void clear_mode();
	//! Get value of mode.
	uint8_t mode() const;
	//! Set mode using a constant reference
	void set_mode(uint8_t v);
	/*!
	* Provide mutable access to mode.
	* @return pointer to member variable of mode.
	*/
	uint8_t *mutable_mode();
	
	// optional uint8 clk_div, id 5
	/*!
	* Function for querying if clk_div has been set.
	* @return true if clk_div is set.
	*/
	bool has_clk_div() const;
	//! Function to reset clk_div to its default/unset value.
	void clear_clk_div();
	//! Get value of clk_div.
	uint8_t clk_div() const;
	//! Set clk_div using a constant reference
	void set_clk_div(uint8_t v);
	/*!
	* Provide mutable access to clk_div.
	* @return pointer to member variable of clk_div.
	*/
	uint8_t *mutable_clk_div();
	
	// optional string hall_name, id 6
	/*!
	* Function for querying if hall_name has been set.
	* @return true if hall_name is set.
	*/
	bool has_hall_name() const;
	//! Function to reset hall_name to its default/unset value.
	void clear_hall_name();
	//! Get value of hall_name.
	const std::string &hall_name() const;
	/*!
	* Function for setting hall_name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_hall_name(const void *data, size_t s);
	//! Set hall_name using a constant reference
	void set_hall_name(const std::string &v);
	//! Set hall_name using a pointer to a null-terminated C-string.
	void set_hall_name(const char *);
	/*!
	* Provide mutable access to hall_name.
	* @return pointer to member variable of hall_name.
	*/
	std::string *mutable_hall_name();
	
	// repeated AdcChannel channels, id 7
	//! Function get const-access to the elements of channels.
	const std::vector<AdcChannel> &channels() const;
	//! Function to get the number of elements in channels.
	size_t channels_size() const;
	/*!
	* Function to append a element to channels.
	* @return point to newly added element.
	*/
	AdcChannel* add_channels();
	//! Function to reset channels to its default/unset value.
	void clear_channels();
	//! Get value of element x of channels.
	const AdcChannel &channels(unsigned x) const;
	//! Set channels using a constant reference
	void set_channels(unsigned x, const AdcChannel &v);
	/*!
	* Provide mutable access to channels.
	* @return pointer to member variable of channels.
	*/
	AdcChannel *mutable_channels(unsigned x);
	//! Function to get mutable access to all elements of channels.
	std::vector<AdcChannel> *mutable_channels();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string adc_name, id 1
	std::string m_adc_name;
	//! uint8 adc1_bits, id 2
	uint8_t m_adc1_bits = 0;
	//! uint8 adc2_bits, id 3
	uint8_t m_adc2_bits = 0;
	//! uint8 mode, id 4
	uint8_t m_mode = 0;
	//! uint8 clk_div, id 5
	uint8_t m_clk_div = 0;
	//! string hall_name, id 6
	std::string m_hall_name;
	//! AdcChannel channels, id 7
	std::vector<AdcChannel> m_channels;
	
	private:
	uint8_t p_validbits = 0;
};




class GpioConfig : public Message
{
	public:
	GpioConfig()
	{
	}
	
	bool operator != (const GpioConfig &r) const;
	bool operator == (const GpioConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const std::string &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const std::string &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	std::string *mutable_name();
	
	// optional sint8 gpio, id 2
	/*!
	* Function for querying if gpio has been set.
	* @return true if gpio is set.
	*/
	bool has_gpio() const;
	//! Function to reset gpio to its default/unset value.
	void clear_gpio();
	//! Get value of gpio.
	int8_t gpio() const;
	//! Set gpio using a constant reference
	void set_gpio(int8_t v);
	/*!
	* Provide mutable access to gpio.
	* @return pointer to member variable of gpio.
	*/
	int8_t *mutable_gpio();
	
	// optional gpiocfg_t config, id 3
	/*!
	* Function for querying if config has been set.
	* @return true if config is set.
	*/
	bool has_config() const;
	//! Function to reset config to its default/unset value.
	void clear_config();
	//! Get value of config.
	gpiocfg_t config() const;
	//! Function to get the mode part of bitset config.
	uint8_t config_mode() const;
	//! Function to set the mode part of bitset config.
	void set_config_mode(uint8_t);
	//! Function to get the intrtype part of bitset config.
	uint8_t config_intrtype() const;
	//! Function to set the intrtype part of bitset config.
	void set_config_intrtype(uint8_t);
	//! Function to get the setinit part of bitset config.
	bool config_setinit() const;
	//! Function to set the setinit part of bitset config.
	void set_config_setinit(bool);
	//! Function to get the initlvl part of bitset config.
	bool config_initlvl() const;
	//! Function to set the initlvl part of bitset config.
	void set_config_initlvl(bool);
	//! Function to get the pullup part of bitset config.
	bool config_pullup() const;
	//! Function to set the pullup part of bitset config.
	void set_config_pullup(bool);
	//! Function to get the pulldown part of bitset config.
	bool config_pulldown() const;
	//! Function to set the pulldown part of bitset config.
	void set_config_pulldown(bool);
	//! Set config using a constant reference
	void set_config(gpiocfg_t v);
	/*!
	* Provide mutable access to config.
	* @return pointer to member variable of config.
	*/
	gpiocfg_t *mutable_config();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	std::string m_name;
	//! sint8 gpio, id 2
	int8_t m_gpio = -1;
	//! gpiocfg_t config, id 3
	gpiocfg_t m_config = 0;
	
	private:
	uint8_t p_validbits = 0;
};




class DisplayConfig : public Message
{
	public:
	DisplayConfig()
	{
	}
	
	bool operator != (const DisplayConfig &r) const;
	bool operator == (const DisplayConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional disp_t type, id 1
	/*!
	* Function for querying if type has been set.
	* @return true if type is set.
	*/
	bool has_type() const;
	//! Function to reset type to its default/unset value.
	void clear_type();
	//! Get value of type.
	disp_t type() const;
	//! Set type using a constant reference
	void set_type(disp_t v);
	/*!
	* Provide mutable access to type.
	* @return pointer to member variable of type.
	*/
	disp_t *mutable_type();
	
	// optional unsigned options, id 2
	/*!
	* Function for querying if options has been set.
	* @return true if options is set.
	*/
	bool has_options() const;
	//! Function to reset options to its default/unset value.
	void clear_options();
	//! Get value of options.
	uint64_t options() const;
	//! Set options using a constant reference
	void set_options(uint64_t v);
	/*!
	* Provide mutable access to options.
	* @return pointer to member variable of options.
	*/
	uint64_t *mutable_options();
	
	// optional unsigned maxx, id 3
	/*!
	* Function for querying if maxx has been set.
	* @return true if maxx is set.
	*/
	bool has_maxx() const;
	//! Function to reset maxx to its default/unset value.
	void clear_maxx();
	//! Get value of maxx.
	uint64_t maxx() const;
	//! Set maxx using a constant reference
	void set_maxx(uint64_t v);
	/*!
	* Provide mutable access to maxx.
	* @return pointer to member variable of maxx.
	*/
	uint64_t *mutable_maxx();
	
	// optional unsigned maxy, id 4
	/*!
	* Function for querying if maxy has been set.
	* @return true if maxy is set.
	*/
	bool has_maxy() const;
	//! Function to reset maxy to its default/unset value.
	void clear_maxy();
	//! Get value of maxy.
	uint64_t maxy() const;
	//! Set maxy using a constant reference
	void set_maxy(uint64_t v);
	/*!
	* Provide mutable access to maxy.
	* @return pointer to member variable of maxy.
	*/
	uint64_t *mutable_maxy();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! disp_t type, id 1
	disp_t m_type = dt_none;
	//! unsigned options, id 2
	uint64_t m_options = 0;
	//! unsigned maxx, id 3
	uint64_t m_maxx = 0;
	//! unsigned maxy, id 4
	uint64_t m_maxy = 1;
	
	private:
	uint8_t p_validbits = 0;
};




class SpiDeviceConfig : public Message
{
	public:
	SpiDeviceConfig()
	{
	}
	
	bool operator != (const SpiDeviceConfig &r) const;
	bool operator == (const SpiDeviceConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional spidrv_t drv, id 1
	/*!
	* Function for querying if drv has been set.
	* @return true if drv is set.
	*/
	bool has_drv() const;
	//! Function to reset drv to its default/unset value.
	void clear_drv();
	//! Get value of drv.
	spidrv_t drv() const;
	//! Set drv using a constant reference
	void set_drv(spidrv_t v);
	/*!
	* Provide mutable access to drv.
	* @return pointer to member variable of drv.
	*/
	spidrv_t *mutable_drv();
	
	// optional sint8 cs, id 2
	/*!
	* Function for querying if cs has been set.
	* @return true if cs is set.
	*/
	bool has_cs() const;
	//! Function to reset cs to its default/unset value.
	void clear_cs();
	//! Get value of cs.
	int8_t cs() const;
	//! Set cs using a constant reference
	void set_cs(int8_t v);
	/*!
	* Provide mutable access to cs.
	* @return pointer to member variable of cs.
	*/
	int8_t *mutable_cs();
	
	// optional sint8 intr, id 3
	/*!
	* Function for querying if intr has been set.
	* @return true if intr is set.
	*/
	bool has_intr() const;
	//! Function to reset intr to its default/unset value.
	void clear_intr();
	//! Get value of intr.
	int8_t intr() const;
	//! Set intr using a constant reference
	void set_intr(int8_t v);
	/*!
	* Provide mutable access to intr.
	* @return pointer to member variable of intr.
	*/
	int8_t *mutable_intr();
	
	// optional sint8 reset, id 4
	/*!
	* Function for querying if reset has been set.
	* @return true if reset is set.
	*/
	bool has_reset() const;
	//! Function to reset reset to its default/unset value.
	void clear_reset();
	//! Get value of reset.
	int8_t reset() const;
	//! Set reset using a constant reference
	void set_reset(int8_t v);
	/*!
	* Provide mutable access to reset.
	* @return pointer to member variable of reset.
	*/
	int8_t *mutable_reset();
	
	// optional sint8 cd, id 5
	/*!
	* Function for querying if cd has been set.
	* @return true if cd is set.
	*/
	bool has_cd() const;
	//! Function to reset cd to its default/unset value.
	void clear_cd();
	//! Get value of cd.
	int8_t cd() const;
	//! Set cd using a constant reference
	void set_cd(int8_t v);
	/*!
	* Provide mutable access to cd.
	* @return pointer to member variable of cd.
	*/
	int8_t *mutable_cd();
	
	// optional unsigned freq, id 6
	/*!
	* Function for querying if freq has been set.
	* @return true if freq is set.
	*/
	bool has_freq() const;
	//! Function to reset freq to its default/unset value.
	void clear_freq();
	//! Get value of freq.
	uint64_t freq() const;
	//! Set freq using a constant reference
	void set_freq(uint64_t v);
	/*!
	* Provide mutable access to freq.
	* @return pointer to member variable of freq.
	*/
	uint64_t *mutable_freq();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! spidrv_t drv, id 1
	spidrv_t m_drv = spidrv_invalid;
	//! sint8 cs, id 2
	int8_t m_cs = -1;
	//! sint8 intr, id 3
	int8_t m_intr = -1;
	//! sint8 reset, id 4
	int8_t m_reset = -1;
	//! sint8 cd, id 5
	int8_t m_cd = -1;
	//! unsigned freq, id 6
	uint64_t m_freq = 0;
};




class SpiBusConfig : public Message
{
	public:
	SpiBusConfig()
	{
	}
	
	bool operator != (const SpiBusConfig &r) const;
	bool operator == (const SpiBusConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 host, id 1
	/*!
	* Function for querying if host has been set.
	* @return true if host is set.
	*/
	bool has_host() const;
	//! Function to reset host to its default/unset value.
	void clear_host();
	//! Get value of host.
	int8_t host() const;
	//! Set host using a constant reference
	void set_host(int8_t v);
	/*!
	* Provide mutable access to host.
	* @return pointer to member variable of host.
	*/
	int8_t *mutable_host();
	
	// optional sint8 mosi, id 2
	/*!
	* Function for querying if mosi has been set.
	* @return true if mosi is set.
	*/
	bool has_mosi() const;
	//! Function to reset mosi to its default/unset value.
	void clear_mosi();
	//! Get value of mosi.
	int8_t mosi() const;
	//! Set mosi using a constant reference
	void set_mosi(int8_t v);
	/*!
	* Provide mutable access to mosi.
	* @return pointer to member variable of mosi.
	*/
	int8_t *mutable_mosi();
	
	// optional sint8 miso, id 3
	/*!
	* Function for querying if miso has been set.
	* @return true if miso is set.
	*/
	bool has_miso() const;
	//! Function to reset miso to its default/unset value.
	void clear_miso();
	//! Get value of miso.
	int8_t miso() const;
	//! Set miso using a constant reference
	void set_miso(int8_t v);
	/*!
	* Provide mutable access to miso.
	* @return pointer to member variable of miso.
	*/
	int8_t *mutable_miso();
	
	// optional sint8 sclk, id 4
	/*!
	* Function for querying if sclk has been set.
	* @return true if sclk is set.
	*/
	bool has_sclk() const;
	//! Function to reset sclk to its default/unset value.
	void clear_sclk();
	//! Get value of sclk.
	int8_t sclk() const;
	//! Set sclk using a constant reference
	void set_sclk(int8_t v);
	/*!
	* Provide mutable access to sclk.
	* @return pointer to member variable of sclk.
	*/
	int8_t *mutable_sclk();
	
	// optional sint8 wp, id 5
	/*!
	* Function for querying if wp has been set.
	* @return true if wp is set.
	*/
	bool has_wp() const;
	//! Function to reset wp to its default/unset value.
	void clear_wp();
	//! Get value of wp.
	int8_t wp() const;
	//! Set wp using a constant reference
	void set_wp(int8_t v);
	/*!
	* Provide mutable access to wp.
	* @return pointer to member variable of wp.
	*/
	int8_t *mutable_wp();
	
	// optional sint8 hold, id 6
	/*!
	* Function for querying if hold has been set.
	* @return true if hold is set.
	*/
	bool has_hold() const;
	//! Function to reset hold to its default/unset value.
	void clear_hold();
	//! Get value of hold.
	int8_t hold() const;
	//! Set hold using a constant reference
	void set_hold(int8_t v);
	/*!
	* Provide mutable access to hold.
	* @return pointer to member variable of hold.
	*/
	int8_t *mutable_hold();
	
	// optional spiopt_t options, id 7
	/*!
	* Function for querying if options has been set.
	* @return true if options is set.
	*/
	bool has_options() const;
	//! Function to reset options to its default/unset value.
	void clear_options();
	//! Get value of options.
	spiopt_t options() const;
	//! Function to get the txlsbfirst part of bitset options.
	bool options_txlsbfirst() const;
	//! Function to set the txlsbfirst part of bitset options.
	void set_options_txlsbfirst(bool);
	//! Function to get the rxlsbfirst part of bitset options.
	bool options_rxlsbfirst() const;
	//! Function to set the rxlsbfirst part of bitset options.
	void set_options_rxlsbfirst(bool);
	//! Function to get the mosi_as_miso part of bitset options.
	bool options_mosi_as_miso() const;
	//! Function to set the mosi_as_miso part of bitset options.
	void set_options_mosi_as_miso(bool);
	//! Function to get the positive_cs part of bitset options.
	bool options_positive_cs() const;
	//! Function to set the positive_cs part of bitset options.
	void set_options_positive_cs(bool);
	//! Function to get the full_duplex part of bitset options.
	bool options_full_duplex() const;
	//! Function to set the full_duplex part of bitset options.
	void set_options_full_duplex(bool);
	//! Function to get the pol_hi part of bitset options.
	bool options_pol_hi() const;
	//! Function to set the pol_hi part of bitset options.
	void set_options_pol_hi(bool);
	//! Function to get the pha_hi part of bitset options.
	bool options_pha_hi() const;
	//! Function to set the pha_hi part of bitset options.
	void set_options_pha_hi(bool);
	//! Set options using a constant reference
	void set_options(spiopt_t v);
	/*!
	* Provide mutable access to options.
	* @return pointer to member variable of options.
	*/
	spiopt_t *mutable_options();
	
	// optional sint8 dma, id 8
	/*!
	* Function for querying if dma has been set.
	* @return true if dma is set.
	*/
	bool has_dma() const;
	//! Function to reset dma to its default/unset value.
	void clear_dma();
	//! Get value of dma.
	int8_t dma() const;
	//! Set dma using a constant reference
	void set_dma(int8_t v);
	/*!
	* Provide mutable access to dma.
	* @return pointer to member variable of dma.
	*/
	int8_t *mutable_dma();
	
	// repeated SpiDeviceConfig devices, id 9
	//! Function get const-access to the elements of devices.
	const std::vector<SpiDeviceConfig> &devices() const;
	//! Function to get the number of elements in devices.
	size_t devices_size() const;
	/*!
	* Function to append a element to devices.
	* @return point to newly added element.
	*/
	SpiDeviceConfig* add_devices();
	//! Function to reset devices to its default/unset value.
	void clear_devices();
	//! Get value of element x of devices.
	const SpiDeviceConfig &devices(unsigned x) const;
	//! Set devices using a constant reference
	void set_devices(unsigned x, const SpiDeviceConfig &v);
	/*!
	* Provide mutable access to devices.
	* @return pointer to member variable of devices.
	*/
	SpiDeviceConfig *mutable_devices(unsigned x);
	//! Function to get mutable access to all elements of devices.
	std::vector<SpiDeviceConfig> *mutable_devices();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 host, id 1
	int8_t m_host = -1;
	//! sint8 mosi, id 2
	int8_t m_mosi = -1;
	//! sint8 miso, id 3
	int8_t m_miso = -1;
	//! sint8 sclk, id 4
	int8_t m_sclk = -1;
	//! sint8 wp, id 5
	int8_t m_wp = -1;
	//! sint8 hold, id 6
	int8_t m_hold = -1;
	//! spiopt_t options, id 7
	spiopt_t m_options = 0;
	//! sint8 dma, id 8
	int8_t m_dma = -1;
	//! SpiDeviceConfig devices, id 9
	std::vector<SpiDeviceConfig> m_devices;
	
	private:
	uint8_t p_validbits = 0;
};




class GpioCluster : public Message
{
	public:
	GpioCluster()
	{
	}
	
	bool operator != (const GpioCluster &r) const;
	bool operator == (const GpioCluster &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const std::string &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const std::string &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	std::string *mutable_name();
	
	// optional uint8 base, id 2
	/*!
	* Function for querying if base has been set.
	* @return true if base is set.
	*/
	bool has_base() const;
	//! Function to reset base to its default/unset value.
	void clear_base();
	//! Get value of base.
	uint8_t base() const;
	//! Set base using a constant reference
	void set_base(uint8_t v);
	/*!
	* Provide mutable access to base.
	* @return pointer to member variable of base.
	*/
	uint8_t *mutable_base();
	
	// optional uint8 numio, id 3
	/*!
	* Function for querying if numio has been set.
	* @return true if numio is set.
	*/
	bool has_numio() const;
	//! Function to reset numio to its default/unset value.
	void clear_numio();
	//! Get value of numio.
	uint8_t numio() const;
	//! Set numio using a constant reference
	void set_numio(uint8_t v);
	/*!
	* Provide mutable access to numio.
	* @return pointer to member variable of numio.
	*/
	uint8_t *mutable_numio();
	
	// optional sint8 int_a, id 4
	/*!
	* Function for querying if int_a has been set.
	* @return true if int_a is set.
	*/
	bool has_int_a() const;
	//! Function to reset int_a to its default/unset value.
	void clear_int_a();
	//! Get value of int_a.
	int8_t int_a() const;
	//! Set int_a using a constant reference
	void set_int_a(int8_t v);
	/*!
	* Provide mutable access to int_a.
	* @return pointer to member variable of int_a.
	*/
	int8_t *mutable_int_a();
	
	// optional sint8 int_b, id 5
	/*!
	* Function for querying if int_b has been set.
	* @return true if int_b is set.
	*/
	bool has_int_b() const;
	//! Function to reset int_b to its default/unset value.
	void clear_int_b();
	//! Get value of int_b.
	int8_t int_b() const;
	//! Set int_b using a constant reference
	void set_int_b(int8_t v);
	/*!
	* Provide mutable access to int_b.
	* @return pointer to member variable of int_b.
	*/
	int8_t *mutable_int_b();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	std::string m_name;
	//! uint8 base, id 2
	uint8_t m_base = 0;
	//! uint8 numio, id 3
	uint8_t m_numio = 0;
	//! sint8 int_a, id 4
	int8_t m_int_a = -1;
	//! sint8 int_b, id 5
	int8_t m_int_b = -1;
};




class Hlw8012Config : public Message
{
	public:
	Hlw8012Config()
	{
	}
	
	bool operator != (const Hlw8012Config &r) const;
	bool operator == (const Hlw8012Config &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 sel, id 2
	/*!
	* Function for querying if sel has been set.
	* @return true if sel is set.
	*/
	bool has_sel() const;
	//! Function to reset sel to its default/unset value.
	void clear_sel();
	//! Get value of sel.
	int8_t sel() const;
	//! Set sel using a constant reference
	void set_sel(int8_t v);
	/*!
	* Provide mutable access to sel.
	* @return pointer to member variable of sel.
	*/
	int8_t *mutable_sel();
	
	// optional sint8 cf, id 3
	/*!
	* Function for querying if cf has been set.
	* @return true if cf is set.
	*/
	bool has_cf() const;
	//! Function to reset cf to its default/unset value.
	void clear_cf();
	//! Get value of cf.
	int8_t cf() const;
	//! Set cf using a constant reference
	void set_cf(int8_t v);
	/*!
	* Provide mutable access to cf.
	* @return pointer to member variable of cf.
	*/
	int8_t *mutable_cf();
	
	// optional sint8 cf1, id 4
	/*!
	* Function for querying if cf1 has been set.
	* @return true if cf1 is set.
	*/
	bool has_cf1() const;
	//! Function to reset cf1 to its default/unset value.
	void clear_cf1();
	//! Get value of cf1.
	int8_t cf1() const;
	//! Set cf1 using a constant reference
	void set_cf1(int8_t v);
	/*!
	* Provide mutable access to cf1.
	* @return pointer to member variable of cf1.
	*/
	int8_t *mutable_cf1();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 sel, id 2
	int8_t m_sel = -1;
	//! sint8 cf, id 3
	int8_t m_cf = -1;
	//! sint8 cf1, id 4
	int8_t m_cf1 = -1;
};




class SX1276Config : public Message
{
	public:
	SX1276Config()
	{
	}
	
	bool operator != (const SX1276Config &r) const;
	bool operator == (const SX1276Config &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 dio0, id 1
	/*!
	* Function for querying if dio0 has been set.
	* @return true if dio0 is set.
	*/
	bool has_dio0() const;
	//! Function to reset dio0 to its default/unset value.
	void clear_dio0();
	//! Get value of dio0.
	int8_t dio0() const;
	//! Set dio0 using a constant reference
	void set_dio0(int8_t v);
	/*!
	* Provide mutable access to dio0.
	* @return pointer to member variable of dio0.
	*/
	int8_t *mutable_dio0();
	
	// optional sint8 dio1, id 2
	/*!
	* Function for querying if dio1 has been set.
	* @return true if dio1 is set.
	*/
	bool has_dio1() const;
	//! Function to reset dio1 to its default/unset value.
	void clear_dio1();
	//! Get value of dio1.
	int8_t dio1() const;
	//! Set dio1 using a constant reference
	void set_dio1(int8_t v);
	/*!
	* Provide mutable access to dio1.
	* @return pointer to member variable of dio1.
	*/
	int8_t *mutable_dio1();
	
	// optional sint8 dio2, id 3
	/*!
	* Function for querying if dio2 has been set.
	* @return true if dio2 is set.
	*/
	bool has_dio2() const;
	//! Function to reset dio2 to its default/unset value.
	void clear_dio2();
	//! Get value of dio2.
	int8_t dio2() const;
	//! Set dio2 using a constant reference
	void set_dio2(int8_t v);
	/*!
	* Provide mutable access to dio2.
	* @return pointer to member variable of dio2.
	*/
	int8_t *mutable_dio2();
	
	// optional sint8 dio3, id 4
	/*!
	* Function for querying if dio3 has been set.
	* @return true if dio3 is set.
	*/
	bool has_dio3() const;
	//! Function to reset dio3 to its default/unset value.
	void clear_dio3();
	//! Get value of dio3.
	int8_t dio3() const;
	//! Set dio3 using a constant reference
	void set_dio3(int8_t v);
	/*!
	* Provide mutable access to dio3.
	* @return pointer to member variable of dio3.
	*/
	int8_t *mutable_dio3();
	
	// optional sint8 dio4, id 5
	/*!
	* Function for querying if dio4 has been set.
	* @return true if dio4 is set.
	*/
	bool has_dio4() const;
	//! Function to reset dio4 to its default/unset value.
	void clear_dio4();
	//! Get value of dio4.
	int8_t dio4() const;
	//! Set dio4 using a constant reference
	void set_dio4(int8_t v);
	/*!
	* Provide mutable access to dio4.
	* @return pointer to member variable of dio4.
	*/
	int8_t *mutable_dio4();
	
	// optional sint8 dio5, id 6
	/*!
	* Function for querying if dio5 has been set.
	* @return true if dio5 is set.
	*/
	bool has_dio5() const;
	//! Function to reset dio5 to its default/unset value.
	void clear_dio5();
	//! Get value of dio5.
	int8_t dio5() const;
	//! Set dio5 using a constant reference
	void set_dio5(int8_t v);
	/*!
	* Provide mutable access to dio5.
	* @return pointer to member variable of dio5.
	*/
	int8_t *mutable_dio5();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 dio0, id 1
	int8_t m_dio0 = -1;
	//! sint8 dio1, id 2
	int8_t m_dio1 = -1;
	//! sint8 dio2, id 3
	int8_t m_dio2 = -1;
	//! sint8 dio3, id 4
	int8_t m_dio3 = -1;
	//! sint8 dio4, id 5
	int8_t m_dio4 = -1;
	//! sint8 dio5, id 6
	int8_t m_dio5 = -1;
};




class Tone : public Message
{
	public:
	Tone()
	{
	}
	
	bool operator != (const Tone &r) const;
	bool operator == (const Tone &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional unsigned freq, id 1
	/*!
	* Function for querying if freq has been set.
	* @return true if freq is set.
	*/
	bool has_freq() const;
	//! Function to reset freq to its default/unset value.
	void clear_freq();
	//! Get value of freq.
	uint64_t freq() const;
	//! Set freq using a constant reference
	void set_freq(uint64_t v);
	/*!
	* Provide mutable access to freq.
	* @return pointer to member variable of freq.
	*/
	uint64_t *mutable_freq();
	
	// optional unsigned duration, id 2
	/*!
	* Function for querying if duration has been set.
	* @return true if duration is set.
	*/
	bool has_duration() const;
	//! Function to reset duration to its default/unset value.
	void clear_duration();
	//! Get value of duration.
	uint64_t duration() const;
	//! Set duration using a constant reference
	void set_duration(uint64_t v);
	/*!
	* Provide mutable access to duration.
	* @return pointer to member variable of duration.
	*/
	uint64_t *mutable_duration();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! unsigned freq, id 1
	uint64_t m_freq = 0;
	//! unsigned duration, id 2
	uint64_t m_duration = 0;
	
	private:
	uint8_t p_validbits = 0;
};




class Melody : public Message
{
	public:
	Melody()
	{
	}
	
	bool operator != (const Melody &r) const;
	bool operator == (const Melody &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const std::string &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const std::string &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	std::string *mutable_name();
	
	// repeated fixed16 tones, id 2
	//! Function get const-access to the elements of tones.
	const std::vector<uint16_t> &tones() const;
	//! Function to get the number of elements in tones.
	size_t tones_size() const;
	/*!
	* Function to append a element to tones.
	* @return point to newly added element.
	*/
	void add_tones(uint16_t v);
	//! Function to reset tones to its default/unset value.
	void clear_tones();
	//! Get value of element x of tones.
	uint16_t tones(unsigned x) const;
	//! Set tones using a constant reference
	void set_tones(unsigned x, uint16_t v);
	/*!
	* Provide mutable access to tones.
	* @return pointer to member variable of tones.
	*/
	uint16_t *mutable_tones(unsigned x);
	//! Function to get mutable access to all elements of tones.
	std::vector<uint16_t> *mutable_tones();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	std::string m_name;
	//! fixed16 tones, id 2
	std::vector<uint16_t> m_tones;
};




class BuzzerConfig : public Message
{
	public:
	BuzzerConfig()
	{
	}
	
	bool operator != (const BuzzerConfig &r) const;
	bool operator == (const BuzzerConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 gpio, id 1
	/*!
	* Function for querying if gpio has been set.
	* @return true if gpio is set.
	*/
	bool has_gpio() const;
	//! Function to reset gpio to its default/unset value.
	void clear_gpio();
	//! Get value of gpio.
	int8_t gpio() const;
	//! Set gpio using a constant reference
	void set_gpio(int8_t v);
	/*!
	* Provide mutable access to gpio.
	* @return pointer to member variable of gpio.
	*/
	int8_t *mutable_gpio();
	
	// repeated Melody melodies, id 2
	//! Function get const-access to the elements of melodies.
	const std::vector<Melody> &melodies() const;
	//! Function to get the number of elements in melodies.
	size_t melodies_size() const;
	/*!
	* Function to append a element to melodies.
	* @return point to newly added element.
	*/
	Melody* add_melodies();
	//! Function to reset melodies to its default/unset value.
	void clear_melodies();
	//! Get value of element x of melodies.
	const Melody &melodies(unsigned x) const;
	//! Set melodies using a constant reference
	void set_melodies(unsigned x, const Melody &v);
	/*!
	* Provide mutable access to melodies.
	* @return pointer to member variable of melodies.
	*/
	Melody *mutable_melodies(unsigned x);
	//! Function to get mutable access to all elements of melodies.
	std::vector<Melody> *mutable_melodies();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! sint8 gpio, id 1
	int8_t m_gpio = -1;
	//! Melody melodies, id 2
	std::vector<Melody> m_melodies;
};




class HardwareConfig : public Message
{
	public:
	HardwareConfig()
	{
	}
	
	bool operator != (const HardwareConfig &r) const;
	bool operator == (const HardwareConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Serialize the object using a function for transmitting individual bytes.
	* @param put function to put individual bytes for transmission on the wire
	*/
	void toWire(void (*put)(uint8_t)) const;
	
	//! Function for serializing the object to a string.
	void toString(std::string &put) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(std::ostream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(std::ostream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional fixed32 magic, id 0
	/*!
	* Function for querying if magic has been set.
	* @return true if magic is set.
	*/
	bool has_magic() const;
	//! Function to reset magic to its default/unset value.
	void clear_magic();
	//! Get value of magic.
	uint32_t magic() const;
	//! Set magic using a constant reference
	void set_magic(uint32_t v);
	/*!
	* Provide mutable access to magic.
	* @return pointer to member variable of magic.
	*/
	uint32_t *mutable_magic();
	
	// optional SystemConfig system, id 1
	/*!
	* Function for querying if system has been set.
	* @return true if system is set.
	*/
	bool has_system() const;
	//! Function to reset system to its default/unset value.
	void clear_system();
	//! Get value of system.
	const SystemConfig &system() const;
	/*!
	* Function for setting members of system using data from a serialized object.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_system(const void *data, size_t s);
	//! Set system using a constant reference
	void set_system(const SystemConfig &v);
	/*!
	* Provide mutable access to system.
	* @return pointer to member variable of system.
	*/
	SystemConfig *mutable_system();
	
	// repeated UartConfig uart, id 3
	//! Function get const-access to the elements of uart.
	const std::vector<UartConfig> &uart() const;
	//! Function to get the number of elements in uart.
	size_t uart_size() const;
	/*!
	* Function to append a element to uart.
	* @return point to newly added element.
	*/
	UartConfig* add_uart();
	//! Function to reset uart to its default/unset value.
	void clear_uart();
	//! Get value of element x of uart.
	const UartConfig &uart(unsigned x) const;
	//! Set uart using a constant reference
	void set_uart(unsigned x, const UartConfig &v);
	/*!
	* Provide mutable access to uart.
	* @return pointer to member variable of uart.
	*/
	UartConfig *mutable_uart(unsigned x);
	//! Function to get mutable access to all elements of uart.
	std::vector<UartConfig> *mutable_uart();
	
	// optional AdcConfig adc, id 4
	/*!
	* Function for querying if adc has been set.
	* @return true if adc is set.
	*/
	bool has_adc() const;
	//! Function to reset adc to its default/unset value.
	void clear_adc();
	//! Get value of adc.
	const AdcConfig &adc() const;
	/*!
	* Function for setting adc using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_adc(const void *data, size_t s);
	//! Set adc using a constant reference
	void set_adc(const AdcConfig &v);
	/*!
	* Provide mutable access to adc.
	* @return pointer to member variable of adc.
	*/
	AdcConfig *mutable_adc();
	
	#ifdef CONFIG_TOUCHPAD
	// optional TouchpadConfig touchpad, id 5
	/*!
	* Function for querying if touchpad has been set.
	* @return true if touchpad is set.
	*/
	bool has_touchpad() const;
	//! Function to reset touchpad to its default/unset value.
	void clear_touchpad();
	//! Get value of touchpad.
	const TouchpadConfig &touchpad() const;
	/*!
	* Function for setting touchpad using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_touchpad(const void *data, size_t s);
	//! Set touchpad using a constant reference
	void set_touchpad(const TouchpadConfig &v);
	/*!
	* Provide mutable access to touchpad.
	* @return pointer to member variable of touchpad.
	*/
	TouchpadConfig *mutable_touchpad();
	#endif // CONFIG_TOUCHPAD
	
	#ifdef CONFIG_TOUCHPAD
	// repeated TouchChannelConfig tp_channel, id 6
	//! Function get const-access to the elements of tp_channel.
	const std::vector<TouchChannelConfig> &tp_channel() const;
	//! Function to get the number of elements in tp_channel.
	size_t tp_channel_size() const;
	/*!
	* Function to append a element to tp_channel.
	* @return point to newly added element.
	*/
	TouchChannelConfig* add_tp_channel();
	//! Function to reset tp_channel to its default/unset value.
	void clear_tp_channel();
	//! Get value of element x of tp_channel.
	const TouchChannelConfig &tp_channel(unsigned x) const;
	//! Set tp_channel using a constant reference
	void set_tp_channel(unsigned x, const TouchChannelConfig &v);
	/*!
	* Provide mutable access to tp_channel.
	* @return pointer to member variable of tp_channel.
	*/
	TouchChannelConfig *mutable_tp_channel(unsigned x);
	//! Function to get mutable access to all elements of tp_channel.
	std::vector<TouchChannelConfig> *mutable_tp_channel();
	#endif // CONFIG_TOUCHPAD
	
	// repeated GpioConfig gpios, id 7
	//! Function get const-access to the elements of gpios.
	const std::vector<GpioConfig> &gpios() const;
	//! Function to get the number of elements in gpios.
	size_t gpios_size() const;
	/*!
	* Function to append a element to gpios.
	* @return point to newly added element.
	*/
	GpioConfig* add_gpios();
	//! Function to reset gpios to its default/unset value.
	void clear_gpios();
	//! Get value of element x of gpios.
	const GpioConfig &gpios(unsigned x) const;
	//! Set gpios using a constant reference
	void set_gpios(unsigned x, const GpioConfig &v);
	/*!
	* Provide mutable access to gpios.
	* @return pointer to member variable of gpios.
	*/
	GpioConfig *mutable_gpios(unsigned x);
	//! Function to get mutable access to all elements of gpios.
	std::vector<GpioConfig> *mutable_gpios();
	
	#ifdef CONFIG_SPI
	// repeated SpiBusConfig spibus, id 8
	//! Function get const-access to the elements of spibus.
	const std::vector<SpiBusConfig> &spibus() const;
	//! Function to get the number of elements in spibus.
	size_t spibus_size() const;
	/*!
	* Function to append a element to spibus.
	* @return point to newly added element.
	*/
	SpiBusConfig* add_spibus();
	//! Function to reset spibus to its default/unset value.
	void clear_spibus();
	//! Get value of element x of spibus.
	const SpiBusConfig &spibus(unsigned x) const;
	//! Set spibus using a constant reference
	void set_spibus(unsigned x, const SpiBusConfig &v);
	/*!
	* Provide mutable access to spibus.
	* @return pointer to member variable of spibus.
	*/
	SpiBusConfig *mutable_spibus(unsigned x);
	//! Function to get mutable access to all elements of spibus.
	std::vector<SpiBusConfig> *mutable_spibus();
	#endif // CONFIG_SPI
	
	#ifdef CONFIG_BUTTON
	// repeated ButtonConfig button, id 16
	//! Function get const-access to the elements of button.
	const std::vector<ButtonConfig> &button() const;
	//! Function to get the number of elements in button.
	size_t button_size() const;
	/*!
	* Function to append a element to button.
	* @return point to newly added element.
	*/
	ButtonConfig* add_button();
	//! Function to reset button to its default/unset value.
	void clear_button();
	//! Get value of element x of button.
	const ButtonConfig &button(unsigned x) const;
	//! Set button using a constant reference
	void set_button(unsigned x, const ButtonConfig &v);
	/*!
	* Provide mutable access to button.
	* @return pointer to member variable of button.
	*/
	ButtonConfig *mutable_button(unsigned x);
	//! Function to get mutable access to all elements of button.
	std::vector<ButtonConfig> *mutable_button();
	#endif // CONFIG_BUTTON
	
	#ifdef CONFIG_RELAY
	// repeated RelayConfig relay, id 17
	//! Function get const-access to the elements of relay.
	const std::vector<RelayConfig> &relay() const;
	//! Function to get the number of elements in relay.
	size_t relay_size() const;
	/*!
	* Function to append a element to relay.
	* @return point to newly added element.
	*/
	RelayConfig* add_relay();
	//! Function to reset relay to its default/unset value.
	void clear_relay();
	//! Get value of element x of relay.
	const RelayConfig &relay(unsigned x) const;
	//! Set relay using a constant reference
	void set_relay(unsigned x, const RelayConfig &v);
	/*!
	* Provide mutable access to relay.
	* @return pointer to member variable of relay.
	*/
	RelayConfig *mutable_relay(unsigned x);
	//! Function to get mutable access to all elements of relay.
	std::vector<RelayConfig> *mutable_relay();
	#endif // CONFIG_RELAY
	
	#ifdef CONFIG_LEDS
	// repeated LedConfig led, id 18
	//! Function get const-access to the elements of led.
	const std::vector<LedConfig> &led() const;
	//! Function to get the number of elements in led.
	size_t led_size() const;
	/*!
	* Function to append a element to led.
	* @return point to newly added element.
	*/
	LedConfig* add_led();
	//! Function to reset led to its default/unset value.
	void clear_led();
	//! Get value of element x of led.
	const LedConfig &led(unsigned x) const;
	//! Set led using a constant reference
	void set_led(unsigned x, const LedConfig &v);
	/*!
	* Provide mutable access to led.
	* @return pointer to member variable of led.
	*/
	LedConfig *mutable_led(unsigned x);
	//! Function to get mutable access to all elements of led.
	std::vector<LedConfig> *mutable_led();
	#endif // CONFIG_LEDS
	
	#ifdef CONFIG_BUZZER
	// optional BuzzerConfig buzzer, id 19
	/*!
	* Function for querying if buzzer has been set.
	* @return true if buzzer is set.
	*/
	bool has_buzzer() const;
	//! Function to reset buzzer to its default/unset value.
	void clear_buzzer();
	//! Get value of buzzer.
	const BuzzerConfig &buzzer() const;
	/*!
	* Function for setting buzzer using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_buzzer(const void *data, size_t s);
	//! Set buzzer using a constant reference
	void set_buzzer(const BuzzerConfig &v);
	/*!
	* Provide mutable access to buzzer.
	* @return pointer to member variable of buzzer.
	*/
	BuzzerConfig *mutable_buzzer();
	#endif // CONFIG_BUZZER
	
	#ifdef CONFIG_HLW8012
	// optional Hlw8012Config hlw8012, id 20
	/*!
	* Function for querying if hlw8012 has been set.
	* @return true if hlw8012 is set.
	*/
	bool has_hlw8012() const;
	//! Function to reset hlw8012 to its default/unset value.
	void clear_hlw8012();
	//! Get value of hlw8012.
	const Hlw8012Config &hlw8012() const;
	/*!
	* Function for setting hlw8012 using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_hlw8012(const void *data, size_t s);
	//! Set hlw8012 using a constant reference
	void set_hlw8012(const Hlw8012Config &v);
	/*!
	* Provide mutable access to hlw8012.
	* @return pointer to member variable of hlw8012.
	*/
	Hlw8012Config *mutable_hlw8012();
	#endif // CONFIG_HLW8012
	
	#ifdef CONFIG_MAX7219
	// optional Max7219Config max7219, id 32
	/*!
	* Function for querying if max7219 has been set.
	* @return true if max7219 is set.
	*/
	bool has_max7219() const;
	//! Function to reset max7219 to its default/unset value.
	void clear_max7219();
	//! Get value of max7219.
	const Max7219Config &max7219() const;
	/*!
	* Function for setting max7219 using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_max7219(const void *data, size_t s);
	//! Set max7219 using a constant reference
	void set_max7219(const Max7219Config &v);
	/*!
	* Provide mutable access to max7219.
	* @return pointer to member variable of max7219.
	*/
	Max7219Config *mutable_max7219();
	#endif // CONFIG_MAX7219
	
	#ifdef CONFIG_TLC5947
	// optional Tlc5947Config tlc5947, id 33
	/*!
	* Function for querying if tlc5947 has been set.
	* @return true if tlc5947 is set.
	*/
	bool has_tlc5947() const;
	//! Function to reset tlc5947 to its default/unset value.
	void clear_tlc5947();
	//! Get value of tlc5947.
	const Tlc5947Config &tlc5947() const;
	/*!
	* Function for setting tlc5947 using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_tlc5947(const void *data, size_t s);
	//! Set tlc5947 using a constant reference
	void set_tlc5947(const Tlc5947Config &v);
	/*!
	* Provide mutable access to tlc5947.
	* @return pointer to member variable of tlc5947.
	*/
	Tlc5947Config *mutable_tlc5947();
	#endif // CONFIG_TLC5947
	
	#ifdef CONFIG_RGBLEDS
	// repeated Ws2812bConfig ws2812b, id 34
	//! Function get const-access to the elements of ws2812b.
	const std::vector<Ws2812bConfig> &ws2812b() const;
	//! Function to get the number of elements in ws2812b.
	size_t ws2812b_size() const;
	/*!
	* Function to append a element to ws2812b.
	* @return point to newly added element.
	*/
	Ws2812bConfig* add_ws2812b();
	//! Function to reset ws2812b to its default/unset value.
	void clear_ws2812b();
	//! Get value of element x of ws2812b.
	const Ws2812bConfig &ws2812b(unsigned x) const;
	//! Set ws2812b using a constant reference
	void set_ws2812b(unsigned x, const Ws2812bConfig &v);
	/*!
	* Provide mutable access to ws2812b.
	* @return pointer to member variable of ws2812b.
	*/
	Ws2812bConfig *mutable_ws2812b(unsigned x);
	//! Function to get mutable access to all elements of ws2812b.
	std::vector<Ws2812bConfig> *mutable_ws2812b();
	#endif // CONFIG_RGBLEDS
	
	#ifdef CONFIG_DHT
	// optional DhtConfig dht, id 35
	/*!
	* Function for querying if dht has been set.
	* @return true if dht is set.
	*/
	bool has_dht() const;
	//! Function to reset dht to its default/unset value.
	void clear_dht();
	//! Get value of dht.
	const DhtConfig &dht() const;
	/*!
	* Function for setting dht using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_dht(const void *data, size_t s);
	//! Set dht using a constant reference
	void set_dht(const DhtConfig &v);
	/*!
	* Provide mutable access to dht.
	* @return pointer to member variable of dht.
	*/
	DhtConfig *mutable_dht();
	#endif // CONFIG_DHT
	
	#ifdef CONFIG_I2C
	// repeated I2CConfig i2c, id 36
	//! Function get const-access to the elements of i2c.
	const std::vector<I2CConfig> &i2c() const;
	//! Function to get the number of elements in i2c.
	size_t i2c_size() const;
	/*!
	* Function to append a element to i2c.
	* @return point to newly added element.
	*/
	I2CConfig* add_i2c();
	//! Function to reset i2c to its default/unset value.
	void clear_i2c();
	//! Get value of element x of i2c.
	const I2CConfig &i2c(unsigned x) const;
	//! Set i2c using a constant reference
	void set_i2c(unsigned x, const I2CConfig &v);
	/*!
	* Provide mutable access to i2c.
	* @return pointer to member variable of i2c.
	*/
	I2CConfig *mutable_i2c(unsigned x);
	//! Function to get mutable access to all elements of i2c.
	std::vector<I2CConfig> *mutable_i2c();
	#endif // CONFIG_I2C
	
	#ifdef CONFIG_HCSR04
	// repeated HcSr04Config hcsr04, id 37
	//! Function get const-access to the elements of hcsr04.
	const std::vector<HcSr04Config> &hcsr04() const;
	//! Function to get the number of elements in hcsr04.
	size_t hcsr04_size() const;
	/*!
	* Function to append a element to hcsr04.
	* @return point to newly added element.
	*/
	HcSr04Config* add_hcsr04();
	//! Function to reset hcsr04 to its default/unset value.
	void clear_hcsr04();
	//! Get value of element x of hcsr04.
	const HcSr04Config &hcsr04(unsigned x) const;
	//! Set hcsr04 using a constant reference
	void set_hcsr04(unsigned x, const HcSr04Config &v);
	/*!
	* Provide mutable access to hcsr04.
	* @return pointer to member variable of hcsr04.
	*/
	HcSr04Config *mutable_hcsr04(unsigned x);
	//! Function to get mutable access to all elements of hcsr04.
	std::vector<HcSr04Config> *mutable_hcsr04();
	#endif // CONFIG_HCSR04
	
	#ifdef CONFIG_ONEWIRE
	// optional OneWireConfig onewire, id 38
	/*!
	* Function for querying if onewire has been set.
	* @return true if onewire is set.
	*/
	bool has_onewire() const;
	//! Function to reset onewire to its default/unset value.
	void clear_onewire();
	//! Get value of onewire.
	const OneWireConfig &onewire() const;
	/*!
	* Function for setting onewire using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_onewire(const void *data, size_t s);
	//! Set onewire using a constant reference
	void set_onewire(const OneWireConfig &v);
	/*!
	* Provide mutable access to onewire.
	* @return pointer to member variable of onewire.
	*/
	OneWireConfig *mutable_onewire();
	#endif // CONFIG_ONEWIRE
	
	#ifdef CONFIG_SX1276
	// optional SX1276Config sx1276, id 39
	/*!
	* Function for querying if sx1276 has been set.
	* @return true if sx1276 is set.
	*/
	bool has_sx1276() const;
	//! Function to reset sx1276 to its default/unset value.
	void clear_sx1276();
	//! Get value of sx1276.
	const SX1276Config &sx1276() const;
	/*!
	* Function for setting sx1276 using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_sx1276(const void *data, size_t s);
	//! Set sx1276 using a constant reference
	void set_sx1276(const SX1276Config &v);
	/*!
	* Provide mutable access to sx1276.
	* @return pointer to member variable of sx1276.
	*/
	SX1276Config *mutable_sx1276();
	#endif // CONFIG_SX1276
	
	#ifdef CONFIG_IOEXTENDERS
	// repeated GpioCluster iocluster, id 40
	//! Function get const-access to the elements of iocluster.
	const std::vector<GpioCluster> &iocluster() const;
	//! Function to get the number of elements in iocluster.
	size_t iocluster_size() const;
	/*!
	* Function to append a element to iocluster.
	* @return point to newly added element.
	*/
	GpioCluster* add_iocluster();
	//! Function to reset iocluster to its default/unset value.
	void clear_iocluster();
	//! Get value of element x of iocluster.
	const GpioCluster &iocluster(unsigned x) const;
	//! Set iocluster using a constant reference
	void set_iocluster(unsigned x, const GpioCluster &v);
	/*!
	* Provide mutable access to iocluster.
	* @return pointer to member variable of iocluster.
	*/
	GpioCluster *mutable_iocluster(unsigned x);
	//! Function to get mutable access to all elements of iocluster.
	std::vector<GpioCluster> *mutable_iocluster();
	#endif // CONFIG_IOEXTENDERS
	
	#ifdef CONFIG_DISPLAY
	// optional DisplayConfig display, id 50
	/*!
	* Function for querying if display has been set.
	* @return true if display is set.
	*/
	bool has_display() const;
	//! Function to reset display to its default/unset value.
	void clear_display();
	//! Get value of display.
	const DisplayConfig &display() const;
	/*!
	* Function for setting display using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_display(const void *data, size_t s);
	//! Set display using a constant reference
	void set_display(const DisplayConfig &v);
	/*!
	* Provide mutable access to display.
	* @return pointer to member variable of display.
	*/
	DisplayConfig *mutable_display();
	#endif // CONFIG_DISPLAY
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! fixed32 magic, id 0
	uint32_t m_magic = 0;
	//! SystemConfig system, id 1
	SystemConfig m_system;
	//! UartConfig uart, id 3
	std::vector<UartConfig> m_uart;
	//! AdcConfig adc, id 4
	AdcConfig m_adc;
	#ifdef CONFIG_TOUCHPAD
	//! TouchpadConfig touchpad, id 5
	TouchpadConfig m_touchpad;
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	//! TouchChannelConfig tp_channel, id 6
	std::vector<TouchChannelConfig> m_tp_channel;
	#endif // CONFIG_TOUCHPAD
	//! GpioConfig gpios, id 7
	std::vector<GpioConfig> m_gpios;
	#ifdef CONFIG_SPI
	//! SpiBusConfig spibus, id 8
	std::vector<SpiBusConfig> m_spibus;
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	//! ButtonConfig button, id 16
	std::vector<ButtonConfig> m_button;
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	//! RelayConfig relay, id 17
	std::vector<RelayConfig> m_relay;
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	//! LedConfig led, id 18
	std::vector<LedConfig> m_led;
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	//! BuzzerConfig buzzer, id 19
	BuzzerConfig m_buzzer;
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	//! Hlw8012Config hlw8012, id 20
	Hlw8012Config m_hlw8012;
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	//! Max7219Config max7219, id 32
	Max7219Config m_max7219;
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	//! Tlc5947Config tlc5947, id 33
	Tlc5947Config m_tlc5947;
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	//! Ws2812bConfig ws2812b, id 34
	std::vector<Ws2812bConfig> m_ws2812b;
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	//! DhtConfig dht, id 35
	DhtConfig m_dht;
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	//! I2CConfig i2c, id 36
	std::vector<I2CConfig> m_i2c;
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	//! HcSr04Config hcsr04, id 37
	std::vector<HcSr04Config> m_hcsr04;
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	//! OneWireConfig onewire, id 38
	OneWireConfig m_onewire;
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	//! SX1276Config sx1276, id 39
	SX1276Config m_sx1276;
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	//! GpioCluster iocluster, id 40
	std::vector<GpioCluster> m_iocluster;
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	//! DisplayConfig display, id 50
	DisplayConfig m_display;
	#endif // CONFIG_DISPLAY
	
	private:
	uint16_t p_validbits = 0;
};


inline size_t SystemConfig::getMaxSize()
{
	// optional string manufacturer, id 1 has unlimited size
	// optional string board_name, id 2 has unlimited size
	// optional string board_rev, id 3 has unlimited size
	// optional sint8 diag_uart, id 4 has maximum size 3
	// optional sint8 console_rx, id 5 has maximum size 3
	// optional sint8 console_tx, id 6 has maximum size 3
	// optional string model_name, id 7 has unlimited size
	// optional string model_number, id 8 has unlimited size
	// optional bool usb_diag, id 9 has maximum size 2
	// optional bool usb_con, id 10 has maximum size 2
	// optional sint8 cc1_gpio, id 11 has maximum size 3
	// optional sint8 cc2_gpio, id 12 has maximum size 3
	return SIZE_MAX;
}

inline const std::string &SystemConfig::manufacturer() const
{
	return m_manufacturer;
}

inline bool SystemConfig::has_manufacturer() const
{
	return !m_manufacturer.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_manufacturer()
{
	m_manufacturer.clear();
}

inline std::string *SystemConfig::mutable_manufacturer()
{
	return &m_manufacturer;
}

inline void SystemConfig::set_manufacturer(const void *data, size_t s)
{
	m_manufacturer.assign((const char *)data,s);
}

inline void SystemConfig::set_manufacturer(const char *data)
{
	m_manufacturer = data;
}

inline void SystemConfig::set_manufacturer(const std::string &v)
{
	m_manufacturer = v;
}



inline const std::string &SystemConfig::board_name() const
{
	return m_board_name;
}

inline bool SystemConfig::has_board_name() const
{
	return !m_board_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_board_name()
{
	m_board_name.clear();
}

inline std::string *SystemConfig::mutable_board_name()
{
	return &m_board_name;
}

inline void SystemConfig::set_board_name(const void *data, size_t s)
{
	m_board_name.assign((const char *)data,s);
}

inline void SystemConfig::set_board_name(const char *data)
{
	m_board_name = data;
}

inline void SystemConfig::set_board_name(const std::string &v)
{
	m_board_name = v;
}



inline const std::string &SystemConfig::board_rev() const
{
	return m_board_rev;
}

inline bool SystemConfig::has_board_rev() const
{
	return !m_board_rev.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_board_rev()
{
	m_board_rev.clear();
}

inline std::string *SystemConfig::mutable_board_rev()
{
	return &m_board_rev;
}

inline void SystemConfig::set_board_rev(const void *data, size_t s)
{
	m_board_rev.assign((const char *)data,s);
}

inline void SystemConfig::set_board_rev(const char *data)
{
	m_board_rev = data;
}

inline void SystemConfig::set_board_rev(const std::string &v)
{
	m_board_rev = v;
}



inline int8_t SystemConfig::diag_uart() const
{
	return m_diag_uart;
}

inline bool SystemConfig::has_diag_uart() const
{
	return m_diag_uart != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_diag_uart()
{
	m_diag_uart = 0;
}

inline int8_t *SystemConfig::mutable_diag_uart()
{
	return &m_diag_uart;
}

inline void SystemConfig::set_diag_uart(int8_t v)
{
	m_diag_uart = v;
}



inline int8_t SystemConfig::console_rx() const
{
	return m_console_rx;
}

inline bool SystemConfig::has_console_rx() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_console_rx()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_console_rx = 0;
}

inline int8_t *SystemConfig::mutable_console_rx()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_console_rx = 0;
	}
	return &m_console_rx;
}

inline void SystemConfig::set_console_rx(int8_t v)
{
	m_console_rx = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline int8_t SystemConfig::console_tx() const
{
	return m_console_tx;
}

inline bool SystemConfig::has_console_tx() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_console_tx()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_console_tx = 0;
}

inline int8_t *SystemConfig::mutable_console_tx()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_console_tx = 0;
	}
	return &m_console_tx;
}

inline void SystemConfig::set_console_tx(int8_t v)
{
	m_console_tx = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline const std::string &SystemConfig::model_name() const
{
	return m_model_name;
}

inline bool SystemConfig::has_model_name() const
{
	return !m_model_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_model_name()
{
	m_model_name.clear();
}

inline std::string *SystemConfig::mutable_model_name()
{
	return &m_model_name;
}

inline void SystemConfig::set_model_name(const void *data, size_t s)
{
	m_model_name.assign((const char *)data,s);
}

inline void SystemConfig::set_model_name(const char *data)
{
	m_model_name = data;
}

inline void SystemConfig::set_model_name(const std::string &v)
{
	m_model_name = v;
}



inline const std::string &SystemConfig::model_number() const
{
	return m_model_number;
}

inline bool SystemConfig::has_model_number() const
{
	return !m_model_number.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_model_number()
{
	m_model_number.clear();
}

inline std::string *SystemConfig::mutable_model_number()
{
	return &m_model_number;
}

inline void SystemConfig::set_model_number(const void *data, size_t s)
{
	m_model_number.assign((const char *)data,s);
}

inline void SystemConfig::set_model_number(const char *data)
{
	m_model_number = data;
}

inline void SystemConfig::set_model_number(const std::string &v)
{
	m_model_number = v;
}



#ifdef CONFIG_USB_DIAGLOG
inline bool SystemConfig::usb_diag() const
{
	return m_usb_diag;
}

inline bool SystemConfig::has_usb_diag() const
{
	return m_usb_diag != true;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_usb_diag()
{
	m_usb_diag = true;
}

inline bool *SystemConfig::mutable_usb_diag()
{
	return &m_usb_diag;
}

inline void SystemConfig::set_usb_diag(bool v)
{
	m_usb_diag = v;
}

#endif // CONFIG_USB_DIAGLOG


#ifdef CONFIG_USB_CONSOLE
inline bool SystemConfig::usb_con() const
{
	return m_usb_con;
}

inline bool SystemConfig::has_usb_con() const
{
	return m_usb_con != true;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_usb_con()
{
	m_usb_con = true;
}

inline bool *SystemConfig::mutable_usb_con()
{
	return &m_usb_con;
}

inline void SystemConfig::set_usb_con(bool v)
{
	m_usb_con = v;
}

#endif // CONFIG_USB_CONSOLE


#ifdef CONFIG_ESP_PHY_ENABLE_USB
inline int8_t SystemConfig::cc1_gpio() const
{
	return m_cc1_gpio;
}

inline bool SystemConfig::has_cc1_gpio() const
{
	return m_cc1_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_cc1_gpio()
{
	m_cc1_gpio = -1;
}

inline int8_t *SystemConfig::mutable_cc1_gpio()
{
	return &m_cc1_gpio;
}

inline void SystemConfig::set_cc1_gpio(int8_t v)
{
	m_cc1_gpio = v;
}

#endif // CONFIG_ESP_PHY_ENABLE_USB


#ifdef CONFIG_ESP_PHY_ENABLE_USB
inline int8_t SystemConfig::cc2_gpio() const
{
	return m_cc2_gpio;
}

inline bool SystemConfig::has_cc2_gpio() const
{
	return m_cc2_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_cc2_gpio()
{
	m_cc2_gpio = -1;
}

inline int8_t *SystemConfig::mutable_cc2_gpio()
{
	return &m_cc2_gpio;
}

inline void SystemConfig::set_cc2_gpio(int8_t v)
{
	m_cc2_gpio = v;
}

#endif // CONFIG_ESP_PHY_ENABLE_USB


inline size_t TouchpadConfig::getMaxSize()
{
	// optional bool fsm_mode, id 1 has maximum size 2
	// optional sint8 lvolt, id 2 has maximum size 3
	// optional sint8 hvolt, id 3 has maximum size 3
	// optional sint8 atten, id 4 has maximum size 3
	// optional unsigned interval, id 7 has maximum size 11
	return 22;
}

inline bool TouchpadConfig::fsm_mode() const
{
	return m_fsm_mode;
}

inline bool TouchpadConfig::has_fsm_mode() const
{
	return m_fsm_mode != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchpadConfig::clear_fsm_mode()
{
	m_fsm_mode = false;
}

inline bool *TouchpadConfig::mutable_fsm_mode()
{
	return &m_fsm_mode;
}

inline void TouchpadConfig::set_fsm_mode(bool v)
{
	m_fsm_mode = v;
}



inline int8_t TouchpadConfig::lvolt() const
{
	return m_lvolt;
}

inline bool TouchpadConfig::has_lvolt() const
{
	return m_lvolt != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchpadConfig::clear_lvolt()
{
	m_lvolt = -1;
}

inline int8_t *TouchpadConfig::mutable_lvolt()
{
	return &m_lvolt;
}

inline void TouchpadConfig::set_lvolt(int8_t v)
{
	m_lvolt = v;
}



inline int8_t TouchpadConfig::hvolt() const
{
	return m_hvolt;
}

inline bool TouchpadConfig::has_hvolt() const
{
	return m_hvolt != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchpadConfig::clear_hvolt()
{
	m_hvolt = -1;
}

inline int8_t *TouchpadConfig::mutable_hvolt()
{
	return &m_hvolt;
}

inline void TouchpadConfig::set_hvolt(int8_t v)
{
	m_hvolt = v;
}



inline int8_t TouchpadConfig::atten() const
{
	return m_atten;
}

inline bool TouchpadConfig::has_atten() const
{
	return m_atten != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchpadConfig::clear_atten()
{
	m_atten = -1;
}

inline int8_t *TouchpadConfig::mutable_atten()
{
	return &m_atten;
}

inline void TouchpadConfig::set_atten(int8_t v)
{
	m_atten = v;
}



inline uint64_t TouchpadConfig::interval() const
{
	return m_interval;
}

inline bool TouchpadConfig::has_interval() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchpadConfig::clear_interval()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_interval = 0;
}

inline uint64_t *TouchpadConfig::mutable_interval()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_interval = 0;
	}
	return &m_interval;
}

inline void TouchpadConfig::set_interval(uint64_t v)
{
	m_interval = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline size_t TouchChannelConfig::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional sint8 channel, id 2 has maximum size 3
	// optional fixed16 threshold, id 3 has maximum size 3
	// optional uint8 slope, id 4 has maximum size 3
	// optional uint8 tieopt, id 5 has maximum size 3
	return SIZE_MAX;
}

inline const std::string &TouchChannelConfig::name() const
{
	return m_name;
}

inline bool TouchChannelConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchChannelConfig::clear_name()
{
	m_name.clear();
}

inline std::string *TouchChannelConfig::mutable_name()
{
	return &m_name;
}

inline void TouchChannelConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void TouchChannelConfig::set_name(const char *data)
{
	m_name = data;
}

inline void TouchChannelConfig::set_name(const std::string &v)
{
	m_name = v;
}



inline int8_t TouchChannelConfig::channel() const
{
	return m_channel;
}

inline bool TouchChannelConfig::has_channel() const
{
	return m_channel != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchChannelConfig::clear_channel()
{
	m_channel = -1;
}

inline int8_t *TouchChannelConfig::mutable_channel()
{
	return &m_channel;
}

inline void TouchChannelConfig::set_channel(int8_t v)
{
	m_channel = v;
}



inline uint16_t TouchChannelConfig::threshold() const
{
	return m_threshold;
}

inline bool TouchChannelConfig::has_threshold() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchChannelConfig::clear_threshold()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_threshold = 0;
}

inline uint16_t *TouchChannelConfig::mutable_threshold()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_threshold = 0;
	}
	return &m_threshold;
}

inline void TouchChannelConfig::set_threshold(uint16_t v)
{
	m_threshold = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline uint8_t TouchChannelConfig::slope() const
{
	return m_slope;
}

inline bool TouchChannelConfig::has_slope() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchChannelConfig::clear_slope()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_slope = 0;
}

inline uint8_t *TouchChannelConfig::mutable_slope()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_slope = 0;
	}
	return &m_slope;
}

inline void TouchChannelConfig::set_slope(uint8_t v)
{
	m_slope = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline uint8_t TouchChannelConfig::tieopt() const
{
	return m_tieopt;
}

inline bool TouchChannelConfig::has_tieopt() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchChannelConfig::clear_tieopt()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_tieopt = 0;
}

inline uint8_t *TouchChannelConfig::mutable_tieopt()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_tieopt = 0;
	}
	return &m_tieopt;
}

inline void TouchChannelConfig::set_tieopt(uint8_t v)
{
	m_tieopt = v;
	p_validbits |= ((uint8_t)1U << 2);
}



inline size_t ButtonConfig::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional sint8 gpio, id 2 has maximum size 3
	// optional bool presslvl, id 3 has maximum size 2
	// optional pull_mode_t pull_mode, id 4 has maximum size 11
	// optional sint8 clk, id 5 has maximum size 3
	// optional sint8 dt, id 6 has maximum size 3
	return SIZE_MAX;
}

inline const std::string &ButtonConfig::name() const
{
	return m_name;
}

inline bool ButtonConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ButtonConfig::clear_name()
{
	m_name.clear();
}

inline std::string *ButtonConfig::mutable_name()
{
	return &m_name;
}

inline void ButtonConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void ButtonConfig::set_name(const char *data)
{
	m_name = data;
}

inline void ButtonConfig::set_name(const std::string &v)
{
	m_name = v;
}



inline int8_t ButtonConfig::gpio() const
{
	return m_gpio;
}

inline bool ButtonConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ButtonConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *ButtonConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void ButtonConfig::set_gpio(int8_t v)
{
	m_gpio = v;
}



inline bool ButtonConfig::presslvl() const
{
	return m_presslvl;
}

inline bool ButtonConfig::has_presslvl() const
{
	return m_presslvl != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ButtonConfig::clear_presslvl()
{
	m_presslvl = 0;
}

inline bool *ButtonConfig::mutable_presslvl()
{
	return &m_presslvl;
}

inline void ButtonConfig::set_presslvl(bool v)
{
	m_presslvl = v;
}



inline pull_mode_t ButtonConfig::pull_mode() const
{
	return m_pull_mode;
}

inline bool ButtonConfig::pull_mode_enable() const
{
	return (bool)((m_pull_mode >> 0) & 0x1);
}

inline bool ButtonConfig::pull_mode_up() const
{
	return (bool)((m_pull_mode >> 1) & 0x1);
}

inline bool ButtonConfig::has_pull_mode() const
{
	return m_pull_mode != pull_none;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ButtonConfig::clear_pull_mode()
{
	m_pull_mode = pull_none;
}

inline pull_mode_t *ButtonConfig::mutable_pull_mode()
{
	return &m_pull_mode;
}

inline void ButtonConfig::set_pull_mode_enable(bool v)
{
	m_pull_mode &= ~(0x1ULL << 0);
	m_pull_mode |= ((uint8_t) v << 0);
}

inline void ButtonConfig::set_pull_mode_up(bool v)
{
	m_pull_mode &= ~(0x1ULL << 1);
	m_pull_mode |= ((uint8_t) v << 1);
}

inline void ButtonConfig::set_pull_mode(pull_mode_t v)
{
	m_pull_mode = v;
}



#ifdef CONFIG_ROTARYENCODER
inline int8_t ButtonConfig::clk() const
{
	return m_clk;
}

inline bool ButtonConfig::has_clk() const
{
	return m_clk != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ButtonConfig::clear_clk()
{
	m_clk = -1;
}

inline int8_t *ButtonConfig::mutable_clk()
{
	return &m_clk;
}

inline void ButtonConfig::set_clk(int8_t v)
{
	m_clk = v;
}

#endif // CONFIG_ROTARYENCODER


#ifdef CONFIG_ROTARYENCODER
inline int8_t ButtonConfig::dt() const
{
	return m_dt;
}

inline bool ButtonConfig::has_dt() const
{
	return m_dt != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ButtonConfig::clear_dt()
{
	m_dt = -1;
}

inline int8_t *ButtonConfig::mutable_dt()
{
	return &m_dt;
}

inline void ButtonConfig::set_dt(int8_t v)
{
	m_dt = v;
}

#endif // CONFIG_ROTARYENCODER


inline size_t RelayConfig::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional sint8 gpio, id 2 has maximum size 3
	// optional relay_cfg_t config, id 3 has maximum size 11
	// optional unsigned min_itv, id 4 has maximum size 11
	// optional sint8 interlock, id 5 has maximum size 3
	return SIZE_MAX;
}

inline const std::string &RelayConfig::name() const
{
	return m_name;
}

inline bool RelayConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void RelayConfig::clear_name()
{
	m_name.clear();
}

inline std::string *RelayConfig::mutable_name()
{
	return &m_name;
}

inline void RelayConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void RelayConfig::set_name(const char *data)
{
	m_name = data;
}

inline void RelayConfig::set_name(const std::string &v)
{
	m_name = v;
}



inline int8_t RelayConfig::gpio() const
{
	return m_gpio;
}

inline bool RelayConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void RelayConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *RelayConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void RelayConfig::set_gpio(int8_t v)
{
	m_gpio = v;
}



inline relay_cfg_t RelayConfig::config() const
{
	return m_config;
}

inline bool RelayConfig::config_active_high() const
{
	return (bool)((m_config >> 0) & 0x1);
}

inline bool RelayConfig::config_init_on() const
{
	return (bool)((m_config >> 1) & 0x1);
}

inline bool RelayConfig::config_persistent() const
{
	return (bool)((m_config >> 2) & 0x1);
}

inline bool RelayConfig::config_opendrain() const
{
	return (bool)((m_config >> 3) & 0x1);
}

inline bool RelayConfig::config_mqtt() const
{
	return (bool)((m_config >> 4) & 0x1);
}

inline bool RelayConfig::has_config() const
{
	return m_config != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void RelayConfig::clear_config()
{
	m_config = 0;
}

inline relay_cfg_t *RelayConfig::mutable_config()
{
	return &m_config;
}

inline void RelayConfig::set_config_active_high(bool v)
{
	m_config &= ~(0x1ULL << 0);
	m_config |= ((uint8_t) v << 0);
}

inline void RelayConfig::set_config_init_on(bool v)
{
	m_config &= ~(0x1ULL << 1);
	m_config |= ((uint8_t) v << 1);
}

inline void RelayConfig::set_config_persistent(bool v)
{
	m_config &= ~(0x1ULL << 2);
	m_config |= ((uint8_t) v << 2);
}

inline void RelayConfig::set_config_opendrain(bool v)
{
	m_config &= ~(0x1ULL << 3);
	m_config |= ((uint8_t) v << 3);
}

inline void RelayConfig::set_config_mqtt(bool v)
{
	m_config &= ~(0x1ULL << 4);
	m_config |= ((uint8_t) v << 4);
}

inline void RelayConfig::set_config(relay_cfg_t v)
{
	m_config = v;
}



inline uint64_t RelayConfig::min_itv() const
{
	return m_min_itv;
}

inline bool RelayConfig::has_min_itv() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void RelayConfig::clear_min_itv()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_min_itv = 0;
}

inline uint64_t *RelayConfig::mutable_min_itv()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_min_itv = 0;
	}
	return &m_min_itv;
}

inline void RelayConfig::set_min_itv(uint64_t v)
{
	m_min_itv = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline int8_t RelayConfig::interlock() const
{
	return m_interlock;
}

inline bool RelayConfig::has_interlock() const
{
	return m_interlock != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void RelayConfig::clear_interlock()
{
	m_interlock = -1;
}

inline int8_t *RelayConfig::mutable_interlock()
{
	return &m_interlock;
}

inline void RelayConfig::set_interlock(int8_t v)
{
	m_interlock = v;
}



inline size_t Max7219Config::getMaxSize()
{
	// optional sint8 clk, id 1 has maximum size 3
	// optional sint8 dout, id 2 has maximum size 3
	// optional sint8 cs, id 3 has maximum size 3
	// optional bool odrain, id 4 has maximum size 2
	// optional uint8 digits, id 5 has maximum size 3
	return 14;
}

inline int8_t Max7219Config::clk() const
{
	return m_clk;
}

inline bool Max7219Config::has_clk() const
{
	return m_clk != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Max7219Config::clear_clk()
{
	m_clk = -1;
}

inline int8_t *Max7219Config::mutable_clk()
{
	return &m_clk;
}

inline void Max7219Config::set_clk(int8_t v)
{
	m_clk = v;
}



inline int8_t Max7219Config::dout() const
{
	return m_dout;
}

inline bool Max7219Config::has_dout() const
{
	return m_dout != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Max7219Config::clear_dout()
{
	m_dout = -1;
}

inline int8_t *Max7219Config::mutable_dout()
{
	return &m_dout;
}

inline void Max7219Config::set_dout(int8_t v)
{
	m_dout = v;
}



inline int8_t Max7219Config::cs() const
{
	return m_cs;
}

inline bool Max7219Config::has_cs() const
{
	return m_cs != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Max7219Config::clear_cs()
{
	m_cs = -1;
}

inline int8_t *Max7219Config::mutable_cs()
{
	return &m_cs;
}

inline void Max7219Config::set_cs(int8_t v)
{
	m_cs = v;
}



inline bool Max7219Config::odrain() const
{
	return m_odrain;
}

inline bool Max7219Config::has_odrain() const
{
	return m_odrain != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Max7219Config::clear_odrain()
{
	m_odrain = false;
}

inline bool *Max7219Config::mutable_odrain()
{
	return &m_odrain;
}

inline void Max7219Config::set_odrain(bool v)
{
	m_odrain = v;
}



inline uint8_t Max7219Config::digits() const
{
	return m_digits;
}

inline bool Max7219Config::has_digits() const
{
	return m_digits != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Max7219Config::clear_digits()
{
	m_digits = 0;
}

inline uint8_t *Max7219Config::mutable_digits()
{
	return &m_digits;
}

inline void Max7219Config::set_digits(uint8_t v)
{
	m_digits = v;
}



inline size_t Tlc5947Config::getMaxSize()
{
	// optional sint8 sin, id 1 has maximum size 3
	// optional sint8 sclk, id 2 has maximum size 3
	// optional sint8 xlat, id 3 has maximum size 3
	// optional sint8 blank, id 4 has maximum size 3
	// optional uint8 ntlc, id 5 has maximum size 3
	return 15;
}

inline int8_t Tlc5947Config::sin() const
{
	return m_sin;
}

inline bool Tlc5947Config::has_sin() const
{
	return m_sin != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tlc5947Config::clear_sin()
{
	m_sin = -1;
}

inline int8_t *Tlc5947Config::mutable_sin()
{
	return &m_sin;
}

inline void Tlc5947Config::set_sin(int8_t v)
{
	m_sin = v;
}



inline int8_t Tlc5947Config::sclk() const
{
	return m_sclk;
}

inline bool Tlc5947Config::has_sclk() const
{
	return m_sclk != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tlc5947Config::clear_sclk()
{
	m_sclk = -1;
}

inline int8_t *Tlc5947Config::mutable_sclk()
{
	return &m_sclk;
}

inline void Tlc5947Config::set_sclk(int8_t v)
{
	m_sclk = v;
}



inline int8_t Tlc5947Config::xlat() const
{
	return m_xlat;
}

inline bool Tlc5947Config::has_xlat() const
{
	return m_xlat != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tlc5947Config::clear_xlat()
{
	m_xlat = -1;
}

inline int8_t *Tlc5947Config::mutable_xlat()
{
	return &m_xlat;
}

inline void Tlc5947Config::set_xlat(int8_t v)
{
	m_xlat = v;
}



inline int8_t Tlc5947Config::blank() const
{
	return m_blank;
}

inline bool Tlc5947Config::has_blank() const
{
	return m_blank != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tlc5947Config::clear_blank()
{
	m_blank = -1;
}

inline int8_t *Tlc5947Config::mutable_blank()
{
	return &m_blank;
}

inline void Tlc5947Config::set_blank(int8_t v)
{
	m_blank = v;
}



inline uint8_t Tlc5947Config::ntlc() const
{
	return m_ntlc;
}

inline bool Tlc5947Config::has_ntlc() const
{
	return m_ntlc != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tlc5947Config::clear_ntlc()
{
	m_ntlc = 0;
}

inline uint8_t *Tlc5947Config::mutable_ntlc()
{
	return &m_ntlc;
}

inline void Tlc5947Config::set_ntlc(uint8_t v)
{
	m_ntlc = v;
}



inline size_t Ws2812bConfig::getMaxSize()
{
	// optional sint8 gpio, id 1 has maximum size 3
	// optional sint8 ch, id 2 has maximum size 3
	// optional uint8 nleds, id 3 has maximum size 3
	// optional string name, id 4 has unlimited size
	return SIZE_MAX;
}

inline int8_t Ws2812bConfig::gpio() const
{
	return m_gpio;
}

inline bool Ws2812bConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Ws2812bConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *Ws2812bConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void Ws2812bConfig::set_gpio(int8_t v)
{
	m_gpio = v;
}



inline int8_t Ws2812bConfig::ch() const
{
	return m_ch;
}

inline bool Ws2812bConfig::has_ch() const
{
	return m_ch != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Ws2812bConfig::clear_ch()
{
	m_ch = -1;
}

inline int8_t *Ws2812bConfig::mutable_ch()
{
	return &m_ch;
}

inline void Ws2812bConfig::set_ch(int8_t v)
{
	m_ch = v;
}



inline uint8_t Ws2812bConfig::nleds() const
{
	return m_nleds;
}

inline bool Ws2812bConfig::has_nleds() const
{
	return m_nleds != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Ws2812bConfig::clear_nleds()
{
	m_nleds = 0;
}

inline uint8_t *Ws2812bConfig::mutable_nleds()
{
	return &m_nleds;
}

inline void Ws2812bConfig::set_nleds(uint8_t v)
{
	m_nleds = v;
}



inline const std::string &Ws2812bConfig::name() const
{
	return m_name;
}

inline bool Ws2812bConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Ws2812bConfig::clear_name()
{
	m_name.clear();
}

inline std::string *Ws2812bConfig::mutable_name()
{
	return &m_name;
}

inline void Ws2812bConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void Ws2812bConfig::set_name(const char *data)
{
	m_name = data;
}

inline void Ws2812bConfig::set_name(const std::string &v)
{
	m_name = v;
}



inline size_t DhtConfig::getMaxSize()
{
	// optional dht_model_t model, id 1 has maximum size 3
	// optional sint8 gpio, id 2 has maximum size 3
	return 6;
}

inline dht_model_t DhtConfig::model() const
{
	return m_model;
}

inline bool DhtConfig::has_model() const
{
	return m_model != DHT_NONE;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DhtConfig::clear_model()
{
	m_model = DHT_NONE;
}

inline dht_model_t *DhtConfig::mutable_model()
{
	return &m_model;
}

inline void DhtConfig::set_model(dht_model_t v)
{
	m_model = v;
}



inline int8_t DhtConfig::gpio() const
{
	return m_gpio;
}

inline bool DhtConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DhtConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *DhtConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void DhtConfig::set_gpio(int8_t v)
{
	m_gpio = v;
}



inline size_t I2CConfig::getMaxSize()
{
	// optional uint8 port, id 1 has maximum size 3
	// optional sint8 sda, id 2 has maximum size 3
	// optional sint8 scl, id 3 has maximum size 3
	// optional unsigned freq, id 4 has maximum size 11
	// optional bool xpullup, id 5 has maximum size 2
	// repeated i2cdev_t devices, id 6 has unlimited size
	return SIZE_MAX;
}

inline uint8_t I2CConfig::port() const
{
	return m_port;
}

inline bool I2CConfig::has_port() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void I2CConfig::clear_port()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_port = 0;
}

inline uint8_t *I2CConfig::mutable_port()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_port = 0;
	}
	return &m_port;
}

inline void I2CConfig::set_port(uint8_t v)
{
	m_port = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline int8_t I2CConfig::sda() const
{
	return m_sda;
}

inline bool I2CConfig::has_sda() const
{
	return m_sda != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void I2CConfig::clear_sda()
{
	m_sda = -1;
}

inline int8_t *I2CConfig::mutable_sda()
{
	return &m_sda;
}

inline void I2CConfig::set_sda(int8_t v)
{
	m_sda = v;
}



inline int8_t I2CConfig::scl() const
{
	return m_scl;
}

inline bool I2CConfig::has_scl() const
{
	return m_scl != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void I2CConfig::clear_scl()
{
	m_scl = -1;
}

inline int8_t *I2CConfig::mutable_scl()
{
	return &m_scl;
}

inline void I2CConfig::set_scl(int8_t v)
{
	m_scl = v;
}



inline uint64_t I2CConfig::freq() const
{
	return m_freq;
}

inline bool I2CConfig::has_freq() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void I2CConfig::clear_freq()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_freq = 100000;
}

inline uint64_t *I2CConfig::mutable_freq()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_freq = 100000;
	}
	return &m_freq;
}

inline void I2CConfig::set_freq(uint64_t v)
{
	m_freq = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline bool I2CConfig::xpullup() const
{
	return m_xpullup;
}

inline bool I2CConfig::has_xpullup() const
{
	return m_xpullup != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void I2CConfig::clear_xpullup()
{
	m_xpullup = false;
}

inline bool *I2CConfig::mutable_xpullup()
{
	return &m_xpullup;
}

inline void I2CConfig::set_xpullup(bool v)
{
	m_xpullup = v;
}



#ifdef CONFIG_I2C_XDEV
inline i2cdev_t I2CConfig::devices(unsigned x) const
{
	return m_devices[x];
}

inline const std::vector<i2cdev_t> &I2CConfig::devices() const
{
	return m_devices;
}

inline uint8_t I2CConfig::devices_addr(unsigned x) const
{
	return (uint8_t)((m_devices[x] >> 0) & 0x7f);
}

inline i2cdrv_t I2CConfig::devices_drv(unsigned x) const
{
	return (i2cdrv_t)((m_devices[x] >> 8) & 0xff);
}

inline uint8_t I2CConfig::devices_intr(unsigned x) const
{
	return (uint8_t)((m_devices[x] >> 16) & 0x3f);
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void I2CConfig::clear_devices()
{
	m_devices.clear();
}

inline i2cdev_t *I2CConfig::mutable_devices(unsigned x)
{
	if (x >= m_devices.size())
		m_devices.resize(x+1);
	return &m_devices[x];
}

inline std::vector<i2cdev_t> *I2CConfig::mutable_devices()
{
	return &m_devices;
}

inline void I2CConfig::set_devices_addr(unsigned x, uint8_t v)
{
	m_devices[x] &= ~(0x7fULL << 0);
	m_devices[x] |= ((uint32_t) v << 0);
}

inline void I2CConfig::set_devices_drv(unsigned x, i2cdrv_t v)
{
	m_devices[x] &= ~(0xffULL << 8);
	m_devices[x] |= ((uint32_t) v << 8);
}

inline void I2CConfig::set_devices_intr(unsigned x, uint8_t v)
{
	m_devices[x] &= ~(0x3fULL << 16);
	m_devices[x] |= ((uint32_t) v << 16);
}

inline void I2CConfig::add_devices(i2cdev_t v)
{
	m_devices.push_back(v);
}

inline void I2CConfig::set_devices(unsigned x, i2cdev_t v)
{
	assert(x < m_devices.size());
	m_devices[x] = v;
}

inline size_t I2CConfig::devices_size() const
{
	return m_devices.size();
}

#endif // CONFIG_I2C_XDEV


inline size_t HcSr04Config::getMaxSize()
{
	// optional sint8 trigger, id 1 has maximum size 3
	// optional sint8 echo, id 2 has maximum size 3
	// optional string name, id 3 has unlimited size
	return SIZE_MAX;
}

inline int8_t HcSr04Config::trigger() const
{
	return m_trigger;
}

inline bool HcSr04Config::has_trigger() const
{
	return m_trigger != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HcSr04Config::clear_trigger()
{
	m_trigger = -1;
}

inline int8_t *HcSr04Config::mutable_trigger()
{
	return &m_trigger;
}

inline void HcSr04Config::set_trigger(int8_t v)
{
	m_trigger = v;
}



inline int8_t HcSr04Config::echo() const
{
	return m_echo;
}

inline bool HcSr04Config::has_echo() const
{
	return m_echo != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HcSr04Config::clear_echo()
{
	m_echo = -1;
}

inline int8_t *HcSr04Config::mutable_echo()
{
	return &m_echo;
}

inline void HcSr04Config::set_echo(int8_t v)
{
	m_echo = v;
}



inline const std::string &HcSr04Config::name() const
{
	return m_name;
}

inline bool HcSr04Config::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HcSr04Config::clear_name()
{
	m_name.clear();
}

inline std::string *HcSr04Config::mutable_name()
{
	return &m_name;
}

inline void HcSr04Config::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void HcSr04Config::set_name(const char *data)
{
	m_name = data;
}

inline void HcSr04Config::set_name(const std::string &v)
{
	m_name = v;
}



inline size_t LedConfig::getMaxSize()
{
	// optional sint8 gpio, id 1 has maximum size 3
	// optional ledcfg_t config, id 2 has maximum size 11
	// optional string name, id 3 has unlimited size
	// optional sint8 pwm_ch, id 4 has maximum size 3
	return SIZE_MAX;
}

inline int8_t LedConfig::gpio() const
{
	return m_gpio;
}

inline bool LedConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void LedConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *LedConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void LedConfig::set_gpio(int8_t v)
{
	m_gpio = v;
}



inline ledcfg_t LedConfig::config() const
{
	return m_config;
}

inline bool LedConfig::config_active_high() const
{
	return (bool)((m_config >> 0) & 0x1);
}

inline bool LedConfig::config_open_drain() const
{
	return (bool)((m_config >> 1) & 0x1);
}

inline bool LedConfig::config_init_high() const
{
	return (bool)((m_config >> 2) & 0x1);
}

inline bool LedConfig::has_config() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void LedConfig::clear_config()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_config = 0;
}

inline ledcfg_t *LedConfig::mutable_config()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_config = 0;
	}
	return &m_config;
}

inline void LedConfig::set_config_active_high(bool v)
{
	m_config &= ~(0x1ULL << 0);
	m_config |= ((uint8_t) v << 0);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void LedConfig::set_config_open_drain(bool v)
{
	m_config &= ~(0x1ULL << 1);
	m_config |= ((uint8_t) v << 1);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void LedConfig::set_config_init_high(bool v)
{
	m_config &= ~(0x1ULL << 2);
	m_config |= ((uint8_t) v << 2);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void LedConfig::set_config(ledcfg_t v)
{
	m_config = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline const std::string &LedConfig::name() const
{
	return m_name;
}

inline bool LedConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void LedConfig::clear_name()
{
	m_name.clear();
}

inline std::string *LedConfig::mutable_name()
{
	return &m_name;
}

inline void LedConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void LedConfig::set_name(const char *data)
{
	m_name = data;
}

inline void LedConfig::set_name(const std::string &v)
{
	m_name = v;
}



inline int8_t LedConfig::pwm_ch() const
{
	return m_pwm_ch;
}

inline bool LedConfig::has_pwm_ch() const
{
	return m_pwm_ch != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void LedConfig::clear_pwm_ch()
{
	m_pwm_ch = -1;
}

inline int8_t *LedConfig::mutable_pwm_ch()
{
	return &m_pwm_ch;
}

inline void LedConfig::set_pwm_ch(int8_t v)
{
	m_pwm_ch = v;
}



inline size_t OneWireConfig::getMaxSize()
{
	// optional sint8 gpio, id 1 has maximum size 3
	// optional bool pullup, id 2 has maximum size 2
	// optional sint8 power, id 3 has maximum size 3
	return 8;
}

inline int8_t OneWireConfig::gpio() const
{
	return m_gpio;
}

inline bool OneWireConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void OneWireConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *OneWireConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void OneWireConfig::set_gpio(int8_t v)
{
	m_gpio = v;
}



inline bool OneWireConfig::pullup() const
{
	return m_pullup;
}

inline bool OneWireConfig::has_pullup() const
{
	return m_pullup != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void OneWireConfig::clear_pullup()
{
	m_pullup = false;
}

inline bool *OneWireConfig::mutable_pullup()
{
	return &m_pullup;
}

inline void OneWireConfig::set_pullup(bool v)
{
	m_pullup = v;
}



inline int8_t OneWireConfig::power() const
{
	return m_power;
}

inline bool OneWireConfig::has_power() const
{
	return m_power != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void OneWireConfig::clear_power()
{
	m_power = -1;
}

inline int8_t *OneWireConfig::mutable_power()
{
	return &m_power;
}

inline void OneWireConfig::set_power(int8_t v)
{
	m_power = v;
}



inline size_t UartConfig::getMaxSize()
{
	// optional sint8 port, id 1 has maximum size 3
	// optional sint8 tx_gpio, id 2 has maximum size 3
	// optional sint8 rx_gpio, id 3 has maximum size 3
	// optional sint8 cts_gpio, id 4 has maximum size 3
	// optional sint8 rts_gpio, id 5 has maximum size 3
	return 15;
}

inline int8_t UartConfig::port() const
{
	return m_port;
}

inline bool UartConfig::has_port() const
{
	return m_port != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartConfig::clear_port()
{
	m_port = -1;
}

inline int8_t *UartConfig::mutable_port()
{
	return &m_port;
}

inline void UartConfig::set_port(int8_t v)
{
	m_port = v;
}



inline int8_t UartConfig::tx_gpio() const
{
	return m_tx_gpio;
}

inline bool UartConfig::has_tx_gpio() const
{
	return m_tx_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartConfig::clear_tx_gpio()
{
	m_tx_gpio = -1;
}

inline int8_t *UartConfig::mutable_tx_gpio()
{
	return &m_tx_gpio;
}

inline void UartConfig::set_tx_gpio(int8_t v)
{
	m_tx_gpio = v;
}



inline int8_t UartConfig::rx_gpio() const
{
	return m_rx_gpio;
}

inline bool UartConfig::has_rx_gpio() const
{
	return m_rx_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartConfig::clear_rx_gpio()
{
	m_rx_gpio = -1;
}

inline int8_t *UartConfig::mutable_rx_gpio()
{
	return &m_rx_gpio;
}

inline void UartConfig::set_rx_gpio(int8_t v)
{
	m_rx_gpio = v;
}



inline int8_t UartConfig::cts_gpio() const
{
	return m_cts_gpio;
}

inline bool UartConfig::has_cts_gpio() const
{
	return m_cts_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartConfig::clear_cts_gpio()
{
	m_cts_gpio = -1;
}

inline int8_t *UartConfig::mutable_cts_gpio()
{
	return &m_cts_gpio;
}

inline void UartConfig::set_cts_gpio(int8_t v)
{
	m_cts_gpio = v;
}



inline int8_t UartConfig::rts_gpio() const
{
	return m_rts_gpio;
}

inline bool UartConfig::has_rts_gpio() const
{
	return m_rts_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartConfig::clear_rts_gpio()
{
	m_rts_gpio = -1;
}

inline int8_t *UartConfig::mutable_rts_gpio()
{
	return &m_rts_gpio;
}

inline void UartConfig::set_rts_gpio(int8_t v)
{
	m_rts_gpio = v;
}



inline size_t AdcChannel::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional uint8 unit, id 2 has maximum size 3
	// optional sint8 ch, id 3 has maximum size 3
	// optional uint8 atten, id 4 has maximum size 3
	// optional uint16 interval, id 5 has maximum size 4
	// optional uint8 window, id 6 has maximum size 3
	// optional float scale, id 8 has maximum size 5
	// optional float offset, id 9 has maximum size 5
	// optional string dim, id 10 has unlimited size
	return SIZE_MAX;
}

inline const std::string &AdcChannel::name() const
{
	return m_name;
}

inline bool AdcChannel::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_name()
{
	m_name.clear();
}

inline std::string *AdcChannel::mutable_name()
{
	return &m_name;
}

inline void AdcChannel::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void AdcChannel::set_name(const char *data)
{
	m_name = data;
}

inline void AdcChannel::set_name(const std::string &v)
{
	m_name = v;
}



inline uint8_t AdcChannel::unit() const
{
	return m_unit;
}

inline bool AdcChannel::has_unit() const
{
	return m_unit != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_unit()
{
	m_unit = 0;
}

inline uint8_t *AdcChannel::mutable_unit()
{
	return &m_unit;
}

inline void AdcChannel::set_unit(uint8_t v)
{
	m_unit = v;
}



inline int8_t AdcChannel::ch() const
{
	return m_ch;
}

inline bool AdcChannel::has_ch() const
{
	return m_ch != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_ch()
{
	m_ch = -1;
}

inline int8_t *AdcChannel::mutable_ch()
{
	return &m_ch;
}

inline void AdcChannel::set_ch(int8_t v)
{
	m_ch = v;
}



inline uint8_t AdcChannel::atten() const
{
	return m_atten;
}

inline bool AdcChannel::has_atten() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_atten()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_atten = 0;
}

inline uint8_t *AdcChannel::mutable_atten()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_atten = 0;
	}
	return &m_atten;
}

inline void AdcChannel::set_atten(uint8_t v)
{
	m_atten = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline uint16_t AdcChannel::interval() const
{
	return m_interval;
}

inline bool AdcChannel::has_interval() const
{
	return m_interval != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_interval()
{
	m_interval = 0;
}

inline uint16_t *AdcChannel::mutable_interval()
{
	return &m_interval;
}

inline void AdcChannel::set_interval(uint16_t v)
{
	m_interval = v;
}



inline uint8_t AdcChannel::window() const
{
	return m_window;
}

inline bool AdcChannel::has_window() const
{
	return m_window != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_window()
{
	m_window = 0;
}

inline uint8_t *AdcChannel::mutable_window()
{
	return &m_window;
}

inline void AdcChannel::set_window(uint8_t v)
{
	m_window = v;
}



inline float AdcChannel::scale() const
{
	return m_scale;
}

inline bool AdcChannel::has_scale() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_scale()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_scale = 1;
}

inline float *AdcChannel::mutable_scale()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_scale = 1;
	}
	return &m_scale;
}

inline void AdcChannel::set_scale(float v)
{
	m_scale = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline float AdcChannel::offset() const
{
	return m_offset;
}

inline bool AdcChannel::has_offset() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_offset()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_offset = 0;
}

inline float *AdcChannel::mutable_offset()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_offset = 0;
	}
	return &m_offset;
}

inline void AdcChannel::set_offset(float v)
{
	m_offset = v;
	p_validbits |= ((uint8_t)1U << 2);
}



inline const std::string &AdcChannel::dim() const
{
	return m_dim;
}

inline bool AdcChannel::has_dim() const
{
	return !m_dim.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_dim()
{
	m_dim.clear();
}

inline std::string *AdcChannel::mutable_dim()
{
	return &m_dim;
}

inline void AdcChannel::set_dim(const void *data, size_t s)
{
	m_dim.assign((const char *)data,s);
}

inline void AdcChannel::set_dim(const char *data)
{
	m_dim = data;
}

inline void AdcChannel::set_dim(const std::string &v)
{
	m_dim = v;
}



inline size_t AdcConfig::getMaxSize()
{
	// optional string adc_name, id 1 has unlimited size
	// optional uint8 adc1_bits, id 2 has maximum size 3
	// optional uint8 adc2_bits, id 3 has maximum size 3
	// optional uint8 mode, id 4 has maximum size 3
	// optional uint8 clk_div, id 5 has maximum size 3
	// optional string hall_name, id 6 has unlimited size
	// repeated AdcChannel channels, id 7 has unlimited size
	return SIZE_MAX;
}

inline const std::string &AdcConfig::adc_name() const
{
	return m_adc_name;
}

inline bool AdcConfig::has_adc_name() const
{
	return !m_adc_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcConfig::clear_adc_name()
{
	m_adc_name.clear();
}

inline std::string *AdcConfig::mutable_adc_name()
{
	return &m_adc_name;
}

inline void AdcConfig::set_adc_name(const void *data, size_t s)
{
	m_adc_name.assign((const char *)data,s);
}

inline void AdcConfig::set_adc_name(const char *data)
{
	m_adc_name = data;
}

inline void AdcConfig::set_adc_name(const std::string &v)
{
	m_adc_name = v;
}



inline uint8_t AdcConfig::adc1_bits() const
{
	return m_adc1_bits;
}

inline bool AdcConfig::has_adc1_bits() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcConfig::clear_adc1_bits()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_adc1_bits = 0;
}

inline uint8_t *AdcConfig::mutable_adc1_bits()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_adc1_bits = 0;
	}
	return &m_adc1_bits;
}

inline void AdcConfig::set_adc1_bits(uint8_t v)
{
	m_adc1_bits = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline uint8_t AdcConfig::adc2_bits() const
{
	return m_adc2_bits;
}

inline bool AdcConfig::has_adc2_bits() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcConfig::clear_adc2_bits()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_adc2_bits = 0;
}

inline uint8_t *AdcConfig::mutable_adc2_bits()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_adc2_bits = 0;
	}
	return &m_adc2_bits;
}

inline void AdcConfig::set_adc2_bits(uint8_t v)
{
	m_adc2_bits = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline uint8_t AdcConfig::mode() const
{
	return m_mode;
}

inline bool AdcConfig::has_mode() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcConfig::clear_mode()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_mode = 0;
}

inline uint8_t *AdcConfig::mutable_mode()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_mode = 0;
	}
	return &m_mode;
}

inline void AdcConfig::set_mode(uint8_t v)
{
	m_mode = v;
	p_validbits |= ((uint8_t)1U << 2);
}



inline uint8_t AdcConfig::clk_div() const
{
	return m_clk_div;
}

inline bool AdcConfig::has_clk_div() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 3));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcConfig::clear_clk_div()
{
	p_validbits &= ~((uint8_t)1U << 3);
	m_clk_div = 0;
}

inline uint8_t *AdcConfig::mutable_clk_div()
{
	if (0 == (p_validbits & ((uint8_t)1U << 3))) {
		p_validbits |= ((uint8_t)1U << 3);
		m_clk_div = 0;
	}
	return &m_clk_div;
}

inline void AdcConfig::set_clk_div(uint8_t v)
{
	m_clk_div = v;
	p_validbits |= ((uint8_t)1U << 3);
}



inline const std::string &AdcConfig::hall_name() const
{
	return m_hall_name;
}

inline bool AdcConfig::has_hall_name() const
{
	return !m_hall_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcConfig::clear_hall_name()
{
	m_hall_name.clear();
}

inline std::string *AdcConfig::mutable_hall_name()
{
	return &m_hall_name;
}

inline void AdcConfig::set_hall_name(const void *data, size_t s)
{
	m_hall_name.assign((const char *)data,s);
}

inline void AdcConfig::set_hall_name(const char *data)
{
	m_hall_name = data;
}

inline void AdcConfig::set_hall_name(const std::string &v)
{
	m_hall_name = v;
}



inline const AdcChannel &AdcConfig::channels(unsigned x) const
{
	return m_channels[x];
}

inline const std::vector<AdcChannel> &AdcConfig::channels() const
{
	return m_channels;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcConfig::clear_channels()
{
	m_channels.clear();
}

inline AdcChannel *AdcConfig::mutable_channels(unsigned x)
{
	if (x >= m_channels.size())
		m_channels.resize(x+1);
	return &m_channels[x];
}

inline std::vector<AdcChannel> *AdcConfig::mutable_channels()
{
	return &m_channels;
}

inline AdcChannel *AdcConfig::add_channels()
{
	m_channels.resize(m_channels.size()+1);
	return &m_channels.back();
}

inline void AdcConfig::set_channels(unsigned x, const AdcChannel &v)
{
	assert(x < m_channels.size());
	m_channels[x] = v;
}

inline size_t AdcConfig::channels_size() const
{
	return m_channels.size();
}



inline size_t GpioConfig::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional sint8 gpio, id 2 has maximum size 3
	// optional gpiocfg_t config, id 3 has maximum size 11
	return SIZE_MAX;
}

inline const std::string &GpioConfig::name() const
{
	return m_name;
}

inline bool GpioConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioConfig::clear_name()
{
	m_name.clear();
}

inline std::string *GpioConfig::mutable_name()
{
	return &m_name;
}

inline void GpioConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void GpioConfig::set_name(const char *data)
{
	m_name = data;
}

inline void GpioConfig::set_name(const std::string &v)
{
	m_name = v;
}



inline int8_t GpioConfig::gpio() const
{
	return m_gpio;
}

inline bool GpioConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *GpioConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void GpioConfig::set_gpio(int8_t v)
{
	m_gpio = v;
}



inline gpiocfg_t GpioConfig::config() const
{
	return m_config;
}

inline uint8_t GpioConfig::config_mode() const
{
	return (uint8_t)((m_config >> 0) & 0x3);
}

inline uint8_t GpioConfig::config_intrtype() const
{
	return (uint8_t)((m_config >> 2) & 0x7);
}

inline bool GpioConfig::config_setinit() const
{
	return (bool)((m_config >> 5) & 0x1);
}

inline bool GpioConfig::config_initlvl() const
{
	return (bool)((m_config >> 6) & 0x1);
}

inline bool GpioConfig::config_pullup() const
{
	return (bool)((m_config >> 7) & 0x1);
}

inline bool GpioConfig::config_pulldown() const
{
	return (bool)((m_config >> 8) & 0x1);
}

inline bool GpioConfig::has_config() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioConfig::clear_config()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_config = 0;
}

inline gpiocfg_t *GpioConfig::mutable_config()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_config = 0;
	}
	return &m_config;
}

inline void GpioConfig::set_config_mode(uint8_t v)
{
	m_config &= ~(0x3ULL << 0);
	m_config |= ((uint16_t) v << 0);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void GpioConfig::set_config_intrtype(uint8_t v)
{
	m_config &= ~(0x7ULL << 2);
	m_config |= ((uint16_t) v << 2);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void GpioConfig::set_config_setinit(bool v)
{
	m_config &= ~(0x1ULL << 5);
	m_config |= ((uint16_t) v << 5);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void GpioConfig::set_config_initlvl(bool v)
{
	m_config &= ~(0x1ULL << 6);
	m_config |= ((uint16_t) v << 6);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void GpioConfig::set_config_pullup(bool v)
{
	m_config &= ~(0x1ULL << 7);
	m_config |= ((uint16_t) v << 7);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void GpioConfig::set_config_pulldown(bool v)
{
	m_config &= ~(0x1ULL << 8);
	m_config |= ((uint16_t) v << 8);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void GpioConfig::set_config(gpiocfg_t v)
{
	m_config = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline size_t DisplayConfig::getMaxSize()
{
	// optional disp_t type, id 1 has maximum size 2
	// optional unsigned options, id 2 has maximum size 11
	// optional unsigned maxx, id 3 has maximum size 11
	// optional unsigned maxy, id 4 has maximum size 11
	return 35;
}

inline disp_t DisplayConfig::type() const
{
	return m_type;
}

inline bool DisplayConfig::has_type() const
{
	return m_type != dt_none;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DisplayConfig::clear_type()
{
	m_type = dt_none;
}

inline disp_t *DisplayConfig::mutable_type()
{
	return &m_type;
}

inline void DisplayConfig::set_type(disp_t v)
{
	m_type = v;
}



inline uint64_t DisplayConfig::options() const
{
	return m_options;
}

inline bool DisplayConfig::has_options() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DisplayConfig::clear_options()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_options = 0;
}

inline uint64_t *DisplayConfig::mutable_options()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_options = 0;
	}
	return &m_options;
}

inline void DisplayConfig::set_options(uint64_t v)
{
	m_options = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline uint64_t DisplayConfig::maxx() const
{
	return m_maxx;
}

inline bool DisplayConfig::has_maxx() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DisplayConfig::clear_maxx()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_maxx = 0;
}

inline uint64_t *DisplayConfig::mutable_maxx()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_maxx = 0;
	}
	return &m_maxx;
}

inline void DisplayConfig::set_maxx(uint64_t v)
{
	m_maxx = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline uint64_t DisplayConfig::maxy() const
{
	return m_maxy;
}

inline bool DisplayConfig::has_maxy() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DisplayConfig::clear_maxy()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_maxy = 1;
}

inline uint64_t *DisplayConfig::mutable_maxy()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_maxy = 1;
	}
	return &m_maxy;
}

inline void DisplayConfig::set_maxy(uint64_t v)
{
	m_maxy = v;
	p_validbits |= ((uint8_t)1U << 2);
}



inline size_t SpiDeviceConfig::getMaxSize()
{
	// optional spidrv_t drv, id 1 has maximum size 2
	// optional sint8 cs, id 2 has maximum size 3
	// optional sint8 intr, id 3 has maximum size 3
	// optional sint8 reset, id 4 has maximum size 3
	// optional sint8 cd, id 5 has maximum size 3
	// optional unsigned freq, id 6 has maximum size 11
	return 25;
}

inline spidrv_t SpiDeviceConfig::drv() const
{
	return m_drv;
}

inline bool SpiDeviceConfig::has_drv() const
{
	return m_drv != spidrv_invalid;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiDeviceConfig::clear_drv()
{
	m_drv = spidrv_invalid;
}

inline spidrv_t *SpiDeviceConfig::mutable_drv()
{
	return &m_drv;
}

inline void SpiDeviceConfig::set_drv(spidrv_t v)
{
	m_drv = v;
}



inline int8_t SpiDeviceConfig::cs() const
{
	return m_cs;
}

inline bool SpiDeviceConfig::has_cs() const
{
	return m_cs != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiDeviceConfig::clear_cs()
{
	m_cs = -1;
}

inline int8_t *SpiDeviceConfig::mutable_cs()
{
	return &m_cs;
}

inline void SpiDeviceConfig::set_cs(int8_t v)
{
	m_cs = v;
}



inline int8_t SpiDeviceConfig::intr() const
{
	return m_intr;
}

inline bool SpiDeviceConfig::has_intr() const
{
	return m_intr != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiDeviceConfig::clear_intr()
{
	m_intr = -1;
}

inline int8_t *SpiDeviceConfig::mutable_intr()
{
	return &m_intr;
}

inline void SpiDeviceConfig::set_intr(int8_t v)
{
	m_intr = v;
}



inline int8_t SpiDeviceConfig::reset() const
{
	return m_reset;
}

inline bool SpiDeviceConfig::has_reset() const
{
	return m_reset != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiDeviceConfig::clear_reset()
{
	m_reset = -1;
}

inline int8_t *SpiDeviceConfig::mutable_reset()
{
	return &m_reset;
}

inline void SpiDeviceConfig::set_reset(int8_t v)
{
	m_reset = v;
}



inline int8_t SpiDeviceConfig::cd() const
{
	return m_cd;
}

inline bool SpiDeviceConfig::has_cd() const
{
	return m_cd != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiDeviceConfig::clear_cd()
{
	m_cd = -1;
}

inline int8_t *SpiDeviceConfig::mutable_cd()
{
	return &m_cd;
}

inline void SpiDeviceConfig::set_cd(int8_t v)
{
	m_cd = v;
}



inline uint64_t SpiDeviceConfig::freq() const
{
	return m_freq;
}

inline bool SpiDeviceConfig::has_freq() const
{
	return m_freq != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiDeviceConfig::clear_freq()
{
	m_freq = 0;
}

inline uint64_t *SpiDeviceConfig::mutable_freq()
{
	return &m_freq;
}

inline void SpiDeviceConfig::set_freq(uint64_t v)
{
	m_freq = v;
}



inline size_t SpiBusConfig::getMaxSize()
{
	// optional sint8 host, id 1 has maximum size 3
	// optional sint8 mosi, id 2 has maximum size 3
	// optional sint8 miso, id 3 has maximum size 3
	// optional sint8 sclk, id 4 has maximum size 3
	// optional sint8 wp, id 5 has maximum size 3
	// optional sint8 hold, id 6 has maximum size 3
	// optional spiopt_t options, id 7 has maximum size 11
	// optional sint8 dma, id 8 has maximum size 3
	// repeated SpiDeviceConfig devices, id 9 has unlimited size
	return SIZE_MAX;
}

inline int8_t SpiBusConfig::host() const
{
	return m_host;
}

inline bool SpiBusConfig::has_host() const
{
	return m_host != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiBusConfig::clear_host()
{
	m_host = -1;
}

inline int8_t *SpiBusConfig::mutable_host()
{
	return &m_host;
}

inline void SpiBusConfig::set_host(int8_t v)
{
	m_host = v;
}



inline int8_t SpiBusConfig::mosi() const
{
	return m_mosi;
}

inline bool SpiBusConfig::has_mosi() const
{
	return m_mosi != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiBusConfig::clear_mosi()
{
	m_mosi = -1;
}

inline int8_t *SpiBusConfig::mutable_mosi()
{
	return &m_mosi;
}

inline void SpiBusConfig::set_mosi(int8_t v)
{
	m_mosi = v;
}



inline int8_t SpiBusConfig::miso() const
{
	return m_miso;
}

inline bool SpiBusConfig::has_miso() const
{
	return m_miso != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiBusConfig::clear_miso()
{
	m_miso = -1;
}

inline int8_t *SpiBusConfig::mutable_miso()
{
	return &m_miso;
}

inline void SpiBusConfig::set_miso(int8_t v)
{
	m_miso = v;
}



inline int8_t SpiBusConfig::sclk() const
{
	return m_sclk;
}

inline bool SpiBusConfig::has_sclk() const
{
	return m_sclk != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiBusConfig::clear_sclk()
{
	m_sclk = -1;
}

inline int8_t *SpiBusConfig::mutable_sclk()
{
	return &m_sclk;
}

inline void SpiBusConfig::set_sclk(int8_t v)
{
	m_sclk = v;
}



inline int8_t SpiBusConfig::wp() const
{
	return m_wp;
}

inline bool SpiBusConfig::has_wp() const
{
	return m_wp != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiBusConfig::clear_wp()
{
	m_wp = -1;
}

inline int8_t *SpiBusConfig::mutable_wp()
{
	return &m_wp;
}

inline void SpiBusConfig::set_wp(int8_t v)
{
	m_wp = v;
}



inline int8_t SpiBusConfig::hold() const
{
	return m_hold;
}

inline bool SpiBusConfig::has_hold() const
{
	return m_hold != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiBusConfig::clear_hold()
{
	m_hold = -1;
}

inline int8_t *SpiBusConfig::mutable_hold()
{
	return &m_hold;
}

inline void SpiBusConfig::set_hold(int8_t v)
{
	m_hold = v;
}



inline spiopt_t SpiBusConfig::options() const
{
	return m_options;
}

inline bool SpiBusConfig::options_txlsbfirst() const
{
	return (bool)((m_options >> 0) & 0x1);
}

inline bool SpiBusConfig::options_rxlsbfirst() const
{
	return (bool)((m_options >> 1) & 0x1);
}

inline bool SpiBusConfig::options_mosi_as_miso() const
{
	return (bool)((m_options >> 2) & 0x1);
}

inline bool SpiBusConfig::options_positive_cs() const
{
	return (bool)((m_options >> 3) & 0x1);
}

inline bool SpiBusConfig::options_full_duplex() const
{
	return (bool)((m_options >> 4) & 0x1);
}

inline bool SpiBusConfig::options_pol_hi() const
{
	return (bool)((m_options >> 5) & 0x1);
}

inline bool SpiBusConfig::options_pha_hi() const
{
	return (bool)((m_options >> 6) & 0x1);
}

inline bool SpiBusConfig::has_options() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiBusConfig::clear_options()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_options = 0;
}

inline spiopt_t *SpiBusConfig::mutable_options()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_options = 0;
	}
	return &m_options;
}

inline void SpiBusConfig::set_options_txlsbfirst(bool v)
{
	m_options &= ~(0x1ULL << 0);
	m_options |= ((uint8_t) v << 0);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void SpiBusConfig::set_options_rxlsbfirst(bool v)
{
	m_options &= ~(0x1ULL << 1);
	m_options |= ((uint8_t) v << 1);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void SpiBusConfig::set_options_mosi_as_miso(bool v)
{
	m_options &= ~(0x1ULL << 2);
	m_options |= ((uint8_t) v << 2);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void SpiBusConfig::set_options_positive_cs(bool v)
{
	m_options &= ~(0x1ULL << 3);
	m_options |= ((uint8_t) v << 3);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void SpiBusConfig::set_options_full_duplex(bool v)
{
	m_options &= ~(0x1ULL << 4);
	m_options |= ((uint8_t) v << 4);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void SpiBusConfig::set_options_pol_hi(bool v)
{
	m_options &= ~(0x1ULL << 5);
	m_options |= ((uint8_t) v << 5);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void SpiBusConfig::set_options_pha_hi(bool v)
{
	m_options &= ~(0x1ULL << 6);
	m_options |= ((uint8_t) v << 6);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void SpiBusConfig::set_options(spiopt_t v)
{
	m_options = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline int8_t SpiBusConfig::dma() const
{
	return m_dma;
}

inline bool SpiBusConfig::has_dma() const
{
	return m_dma != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiBusConfig::clear_dma()
{
	m_dma = -1;
}

inline int8_t *SpiBusConfig::mutable_dma()
{
	return &m_dma;
}

inline void SpiBusConfig::set_dma(int8_t v)
{
	m_dma = v;
}



inline const SpiDeviceConfig &SpiBusConfig::devices(unsigned x) const
{
	return m_devices[x];
}

inline const std::vector<SpiDeviceConfig> &SpiBusConfig::devices() const
{
	return m_devices;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SpiBusConfig::clear_devices()
{
	m_devices.clear();
}

inline SpiDeviceConfig *SpiBusConfig::mutable_devices(unsigned x)
{
	if (x >= m_devices.size())
		m_devices.resize(x+1);
	return &m_devices[x];
}

inline std::vector<SpiDeviceConfig> *SpiBusConfig::mutable_devices()
{
	return &m_devices;
}

inline SpiDeviceConfig *SpiBusConfig::add_devices()
{
	m_devices.resize(m_devices.size()+1);
	return &m_devices.back();
}

inline void SpiBusConfig::set_devices(unsigned x, const SpiDeviceConfig &v)
{
	assert(x < m_devices.size());
	m_devices[x] = v;
}

inline size_t SpiBusConfig::devices_size() const
{
	return m_devices.size();
}



inline size_t GpioCluster::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional uint8 base, id 2 has maximum size 3
	// optional uint8 numio, id 3 has maximum size 3
	// optional sint8 int_a, id 4 has maximum size 3
	// optional sint8 int_b, id 5 has maximum size 3
	return SIZE_MAX;
}

inline const std::string &GpioCluster::name() const
{
	return m_name;
}

inline bool GpioCluster::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioCluster::clear_name()
{
	m_name.clear();
}

inline std::string *GpioCluster::mutable_name()
{
	return &m_name;
}

inline void GpioCluster::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void GpioCluster::set_name(const char *data)
{
	m_name = data;
}

inline void GpioCluster::set_name(const std::string &v)
{
	m_name = v;
}



inline uint8_t GpioCluster::base() const
{
	return m_base;
}

inline bool GpioCluster::has_base() const
{
	return m_base != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioCluster::clear_base()
{
	m_base = 0;
}

inline uint8_t *GpioCluster::mutable_base()
{
	return &m_base;
}

inline void GpioCluster::set_base(uint8_t v)
{
	m_base = v;
}



inline uint8_t GpioCluster::numio() const
{
	return m_numio;
}

inline bool GpioCluster::has_numio() const
{
	return m_numio != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioCluster::clear_numio()
{
	m_numio = 0;
}

inline uint8_t *GpioCluster::mutable_numio()
{
	return &m_numio;
}

inline void GpioCluster::set_numio(uint8_t v)
{
	m_numio = v;
}



inline int8_t GpioCluster::int_a() const
{
	return m_int_a;
}

inline bool GpioCluster::has_int_a() const
{
	return m_int_a != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioCluster::clear_int_a()
{
	m_int_a = -1;
}

inline int8_t *GpioCluster::mutable_int_a()
{
	return &m_int_a;
}

inline void GpioCluster::set_int_a(int8_t v)
{
	m_int_a = v;
}



inline int8_t GpioCluster::int_b() const
{
	return m_int_b;
}

inline bool GpioCluster::has_int_b() const
{
	return m_int_b != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioCluster::clear_int_b()
{
	m_int_b = -1;
}

inline int8_t *GpioCluster::mutable_int_b()
{
	return &m_int_b;
}

inline void GpioCluster::set_int_b(int8_t v)
{
	m_int_b = v;
}



inline size_t Hlw8012Config::getMaxSize()
{
	// optional sint8 sel, id 2 has maximum size 3
	// optional sint8 cf, id 3 has maximum size 3
	// optional sint8 cf1, id 4 has maximum size 3
	return 9;
}

inline int8_t Hlw8012Config::sel() const
{
	return m_sel;
}

inline bool Hlw8012Config::has_sel() const
{
	return m_sel != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Hlw8012Config::clear_sel()
{
	m_sel = -1;
}

inline int8_t *Hlw8012Config::mutable_sel()
{
	return &m_sel;
}

inline void Hlw8012Config::set_sel(int8_t v)
{
	m_sel = v;
}



inline int8_t Hlw8012Config::cf() const
{
	return m_cf;
}

inline bool Hlw8012Config::has_cf() const
{
	return m_cf != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Hlw8012Config::clear_cf()
{
	m_cf = -1;
}

inline int8_t *Hlw8012Config::mutable_cf()
{
	return &m_cf;
}

inline void Hlw8012Config::set_cf(int8_t v)
{
	m_cf = v;
}



inline int8_t Hlw8012Config::cf1() const
{
	return m_cf1;
}

inline bool Hlw8012Config::has_cf1() const
{
	return m_cf1 != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Hlw8012Config::clear_cf1()
{
	m_cf1 = -1;
}

inline int8_t *Hlw8012Config::mutable_cf1()
{
	return &m_cf1;
}

inline void Hlw8012Config::set_cf1(int8_t v)
{
	m_cf1 = v;
}



inline size_t SX1276Config::getMaxSize()
{
	// optional sint8 dio0, id 1 has maximum size 3
	// optional sint8 dio1, id 2 has maximum size 3
	// optional sint8 dio2, id 3 has maximum size 3
	// optional sint8 dio3, id 4 has maximum size 3
	// optional sint8 dio4, id 5 has maximum size 3
	// optional sint8 dio5, id 6 has maximum size 3
	return 18;
}

inline int8_t SX1276Config::dio0() const
{
	return m_dio0;
}

inline bool SX1276Config::has_dio0() const
{
	return m_dio0 != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SX1276Config::clear_dio0()
{
	m_dio0 = -1;
}

inline int8_t *SX1276Config::mutable_dio0()
{
	return &m_dio0;
}

inline void SX1276Config::set_dio0(int8_t v)
{
	m_dio0 = v;
}



inline int8_t SX1276Config::dio1() const
{
	return m_dio1;
}

inline bool SX1276Config::has_dio1() const
{
	return m_dio1 != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SX1276Config::clear_dio1()
{
	m_dio1 = -1;
}

inline int8_t *SX1276Config::mutable_dio1()
{
	return &m_dio1;
}

inline void SX1276Config::set_dio1(int8_t v)
{
	m_dio1 = v;
}



inline int8_t SX1276Config::dio2() const
{
	return m_dio2;
}

inline bool SX1276Config::has_dio2() const
{
	return m_dio2 != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SX1276Config::clear_dio2()
{
	m_dio2 = -1;
}

inline int8_t *SX1276Config::mutable_dio2()
{
	return &m_dio2;
}

inline void SX1276Config::set_dio2(int8_t v)
{
	m_dio2 = v;
}



inline int8_t SX1276Config::dio3() const
{
	return m_dio3;
}

inline bool SX1276Config::has_dio3() const
{
	return m_dio3 != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SX1276Config::clear_dio3()
{
	m_dio3 = -1;
}

inline int8_t *SX1276Config::mutable_dio3()
{
	return &m_dio3;
}

inline void SX1276Config::set_dio3(int8_t v)
{
	m_dio3 = v;
}



inline int8_t SX1276Config::dio4() const
{
	return m_dio4;
}

inline bool SX1276Config::has_dio4() const
{
	return m_dio4 != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SX1276Config::clear_dio4()
{
	m_dio4 = -1;
}

inline int8_t *SX1276Config::mutable_dio4()
{
	return &m_dio4;
}

inline void SX1276Config::set_dio4(int8_t v)
{
	m_dio4 = v;
}



inline int8_t SX1276Config::dio5() const
{
	return m_dio5;
}

inline bool SX1276Config::has_dio5() const
{
	return m_dio5 != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SX1276Config::clear_dio5()
{
	m_dio5 = -1;
}

inline int8_t *SX1276Config::mutable_dio5()
{
	return &m_dio5;
}

inline void SX1276Config::set_dio5(int8_t v)
{
	m_dio5 = v;
}



inline size_t Tone::getMaxSize()
{
	// optional unsigned freq, id 1 has maximum size 11
	// optional unsigned duration, id 2 has maximum size 11
	return 22;
}

inline uint64_t Tone::freq() const
{
	return m_freq;
}

inline bool Tone::has_freq() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tone::clear_freq()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_freq = 0;
}

inline uint64_t *Tone::mutable_freq()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_freq = 0;
	}
	return &m_freq;
}

inline void Tone::set_freq(uint64_t v)
{
	m_freq = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline uint64_t Tone::duration() const
{
	return m_duration;
}

inline bool Tone::has_duration() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tone::clear_duration()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_duration = 0;
}

inline uint64_t *Tone::mutable_duration()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_duration = 0;
	}
	return &m_duration;
}

inline void Tone::set_duration(uint64_t v)
{
	m_duration = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline size_t Melody::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// repeated fixed16 tones, id 2 has unlimited size
	return SIZE_MAX;
}

inline const std::string &Melody::name() const
{
	return m_name;
}

inline bool Melody::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Melody::clear_name()
{
	m_name.clear();
}

inline std::string *Melody::mutable_name()
{
	return &m_name;
}

inline void Melody::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void Melody::set_name(const char *data)
{
	m_name = data;
}

inline void Melody::set_name(const std::string &v)
{
	m_name = v;
}



inline uint16_t Melody::tones(unsigned x) const
{
	return m_tones[x];
}

inline const std::vector<uint16_t> &Melody::tones() const
{
	return m_tones;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Melody::clear_tones()
{
	m_tones.clear();
}

inline uint16_t *Melody::mutable_tones(unsigned x)
{
	if (x >= m_tones.size())
		m_tones.resize(x+1);
	return &m_tones[x];
}

inline std::vector<uint16_t> *Melody::mutable_tones()
{
	return &m_tones;
}

inline void Melody::add_tones(uint16_t v)
{
	m_tones.push_back(v);
}

inline void Melody::set_tones(unsigned x, uint16_t v)
{
	assert(x < m_tones.size());
	m_tones[x] = v;
}

inline size_t Melody::tones_size() const
{
	return m_tones.size();
}



inline size_t BuzzerConfig::getMaxSize()
{
	// optional sint8 gpio, id 1 has maximum size 3
	// repeated Melody melodies, id 2 has unlimited size
	return SIZE_MAX;
}

inline int8_t BuzzerConfig::gpio() const
{
	return m_gpio;
}

inline bool BuzzerConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void BuzzerConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *BuzzerConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void BuzzerConfig::set_gpio(int8_t v)
{
	m_gpio = v;
}



inline const Melody &BuzzerConfig::melodies(unsigned x) const
{
	return m_melodies[x];
}

inline const std::vector<Melody> &BuzzerConfig::melodies() const
{
	return m_melodies;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void BuzzerConfig::clear_melodies()
{
	m_melodies.clear();
}

inline Melody *BuzzerConfig::mutable_melodies(unsigned x)
{
	if (x >= m_melodies.size())
		m_melodies.resize(x+1);
	return &m_melodies[x];
}

inline std::vector<Melody> *BuzzerConfig::mutable_melodies()
{
	return &m_melodies;
}

inline Melody *BuzzerConfig::add_melodies()
{
	m_melodies.resize(m_melodies.size()+1);
	return &m_melodies.back();
}

inline void BuzzerConfig::set_melodies(unsigned x, const Melody &v)
{
	assert(x < m_melodies.size());
	m_melodies[x] = v;
}

inline size_t BuzzerConfig::melodies_size() const
{
	return m_melodies.size();
}



inline size_t HardwareConfig::getMaxSize()
{
	// optional fixed32 magic, id 0 has maximum size 5
	// optional SystemConfig system, id 1 has maximum size 15
	// repeated UartConfig uart, id 3 has unlimited size
	// optional AdcConfig adc, id 4 has maximum size 10
	// optional TouchpadConfig touchpad, id 5 has maximum size 23
	// repeated TouchChannelConfig tp_channel, id 6 has unlimited size
	// repeated GpioConfig gpios, id 7 has unlimited size
	// repeated SpiBusConfig spibus, id 8 has unlimited size
	// repeated ButtonConfig button, id 16 has unlimited size
	// repeated RelayConfig relay, id 17 has unlimited size
	// repeated LedConfig led, id 18 has unlimited size
	// optional BuzzerConfig buzzer, id 19 has maximum size 4
	// optional Hlw8012Config hlw8012, id 20 has maximum size 11
	// optional Max7219Config max7219, id 32 has maximum size 16
	// optional Tlc5947Config tlc5947, id 33 has maximum size 17
	// repeated Ws2812bConfig ws2812b, id 34 has unlimited size
	// optional DhtConfig dht, id 35 has maximum size 8
	// repeated I2CConfig i2c, id 36 has unlimited size
	// repeated HcSr04Config hcsr04, id 37 has unlimited size
	// optional OneWireConfig onewire, id 38 has maximum size 10
	// optional SX1276Config sx1276, id 39 has maximum size 20
	// repeated GpioCluster iocluster, id 40 has unlimited size
	// optional DisplayConfig display, id 50 has maximum size 37
	return SIZE_MAX;
}

inline uint32_t HardwareConfig::magic() const
{
	return m_magic;
}

inline bool HardwareConfig::has_magic() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_magic()
{
	p_validbits &= ~((uint16_t)1U << 0);
	m_magic = 0;
}

inline uint32_t *HardwareConfig::mutable_magic()
{
	if (0 == (p_validbits & ((uint16_t)1U << 0))) {
		p_validbits |= ((uint16_t)1U << 0);
		m_magic = 0;
	}
	return &m_magic;
}

inline void HardwareConfig::set_magic(uint32_t v)
{
	m_magic = v;
	p_validbits |= ((uint16_t)1U << 0);
}



inline const SystemConfig &HardwareConfig::system() const
{
	return m_system;
}

inline bool HardwareConfig::has_system() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_system()
{
	p_validbits &= ~((uint16_t)1U << 1);
	m_system.clear();
}

inline SystemConfig *HardwareConfig::mutable_system()
{
	if (0 == (p_validbits & ((uint16_t)1U << 1))) {
		p_validbits |= ((uint16_t)1U << 1);
		m_system.clear();
	}
	return &m_system;
}

inline void HardwareConfig::set_system(const void *data, size_t s)
{
	m_system.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 1);
}

inline void HardwareConfig::set_system(const SystemConfig &v)
{
	m_system = v;
	p_validbits |= ((uint16_t)1U << 1);
}



inline const UartConfig &HardwareConfig::uart(unsigned x) const
{
	return m_uart[x];
}

inline const std::vector<UartConfig> &HardwareConfig::uart() const
{
	return m_uart;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_uart()
{
	m_uart.clear();
}

inline UartConfig *HardwareConfig::mutable_uart(unsigned x)
{
	if (x >= m_uart.size())
		m_uart.resize(x+1);
	return &m_uart[x];
}

inline std::vector<UartConfig> *HardwareConfig::mutable_uart()
{
	return &m_uart;
}

inline UartConfig *HardwareConfig::add_uart()
{
	m_uart.resize(m_uart.size()+1);
	return &m_uart.back();
}

inline void HardwareConfig::set_uart(unsigned x, const UartConfig &v)
{
	assert(x < m_uart.size());
	m_uart[x] = v;
}

inline size_t HardwareConfig::uart_size() const
{
	return m_uart.size();
}



inline const AdcConfig &HardwareConfig::adc() const
{
	return m_adc;
}

inline bool HardwareConfig::has_adc() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_adc()
{
	p_validbits &= ~((uint16_t)1U << 2);
	m_adc.clear();
}

inline AdcConfig *HardwareConfig::mutable_adc()
{
	if (0 == (p_validbits & ((uint16_t)1U << 2))) {
		p_validbits |= ((uint16_t)1U << 2);
		m_adc.clear();
	}
	return &m_adc;
}

inline void HardwareConfig::set_adc(const void *data, size_t s)
{
	m_adc.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 2);
}

inline void HardwareConfig::set_adc(const AdcConfig &v)
{
	m_adc = v;
	p_validbits |= ((uint16_t)1U << 2);
}



#ifdef CONFIG_TOUCHPAD
inline const TouchpadConfig &HardwareConfig::touchpad() const
{
	return m_touchpad;
}

inline bool HardwareConfig::has_touchpad() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 3));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_touchpad()
{
	p_validbits &= ~((uint16_t)1U << 3);
	m_touchpad.clear();
}

inline TouchpadConfig *HardwareConfig::mutable_touchpad()
{
	if (0 == (p_validbits & ((uint16_t)1U << 3))) {
		p_validbits |= ((uint16_t)1U << 3);
		m_touchpad.clear();
	}
	return &m_touchpad;
}

inline void HardwareConfig::set_touchpad(const void *data, size_t s)
{
	m_touchpad.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 3);
}

inline void HardwareConfig::set_touchpad(const TouchpadConfig &v)
{
	m_touchpad = v;
	p_validbits |= ((uint16_t)1U << 3);
}

#endif // CONFIG_TOUCHPAD


#ifdef CONFIG_TOUCHPAD
inline const TouchChannelConfig &HardwareConfig::tp_channel(unsigned x) const
{
	return m_tp_channel[x];
}

inline const std::vector<TouchChannelConfig> &HardwareConfig::tp_channel() const
{
	return m_tp_channel;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_tp_channel()
{
	m_tp_channel.clear();
}

inline TouchChannelConfig *HardwareConfig::mutable_tp_channel(unsigned x)
{
	if (x >= m_tp_channel.size())
		m_tp_channel.resize(x+1);
	return &m_tp_channel[x];
}

inline std::vector<TouchChannelConfig> *HardwareConfig::mutable_tp_channel()
{
	return &m_tp_channel;
}

inline TouchChannelConfig *HardwareConfig::add_tp_channel()
{
	m_tp_channel.resize(m_tp_channel.size()+1);
	return &m_tp_channel.back();
}

inline void HardwareConfig::set_tp_channel(unsigned x, const TouchChannelConfig &v)
{
	assert(x < m_tp_channel.size());
	m_tp_channel[x] = v;
}

inline size_t HardwareConfig::tp_channel_size() const
{
	return m_tp_channel.size();
}

#endif // CONFIG_TOUCHPAD


inline const GpioConfig &HardwareConfig::gpios(unsigned x) const
{
	return m_gpios[x];
}

inline const std::vector<GpioConfig> &HardwareConfig::gpios() const
{
	return m_gpios;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_gpios()
{
	m_gpios.clear();
}

inline GpioConfig *HardwareConfig::mutable_gpios(unsigned x)
{
	if (x >= m_gpios.size())
		m_gpios.resize(x+1);
	return &m_gpios[x];
}

inline std::vector<GpioConfig> *HardwareConfig::mutable_gpios()
{
	return &m_gpios;
}

inline GpioConfig *HardwareConfig::add_gpios()
{
	m_gpios.resize(m_gpios.size()+1);
	return &m_gpios.back();
}

inline void HardwareConfig::set_gpios(unsigned x, const GpioConfig &v)
{
	assert(x < m_gpios.size());
	m_gpios[x] = v;
}

inline size_t HardwareConfig::gpios_size() const
{
	return m_gpios.size();
}



#ifdef CONFIG_SPI
inline const SpiBusConfig &HardwareConfig::spibus(unsigned x) const
{
	return m_spibus[x];
}

inline const std::vector<SpiBusConfig> &HardwareConfig::spibus() const
{
	return m_spibus;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_spibus()
{
	m_spibus.clear();
}

inline SpiBusConfig *HardwareConfig::mutable_spibus(unsigned x)
{
	if (x >= m_spibus.size())
		m_spibus.resize(x+1);
	return &m_spibus[x];
}

inline std::vector<SpiBusConfig> *HardwareConfig::mutable_spibus()
{
	return &m_spibus;
}

inline SpiBusConfig *HardwareConfig::add_spibus()
{
	m_spibus.resize(m_spibus.size()+1);
	return &m_spibus.back();
}

inline void HardwareConfig::set_spibus(unsigned x, const SpiBusConfig &v)
{
	assert(x < m_spibus.size());
	m_spibus[x] = v;
}

inline size_t HardwareConfig::spibus_size() const
{
	return m_spibus.size();
}

#endif // CONFIG_SPI


#ifdef CONFIG_BUTTON
inline const ButtonConfig &HardwareConfig::button(unsigned x) const
{
	return m_button[x];
}

inline const std::vector<ButtonConfig> &HardwareConfig::button() const
{
	return m_button;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_button()
{
	m_button.clear();
}

inline ButtonConfig *HardwareConfig::mutable_button(unsigned x)
{
	if (x >= m_button.size())
		m_button.resize(x+1);
	return &m_button[x];
}

inline std::vector<ButtonConfig> *HardwareConfig::mutable_button()
{
	return &m_button;
}

inline ButtonConfig *HardwareConfig::add_button()
{
	m_button.resize(m_button.size()+1);
	return &m_button.back();
}

inline void HardwareConfig::set_button(unsigned x, const ButtonConfig &v)
{
	assert(x < m_button.size());
	m_button[x] = v;
}

inline size_t HardwareConfig::button_size() const
{
	return m_button.size();
}

#endif // CONFIG_BUTTON


#ifdef CONFIG_RELAY
inline const RelayConfig &HardwareConfig::relay(unsigned x) const
{
	return m_relay[x];
}

inline const std::vector<RelayConfig> &HardwareConfig::relay() const
{
	return m_relay;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_relay()
{
	m_relay.clear();
}

inline RelayConfig *HardwareConfig::mutable_relay(unsigned x)
{
	if (x >= m_relay.size())
		m_relay.resize(x+1);
	return &m_relay[x];
}

inline std::vector<RelayConfig> *HardwareConfig::mutable_relay()
{
	return &m_relay;
}

inline RelayConfig *HardwareConfig::add_relay()
{
	m_relay.resize(m_relay.size()+1);
	return &m_relay.back();
}

inline void HardwareConfig::set_relay(unsigned x, const RelayConfig &v)
{
	assert(x < m_relay.size());
	m_relay[x] = v;
}

inline size_t HardwareConfig::relay_size() const
{
	return m_relay.size();
}

#endif // CONFIG_RELAY


#ifdef CONFIG_LEDS
inline const LedConfig &HardwareConfig::led(unsigned x) const
{
	return m_led[x];
}

inline const std::vector<LedConfig> &HardwareConfig::led() const
{
	return m_led;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_led()
{
	m_led.clear();
}

inline LedConfig *HardwareConfig::mutable_led(unsigned x)
{
	if (x >= m_led.size())
		m_led.resize(x+1);
	return &m_led[x];
}

inline std::vector<LedConfig> *HardwareConfig::mutable_led()
{
	return &m_led;
}

inline LedConfig *HardwareConfig::add_led()
{
	m_led.resize(m_led.size()+1);
	return &m_led.back();
}

inline void HardwareConfig::set_led(unsigned x, const LedConfig &v)
{
	assert(x < m_led.size());
	m_led[x] = v;
}

inline size_t HardwareConfig::led_size() const
{
	return m_led.size();
}

#endif // CONFIG_LEDS


#ifdef CONFIG_BUZZER
inline const BuzzerConfig &HardwareConfig::buzzer() const
{
	return m_buzzer;
}

inline bool HardwareConfig::has_buzzer() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 4));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_buzzer()
{
	p_validbits &= ~((uint16_t)1U << 4);
	m_buzzer.clear();
}

inline BuzzerConfig *HardwareConfig::mutable_buzzer()
{
	if (0 == (p_validbits & ((uint16_t)1U << 4))) {
		p_validbits |= ((uint16_t)1U << 4);
		m_buzzer.clear();
	}
	return &m_buzzer;
}

inline void HardwareConfig::set_buzzer(const void *data, size_t s)
{
	m_buzzer.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 4);
}

inline void HardwareConfig::set_buzzer(const BuzzerConfig &v)
{
	m_buzzer = v;
	p_validbits |= ((uint16_t)1U << 4);
}

#endif // CONFIG_BUZZER


#ifdef CONFIG_HLW8012
inline const Hlw8012Config &HardwareConfig::hlw8012() const
{
	return m_hlw8012;
}

inline bool HardwareConfig::has_hlw8012() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 5));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_hlw8012()
{
	p_validbits &= ~((uint16_t)1U << 5);
	m_hlw8012.clear();
}

inline Hlw8012Config *HardwareConfig::mutable_hlw8012()
{
	if (0 == (p_validbits & ((uint16_t)1U << 5))) {
		p_validbits |= ((uint16_t)1U << 5);
		m_hlw8012.clear();
	}
	return &m_hlw8012;
}

inline void HardwareConfig::set_hlw8012(const void *data, size_t s)
{
	m_hlw8012.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 5);
}

inline void HardwareConfig::set_hlw8012(const Hlw8012Config &v)
{
	m_hlw8012 = v;
	p_validbits |= ((uint16_t)1U << 5);
}

#endif // CONFIG_HLW8012


#ifdef CONFIG_MAX7219
inline const Max7219Config &HardwareConfig::max7219() const
{
	return m_max7219;
}

inline bool HardwareConfig::has_max7219() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 6));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_max7219()
{
	p_validbits &= ~((uint16_t)1U << 6);
	m_max7219.clear();
}

inline Max7219Config *HardwareConfig::mutable_max7219()
{
	if (0 == (p_validbits & ((uint16_t)1U << 6))) {
		p_validbits |= ((uint16_t)1U << 6);
		m_max7219.clear();
	}
	return &m_max7219;
}

inline void HardwareConfig::set_max7219(const void *data, size_t s)
{
	m_max7219.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 6);
}

inline void HardwareConfig::set_max7219(const Max7219Config &v)
{
	m_max7219 = v;
	p_validbits |= ((uint16_t)1U << 6);
}

#endif // CONFIG_MAX7219


#ifdef CONFIG_TLC5947
inline const Tlc5947Config &HardwareConfig::tlc5947() const
{
	return m_tlc5947;
}

inline bool HardwareConfig::has_tlc5947() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 7));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_tlc5947()
{
	p_validbits &= ~((uint16_t)1U << 7);
	m_tlc5947.clear();
}

inline Tlc5947Config *HardwareConfig::mutable_tlc5947()
{
	if (0 == (p_validbits & ((uint16_t)1U << 7))) {
		p_validbits |= ((uint16_t)1U << 7);
		m_tlc5947.clear();
	}
	return &m_tlc5947;
}

inline void HardwareConfig::set_tlc5947(const void *data, size_t s)
{
	m_tlc5947.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 7);
}

inline void HardwareConfig::set_tlc5947(const Tlc5947Config &v)
{
	m_tlc5947 = v;
	p_validbits |= ((uint16_t)1U << 7);
}

#endif // CONFIG_TLC5947


#ifdef CONFIG_RGBLEDS
inline const Ws2812bConfig &HardwareConfig::ws2812b(unsigned x) const
{
	return m_ws2812b[x];
}

inline const std::vector<Ws2812bConfig> &HardwareConfig::ws2812b() const
{
	return m_ws2812b;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_ws2812b()
{
	m_ws2812b.clear();
}

inline Ws2812bConfig *HardwareConfig::mutable_ws2812b(unsigned x)
{
	if (x >= m_ws2812b.size())
		m_ws2812b.resize(x+1);
	return &m_ws2812b[x];
}

inline std::vector<Ws2812bConfig> *HardwareConfig::mutable_ws2812b()
{
	return &m_ws2812b;
}

inline Ws2812bConfig *HardwareConfig::add_ws2812b()
{
	m_ws2812b.resize(m_ws2812b.size()+1);
	return &m_ws2812b.back();
}

inline void HardwareConfig::set_ws2812b(unsigned x, const Ws2812bConfig &v)
{
	assert(x < m_ws2812b.size());
	m_ws2812b[x] = v;
}

inline size_t HardwareConfig::ws2812b_size() const
{
	return m_ws2812b.size();
}

#endif // CONFIG_RGBLEDS


#ifdef CONFIG_DHT
inline const DhtConfig &HardwareConfig::dht() const
{
	return m_dht;
}

inline bool HardwareConfig::has_dht() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 8));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_dht()
{
	p_validbits &= ~((uint16_t)1U << 8);
	m_dht.clear();
}

inline DhtConfig *HardwareConfig::mutable_dht()
{
	if (0 == (p_validbits & ((uint16_t)1U << 8))) {
		p_validbits |= ((uint16_t)1U << 8);
		m_dht.clear();
	}
	return &m_dht;
}

inline void HardwareConfig::set_dht(const void *data, size_t s)
{
	m_dht.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 8);
}

inline void HardwareConfig::set_dht(const DhtConfig &v)
{
	m_dht = v;
	p_validbits |= ((uint16_t)1U << 8);
}

#endif // CONFIG_DHT


#ifdef CONFIG_I2C
inline const I2CConfig &HardwareConfig::i2c(unsigned x) const
{
	return m_i2c[x];
}

inline const std::vector<I2CConfig> &HardwareConfig::i2c() const
{
	return m_i2c;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_i2c()
{
	m_i2c.clear();
}

inline I2CConfig *HardwareConfig::mutable_i2c(unsigned x)
{
	if (x >= m_i2c.size())
		m_i2c.resize(x+1);
	return &m_i2c[x];
}

inline std::vector<I2CConfig> *HardwareConfig::mutable_i2c()
{
	return &m_i2c;
}

inline I2CConfig *HardwareConfig::add_i2c()
{
	m_i2c.resize(m_i2c.size()+1);
	return &m_i2c.back();
}

inline void HardwareConfig::set_i2c(unsigned x, const I2CConfig &v)
{
	assert(x < m_i2c.size());
	m_i2c[x] = v;
}

inline size_t HardwareConfig::i2c_size() const
{
	return m_i2c.size();
}

#endif // CONFIG_I2C


#ifdef CONFIG_HCSR04
inline const HcSr04Config &HardwareConfig::hcsr04(unsigned x) const
{
	return m_hcsr04[x];
}

inline const std::vector<HcSr04Config> &HardwareConfig::hcsr04() const
{
	return m_hcsr04;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_hcsr04()
{
	m_hcsr04.clear();
}

inline HcSr04Config *HardwareConfig::mutable_hcsr04(unsigned x)
{
	if (x >= m_hcsr04.size())
		m_hcsr04.resize(x+1);
	return &m_hcsr04[x];
}

inline std::vector<HcSr04Config> *HardwareConfig::mutable_hcsr04()
{
	return &m_hcsr04;
}

inline HcSr04Config *HardwareConfig::add_hcsr04()
{
	m_hcsr04.resize(m_hcsr04.size()+1);
	return &m_hcsr04.back();
}

inline void HardwareConfig::set_hcsr04(unsigned x, const HcSr04Config &v)
{
	assert(x < m_hcsr04.size());
	m_hcsr04[x] = v;
}

inline size_t HardwareConfig::hcsr04_size() const
{
	return m_hcsr04.size();
}

#endif // CONFIG_HCSR04


#ifdef CONFIG_ONEWIRE
inline const OneWireConfig &HardwareConfig::onewire() const
{
	return m_onewire;
}

inline bool HardwareConfig::has_onewire() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 9));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_onewire()
{
	p_validbits &= ~((uint16_t)1U << 9);
	m_onewire.clear();
}

inline OneWireConfig *HardwareConfig::mutable_onewire()
{
	if (0 == (p_validbits & ((uint16_t)1U << 9))) {
		p_validbits |= ((uint16_t)1U << 9);
		m_onewire.clear();
	}
	return &m_onewire;
}

inline void HardwareConfig::set_onewire(const void *data, size_t s)
{
	m_onewire.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 9);
}

inline void HardwareConfig::set_onewire(const OneWireConfig &v)
{
	m_onewire = v;
	p_validbits |= ((uint16_t)1U << 9);
}

#endif // CONFIG_ONEWIRE


#ifdef CONFIG_SX1276
inline const SX1276Config &HardwareConfig::sx1276() const
{
	return m_sx1276;
}

inline bool HardwareConfig::has_sx1276() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 10));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_sx1276()
{
	p_validbits &= ~((uint16_t)1U << 10);
	m_sx1276.clear();
}

inline SX1276Config *HardwareConfig::mutable_sx1276()
{
	if (0 == (p_validbits & ((uint16_t)1U << 10))) {
		p_validbits |= ((uint16_t)1U << 10);
		m_sx1276.clear();
	}
	return &m_sx1276;
}

inline void HardwareConfig::set_sx1276(const void *data, size_t s)
{
	m_sx1276.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 10);
}

inline void HardwareConfig::set_sx1276(const SX1276Config &v)
{
	m_sx1276 = v;
	p_validbits |= ((uint16_t)1U << 10);
}

#endif // CONFIG_SX1276


#ifdef CONFIG_IOEXTENDERS
inline const GpioCluster &HardwareConfig::iocluster(unsigned x) const
{
	return m_iocluster[x];
}

inline const std::vector<GpioCluster> &HardwareConfig::iocluster() const
{
	return m_iocluster;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_iocluster()
{
	m_iocluster.clear();
}

inline GpioCluster *HardwareConfig::mutable_iocluster(unsigned x)
{
	if (x >= m_iocluster.size())
		m_iocluster.resize(x+1);
	return &m_iocluster[x];
}

inline std::vector<GpioCluster> *HardwareConfig::mutable_iocluster()
{
	return &m_iocluster;
}

inline GpioCluster *HardwareConfig::add_iocluster()
{
	m_iocluster.resize(m_iocluster.size()+1);
	return &m_iocluster.back();
}

inline void HardwareConfig::set_iocluster(unsigned x, const GpioCluster &v)
{
	assert(x < m_iocluster.size());
	m_iocluster[x] = v;
}

inline size_t HardwareConfig::iocluster_size() const
{
	return m_iocluster.size();
}

#endif // CONFIG_IOEXTENDERS


#ifdef CONFIG_DISPLAY
inline const DisplayConfig &HardwareConfig::display() const
{
	return m_display;
}

inline bool HardwareConfig::has_display() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 11));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_display()
{
	p_validbits &= ~((uint16_t)1U << 11);
	m_display.clear();
}

inline DisplayConfig *HardwareConfig::mutable_display()
{
	if (0 == (p_validbits & ((uint16_t)1U << 11))) {
		p_validbits |= ((uint16_t)1U << 11);
		m_display.clear();
	}
	return &m_display;
}

inline void HardwareConfig::set_display(const void *data, size_t s)
{
	m_display.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 11);
}

inline void HardwareConfig::set_display(const DisplayConfig &v)
{
	m_display = v;
	p_validbits |= ((uint16_t)1U << 11);
}

#endif // CONFIG_DISPLAY


#endif
