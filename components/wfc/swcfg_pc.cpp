/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: R2104.48 (hg:436/e1544d21e885)
 * WFC is Copyright 2015-2021, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : swcfg.wfc
 * Copyright: 2018-2021
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2022-10-07, 14:15:34 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from pc:
 * Optimize        : "speed"
 * toASCII         : "toASCII"
 * toSink          : ""
 * 
 * options from common:
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bool      : "ascii_bool"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * BaseClass       : ""
 * bytestype       : "std::string"
 * calcSize        : "calcSize"
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * copyright       : ""
 * email           : ""
 * endian          : "unknown"
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * IntSize         : 64
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * SortMembers     : "id"
 * stringtype      : "std::string"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * toString        : "toString"
 * toWire          : "toWire"
 * UnknownField    : "skip"
 * VarIntBits      : 64
 * wireput         : ""
 * wiresize        : ""
 * 
 * enabled flags from commandline:
 * 	enumnames
 * enabled flags from pc:
 * 	enummap
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux, withEqual, withUnequal
 */

#include <ostream>
#include <map>
#include <stdlib.h>
#include <string.h>
#include "swcfg.h"

#include "wfccore.h"

#if !defined(WFC_ENDIAN) || (WFC_ENDIAN != 0)
#error wfc: incompatible settings concerning endian
#endif


static const char *rstrsn_t_names[] = {
	"brownout",
	"deepsleep",
	"external",
	"internal_wdt",
	"panic",
	"powerup",
	"sdio",
	"software",
	"task_wdt",
	"unknown",
	"watchdog",
};

static rstrsn_t rstrsn_t_values[] = {
	brownout,
	deepsleep,
	external,
	internal_wdt,
	panic,
	powerup,
	sdio,
	software,
	task_wdt,
	unknown,
	watchdog,
};

size_t parse_ascii_rstrsn_t(rstrsn_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (rstrsn_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(rstrsn_t_names)/sizeof(rstrsn_t_names[0]); ++i) {
		if (0 == strcmp(rstrsn_t_names[i],s)) {
			*v = rstrsn_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *strReset(rstrsn_t e)
{
	for (size_t i = 0; i < sizeof(rstrsn_t_values)/sizeof(rstrsn_t_values[0]); ++i) {
		if (e == rstrsn_t_values[i])
			return rstrsn_t_names[i];
	}
	return 0;
}

static const char *WeekDay_names[] = {
	"EveryDay",
	"Friday",
	"Holiday",
	"Monday",
	"Saturday",
	"Sunday",
	"Thursday",
	"Tuesday",
	"Wednesday",
	"WeekEnd",
	"WorkDay",
};

static WeekDay WeekDay_values[] = {
	EveryDay,
	Friday,
	Holiday,
	Monday,
	Saturday,
	Sunday,
	Thursday,
	Tuesday,
	Wednesday,
	WeekEnd,
	WorkDay,
};

size_t parse_ascii_WeekDay(WeekDay *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (WeekDay)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(WeekDay_names)/sizeof(WeekDay_names[0]); ++i) {
		if (0 == strcmp(WeekDay_names[i],s)) {
			*v = WeekDay_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *WeekDay_str(WeekDay e)
{
	for (size_t i = 0; i < sizeof(WeekDay_values)/sizeof(WeekDay_values[0]); ++i) {
		if (e == WeekDay_values[i])
			return WeekDay_names[i];
	}
	return 0;
}

static const char *uart_wl_t_names[] = {
	"uart_wl_5",
	"uart_wl_6",
	"uart_wl_7",
	"uart_wl_8",
};


size_t parse_ascii_uart_wl_t(uart_wl_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (uart_wl_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(uart_wl_t_names)/sizeof(uart_wl_t_names[0]); ++i) {
		if (0 == strcmp(uart_wl_t_names[i],s)) {
			*v = (uart_wl_t)i;
			return strlen(s);
		}
	}
	return 0;
}

const char *uart_wl_t_str(uart_wl_t e)
{
	return uart_wl_t_names[(size_t)e];
}

static const char *uart_sb_t_names[] = {
	"uart_sb_1",
	"uart_sb_1_5",
	"uart_sb_2",
	"uart_sb_none",
};

static uart_sb_t uart_sb_t_values[] = {
	uart_sb_1,
	uart_sb_1_5,
	uart_sb_2,
	uart_sb_none,
};

size_t parse_ascii_uart_sb_t(uart_sb_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (uart_sb_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(uart_sb_t_names)/sizeof(uart_sb_t_names[0]); ++i) {
		if (0 == strcmp(uart_sb_t_names[i],s)) {
			*v = uart_sb_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *uart_sb_t_str(uart_sb_t e)
{
	for (size_t i = 0; i < sizeof(uart_sb_t_values)/sizeof(uart_sb_t_values[0]); ++i) {
		if (e == uart_sb_t_values[i])
			return uart_sb_t_names[i];
	}
	return 0;
}

static const char *uart_p_t_names[] = {
	"uart_p_e",
	"uart_p_n",
	"uart_p_o",
};

static uart_p_t uart_p_t_values[] = {
	uart_p_e,
	uart_p_n,
	uart_p_o,
};

size_t parse_ascii_uart_p_t(uart_p_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (uart_p_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(uart_p_t_names)/sizeof(uart_p_t_names[0]); ++i) {
		if (0 == strcmp(uart_p_t_names[i],s)) {
			*v = uart_p_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *uart_p_t_str(uart_p_t e)
{
	for (size_t i = 0; i < sizeof(uart_p_t_values)/sizeof(uart_p_t_values[0]); ++i) {
		if (e == uart_p_t_values[i])
			return uart_p_t_names[i];
	}
	return 0;
}

static const char *sigtype_t_names[] = {
	"st_float",
	"st_int",
	"st_invalid",
	"st_string",
};

static sigtype_t sigtype_t_values[] = {
	st_float,
	st_int,
	st_invalid,
	st_string,
};

size_t parse_ascii_sigtype_t(sigtype_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (sigtype_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(sigtype_t_names)/sizeof(sigtype_t_names[0]); ++i) {
		if (0 == strcmp(sigtype_t_names[i],s)) {
			*v = sigtype_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *sigtype_t_str(sigtype_t e)
{
	for (size_t i = 0; i < sizeof(sigtype_t_values)/sizeof(sigtype_t_values[0]); ++i) {
		if (e == sigtype_t_values[i])
			return sigtype_t_names[i];
	}
	return 0;
}

WifiConfig::WifiConfig()
: m_ssid()
, m_pass()
, m_mac()
, m_activate(false)
, m_addr4(0)
, m_netmask4(0)
, m_gateway4(0)
, p_validbits(0)
{
}

void WifiConfig::clear()
{
	m_ssid.clear();
	m_pass.clear();
	m_mac.clear();
	m_activate = false;
	m_addr4 = 0;
	m_netmask4 = 0;
	m_gateway4 = 0;
	p_validbits = 0;
}

void WifiConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "WifiConfig {";
	++indent;
	ascii_string(o,indent,m_ssid.data(),m_ssid.size(),"ssid");
	ascii_string(o,indent,m_pass.data(),m_pass.size(),"pass");
	ascii_bytes(o,(const uint8_t*)m_mac.data(),m_mac.size(),indent,"mac");
	ascii_bool(o, indent, "activate", m_activate);
	ascii_indent(o, indent, "addr4");
	ip4_to_ascii(o,m_addr4);
	o << ';';
	ascii_numeric(o, indent, "netmask4", (unsigned) m_netmask4);
	ascii_indent(o, indent, "gateway4");
	ip4_to_ascii(o,m_gateway4);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t WifiConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -1;
		a += fn;
		switch (fid) {
		case 0xa:	// ssid id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -2;
				m_ssid.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x12:	// pass id 2, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -3;
				m_pass.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x1a:	// mac id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -4;
				m_mac.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x23:	// activate id 4, type bool, coding 8bit
			if (a >= e)
				return -5;
			m_activate = *a++;
			break;
		case 0x2d:	// addr4 id 5, type uint32_t, coding 32bit
			if ((a+3) >= e)
				return -6;
			set_addr4((uint32_t) read_u32(a));
			a += 4;
			break;
		case 0x33:	// netmask4 id 6, type uint8_t, coding 8bit
			if (a >= e)
				return -7;
			set_netmask4(*a++);
			break;
		case 0x3d:	// gateway4 id 7, type uint32_t, coding 32bit
			if ((a+3) >= e)
				return -8;
			set_gateway4((uint32_t) read_u32(a));
			a += 4;
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -9;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -10;
	return a-(const uint8_t *)b;
}

ssize_t WifiConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has ssid?
	if (!m_ssid.empty()) {
		// 'ssid': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -11;
		*a++ = 0xa;
		ssize_t ssid_s = m_ssid.size();
		n = write_varint(a,e-a,ssid_s);
		a += n;
		if ((n <= 0) || ((e-a) < ssid_s))
			return -12;
		memcpy(a,m_ssid.data(),ssid_s);
		a += ssid_s;
	}
	// has pass?
	if (!m_pass.empty()) {
		// 'pass': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -13;
		*a++ = 0x12;
		ssize_t pass_s = m_pass.size();
		n = write_varint(a,e-a,pass_s);
		a += n;
		if ((n <= 0) || ((e-a) < pass_s))
			return -14;
		memcpy(a,m_pass.data(),pass_s);
		a += pass_s;
	}
	// has mac?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'mac': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -15;
		*a++ = 0x1a;
		ssize_t mac_s = m_mac.size();
		n = write_varint(a,e-a,mac_s);
		a += n;
		if ((n <= 0) || ((e-a) < mac_s))
			return -16;
		memcpy(a,m_mac.data(),mac_s);
		a += mac_s;
	}
	// 'activate': id=4, encoding=8bit, tag=0x23
	if (2 > (e-a))
		return -17;
	*a++ = 0x23;
	*a++ = m_activate;
	// has addr4?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'addr4': id=5, encoding=32bit, tag=0x2d
		if (5 > (e-a))
			return -18;
		*a++ = 0x2d;
		if ((e-a) < 4)
			return -19;
		write_u32(a,(uint32_t)m_addr4);
		a += 4;
	}
	// has netmask4?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'netmask4': id=6, encoding=8bit, tag=0x33
		if (2 > (e-a))
			return -20;
		*a++ = 0x33;
		*a++ = m_netmask4;
	}
	// has gateway4?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'gateway4': id=7, encoding=32bit, tag=0x3d
		if (5 > (e-a))
			return -21;
		*a++ = 0x3d;
		if ((e-a) < 4)
			return -22;
		write_u32(a,(uint32_t)m_gateway4);
		a += 4;
	}
	assert(a <= e);
	return a-b;
}

void WifiConfig::toWire(void (*put)(uint8_t)) const
{
	if (!m_ssid.empty()) {
		// 'ssid': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'ssid': id=1
		size_t ssid_s = m_ssid.size();
		send_varint(put,ssid_s);
		send_bytes(put,(const uint8_t*) m_ssid.data(),ssid_s);
	}
	if (!m_pass.empty()) {
		// 'pass': id=2, encoding=lenpfx, tag=0x12
		put(0x12);	// 'pass': id=2
		size_t pass_s = m_pass.size();
		send_varint(put,pass_s);
		send_bytes(put,(const uint8_t*) m_pass.data(),pass_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'mac': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'mac': id=3
		size_t mac_s = m_mac.size();
		send_varint(put,mac_s);
		send_bytes(put,(const uint8_t*) m_mac.data(),mac_s);
	}
	// 'activate': id=4, encoding=8bit, tag=0x23
	put(0x23);	// 'activate': id=4
	put(m_activate);
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'addr4': id=5, encoding=32bit, tag=0x2d
		put(0x2d);	// 'addr4': id=5
		send_u32(put,(uint32_t)m_addr4);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'netmask4': id=6, encoding=8bit, tag=0x33
		put(0x33);	// 'netmask4': id=6
		put(m_netmask4);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'gateway4': id=7, encoding=32bit, tag=0x3d
		put(0x3d);	// 'gateway4': id=7
		send_u32(put,(uint32_t)m_gateway4);
	}
}

void WifiConfig::toString(std::string &put) const
{
	if (!m_ssid.empty()) {
		// 'ssid': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'ssid': id=1
		size_t ssid_s = m_ssid.size();
		send_varint(put,ssid_s);
		put.append((const char *)(const uint8_t*) m_ssid.data(),ssid_s);
	}
	if (!m_pass.empty()) {
		// 'pass': id=2, encoding=lenpfx, tag=0x12
		put.push_back(0x12);	// 'pass': id=2
		size_t pass_s = m_pass.size();
		send_varint(put,pass_s);
		put.append((const char *)(const uint8_t*) m_pass.data(),pass_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'mac': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'mac': id=3
		size_t mac_s = m_mac.size();
		send_varint(put,mac_s);
		put.append((const char *)(const uint8_t*) m_mac.data(),mac_s);
	}
	// 'activate': id=4, encoding=8bit, tag=0x23
	put.push_back(0x23);	// 'activate': id=4
	put.push_back(m_activate);
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'addr4': id=5, encoding=32bit, tag=0x2d
		put.push_back(0x2d);	// 'addr4': id=5
		send_u32(put,(uint32_t)m_addr4);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'netmask4': id=6, encoding=8bit, tag=0x33
		put.push_back(0x33);	// 'netmask4': id=6
		put.push_back(m_netmask4);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'gateway4': id=7, encoding=32bit, tag=0x3d
		put.push_back(0x3d);	// 'gateway4': id=7
		send_u32(put,(uint32_t)m_gateway4);
	}
}

void WifiConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_ssid()) {
		fsep = json_indent(json,indLvl,fsep,"ssid");
		json_cstr(json,m_ssid.c_str());
	}
	if (has_pass()) {
		fsep = json_indent(json,indLvl,fsep,"pass");
		json_cstr(json,m_pass.c_str());
	}
	if (has_mac()) {
		fsep = json_indent(json,indLvl,fsep,"mac");
		json_string(json,m_mac);
	}
	fsep = json_indent(json,indLvl,fsep,"activate");
	json << (m_activate ? "true" : "false");
	if (has_addr4()) {
		fsep = json_indent(json,indLvl,fsep,"addr4");
		json.put('"');
		ip4_to_ascii(json,m_addr4);
		json.put('"');
	}
	if (has_netmask4()) {
		fsep = json_indent(json,indLvl,fsep,"netmask4");
		json << (unsigned) m_netmask4;
	}
	if (has_gateway4()) {
		fsep = json_indent(json,indLvl,fsep,"gateway4");
		json.put('"');
		ip4_to_ascii(json,m_gateway4);
		json.put('"');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t WifiConfig::calcSize() const
{
	// bool activate: tagsize 1, data size 1
	size_t r = 2;	// required size, default is fixed length
	// optional string ssid, id 1
	if (!m_ssid.empty()) {
		size_t ssid_s = m_ssid.size();
		r += ssid_s + wiresize(ssid_s) + 1 /* tag(ssid) 0x8 */;
	}
	// optional string pass, id 2
	if (!m_pass.empty()) {
		size_t pass_s = m_pass.size();
		r += pass_s + wiresize(pass_s) + 1 /* tag(pass) 0x10 */;
	}
	// optional bytes mac, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t mac_s = m_mac.size();
		r += mac_s + wiresize(mac_s) + 1 /* tag(mac) 0x18 */;
	}
	// optional fixed32 addr4, id 5
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += 5;
	}
	// optional fixed8 netmask4, id 6
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += 2;
	}
	// optional fixed32 gateway4, id 7
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		r += 5;
	}
	return r;
}

bool WifiConfig::operator != (const WifiConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_ssid() && (m_ssid != r.m_ssid))
		return true;
	if (has_pass() && (m_pass != r.m_pass))
		return true;
	if (has_mac() && (m_mac != r.m_mac))
		return true;
	if (m_activate != r.m_activate)
		return true;
	if (has_addr4() && (m_addr4 != r.m_addr4))
		return true;
	if (has_netmask4() && (m_netmask4 != r.m_netmask4))
		return true;
	if (has_gateway4() && (m_gateway4 != r.m_gateway4))
		return true;
	return false;
}


bool WifiConfig::operator == (const WifiConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int WifiConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"ssid")) {
		if (value == 0) {
			clear_ssid();
			return 0;
		}
		m_ssid = value;
		int r = m_ssid.size();
		return r;
	}
	if (0 == strcmp(name,"pass")) {
		if (value == 0) {
			clear_pass();
			return 0;
		}
		m_pass = value;
		int r = m_pass.size();
		return r;
	}
	if (0 == strcmp(name,"mac")) {
		if (value == 0) {
			clear_mac();
			return 0;
		}
		int r = parse_ascii_bytes(m_mac,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"activate")) {
		int r = parse_ascii_bool(&m_activate,value);
		return r;
	}
	if (0 == strcmp(name,"addr4")) {
		if (value == 0) {
			clear_addr4();
			return 0;
		}
		int r = parse_ipv4(&m_addr4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"netmask4")) {
		if (value == 0) {
			clear_netmask4();
			return 0;
		}
		int r = parse_ascii_u8(&m_netmask4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"gateway4")) {
		if (value == 0) {
			clear_gateway4();
			return 0;
		}
		int r = parse_ipv4(&m_gateway4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	return -23;
}

MQTT::MQTT()
: m_uri()
, m_enable(false)
, m_username()
, m_password()
{
}

void MQTT::clear()
{
	m_uri.clear();
	m_enable = false;
	m_username.clear();
	m_password.clear();
	m_subscribtions.clear();
}

void MQTT::toASCII(std::ostream &o, size_t indent) const
{
	o << "MQTT {";
	++indent;
	ascii_string(o,indent,m_uri.data(),m_uri.size(),"uri");
	ascii_bool(o, indent, "enable", m_enable);
	ascii_string(o,indent,m_username.data(),m_username.size(),"username");
	ascii_string(o,indent,m_password.data(),m_password.size(),"password");
	ascii_indent(o,indent);
	size_t s_subscribtions = m_subscribtions.size();
	o << "subscribtions[" << s_subscribtions << "] = {";
	++indent;
	for (size_t i = 0, e = s_subscribtions; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,indent,m_subscribtions[i].data(),m_subscribtions[i].size(),0);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t MQTT::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -24;
		a += fn;
		switch (fid) {
		case 0xa:	// uri id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -25;
				m_uri.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x13:	// enable id 2, type bool, coding 8bit
			if (a >= e)
				return -26;
			set_enable(*a++);
			break;
		case 0x1a:	// username id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -27;
				m_username.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x22:	// password id 4, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -28;
				m_password.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x2a:	// subscribtions id 5, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -29;
				m_subscribtions.emplace_back((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -30;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -31;
	return a-(const uint8_t *)b;
}

ssize_t MQTT::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has uri?
	if (!m_uri.empty()) {
		// 'uri': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -32;
		*a++ = 0xa;
		ssize_t uri_s = m_uri.size();
		n = write_varint(a,e-a,uri_s);
		a += n;
		if ((n <= 0) || ((e-a) < uri_s))
			return -33;
		memcpy(a,m_uri.data(),uri_s);
		a += uri_s;
	}
	// has enable?
	if (m_enable != false) {
		// 'enable': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -34;
		*a++ = 0x13;
		*a++ = m_enable;
	}
	// has username?
	if (!m_username.empty()) {
		// 'username': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -35;
		*a++ = 0x1a;
		ssize_t username_s = m_username.size();
		n = write_varint(a,e-a,username_s);
		a += n;
		if ((n <= 0) || ((e-a) < username_s))
			return -36;
		memcpy(a,m_username.data(),username_s);
		a += username_s;
	}
	// has password?
	if (!m_password.empty()) {
		// 'password': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -37;
		*a++ = 0x22;
		ssize_t password_s = m_password.size();
		n = write_varint(a,e-a,password_s);
		a += n;
		if ((n <= 0) || ((e-a) < password_s))
			return -38;
		memcpy(a,m_password.data(),password_s);
		a += password_s;
	}
	for (const auto &x : m_subscribtions) {
		// 'subscribtions': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -39;
		*a++ = 0x2a;
		ssize_t subscribtions_s = x.size();
		n = write_varint(a,e-a,subscribtions_s);
		a += n;
		if ((n <= 0) || ((e-a) < subscribtions_s))
			return -40;
		memcpy(a,x.data(),subscribtions_s);
		a += subscribtions_s;
	}
	assert(a <= e);
	return a-b;
}

void MQTT::toWire(void (*put)(uint8_t)) const
{
	if (!m_uri.empty()) {
		// 'uri': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'uri': id=1
		size_t uri_s = m_uri.size();
		send_varint(put,uri_s);
		send_bytes(put,(const uint8_t*) m_uri.data(),uri_s);
	}
	if (m_enable != false) {
		// 'enable': id=2, encoding=8bit, tag=0x13
		put(0x13);	// 'enable': id=2
		put(m_enable);
	}
	if (!m_username.empty()) {
		// 'username': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'username': id=3
		size_t username_s = m_username.size();
		send_varint(put,username_s);
		send_bytes(put,(const uint8_t*) m_username.data(),username_s);
	}
	if (!m_password.empty()) {
		// 'password': id=4, encoding=lenpfx, tag=0x22
		put(0x22);	// 'password': id=4
		size_t password_s = m_password.size();
		send_varint(put,password_s);
		send_bytes(put,(const uint8_t*) m_password.data(),password_s);
	}
	for (size_t x = 0, y = m_subscribtions.size(); x != y; ++x) {
		// 'subscribtions': id=5, encoding=lenpfx, tag=0x2a
		put(0x2a);	// 'subscribtions': id=5
		size_t subscribtions_s = m_subscribtions[x].size();
		send_varint(put,subscribtions_s);
		send_bytes(put,(const uint8_t*) m_subscribtions[x].data(),subscribtions_s);
	}
}

void MQTT::toString(std::string &put) const
{
	if (!m_uri.empty()) {
		// 'uri': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'uri': id=1
		size_t uri_s = m_uri.size();
		send_varint(put,uri_s);
		put.append((const char *)(const uint8_t*) m_uri.data(),uri_s);
	}
	if (m_enable != false) {
		// 'enable': id=2, encoding=8bit, tag=0x13
		put.push_back(0x13);	// 'enable': id=2
		put.push_back(m_enable);
	}
	if (!m_username.empty()) {
		// 'username': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'username': id=3
		size_t username_s = m_username.size();
		send_varint(put,username_s);
		put.append((const char *)(const uint8_t*) m_username.data(),username_s);
	}
	if (!m_password.empty()) {
		// 'password': id=4, encoding=lenpfx, tag=0x22
		put.push_back(0x22);	// 'password': id=4
		size_t password_s = m_password.size();
		send_varint(put,password_s);
		put.append((const char *)(const uint8_t*) m_password.data(),password_s);
	}
	for (size_t x = 0, y = m_subscribtions.size(); x != y; ++x) {
		// 'subscribtions': id=5, encoding=lenpfx, tag=0x2a
		put.push_back(0x2a);	// 'subscribtions': id=5
		size_t subscribtions_s = m_subscribtions[x].size();
		send_varint(put,subscribtions_s);
		put.append((const char *)(const uint8_t*) m_subscribtions[x].data(),subscribtions_s);
	}
}

void MQTT::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_uri()) {
		fsep = json_indent(json,indLvl,fsep,"uri");
		json_cstr(json,m_uri.c_str());
	}
	if (has_enable()) {
		fsep = json_indent(json,indLvl,fsep,"enable");
		json << (m_enable ? "true" : "false");
	}
	if (has_username()) {
		fsep = json_indent(json,indLvl,fsep,"username");
		json_cstr(json,m_username.c_str());
	}
	if (has_password()) {
		fsep = json_indent(json,indLvl,fsep,"password");
		json_cstr(json,m_password.c_str());
	}
	if (size_t s = m_subscribtions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"subscribtions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_subscribtions[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t MQTT::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string uri, id 1
	if (!m_uri.empty()) {
		size_t uri_s = m_uri.size();
		r += uri_s + wiresize(uri_s) + 1 /* tag(uri) 0x8 */;
	}
	// optional bool enable, id 2
	if (m_enable != false) {
		r += 2;
	}
	// optional string username, id 3
	if (!m_username.empty()) {
		size_t username_s = m_username.size();
		r += username_s + wiresize(username_s) + 1 /* tag(username) 0x18 */;
	}
	// optional string password, id 4
	if (!m_password.empty()) {
		size_t password_s = m_password.size();
		r += password_s + wiresize(password_s) + 1 /* tag(password) 0x20 */;
	}
	// repeated string subscribtions, id 5
	if (!m_subscribtions.empty()) {
		// subscribtions: repeated std::string
		for (size_t x = 0, y = m_subscribtions.size(); x < y; ++x) {
			size_t s = m_subscribtions[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(subscribtions) 0x28 */;
		}
	}
	return r;
}

bool MQTT::operator != (const MQTT &r) const
{
	if (has_uri() && (m_uri != r.m_uri))
		return true;
	if (has_enable() && (m_enable != r.m_enable))
		return true;
	if (has_username() && (m_username != r.m_username))
		return true;
	if (has_password() && (m_password != r.m_password))
		return true;
	if (m_subscribtions != r.m_subscribtions)
		return true;
	return false;
}


bool MQTT::operator == (const MQTT &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int MQTT::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"uri")) {
		if (value == 0) {
			clear_uri();
			return 0;
		}
		m_uri = value;
		int r = m_uri.size();
		return r;
	}
	if (0 == strcmp(name,"enable")) {
		if (value == 0) {
			clear_enable();
			return 0;
		}
		int r = parse_ascii_bool(&m_enable,value);
		return r;
	}
	if (0 == strcmp(name,"username")) {
		if (value == 0) {
			clear_username();
			return 0;
		}
		m_username = value;
		int r = m_username.size();
		return r;
	}
	if (0 == strcmp(name,"password")) {
		if (value == 0) {
			clear_password();
			return 0;
		}
		m_password = value;
		int r = m_password.size();
		return r;
	}
	if (0 == memcmp(name,"subscribtions",13)) {
		if ((name[13] == 0) && (value == 0)) {
			clear_subscribtions();
			return 0;
		} else if (name[13] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[14] == '+') && (name[15] == ']')) {
				x = m_subscribtions.size();
				m_subscribtions.resize(x+1);
				idxe = (char*)(name + 15);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+14,&idxe,0);
				if (idxe[0] != ']')
					return -41;
				if (m_subscribtions.size() <= x)
					return -42;
				if ((idxe[1] == 0) && (value == 0)) {
					m_subscribtions.erase(m_subscribtions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -43;
			m_subscribtions[x] = value;
			return m_subscribtions[x].size();
		}
	}
	return -44;
}

Date::Date()
: m_day(0)
, m_month(0)
, m_year(0)
, m_endday(0)
, m_endmonth(0)
, m_endyear(0)
{
}

void Date::clear()
{
	m_day = 0;
	m_month = 0;
	m_year = 0;
	m_endday = 0;
	m_endmonth = 0;
	m_endyear = 0;
}

void Date::toASCII(std::ostream &o, size_t indent) const
{
	o << "Date {";
	++indent;
	ascii_numeric(o, indent, "day", (unsigned) m_day);
	ascii_numeric(o, indent, "month", (unsigned) m_month);
	ascii_numeric(o, indent, "year", m_year);
	ascii_numeric(o, indent, "endday", (unsigned) m_endday);
	ascii_numeric(o, indent, "endmonth", (unsigned) m_endmonth);
	ascii_numeric(o, indent, "endyear", (unsigned) m_endyear);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Date::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -45;
		a += fn;
		switch (fid) {
		case 0xb:	// day id 1, type uint8_t, coding 8bit
			if (a >= e)
				return -46;
			set_day(*a++);
			break;
		case 0x13:	// month id 2, type uint8_t, coding 8bit
			if (a >= e)
				return -47;
			set_month(*a++);
			break;
		case 0x1c:	// year id 3, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -48;
			set_year((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x23:	// endday id 4, type uint8_t, coding 8bit
			if (a >= e)
				return -49;
			set_endday(*a++);
			break;
		case 0x2b:	// endmonth id 5, type uint8_t, coding 8bit
			if (a >= e)
				return -50;
			set_endmonth(*a++);
			break;
		case 0x33:	// endyear id 6, type uint8_t, coding 8bit
			if (a >= e)
				return -51;
			set_endyear(*a++);
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -52;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -53;
	return a-(const uint8_t *)b;
}

ssize_t Date::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	// has day?
	if (m_day != 0) {
		// 'day': id=1, encoding=8bit, tag=0xb
		if (2 > (e-a))
			return -54;
		*a++ = 0xb;
		*a++ = m_day;
	}
	// has month?
	if (m_month != 0) {
		// 'month': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -55;
		*a++ = 0x13;
		*a++ = m_month;
	}
	// has year?
	if (m_year != 0) {
		// 'year': id=3, encoding=16bit, tag=0x1c
		if (3 > (e-a))
			return -56;
		*a++ = 0x1c;
		write_u16(a,m_year);
		a += 2;
	}
	// has endday?
	if (m_endday != 0) {
		// 'endday': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -57;
		*a++ = 0x23;
		*a++ = m_endday;
	}
	// has endmonth?
	if (m_endmonth != 0) {
		// 'endmonth': id=5, encoding=8bit, tag=0x2b
		if (2 > (e-a))
			return -58;
		*a++ = 0x2b;
		*a++ = m_endmonth;
	}
	// has endyear?
	if (m_endyear != 0) {
		// 'endyear': id=6, encoding=8bit, tag=0x33
		if (2 > (e-a))
			return -59;
		*a++ = 0x33;
		*a++ = m_endyear;
	}
	assert(a <= e);
	return a-b;
}

void Date::toWire(void (*put)(uint8_t)) const
{
	if (m_day != 0) {
		// 'day': id=1, encoding=8bit, tag=0xb
		put(0xb);	// 'day': id=1
		put(m_day);
	}
	if (m_month != 0) {
		// 'month': id=2, encoding=8bit, tag=0x13
		put(0x13);	// 'month': id=2
		put(m_month);
	}
	if (m_year != 0) {
		// 'year': id=3, encoding=16bit, tag=0x1c
		put(0x1c);	// 'year': id=3
		send_u16(put,m_year);
	}
	if (m_endday != 0) {
		// 'endday': id=4, encoding=8bit, tag=0x23
		put(0x23);	// 'endday': id=4
		put(m_endday);
	}
	if (m_endmonth != 0) {
		// 'endmonth': id=5, encoding=8bit, tag=0x2b
		put(0x2b);	// 'endmonth': id=5
		put(m_endmonth);
	}
	if (m_endyear != 0) {
		// 'endyear': id=6, encoding=8bit, tag=0x33
		put(0x33);	// 'endyear': id=6
		put(m_endyear);
	}
}

void Date::toString(std::string &put) const
{
	if (m_day != 0) {
		// 'day': id=1, encoding=8bit, tag=0xb
		put.push_back(0xb);	// 'day': id=1
		put.push_back(m_day);
	}
	if (m_month != 0) {
		// 'month': id=2, encoding=8bit, tag=0x13
		put.push_back(0x13);	// 'month': id=2
		put.push_back(m_month);
	}
	if (m_year != 0) {
		// 'year': id=3, encoding=16bit, tag=0x1c
		put.push_back(0x1c);	// 'year': id=3
		send_u16(put,m_year);
	}
	if (m_endday != 0) {
		// 'endday': id=4, encoding=8bit, tag=0x23
		put.push_back(0x23);	// 'endday': id=4
		put.push_back(m_endday);
	}
	if (m_endmonth != 0) {
		// 'endmonth': id=5, encoding=8bit, tag=0x2b
		put.push_back(0x2b);	// 'endmonth': id=5
		put.push_back(m_endmonth);
	}
	if (m_endyear != 0) {
		// 'endyear': id=6, encoding=8bit, tag=0x33
		put.push_back(0x33);	// 'endyear': id=6
		put.push_back(m_endyear);
	}
}

void Date::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_day()) {
		fsep = json_indent(json,indLvl,fsep,"day");
		json << (unsigned) m_day;
	}
	if (has_month()) {
		fsep = json_indent(json,indLvl,fsep,"month");
		json << (unsigned) m_month;
	}
	if (has_year()) {
		fsep = json_indent(json,indLvl,fsep,"year");
		json << m_year;
	}
	if (has_endday()) {
		fsep = json_indent(json,indLvl,fsep,"endday");
		json << (unsigned) m_endday;
	}
	if (has_endmonth()) {
		fsep = json_indent(json,indLvl,fsep,"endmonth");
		json << (unsigned) m_endmonth;
	}
	if (has_endyear()) {
		fsep = json_indent(json,indLvl,fsep,"endyear");
		json << (unsigned) m_endyear;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Date::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed8 day, id 1
	if (m_day != 0) {
		r += 2;
	}
	// optional fixed8 month, id 2
	if (m_month != 0) {
		r += 2;
	}
	// optional fixed16 year, id 3
	if (m_year != 0) {
		r += 3;
	}
	// optional fixed8 endday, id 4
	if (m_endday != 0) {
		r += 2;
	}
	// optional fixed8 endmonth, id 5
	if (m_endmonth != 0) {
		r += 2;
	}
	// optional fixed8 endyear, id 6
	if (m_endyear != 0) {
		r += 2;
	}
	return r;
}

bool Date::operator != (const Date &r) const
{
	if (has_day() && (m_day != r.m_day))
		return true;
	if (has_month() && (m_month != r.m_month))
		return true;
	if (has_year() && (m_year != r.m_year))
		return true;
	if (has_endday() && (m_endday != r.m_endday))
		return true;
	if (has_endmonth() && (m_endmonth != r.m_endmonth))
		return true;
	if (has_endyear() && (m_endyear != r.m_endyear))
		return true;
	return false;
}


bool Date::operator == (const Date &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Date::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"day")) {
		if (value == 0) {
			clear_day();
			return 0;
		}
		int r = parse_ascii_u8(&m_day,value);
		return r;
	}
	if (0 == strcmp(name,"month")) {
		if (value == 0) {
			clear_month();
			return 0;
		}
		int r = parse_ascii_u8(&m_month,value);
		return r;
	}
	if (0 == strcmp(name,"year")) {
		if (value == 0) {
			clear_year();
			return 0;
		}
		int r = parse_ascii_u16(&m_year,value);
		return r;
	}
	if (0 == strcmp(name,"endday")) {
		if (value == 0) {
			clear_endday();
			return 0;
		}
		int r = parse_ascii_u8(&m_endday,value);
		return r;
	}
	if (0 == strcmp(name,"endmonth")) {
		if (value == 0) {
			clear_endmonth();
			return 0;
		}
		int r = parse_ascii_u8(&m_endmonth,value);
		return r;
	}
	if (0 == strcmp(name,"endyear")) {
		if (value == 0) {
			clear_endyear();
			return 0;
		}
		int r = parse_ascii_u8(&m_endyear,value);
		return r;
	}
	return -60;
}

AtAction::AtAction()
: m_day(Sunday)
, m_min_of_day(0)
, m_action()
, m_enable(true)
, p_validbits(0)
{
}

void AtAction::clear()
{
	m_day = Sunday;
	m_min_of_day = 0;
	m_action.clear();
	m_enable = true;
	p_validbits = 0;
}

void AtAction::toASCII(std::ostream &o, size_t indent) const
{
	o << "AtAction {";
	++indent;
	if (const char *v = WeekDay_str(m_day))
		o << v;
	else
		o << m_day;
	o << ';';
	ascii_numeric(o, indent, "min_of_day", m_min_of_day);
	ascii_string(o,indent,m_action.data(),m_action.size(),"action");
	ascii_bool(o, indent, "enable", m_enable);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AtAction::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -61;
		a += fn;
		switch (fid) {
		case 0x8:	// day id 1, type WeekDay, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -62;
				a += n;
				set_day((WeekDay) v);
			}
			break;
		case 0x10:	// min_of_day id 2, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -63;
				a += n;
				set_min_of_day(v);
			}
			break;
		case 0x1a:	// action id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -64;
				m_action.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 2);
			break;
		case 0x23:	// enable id 4, type bool, coding 8bit
			if (a >= e)
				return -65;
			m_enable = *a++;
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -66;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -67;
	return a-(const uint8_t *)b;
}

ssize_t AtAction::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has day?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'day': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -68;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_day);
		if (n <= 0)
			return -69;
		a += n;
	}
	// has min_of_day?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'min_of_day': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -70;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_min_of_day);
		if (n <= 0)
			return -71;
		a += n;
	}
	// has action?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'action': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -72;
		*a++ = 0x1a;
		ssize_t action_s = m_action.size();
		n = write_varint(a,e-a,action_s);
		a += n;
		if ((n <= 0) || ((e-a) < action_s))
			return -73;
		memcpy(a,m_action.data(),action_s);
		a += action_s;
	}
	// 'enable': id=4, encoding=8bit, tag=0x23
	if (2 > (e-a))
		return -74;
	*a++ = 0x23;
	*a++ = m_enable;
	assert(a <= e);
	return a-b;
}

void AtAction::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'day': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'day': id=1
		send_varint(put,m_day);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'min_of_day': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'min_of_day': id=2
		send_varint(put,m_min_of_day);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'action': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'action': id=3
		size_t action_s = m_action.size();
		send_varint(put,action_s);
		send_bytes(put,(const uint8_t*) m_action.data(),action_s);
	}
	// 'enable': id=4, encoding=8bit, tag=0x23
	put(0x23);	// 'enable': id=4
	put(m_enable);
}

void AtAction::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'day': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'day': id=1
		send_varint(put,m_day);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'min_of_day': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'min_of_day': id=2
		send_varint(put,m_min_of_day);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'action': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'action': id=3
		size_t action_s = m_action.size();
		send_varint(put,action_s);
		put.append((const char *)(const uint8_t*) m_action.data(),action_s);
	}
	// 'enable': id=4, encoding=8bit, tag=0x23
	put.push_back(0x23);	// 'enable': id=4
	put.push_back(m_enable);
}

void AtAction::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_day()) {
		fsep = json_indent(json,indLvl,fsep,"day");
		if (const char *v = WeekDay_str(m_day)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_day;
		}
	}
	if (has_min_of_day()) {
		fsep = json_indent(json,indLvl,fsep,"min_of_day");
		json.put('"');
		min_of_day_to_ascii(json,m_min_of_day);
		json.put('"');
	}
	if (has_action()) {
		fsep = json_indent(json,indLvl,fsep,"action");
		json_cstr(json,m_action.c_str());
	}
	fsep = json_indent(json,indLvl,fsep,"enable");
	json << (m_enable ? "true" : "false");
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AtAction::calcSize() const
{
	// bool enable: tagsize 1, data size 1
	size_t r = 2;	// required size, default is fixed length
	// optional WeekDay day, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_day) + 1 /* tag(day) 0x8 */;
	}
	// optional unsigned min_of_day, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_min_of_day) + 1 /* tag(min_of_day) 0x10 */;
	}
	// optional string action, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		size_t action_s = m_action.size();
		r += action_s + wiresize(action_s) + 1 /* tag(action) 0x18 */;
	}
	return r;
}

bool AtAction::operator != (const AtAction &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_day() && (m_day != r.m_day))
		return true;
	if (has_min_of_day() && (m_min_of_day != r.m_min_of_day))
		return true;
	if (has_action() && (m_action != r.m_action))
		return true;
	if (m_enable != r.m_enable)
		return true;
	return false;
}


bool AtAction::operator == (const AtAction &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AtAction::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"day")) {
		if (value == 0) {
			clear_day();
			return 0;
		}
		WeekDay v;
		size_t r = parse_ascii_WeekDay(&v,value);
		if (r == 0)
			return -75;
		set_day(v);
		return r;
	}
	if (0 == strcmp(name,"min_of_day")) {
		if (value == 0) {
			clear_min_of_day();
			return 0;
		}
		int r = parse_ascii_u64(&m_min_of_day,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"action")) {
		if (value == 0) {
			clear_action();
			return 0;
		}
		m_action = value;
		int r = m_action.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"enable")) {
		int r = parse_ascii_bool(&m_enable,value);
		return r;
	}
	return -76;
}

Influx::Influx()
: m_hostname()
, m_port(0)
, m_measurement()
// omitted obsolete member interval
, m_database()
{
}

void Influx::clear()
{
	m_hostname.clear();
	m_port = 0;
	m_measurement.clear();
	m_database.clear();
}

void Influx::toASCII(std::ostream &o, size_t indent) const
{
	o << "Influx {";
	++indent;
	ascii_string(o,indent,m_hostname.data(),m_hostname.size(),"hostname");
	ascii_numeric(o, indent, "port", m_port);
	ascii_string(o,indent,m_measurement.data(),m_measurement.size(),"measurement");
	ascii_string(o,indent,m_database.data(),m_database.size(),"database");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Influx::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -77;
		a += fn;
		switch (fid) {
		case 0xa:	// hostname id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -78;
				m_hostname.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x14:	// port id 2, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -79;
			set_port((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x1a:	// measurement id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -80;
				m_measurement.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x2a:	// database id 5, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -81;
				m_database.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -82;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -83;
	return a-(const uint8_t *)b;
}

ssize_t Influx::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has hostname?
	if (!m_hostname.empty()) {
		// 'hostname': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -84;
		*a++ = 0xa;
		ssize_t hostname_s = m_hostname.size();
		n = write_varint(a,e-a,hostname_s);
		a += n;
		if ((n <= 0) || ((e-a) < hostname_s))
			return -85;
		memcpy(a,m_hostname.data(),hostname_s);
		a += hostname_s;
	}
	// has port?
	if (m_port != 0) {
		// 'port': id=2, encoding=16bit, tag=0x14
		if (3 > (e-a))
			return -86;
		*a++ = 0x14;
		write_u16(a,m_port);
		a += 2;
	}
	// has measurement?
	if (!m_measurement.empty()) {
		// 'measurement': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -87;
		*a++ = 0x1a;
		ssize_t measurement_s = m_measurement.size();
		n = write_varint(a,e-a,measurement_s);
		a += n;
		if ((n <= 0) || ((e-a) < measurement_s))
			return -88;
		memcpy(a,m_measurement.data(),measurement_s);
		a += measurement_s;
	}
	// 'interval' is obsolete. Therefore no data will be written.
	// has database?
	if (!m_database.empty()) {
		// 'database': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -89;
		*a++ = 0x2a;
		ssize_t database_s = m_database.size();
		n = write_varint(a,e-a,database_s);
		a += n;
		if ((n <= 0) || ((e-a) < database_s))
			return -90;
		memcpy(a,m_database.data(),database_s);
		a += database_s;
	}
	assert(a <= e);
	return a-b;
}

void Influx::toWire(void (*put)(uint8_t)) const
{
	if (!m_hostname.empty()) {
		// 'hostname': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'hostname': id=1
		size_t hostname_s = m_hostname.size();
		send_varint(put,hostname_s);
		send_bytes(put,(const uint8_t*) m_hostname.data(),hostname_s);
	}
	if (m_port != 0) {
		// 'port': id=2, encoding=16bit, tag=0x14
		put(0x14);	// 'port': id=2
		send_u16(put,m_port);
	}
	if (!m_measurement.empty()) {
		// 'measurement': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'measurement': id=3
		size_t measurement_s = m_measurement.size();
		send_varint(put,measurement_s);
		send_bytes(put,(const uint8_t*) m_measurement.data(),measurement_s);
	}
	// 'interval' is deprecated. Therefore no data will be written.
	if (!m_database.empty()) {
		// 'database': id=5, encoding=lenpfx, tag=0x2a
		put(0x2a);	// 'database': id=5
		size_t database_s = m_database.size();
		send_varint(put,database_s);
		send_bytes(put,(const uint8_t*) m_database.data(),database_s);
	}
}

void Influx::toString(std::string &put) const
{
	if (!m_hostname.empty()) {
		// 'hostname': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'hostname': id=1
		size_t hostname_s = m_hostname.size();
		send_varint(put,hostname_s);
		put.append((const char *)(const uint8_t*) m_hostname.data(),hostname_s);
	}
	if (m_port != 0) {
		// 'port': id=2, encoding=16bit, tag=0x14
		put.push_back(0x14);	// 'port': id=2
		send_u16(put,m_port);
	}
	if (!m_measurement.empty()) {
		// 'measurement': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'measurement': id=3
		size_t measurement_s = m_measurement.size();
		send_varint(put,measurement_s);
		put.append((const char *)(const uint8_t*) m_measurement.data(),measurement_s);
	}
	// 'interval' is deprecated. Therefore no data will be written.
	if (!m_database.empty()) {
		// 'database': id=5, encoding=lenpfx, tag=0x2a
		put.push_back(0x2a);	// 'database': id=5
		size_t database_s = m_database.size();
		send_varint(put,database_s);
		put.append((const char *)(const uint8_t*) m_database.data(),database_s);
	}
}

void Influx::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_hostname()) {
		fsep = json_indent(json,indLvl,fsep,"hostname");
		json_cstr(json,m_hostname.c_str());
	}
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << m_port;
	}
	if (has_measurement()) {
		fsep = json_indent(json,indLvl,fsep,"measurement");
		json_cstr(json,m_measurement.c_str());
	}
	if (has_database()) {
		fsep = json_indent(json,indLvl,fsep,"database");
		json_cstr(json,m_database.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Influx::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string hostname, id 1
	if (!m_hostname.empty()) {
		size_t hostname_s = m_hostname.size();
		r += hostname_s + wiresize(hostname_s) + 1 /* tag(hostname) 0x8 */;
	}
	// optional fixed16 port, id 2
	if (m_port != 0) {
		r += 3;
	}
	// optional string measurement, id 3
	if (!m_measurement.empty()) {
		size_t measurement_s = m_measurement.size();
		r += measurement_s + wiresize(measurement_s) + 1 /* tag(measurement) 0x18 */;
	}
	// obsolete optional unsigned interval, id 4
	// optional string database, id 5
	if (!m_database.empty()) {
		size_t database_s = m_database.size();
		r += database_s + wiresize(database_s) + 1 /* tag(database) 0x28 */;
	}
	return r;
}

bool Influx::operator != (const Influx &r) const
{
	if (has_hostname() && (m_hostname != r.m_hostname))
		return true;
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_measurement() && (m_measurement != r.m_measurement))
		return true;
	if (has_database() && (m_database != r.m_database))
		return true;
	return false;
}


bool Influx::operator == (const Influx &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Influx::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"hostname")) {
		if (value == 0) {
			clear_hostname();
			return 0;
		}
		m_hostname = value;
		int r = m_hostname.size();
		return r;
	}
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_port,value);
		return r;
	}
	if (0 == strcmp(name,"measurement")) {
		if (value == 0) {
			clear_measurement();
			return 0;
		}
		m_measurement = value;
		int r = m_measurement.size();
		return r;
	}
	if (0 == strcmp(name,"database")) {
		if (value == 0) {
			clear_database();
			return 0;
		}
		m_database = value;
		int r = m_database.size();
		return r;
	}
	return -91;
}

UartSettings::UartSettings()
: m_port(0)
, m_baudrate(0)
, m_config(5)
, m_rx_thresh(0)
, m_tx_bufsize(0)
, m_rx_bufsize(0)
, p_validbits(0)
{
}

void UartSettings::clear()
{
	m_port = 0;
	m_baudrate = 0;
	m_config = 5;
	m_rx_thresh = 0;
	m_tx_bufsize = 0;
	m_rx_bufsize = 0;
	p_validbits = 0;
}

void UartSettings::toASCII(std::ostream &o, size_t indent) const
{
	o << "UartSettings {";
	++indent;
	ascii_numeric(o, indent, "port", (unsigned) m_port);
	ascii_numeric(o, indent, "baudrate", m_baudrate);
	ascii_numeric(o, indent, "config", m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".wl = " ;
	o << uart_wl_t_str(config_wl());
	o << ';';
	ascii_indent(o,indent);
	o << ".sb = " ;
	o << uart_sb_t_str(config_sb());
	o << ';';
	ascii_indent(o,indent);
	o << ".rts = " ;
	o << (config_rts() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".cts = " ;
	o << (config_cts() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".p = " ;
	o << uart_p_t_str(config_p());
	o << ';';
	ascii_indent(o,indent);
	o << ".ref_tick = " ;
	o << (config_ref_tick() ? "true;" : "false;");
	--indent;
	ascii_numeric(o, indent, "rx_thresh", (unsigned) m_rx_thresh);
	ascii_numeric(o, indent, "tx_bufsize", m_tx_bufsize);
	ascii_numeric(o, indent, "rx_bufsize", m_rx_bufsize);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t UartSettings::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -92;
		a += fn;
		switch (fid) {
		case 0x8:	// port id 1, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -93;
				a += n;
				set_port(v);
			}
			break;
		case 0x10:	// baudrate id 2, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -94;
				a += n;
				set_baudrate(v);
			}
			break;
		case 0x1c:	// config id 3, type uartcfg_t, coding 16bit
			if ((a+1) >= e)
				return -95;
			set_config((uartcfg_t) (uartcfg_t) read_u16(a));
			a += 2;
			break;
		case 0x23:	// rx_thresh id 4, type uint8_t, coding 8bit
			if (a >= e)
				return -96;
			set_rx_thresh(*a++);
			break;
		case 0x30:	// tx_bufsize id 6, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -97;
				a += n;
				set_tx_bufsize(v);
			}
			break;
		case 0x38:	// rx_bufsize id 7, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -98;
				a += n;
				set_rx_bufsize(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -99;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -100;
	return a-(const uint8_t *)b;
}

ssize_t UartSettings::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -101;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_port);
		if (n <= 0)
			return -102;
		a += n;
	}
	// has baudrate?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'baudrate': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -103;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_baudrate);
		if (n <= 0)
			return -104;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'config': id=3, encoding=16bit, tag=0x1c
		if (a >= e)
			return -105;
		*a++ = 0x1c;
		write_u16(a,m_config);
		a += 2;
	}
	// has rx_thresh?
	if (m_rx_thresh != 0) {
		// 'rx_thresh': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -106;
		*a++ = 0x23;
		*a++ = m_rx_thresh;
	}
	// has tx_bufsize?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'tx_bufsize': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -107;
		*a++ = 0x30;
		n = write_varint(a,e-a,m_tx_bufsize);
		if (n <= 0)
			return -108;
		a += n;
	}
	// has rx_bufsize?
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'rx_bufsize': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -109;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_rx_bufsize);
		if (n <= 0)
			return -110;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void UartSettings::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'port': id=1
		send_varint(put,m_port);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'baudrate': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'baudrate': id=2
		send_varint(put,m_baudrate);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'config': id=3, encoding=16bit, tag=0x1c
		put(0x1c);	// 'config': id=3
		send_u16(put,m_config);
	}
	if (m_rx_thresh != 0) {
		// 'rx_thresh': id=4, encoding=8bit, tag=0x23
		put(0x23);	// 'rx_thresh': id=4
		put(m_rx_thresh);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'tx_bufsize': id=6, encoding=varint, tag=0x30
		put(0x30);	// 'tx_bufsize': id=6
		send_varint(put,m_tx_bufsize);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'rx_bufsize': id=7, encoding=varint, tag=0x38
		put(0x38);	// 'rx_bufsize': id=7
		send_varint(put,m_rx_bufsize);
	}
}

void UartSettings::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'port': id=1
		send_varint(put,m_port);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'baudrate': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'baudrate': id=2
		send_varint(put,m_baudrate);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'config': id=3, encoding=16bit, tag=0x1c
		put.push_back(0x1c);	// 'config': id=3
		send_u16(put,m_config);
	}
	if (m_rx_thresh != 0) {
		// 'rx_thresh': id=4, encoding=8bit, tag=0x23
		put.push_back(0x23);	// 'rx_thresh': id=4
		put.push_back(m_rx_thresh);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'tx_bufsize': id=6, encoding=varint, tag=0x30
		put.push_back(0x30);	// 'tx_bufsize': id=6
		send_varint(put,m_tx_bufsize);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'rx_bufsize': id=7, encoding=varint, tag=0x38
		put.push_back(0x38);	// 'rx_bufsize': id=7
		send_varint(put,m_rx_bufsize);
	}
}

void UartSettings::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << (unsigned) m_port;
	}
	if (has_baudrate()) {
		fsep = json_indent(json,indLvl,fsep,"baudrate");
		json << m_baudrate;
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (has_rx_thresh()) {
		fsep = json_indent(json,indLvl,fsep,"rx_thresh");
		json << (unsigned) m_rx_thresh;
	}
	if (has_tx_bufsize()) {
		fsep = json_indent(json,indLvl,fsep,"tx_bufsize");
		json << m_tx_bufsize;
	}
	if (has_rx_bufsize()) {
		fsep = json_indent(json,indLvl,fsep,"rx_bufsize");
		json << m_rx_bufsize;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t UartSettings::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional uint8 port, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional unsigned baudrate, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_baudrate) + 1 /* tag(baudrate) 0x10 */;
	}
	// optional uartcfg_t config, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	// optional fixed8 rx_thresh, id 4
	if (m_rx_thresh != 0) {
		r += 2;
	}
	// optional unsigned tx_bufsize, id 6
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		r += wiresize((varint_t)m_tx_bufsize) + 1 /* tag(tx_bufsize) 0x30 */;
	}
	// optional unsigned rx_bufsize, id 7
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		r += wiresize((varint_t)m_rx_bufsize) + 1 /* tag(rx_bufsize) 0x38 */;
	}
	return r;
}

bool UartSettings::operator != (const UartSettings &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_baudrate() && (m_baudrate != r.m_baudrate))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	if (has_rx_thresh() && (m_rx_thresh != r.m_rx_thresh))
		return true;
	if (has_tx_bufsize() && (m_tx_bufsize != r.m_tx_bufsize))
		return true;
	if (has_rx_bufsize() && (m_rx_bufsize != r.m_rx_bufsize))
		return true;
	return false;
}


bool UartSettings::operator == (const UartSettings &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int UartSettings::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u8(&m_port,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"baudrate")) {
		if (value == 0) {
			clear_baudrate();
			return 0;
		}
		int r = parse_ascii_u64(&m_baudrate,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((uartcfg_t)ull);
			else if (!strcmp(name,"wl"))
				set_config_wl((uart_wl_t)ull);
			else if (!strcmp(name,"sb"))
				set_config_sb((uart_sb_t)ull);
			else if (!strcmp(name,"rts"))
				set_config_rts((bool)ull);
			else if (!strcmp(name,"cts"))
				set_config_cts((bool)ull);
			else if (!strcmp(name,"p"))
				set_config_p((uart_p_t)ull);
			else if (!strcmp(name,"ref_tick"))
				set_config_ref_tick((bool)ull);
			return eptr - value;
		} else {
			return -111;
		}
	}
	if (0 == strcmp(name,"rx_thresh")) {
		if (value == 0) {
			clear_rx_thresh();
			return 0;
		}
		int r = parse_ascii_u8(&m_rx_thresh,value);
		return r;
	}
	if (0 == strcmp(name,"tx_bufsize")) {
		if (value == 0) {
			clear_tx_bufsize();
			return 0;
		}
		int r = parse_ascii_u64(&m_tx_bufsize,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	if (0 == strcmp(name,"rx_bufsize")) {
		if (value == 0) {
			clear_rx_bufsize();
			return 0;
		}
		int r = parse_ascii_u64(&m_rx_bufsize,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 4);
		return r;
	}
	return -112;
}

FtpHttpConfig::FtpHttpConfig()
: m_port(0)
, m_start(true)
, m_root()
, m_uploaddir()
, p_validbits(0)
{
}

void FtpHttpConfig::clear()
{
	m_port = 0;
	m_start = true;
	m_root.clear();
	m_uploaddir.clear();
	p_validbits = 0;
}

void FtpHttpConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "FtpHttpConfig {";
	++indent;
	ascii_numeric(o, indent, "port", m_port);
	ascii_bool(o, indent, "start", m_start);
	ascii_string(o,indent,m_root.data(),m_root.size(),"root");
	ascii_string(o,indent,m_uploaddir.data(),m_uploaddir.size(),"uploaddir");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t FtpHttpConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -113;
		a += fn;
		switch (fid) {
		case 0xc:	// port id 1, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -114;
			set_port((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x13:	// start id 2, type bool, coding 8bit
			if (a >= e)
				return -115;
			set_start(*a++);
			break;
		case 0x1a:	// root id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -116;
				m_root.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x22:	// uploaddir id 4, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -117;
				m_uploaddir.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -118;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -119;
	return a-(const uint8_t *)b;
}

ssize_t FtpHttpConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (m_port != 0) {
		// 'port': id=1, encoding=16bit, tag=0xc
		if (3 > (e-a))
			return -120;
		*a++ = 0xc;
		write_u16(a,m_port);
		a += 2;
	}
	// has start?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'start': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -121;
		*a++ = 0x13;
		*a++ = m_start;
	}
	// has root?
	if (!m_root.empty()) {
		// 'root': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -122;
		*a++ = 0x1a;
		ssize_t root_s = m_root.size();
		n = write_varint(a,e-a,root_s);
		a += n;
		if ((n <= 0) || ((e-a) < root_s))
			return -123;
		memcpy(a,m_root.data(),root_s);
		a += root_s;
	}
	// has uploaddir?
	if (!m_uploaddir.empty()) {
		// 'uploaddir': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -124;
		*a++ = 0x22;
		ssize_t uploaddir_s = m_uploaddir.size();
		n = write_varint(a,e-a,uploaddir_s);
		a += n;
		if ((n <= 0) || ((e-a) < uploaddir_s))
			return -125;
		memcpy(a,m_uploaddir.data(),uploaddir_s);
		a += uploaddir_s;
	}
	assert(a <= e);
	return a-b;
}

void FtpHttpConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_port != 0) {
		// 'port': id=1, encoding=16bit, tag=0xc
		put(0xc);	// 'port': id=1
		send_u16(put,m_port);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'start': id=2, encoding=8bit, tag=0x13
		put(0x13);	// 'start': id=2
		put(m_start);
	}
	if (!m_root.empty()) {
		// 'root': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'root': id=3
		size_t root_s = m_root.size();
		send_varint(put,root_s);
		send_bytes(put,(const uint8_t*) m_root.data(),root_s);
	}
	if (!m_uploaddir.empty()) {
		// 'uploaddir': id=4, encoding=lenpfx, tag=0x22
		put(0x22);	// 'uploaddir': id=4
		size_t uploaddir_s = m_uploaddir.size();
		send_varint(put,uploaddir_s);
		send_bytes(put,(const uint8_t*) m_uploaddir.data(),uploaddir_s);
	}
}

void FtpHttpConfig::toString(std::string &put) const
{
	if (m_port != 0) {
		// 'port': id=1, encoding=16bit, tag=0xc
		put.push_back(0xc);	// 'port': id=1
		send_u16(put,m_port);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'start': id=2, encoding=8bit, tag=0x13
		put.push_back(0x13);	// 'start': id=2
		put.push_back(m_start);
	}
	if (!m_root.empty()) {
		// 'root': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'root': id=3
		size_t root_s = m_root.size();
		send_varint(put,root_s);
		put.append((const char *)(const uint8_t*) m_root.data(),root_s);
	}
	if (!m_uploaddir.empty()) {
		// 'uploaddir': id=4, encoding=lenpfx, tag=0x22
		put.push_back(0x22);	// 'uploaddir': id=4
		size_t uploaddir_s = m_uploaddir.size();
		send_varint(put,uploaddir_s);
		put.append((const char *)(const uint8_t*) m_uploaddir.data(),uploaddir_s);
	}
}

void FtpHttpConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << m_port;
	}
	if (has_start()) {
		fsep = json_indent(json,indLvl,fsep,"start");
		json << (m_start ? "true" : "false");
	}
	if (has_root()) {
		fsep = json_indent(json,indLvl,fsep,"root");
		json_cstr(json,m_root.c_str());
	}
	if (has_uploaddir()) {
		fsep = json_indent(json,indLvl,fsep,"uploaddir");
		json_cstr(json,m_uploaddir.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t FtpHttpConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed16 port, id 1
	if (m_port != 0) {
		r += 3;
	}
	// optional bool start, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += 2;
	}
	// optional string root, id 3
	if (!m_root.empty()) {
		size_t root_s = m_root.size();
		r += root_s + wiresize(root_s) + 1 /* tag(root) 0x18 */;
	}
	// optional string uploaddir, id 4
	if (!m_uploaddir.empty()) {
		size_t uploaddir_s = m_uploaddir.size();
		r += uploaddir_s + wiresize(uploaddir_s) + 1 /* tag(uploaddir) 0x20 */;
	}
	return r;
}

bool FtpHttpConfig::operator != (const FtpHttpConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_start() && (m_start != r.m_start))
		return true;
	if (has_root() && (m_root != r.m_root))
		return true;
	if (has_uploaddir() && (m_uploaddir != r.m_uploaddir))
		return true;
	return false;
}


bool FtpHttpConfig::operator == (const FtpHttpConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int FtpHttpConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_port,value);
		return r;
	}
	if (0 == strcmp(name,"start")) {
		if (value == 0) {
			clear_start();
			return 0;
		}
		int r = parse_ascii_bool(&m_start,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"root")) {
		if (value == 0) {
			clear_root();
			return 0;
		}
		m_root = value;
		int r = m_root.size();
		return r;
	}
	if (0 == strcmp(name,"uploaddir")) {
		if (value == 0) {
			clear_uploaddir();
			return 0;
		}
		m_uploaddir = value;
		int r = m_uploaddir.size();
		return r;
	}
	return -126;
}

TerminalConfig::TerminalConfig()
: m_uart_rx(-1)
, m_uart_tx(-1)
, m_name()
, p_validbits(0)
{
}

void TerminalConfig::clear()
{
	m_uart_rx = -1;
	m_uart_tx = -1;
	m_name.clear();
	p_validbits = 0;
}

void TerminalConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "TerminalConfig {";
	++indent;
	ascii_numeric(o, indent, "uart_rx", (signed) m_uart_rx);
	ascii_numeric(o, indent, "uart_tx", (signed) m_uart_tx);
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t TerminalConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -127;
		a += fn;
		switch (fid) {
		case 0x8:	// uart_rx id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -128;
				a += n;
				set_uart_rx(varint_sint(v));
			}
			break;
		case 0x10:	// uart_tx id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -129;
				a += n;
				set_uart_tx(varint_sint(v));
			}
			break;
		case 0x1a:	// name id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -130;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -131;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -132;
	return a-(const uint8_t *)b;
}

ssize_t TerminalConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has uart_rx?
	if (m_uart_rx != -1) {
		// 'uart_rx': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -133;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_uart_rx));
		if (n <= 0)
			return -134;
		a += n;
	}
	// has uart_tx?
	if (m_uart_tx != -1) {
		// 'uart_tx': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -135;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_uart_tx));
		if (n <= 0)
			return -136;
		a += n;
	}
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -137;
		*a++ = 0x1a;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -138;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	assert(a <= e);
	return a-b;
}

void TerminalConfig::toWire(void (*put)(uint8_t)) const
{
	if (m_uart_rx != -1) {
		// 'uart_rx': id=1, encoding=varint, tag=0x8
		put(0x8);	// 'uart_rx': id=1
		send_varint(put,sint_varint(m_uart_rx));
	}
	if (m_uart_tx != -1) {
		// 'uart_tx': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'uart_tx': id=2
		send_varint(put,sint_varint(m_uart_tx));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'name': id=3
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
}

void TerminalConfig::toString(std::string &put) const
{
	if (m_uart_rx != -1) {
		// 'uart_rx': id=1, encoding=varint, tag=0x8
		put.push_back(0x8);	// 'uart_rx': id=1
		send_varint(put,sint_varint(m_uart_rx));
	}
	if (m_uart_tx != -1) {
		// 'uart_tx': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'uart_tx': id=2
		send_varint(put,sint_varint(m_uart_tx));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'name': id=3
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
}

void TerminalConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_uart_rx()) {
		fsep = json_indent(json,indLvl,fsep,"uart_rx");
		json << (int) m_uart_rx;
	}
	if (has_uart_tx()) {
		fsep = json_indent(json,indLvl,fsep,"uart_tx");
		json << (int) m_uart_tx;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TerminalConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 uart_rx, id 1
	if (m_uart_rx != -1) {
		r += wiresize_s((varint_t)m_uart_rx) + 1 /* tag(uart_rx) 0x8 */;
	}
	// optional sint8 uart_tx, id 2
	if (m_uart_tx != -1) {
		r += wiresize_s((varint_t)m_uart_tx) + 1 /* tag(uart_tx) 0x10 */;
	}
	// optional string name, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	return r;
}

bool TerminalConfig::operator != (const TerminalConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_uart_rx() && (m_uart_rx != r.m_uart_rx))
		return true;
	if (has_uart_tx() && (m_uart_tx != r.m_uart_tx))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	return false;
}


bool TerminalConfig::operator == (const TerminalConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TerminalConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"uart_rx")) {
		if (value == 0) {
			clear_uart_rx();
			return 0;
		}
		int r = parse_ascii_s8(&m_uart_rx,value);
		return r;
	}
	if (0 == strcmp(name,"uart_tx")) {
		if (value == 0) {
			clear_uart_tx();
			return 0;
		}
		int r = parse_ascii_s8(&m_uart_tx,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	return -139;
}

Trigger::Trigger()
: m_event()
, p_validbits(0)
{
}

void Trigger::clear()
{
	m_event.clear();
	m_action.clear();
	p_validbits = 0;
}

void Trigger::toASCII(std::ostream &o, size_t indent) const
{
	o << "Trigger {";
	++indent;
	ascii_string(o,indent,m_event.data(),m_event.size(),"event");
	ascii_indent(o,indent);
	size_t s_action = m_action.size();
	o << "action[" << s_action << "] = {";
	++indent;
	for (size_t i = 0, e = s_action; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,indent,m_action[i].data(),m_action[i].size(),0);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Trigger::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -140;
		a += fn;
		switch (fid) {
		case 0xa:	// event id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -141;
				m_event.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x12:	// action id 2, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -142;
				m_action.emplace_back((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -143;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -144;
	return a-(const uint8_t *)b;
}

ssize_t Trigger::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has event?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'event': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -145;
		*a++ = 0xa;
		ssize_t event_s = m_event.size();
		n = write_varint(a,e-a,event_s);
		a += n;
		if ((n <= 0) || ((e-a) < event_s))
			return -146;
		memcpy(a,m_event.data(),event_s);
		a += event_s;
	}
	for (const auto &x : m_action) {
		// 'action': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -147;
		*a++ = 0x12;
		ssize_t action_s = x.size();
		n = write_varint(a,e-a,action_s);
		a += n;
		if ((n <= 0) || ((e-a) < action_s))
			return -148;
		memcpy(a,x.data(),action_s);
		a += action_s;
	}
	assert(a <= e);
	return a-b;
}

void Trigger::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'event': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'event': id=1
		size_t event_s = m_event.size();
		send_varint(put,event_s);
		send_bytes(put,(const uint8_t*) m_event.data(),event_s);
	}
	for (size_t x = 0, y = m_action.size(); x != y; ++x) {
		// 'action': id=2, encoding=lenpfx, tag=0x12
		put(0x12);	// 'action': id=2
		size_t action_s = m_action[x].size();
		send_varint(put,action_s);
		send_bytes(put,(const uint8_t*) m_action[x].data(),action_s);
	}
}

void Trigger::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'event': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'event': id=1
		size_t event_s = m_event.size();
		send_varint(put,event_s);
		put.append((const char *)(const uint8_t*) m_event.data(),event_s);
	}
	for (size_t x = 0, y = m_action.size(); x != y; ++x) {
		// 'action': id=2, encoding=lenpfx, tag=0x12
		put.push_back(0x12);	// 'action': id=2
		size_t action_s = m_action[x].size();
		send_varint(put,action_s);
		put.append((const char *)(const uint8_t*) m_action[x].data(),action_s);
	}
}

void Trigger::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_event()) {
		fsep = json_indent(json,indLvl,fsep,"event");
		json_cstr(json,m_event.c_str());
	}
	if (size_t s = m_action.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"action\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_action[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Trigger::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string event, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t event_s = m_event.size();
		r += event_s + wiresize(event_s) + 1 /* tag(event) 0x8 */;
	}
	// repeated string action, id 2
	if (!m_action.empty()) {
		// action: repeated std::string
		for (size_t x = 0, y = m_action.size(); x < y; ++x) {
			size_t s = m_action[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(action) 0x10 */;
		}
	}
	return r;
}

bool Trigger::operator != (const Trigger &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_event() && (m_event != r.m_event))
		return true;
	if (m_action != r.m_action)
		return true;
	return false;
}


bool Trigger::operator == (const Trigger &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Trigger::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"event")) {
		if (value == 0) {
			clear_event();
			return 0;
		}
		m_event = value;
		int r = m_event.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == memcmp(name,"action",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_action();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_action.size();
				m_action.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -149;
				if (m_action.size() <= x)
					return -150;
				if ((idxe[1] == 0) && (value == 0)) {
					m_action.erase(m_action.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -151;
			m_action[x] = value;
			return m_action[x].size();
		}
	}
	return -152;
}

AppParam::AppParam()
: m_key()
, m_uValue(0)
, m_sValue()
, m_dValue(0)
, m_fValue(0)
, p_validbits(0)
{
}

void AppParam::clear()
{
	m_key.clear();
	m_uValue = 0;
	m_sValue.clear();
	m_dValue = 0;
	m_fValue = 0;
	p_validbits = 0;
}

void AppParam::toASCII(std::ostream &o, size_t indent) const
{
	o << "AppParam {";
	++indent;
	ascii_string(o,indent,m_key.data(),m_key.size(),"key");
	ascii_numeric(o, indent, "uValue", m_uValue);
	ascii_string(o,indent,m_sValue.data(),m_sValue.size(),"sValue");
	ascii_numeric(o, indent, "dValue", m_dValue);
	ascii_numeric(o, indent, "fValue", m_fValue);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AppParam::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -153;
		a += fn;
		switch (fid) {
		case 0xa:	// key id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -154;
				m_key.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x10:	// uValue id 2, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -155;
				a += n;
				set_uValue(v);
			}
			break;
		case 0x1a:	// sValue id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -156;
				m_sValue.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 2);
			break;
		case 0x20:	// dValue id 4, type int64_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -157;
				a += n;
				set_dValue(varint_sint(v));
			}
			break;
		case 0x29:	// fValue id 5, type double, coding 64bit
			if ((a+7) >= e)
				return -158;
			set_fValue(read_double(a));
			a += 8;
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -159;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -160;
	return a-(const uint8_t *)b;
}

ssize_t AppParam::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has key?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'key': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -161;
		*a++ = 0xa;
		ssize_t key_s = m_key.size();
		n = write_varint(a,e-a,key_s);
		a += n;
		if ((n <= 0) || ((e-a) < key_s))
			return -162;
		memcpy(a,m_key.data(),key_s);
		a += key_s;
	}
	// has uValue?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'uValue': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -163;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_uValue);
		if (n <= 0)
			return -164;
		a += n;
	}
	// has sValue?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'sValue': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -165;
		*a++ = 0x1a;
		ssize_t sValue_s = m_sValue.size();
		n = write_varint(a,e-a,sValue_s);
		a += n;
		if ((n <= 0) || ((e-a) < sValue_s))
			return -166;
		memcpy(a,m_sValue.data(),sValue_s);
		a += sValue_s;
	}
	// has dValue?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'dValue': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -167;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_dValue));
		if (n <= 0)
			return -168;
		a += n;
	}
	// has fValue?
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'fValue': id=5, encoding=64bit, tag=0x29
		if (9 > (e-a))
			return -169;
		*a++ = 0x29;
		write_u64(a,mangle_double(m_fValue));
		a += 8;
	}
	assert(a <= e);
	return a-b;
}

void AppParam::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'key': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'key': id=1
		size_t key_s = m_key.size();
		send_varint(put,key_s);
		send_bytes(put,(const uint8_t*) m_key.data(),key_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'uValue': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'uValue': id=2
		send_varint(put,m_uValue);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'sValue': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'sValue': id=3
		size_t sValue_s = m_sValue.size();
		send_varint(put,sValue_s);
		send_bytes(put,(const uint8_t*) m_sValue.data(),sValue_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'dValue': id=4, encoding=varint, tag=0x20
		put(0x20);	// 'dValue': id=4
		send_varint(put,sint_varint(m_dValue));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'fValue': id=5, encoding=64bit, tag=0x29
		put(0x29);	// 'fValue': id=5
		send_u64(put,mangle_double(m_fValue));
	}
}

void AppParam::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'key': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'key': id=1
		size_t key_s = m_key.size();
		send_varint(put,key_s);
		put.append((const char *)(const uint8_t*) m_key.data(),key_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'uValue': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'uValue': id=2
		send_varint(put,m_uValue);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'sValue': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'sValue': id=3
		size_t sValue_s = m_sValue.size();
		send_varint(put,sValue_s);
		put.append((const char *)(const uint8_t*) m_sValue.data(),sValue_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'dValue': id=4, encoding=varint, tag=0x20
		put.push_back(0x20);	// 'dValue': id=4
		send_varint(put,sint_varint(m_dValue));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'fValue': id=5, encoding=64bit, tag=0x29
		put.push_back(0x29);	// 'fValue': id=5
		send_u64(put,mangle_double(m_fValue));
	}
}

void AppParam::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_key()) {
		fsep = json_indent(json,indLvl,fsep,"key");
		json_cstr(json,m_key.c_str());
	}
	if (has_uValue()) {
		fsep = json_indent(json,indLvl,fsep,"uValue");
		json << m_uValue;
	}
	if (has_sValue()) {
		fsep = json_indent(json,indLvl,fsep,"sValue");
		json_cstr(json,m_sValue.c_str());
	}
	if (has_dValue()) {
		fsep = json_indent(json,indLvl,fsep,"dValue");
		json << m_dValue;
	}
	if (has_fValue()) {
		fsep = json_indent(json,indLvl,fsep,"fValue");
		to_dblstr(json,m_fValue);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AppParam::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string key, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t key_s = m_key.size();
		r += key_s + wiresize(key_s) + 1 /* tag(key) 0x8 */;
	}
	// optional unsigned uValue, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_uValue) + 1 /* tag(uValue) 0x10 */;
	}
	// optional string sValue, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		size_t sValue_s = m_sValue.size();
		r += sValue_s + wiresize(sValue_s) + 1 /* tag(sValue) 0x18 */;
	}
	// optional signed dValue, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		r += wiresize_s((varint_t)m_dValue) + 1 /* tag(dValue) 0x20 */;
	}
	// optional double fValue, id 5
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		r += 9;
	}
	return r;
}

bool AppParam::operator != (const AppParam &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_key() && (m_key != r.m_key))
		return true;
	if (has_uValue() && (m_uValue != r.m_uValue))
		return true;
	if (has_sValue() && (m_sValue != r.m_sValue))
		return true;
	if (has_dValue() && (m_dValue != r.m_dValue))
		return true;
	if (has_fValue() && (m_fValue != r.m_fValue))
		return true;
	return false;
}


bool AppParam::operator == (const AppParam &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AppParam::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"key")) {
		if (value == 0) {
			clear_key();
			return 0;
		}
		m_key = value;
		int r = m_key.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"uValue")) {
		if (value == 0) {
			clear_uValue();
			return 0;
		}
		int r = parse_ascii_u64(&m_uValue,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"sValue")) {
		if (value == 0) {
			clear_sValue();
			return 0;
		}
		m_sValue = value;
		int r = m_sValue.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"dValue")) {
		if (value == 0) {
			clear_dValue();
			return 0;
		}
		int r = parse_ascii_s64(&m_dValue,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	if (0 == strcmp(name,"fValue")) {
		if (value == 0) {
			clear_fValue();
			return 0;
		}
		int r = parse_ascii_dbl(&m_fValue,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 4);
		return r;
	}
	return -170;
}

EventTimer::EventTimer()
: m_name()
, m_time(0)
, m_config(0)
, p_validbits(0)
{
}

void EventTimer::clear()
{
	m_name.clear();
	m_time = 0;
	m_config = 0;
	p_validbits = 0;
}

void EventTimer::toASCII(std::ostream &o, size_t indent) const
{
	o << "EventTimer {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "time", m_time);
	ascii_numeric(o, indent, "config", (unsigned) m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".restart = " ;
	o << (config_restart() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".autostart = " ;
	o << (config_autostart() ? "true;" : "false;");
	--indent;
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t EventTimer::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -171;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -172;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// time id 2, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -173;
				a += n;
				set_time(v);
			}
			break;
		case 0x18:	// config id 3, type eventcfg_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -174;
				a += n;
				set_config((eventcfg_t) v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -175;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -176;
	return a-(const uint8_t *)b;
}

ssize_t EventTimer::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -177;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -178;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has time?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'time': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -179;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_time);
		if (n <= 0)
			return -180;
		a += n;
	}
	// has config?
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -181;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -182;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void EventTimer::toWire(void (*put)(uint8_t)) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'time': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'time': id=2
		send_varint(put,m_time);
	}
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'config': id=3
		send_varint(put,m_config);
	}
}

void EventTimer::toString(std::string &put) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'time': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'time': id=2
		send_varint(put,m_time);
	}
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'config': id=3
		send_varint(put,m_config);
	}
}

void EventTimer::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_time()) {
		fsep = json_indent(json,indLvl,fsep,"time");
		json << m_time;
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t EventTimer::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional unsigned time, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_time) + 1 /* tag(time) 0x10 */;
	}
	// optional eventcfg_t config, id 3
	if (m_config != 0) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	return r;
}

bool EventTimer::operator != (const EventTimer &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_time() && (m_time != r.m_time))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	return false;
}


bool EventTimer::operator == (const EventTimer &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int EventTimer::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"time")) {
		if (value == 0) {
			clear_time();
			return 0;
		}
		int r = parse_ascii_u64(&m_time,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((eventcfg_t)ull);
			else if (!strcmp(name,"restart"))
				set_config_restart((bool)ull);
			else if (!strcmp(name,"autostart"))
				set_config_autostart((bool)ull);
			return eptr - value;
		} else {
			return -183;
		}
	}
	return -184;
}

FunctionConfig::FunctionConfig()
: m_name()
, m_func()
, p_validbits(0)
{
}

void FunctionConfig::clear()
{
	m_name.clear();
	m_func.clear();
	m_params.clear();
	p_validbits = 0;
}

void FunctionConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "FunctionConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_string(o,indent,m_func.data(),m_func.size(),"func");
	ascii_indent(o,indent);
	size_t s_params = m_params.size();
	o << "params[" << s_params << "] = {";
	++indent;
	for (size_t i = 0, e = s_params; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,indent,m_params[i].data(),m_params[i].size(),0);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t FunctionConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -185;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -186;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x12:	// func id 2, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -187;
				m_func.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 1);
			break;
		case 0x1a:	// params id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -188;
				m_params.emplace_back((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -189;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -190;
	return a-(const uint8_t *)b;
}

ssize_t FunctionConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -191;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -192;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has func?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'func': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -193;
		*a++ = 0x12;
		ssize_t func_s = m_func.size();
		n = write_varint(a,e-a,func_s);
		a += n;
		if ((n <= 0) || ((e-a) < func_s))
			return -194;
		memcpy(a,m_func.data(),func_s);
		a += func_s;
	}
	for (const auto &x : m_params) {
		// 'params': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -195;
		*a++ = 0x1a;
		ssize_t params_s = x.size();
		n = write_varint(a,e-a,params_s);
		a += n;
		if ((n <= 0) || ((e-a) < params_s))
			return -196;
		memcpy(a,x.data(),params_s);
		a += params_s;
	}
	assert(a <= e);
	return a-b;
}

void FunctionConfig::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'func': id=2, encoding=lenpfx, tag=0x12
		put(0x12);	// 'func': id=2
		size_t func_s = m_func.size();
		send_varint(put,func_s);
		send_bytes(put,(const uint8_t*) m_func.data(),func_s);
	}
	for (size_t x = 0, y = m_params.size(); x != y; ++x) {
		// 'params': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'params': id=3
		size_t params_s = m_params[x].size();
		send_varint(put,params_s);
		send_bytes(put,(const uint8_t*) m_params[x].data(),params_s);
	}
}

void FunctionConfig::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'func': id=2, encoding=lenpfx, tag=0x12
		put.push_back(0x12);	// 'func': id=2
		size_t func_s = m_func.size();
		send_varint(put,func_s);
		put.append((const char *)(const uint8_t*) m_func.data(),func_s);
	}
	for (size_t x = 0, y = m_params.size(); x != y; ++x) {
		// 'params': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'params': id=3
		size_t params_s = m_params[x].size();
		send_varint(put,params_s);
		put.append((const char *)(const uint8_t*) m_params[x].data(),params_s);
	}
}

void FunctionConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_func()) {
		fsep = json_indent(json,indLvl,fsep,"func");
		json_cstr(json,m_func.c_str());
	}
	if (size_t s = m_params.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"params\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_params[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t FunctionConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional string func, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		size_t func_s = m_func.size();
		r += func_s + wiresize(func_s) + 1 /* tag(func) 0x10 */;
	}
	// repeated string params, id 3
	if (!m_params.empty()) {
		// params: repeated std::string
		for (size_t x = 0, y = m_params.size(); x < y; ++x) {
			size_t s = m_params[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(params) 0x18 */;
		}
	}
	return r;
}

bool FunctionConfig::operator != (const FunctionConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_func() && (m_func != r.m_func))
		return true;
	if (m_params != r.m_params)
		return true;
	return false;
}


bool FunctionConfig::operator == (const FunctionConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int FunctionConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"func")) {
		if (value == 0) {
			clear_func();
			return 0;
		}
		m_func = value;
		int r = m_func.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == memcmp(name,"params",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_params();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_params.size();
				m_params.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -197;
				if (m_params.size() <= x)
					return -198;
				if ((idxe[1] == 0) && (value == 0)) {
					m_params.erase(m_params.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -199;
			m_params[x] = value;
			return m_params[x].size();
		}
	}
	return -200;
}

SignalConfig::SignalConfig()
: m_name()
, m_type(st_invalid)
, m_iv()
{
}

void SignalConfig::clear()
{
	m_name.clear();
	m_type = st_invalid;
	m_iv.clear();
}

void SignalConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "SignalConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	if (const char *v = sigtype_t_str(m_type))
		o << v;
	else
		o << m_type;
	o << ';';
	ascii_string(o,indent,m_iv.data(),m_iv.size(),"iv");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SignalConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -201;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -202;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// type id 2, type sigtype_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -203;
				a += n;
				set_type((sigtype_t) v);
			}
			break;
		case 0x1a:	// iv id 3, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -204;
				m_iv.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -205;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -206;
	return a-(const uint8_t *)b;
}

ssize_t SignalConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -207;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -208;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has type?
	if (m_type != st_invalid) {
		// 'type': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -209;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_type);
		if (n <= 0)
			return -210;
		a += n;
	}
	// has iv?
	if (!m_iv.empty()) {
		// 'iv': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -211;
		*a++ = 0x1a;
		ssize_t iv_s = m_iv.size();
		n = write_varint(a,e-a,iv_s);
		a += n;
		if ((n <= 0) || ((e-a) < iv_s))
			return -212;
		memcpy(a,m_iv.data(),iv_s);
		a += iv_s;
	}
	assert(a <= e);
	return a-b;
}

void SignalConfig::toWire(void (*put)(uint8_t)) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (m_type != st_invalid) {
		// 'type': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'type': id=2
		send_varint(put,m_type);
	}
	if (!m_iv.empty()) {
		// 'iv': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'iv': id=3
		size_t iv_s = m_iv.size();
		send_varint(put,iv_s);
		send_bytes(put,(const uint8_t*) m_iv.data(),iv_s);
	}
}

void SignalConfig::toString(std::string &put) const
{
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (m_type != st_invalid) {
		// 'type': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'type': id=2
		send_varint(put,m_type);
	}
	if (!m_iv.empty()) {
		// 'iv': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'iv': id=3
		size_t iv_s = m_iv.size();
		send_varint(put,iv_s);
		put.append((const char *)(const uint8_t*) m_iv.data(),iv_s);
	}
}

void SignalConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_type()) {
		fsep = json_indent(json,indLvl,fsep,"type");
		if (const char *v = sigtype_t_str(m_type)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_type;
		}
	}
	if (has_iv()) {
		fsep = json_indent(json,indLvl,fsep,"iv");
		json_cstr(json,m_iv.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SignalConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sigtype_t type, id 2
	if (m_type != st_invalid) {
		r += wiresize((varint_t)m_type) + 1 /* tag(type) 0x10 */;
	}
	// optional string iv, id 3
	if (!m_iv.empty()) {
		size_t iv_s = m_iv.size();
		r += iv_s + wiresize(iv_s) + 1 /* tag(iv) 0x18 */;
	}
	return r;
}

bool SignalConfig::operator != (const SignalConfig &r) const
{
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_type() && (m_type != r.m_type))
		return true;
	if (has_iv() && (m_iv != r.m_iv))
		return true;
	return false;
}


bool SignalConfig::operator == (const SignalConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SignalConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"type")) {
		if (value == 0) {
			clear_type();
			return 0;
		}
		sigtype_t v;
		size_t r = parse_ascii_sigtype_t(&v,value);
		if (r == 0)
			return -213;
		set_type(v);
		return r;
	}
	if (0 == strcmp(name,"iv")) {
		if (value == 0) {
			clear_iv();
			return 0;
		}
		m_iv = value;
		int r = m_iv.size();
		return r;
	}
	return -214;
}

OwDeviceConfig::OwDeviceConfig()
: m_id(0)
, m_name()
, p_validbits(0)
{
}

void OwDeviceConfig::clear()
{
	m_id = 0;
	m_name.clear();
	p_validbits = 0;
}

void OwDeviceConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "OwDeviceConfig {";
	++indent;
	ascii_indent(o, indent, "id");
	id64_to_ascii(o,m_id);
	o << ';';
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t OwDeviceConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -215;
		a += fn;
		switch (fid) {
		case 0x9:	// id id 1, type uint64_t, coding 64bit
			if ((a+7) >= e)
				return -216;
			set_id((uint64_t) read_u64(a));
			a += 8;
			break;
		case 0x12:	// name id 2, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -217;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 1);
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -218;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -219;
	return a-(const uint8_t *)b;
}

ssize_t OwDeviceConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has id?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'id': id=1, encoding=64bit, tag=0x9
		if (9 > (e-a))
			return -220;
		*a++ = 0x9;
		write_u64(a,(uint64_t)m_id);
		a += 8;
	}
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'name': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -221;
		*a++ = 0x12;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -222;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	assert(a <= e);
	return a-b;
}

void OwDeviceConfig::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'id': id=1, encoding=64bit, tag=0x9
		put(0x9);	// 'id': id=1
		send_u64(put,(uint64_t)m_id);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'name': id=2, encoding=lenpfx, tag=0x12
		put(0x12);	// 'name': id=2
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
}

void OwDeviceConfig::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'id': id=1, encoding=64bit, tag=0x9
		put.push_back(0x9);	// 'id': id=1
		send_u64(put,(uint64_t)m_id);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'name': id=2, encoding=lenpfx, tag=0x12
		put.push_back(0x12);	// 'name': id=2
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
}

void OwDeviceConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_id()) {
		fsep = json_indent(json,indLvl,fsep,"id");
		json << m_id;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t OwDeviceConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed64 id, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += 9;
	}
	// optional string name, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x10 */;
	}
	return r;
}

bool OwDeviceConfig::operator != (const OwDeviceConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_id() && (m_id != r.m_id))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	return false;
}


bool OwDeviceConfig::operator == (const OwDeviceConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int OwDeviceConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"id")) {
		if (value == 0) {
			clear_id();
			return 0;
		}
		int r = parse_ascii_u64(&m_id,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	return -223;
}

StateConfig::StateConfig()
: m_name()
, p_validbits(0)
{
}

void StateConfig::clear()
{
	m_name.clear();
	m_conds.clear();
	p_validbits = 0;
}

void StateConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "StateConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_indent(o,indent);
	size_t s_conds = m_conds.size();
	o << "conds[" << s_conds << "] = {";
	++indent;
	for (size_t i = 0, e = s_conds; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_conds[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t StateConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -224;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -225;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x12:	// conds id 2, type Trigger, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -226;
				m_conds.emplace_back();
				if (v != 0) {
					n = m_conds.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -227;
					a += v;
				}
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -228;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -229;
	return a-(const uint8_t *)b;
}

ssize_t StateConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -230;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -231;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	for (const auto &x : m_conds) {
		// 'conds': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -232;
		*a++ = 0x12;
		ssize_t conds_ws = x.calcSize();
		n = write_varint(a,e-a,conds_ws);
		a += n;
		if ((n <= 0) || (conds_ws > (e-a)))
			return -233;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == conds_ws);
	}
	assert(a <= e);
	return a-b;
}

void StateConfig::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	for (size_t x = 0, y = m_conds.size(); x != y; ++x) {
		// 'conds': id=2, encoding=lenpfx, tag=0x12
		put(0x12);	// 'conds': id=2
		send_varint(put,m_conds[x].calcSize());
		m_conds[x].toWire(put);
	}
}

void StateConfig::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	for (size_t x = 0, y = m_conds.size(); x != y; ++x) {
		// 'conds': id=2, encoding=lenpfx, tag=0x12
		put.push_back(0x12);	// 'conds': id=2
		send_varint(put,m_conds[x].calcSize());
		m_conds[x].toString(put);
	}
}

void StateConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (size_t s = m_conds.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"conds\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_conds[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t StateConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// repeated Trigger conds, id 2
	// repeated message conds
	for (size_t x = 0, y = m_conds.size(); x < y; ++x) {
		size_t s = m_conds[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(conds) 0x10 */;
	}
	return r;
}

bool StateConfig::operator != (const StateConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (m_conds != r.m_conds)
		return true;
	return false;
}


bool StateConfig::operator == (const StateConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int StateConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == memcmp(name,"conds",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_conds();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_conds.size();
				m_conds.resize(x+1);
				idxe = (char*)(name + 7);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if (idxe[0] != ']')
					return -234;
				if (m_conds.size() <= x)
					return -235;
				if ((idxe[1] == 0) && (value == 0)) {
					m_conds.erase(m_conds.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -236;
			return m_conds[x].setByName(idxe+2,value);
		}
	}
	return -237;
}

StateMachineConfig::StateMachineConfig()
: m_name()
, m_ini_st(0)
, p_validbits(0)
{
}

void StateMachineConfig::clear()
{
	m_name.clear();
	m_ini_st = 0;
	m_states.clear();
	p_validbits = 0;
}

void StateMachineConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "StateMachineConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "ini_st", (unsigned) m_ini_st);
	ascii_indent(o,indent);
	size_t s_states = m_states.size();
	o << "states[" << s_states << "] = {";
	++indent;
	for (size_t i = 0, e = s_states; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_states[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t StateMachineConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -238;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -239;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x10:	// ini_st id 2, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -240;
				a += n;
				set_ini_st(v);
			}
			break;
		case 0x1a:	// states id 3, type StateConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -241;
				m_states.emplace_back();
				if (v != 0) {
					n = m_states.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -242;
					a += v;
				}
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -243;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -244;
	return a-(const uint8_t *)b;
}

ssize_t StateMachineConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -245;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -246;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has ini_st?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'ini_st': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -247;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_ini_st);
		if (n <= 0)
			return -248;
		a += n;
	}
	for (const auto &x : m_states) {
		// 'states': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -249;
		*a++ = 0x1a;
		ssize_t states_ws = x.calcSize();
		n = write_varint(a,e-a,states_ws);
		a += n;
		if ((n <= 0) || (states_ws > (e-a)))
			return -250;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == states_ws);
	}
	assert(a <= e);
	return a-b;
}

void StateMachineConfig::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'ini_st': id=2, encoding=varint, tag=0x10
		put(0x10);	// 'ini_st': id=2
		send_varint(put,m_ini_st);
	}
	for (size_t x = 0, y = m_states.size(); x != y; ++x) {
		// 'states': id=3, encoding=lenpfx, tag=0x1a
		put(0x1a);	// 'states': id=3
		send_varint(put,m_states[x].calcSize());
		m_states[x].toWire(put);
	}
}

void StateMachineConfig::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'ini_st': id=2, encoding=varint, tag=0x10
		put.push_back(0x10);	// 'ini_st': id=2
		send_varint(put,m_ini_st);
	}
	for (size_t x = 0, y = m_states.size(); x != y; ++x) {
		// 'states': id=3, encoding=lenpfx, tag=0x1a
		put.push_back(0x1a);	// 'states': id=3
		send_varint(put,m_states[x].calcSize());
		m_states[x].toString(put);
	}
}

void StateMachineConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_ini_st()) {
		fsep = json_indent(json,indLvl,fsep,"ini_st");
		json << (unsigned) m_ini_st;
	}
	if (size_t s = m_states.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"states\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_states[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t StateMachineConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional uint8 ini_st, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_ini_st) + 1 /* tag(ini_st) 0x10 */;
	}
	// repeated StateConfig states, id 3
	// repeated message states
	for (size_t x = 0, y = m_states.size(); x < y; ++x) {
		size_t s = m_states[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(states) 0x18 */;
	}
	return r;
}

bool StateMachineConfig::operator != (const StateMachineConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_ini_st() && (m_ini_st != r.m_ini_st))
		return true;
	if (m_states != r.m_states)
		return true;
	return false;
}


bool StateMachineConfig::operator == (const StateMachineConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int StateMachineConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"ini_st")) {
		if (value == 0) {
			clear_ini_st();
			return 0;
		}
		int r = parse_ascii_u8(&m_ini_st,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == memcmp(name,"states",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_states();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_states.size();
				m_states.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -251;
				if (m_states.size() <= x)
					return -252;
				if ((idxe[1] == 0) && (value == 0)) {
					m_states.erase(m_states.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -253;
			return m_states[x].setByName(idxe+2,value);
		}
	}
	return -254;
}

ThresholdConfig::ThresholdConfig()
: m_name()
, m_low(0)
, m_high(0)
, p_validbits(0)
{
}

void ThresholdConfig::clear()
{
	m_name.clear();
	m_low = 0;
	m_high = 0;
	p_validbits = 0;
}

void ThresholdConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "ThresholdConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "low", m_low);
	ascii_numeric(o, indent, "high", m_high);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t ThresholdConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -255;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -256;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x15:	// low id 2, type float, coding 32bit
			if ((a+3) >= e)
				return -257;
			set_low(read_float(a));
			a += 4;
			break;
		case 0x1d:	// high id 3, type float, coding 32bit
			if ((a+3) >= e)
				return -258;
			set_high(read_float(a));
			a += 4;
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -259;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -260;
	return a-(const uint8_t *)b;
}

ssize_t ThresholdConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -261;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -262;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has low?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'low': id=2, encoding=32bit, tag=0x15
		if (5 > (e-a))
			return -263;
		*a++ = 0x15;
		if ((e-a) < 4)
			return -264;
		write_u32(a,mangle_float(m_low));
		a += 4;
	}
	// has high?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'high': id=3, encoding=32bit, tag=0x1d
		if (5 > (e-a))
			return -265;
		*a++ = 0x1d;
		if ((e-a) < 4)
			return -266;
		write_u32(a,mangle_float(m_high));
		a += 4;
	}
	assert(a <= e);
	return a-b;
}

void ThresholdConfig::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		send_bytes(put,(const uint8_t*) m_name.data(),name_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'low': id=2, encoding=32bit, tag=0x15
		put(0x15);	// 'low': id=2
		send_u32(put,mangle_float(m_low));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'high': id=3, encoding=32bit, tag=0x1d
		put(0x1d);	// 'high': id=3
		send_u32(put,mangle_float(m_high));
	}
}

void ThresholdConfig::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'name': id=1
		size_t name_s = m_name.size();
		send_varint(put,name_s);
		put.append((const char *)(const uint8_t*) m_name.data(),name_s);
	}
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'low': id=2, encoding=32bit, tag=0x15
		put.push_back(0x15);	// 'low': id=2
		send_u32(put,mangle_float(m_low));
	}
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'high': id=3, encoding=32bit, tag=0x1d
		put.push_back(0x1d);	// 'high': id=3
		send_u32(put,mangle_float(m_high));
	}
}

void ThresholdConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_low()) {
		fsep = json_indent(json,indLvl,fsep,"low");
		to_dblstr(json,m_low);
	}
	if (has_high()) {
		fsep = json_indent(json,indLvl,fsep,"high");
		to_dblstr(json,m_high);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t ThresholdConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional float low, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += 5;
	}
	// optional float high, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += 5;
	}
	return r;
}

bool ThresholdConfig::operator != (const ThresholdConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_low() && (m_low != r.m_low))
		return true;
	if (has_high() && (m_high != r.m_high))
		return true;
	return false;
}


bool ThresholdConfig::operator == (const ThresholdConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int ThresholdConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"low")) {
		if (value == 0) {
			clear_low();
			return 0;
		}
		int r = parse_ascii_flt(&m_low,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"high")) {
		if (value == 0) {
			clear_high();
			return 0;
		}
		int r = parse_ascii_flt(&m_high,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	return -267;
}

LuaConfig::LuaConfig()
{
}

void LuaConfig::clear()
{
	m_init_scripts.clear();
	m_compile_files.clear();
}

void LuaConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "LuaConfig {";
	++indent;
	ascii_indent(o,indent);
	size_t s_init_scripts = m_init_scripts.size();
	o << "init_scripts[" << s_init_scripts << "] = {";
	++indent;
	for (size_t i = 0, e = s_init_scripts; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,indent,m_init_scripts[i].data(),m_init_scripts[i].size(),0);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent);
	size_t s_compile_files = m_compile_files.size();
	o << "compile_files[" << s_compile_files << "] = {";
	++indent;
	for (size_t i = 0, e = s_compile_files; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,indent,m_compile_files[i].data(),m_compile_files[i].size(),0);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t LuaConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -268;
		a += fn;
		switch (fid) {
		case 0xa:	// init_scripts id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -269;
				m_init_scripts.emplace_back((const char*)a,v);
				a += v;
			}
			break;
		case 0x12:	// compile_files id 2, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -270;
				m_compile_files.emplace_back((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -271;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -272;
	return a-(const uint8_t *)b;
}

ssize_t LuaConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	for (const auto &x : m_init_scripts) {
		// 'init_scripts': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -273;
		*a++ = 0xa;
		ssize_t init_scripts_s = x.size();
		n = write_varint(a,e-a,init_scripts_s);
		a += n;
		if ((n <= 0) || ((e-a) < init_scripts_s))
			return -274;
		memcpy(a,x.data(),init_scripts_s);
		a += init_scripts_s;
	}
	for (const auto &x : m_compile_files) {
		// 'compile_files': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -275;
		*a++ = 0x12;
		ssize_t compile_files_s = x.size();
		n = write_varint(a,e-a,compile_files_s);
		a += n;
		if ((n <= 0) || ((e-a) < compile_files_s))
			return -276;
		memcpy(a,x.data(),compile_files_s);
		a += compile_files_s;
	}
	assert(a <= e);
	return a-b;
}

void LuaConfig::toWire(void (*put)(uint8_t)) const
{
	for (size_t x = 0, y = m_init_scripts.size(); x != y; ++x) {
		// 'init_scripts': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'init_scripts': id=1
		size_t init_scripts_s = m_init_scripts[x].size();
		send_varint(put,init_scripts_s);
		send_bytes(put,(const uint8_t*) m_init_scripts[x].data(),init_scripts_s);
	}
	for (size_t x = 0, y = m_compile_files.size(); x != y; ++x) {
		// 'compile_files': id=2, encoding=lenpfx, tag=0x12
		put(0x12);	// 'compile_files': id=2
		size_t compile_files_s = m_compile_files[x].size();
		send_varint(put,compile_files_s);
		send_bytes(put,(const uint8_t*) m_compile_files[x].data(),compile_files_s);
	}
}

void LuaConfig::toString(std::string &put) const
{
	for (size_t x = 0, y = m_init_scripts.size(); x != y; ++x) {
		// 'init_scripts': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'init_scripts': id=1
		size_t init_scripts_s = m_init_scripts[x].size();
		send_varint(put,init_scripts_s);
		put.append((const char *)(const uint8_t*) m_init_scripts[x].data(),init_scripts_s);
	}
	for (size_t x = 0, y = m_compile_files.size(); x != y; ++x) {
		// 'compile_files': id=2, encoding=lenpfx, tag=0x12
		put.push_back(0x12);	// 'compile_files': id=2
		size_t compile_files_s = m_compile_files[x].size();
		send_varint(put,compile_files_s);
		put.append((const char *)(const uint8_t*) m_compile_files[x].data(),compile_files_s);
	}
}

void LuaConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (size_t s = m_init_scripts.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"init_scripts\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_init_scripts[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_compile_files.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"compile_files\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_compile_files[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t LuaConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// repeated string init_scripts, id 1
	if (!m_init_scripts.empty()) {
		// init_scripts: repeated std::string
		for (size_t x = 0, y = m_init_scripts.size(); x < y; ++x) {
			size_t s = m_init_scripts[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(init_scripts) 0x8 */;
		}
	}
	// repeated string compile_files, id 2
	if (!m_compile_files.empty()) {
		// compile_files: repeated std::string
		for (size_t x = 0, y = m_compile_files.size(); x < y; ++x) {
			size_t s = m_compile_files[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(compile_files) 0x10 */;
		}
	}
	return r;
}

bool LuaConfig::operator != (const LuaConfig &r) const
{
	if (m_init_scripts != r.m_init_scripts)
		return true;
	if (m_compile_files != r.m_compile_files)
		return true;
	return false;
}


bool LuaConfig::operator == (const LuaConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int LuaConfig::setByName(const char *name, const char *value)
{
	if (0 == memcmp(name,"init_scripts",12)) {
		if ((name[12] == 0) && (value == 0)) {
			clear_init_scripts();
			return 0;
		} else if (name[12] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[13] == '+') && (name[14] == ']')) {
				x = m_init_scripts.size();
				m_init_scripts.resize(x+1);
				idxe = (char*)(name + 14);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+13,&idxe,0);
				if (idxe[0] != ']')
					return -277;
				if (m_init_scripts.size() <= x)
					return -278;
				if ((idxe[1] == 0) && (value == 0)) {
					m_init_scripts.erase(m_init_scripts.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -279;
			m_init_scripts[x] = value;
			return m_init_scripts[x].size();
		}
	}
	if (0 == memcmp(name,"compile_files",13)) {
		if ((name[13] == 0) && (value == 0)) {
			clear_compile_files();
			return 0;
		} else if (name[13] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[14] == '+') && (name[15] == ']')) {
				x = m_compile_files.size();
				m_compile_files.resize(x+1);
				idxe = (char*)(name + 15);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+14,&idxe,0);
				if (idxe[0] != ']')
					return -280;
				if (m_compile_files.size() <= x)
					return -281;
				if ((idxe[1] == 0) && (value == 0)) {
					m_compile_files.erase(m_compile_files.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -282;
			m_compile_files[x] = value;
			return m_compile_files[x].size();
		}
	}
	return -283;
}

NodeConfig::NodeConfig()
: m_magic(0)
, m_nodename()
, m_pass_hash()
, m_cpu_freq(0)
, m_syslog_host()
, m_sntp_server()
, m_timezone()
#ifdef CONFIG_MQTT
#endif // CONFIG_MQTT
, m_dmesg_size(2048)
#ifdef CONFIG_INFLUX
#endif // CONFIG_INFLUX
, m_station2ap_time(0)
, m_domainname()
, m_actions_enable(1)
#ifdef CONFIG_TERMSERV
#endif // CONFIG_TERMSERV
, m_udp_ctrl_port(12719)
#ifdef CONFIG_FTP
#endif // CONFIG_FTP
#ifdef CONFIG_HTTP
#endif // CONFIG_HTTP
#ifdef CONFIG_SIGNAL_PROC
#endif // CONFIG_SIGNAL_PROC
#ifdef CONFIG_SIGNAL_PROC
#endif // CONFIG_SIGNAL_PROC
#ifdef CONFIG_STATEMACHINES
#endif // CONFIG_STATEMACHINES
, m_max_on_time(0)
, m_threshold_off(0)
, m_threshold_on(0)
, m_dim_step(0)
, m_lightctrl(0)
, m_pwm_freq(0)
#ifdef CONFIG_APP_PARAMS
#endif // CONFIG_APP_PARAMS
#ifdef CONFIG_THRESHOLDS
#endif // CONFIG_THRESHOLDS
#ifdef CONFIG_LUA
#endif // CONFIG_LUA
#ifdef CONFIG_ONEWIRE
#endif // CONFIG_ONEWIRE
, p_validbits(0)
{
}

void NodeConfig::clear()
{
	m_magic = 0;
	m_nodename.clear();
	m_pass_hash.clear();
	m_cpu_freq = 0;
	m_station.clear();
	m_softap.clear();
	m_dns_server.clear();
	m_syslog_host.clear();
	m_sntp_server.clear();
	m_timezone.clear();
	#ifdef CONFIG_MQTT
	m_mqtt.clear();
	#endif // CONFIG_MQTT
	m_dmesg_size = 2048;
	#ifdef CONFIG_INFLUX
	m_influx.clear();
	#endif // CONFIG_INFLUX
	m_station2ap_time = 0;
	m_domainname.clear();
	m_holidays.clear();
	m_at_actions.clear();
	m_actions_enable = 1;
	m_triggers.clear();
	m_uart.clear();
	#ifdef CONFIG_TERMSERV
	m_terminal.clear();
	#endif // CONFIG_TERMSERV
	m_udp_ctrl_port = 12719;
	m_debugs.clear();
	#ifdef CONFIG_FTP
	m_ftpd.clear();
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	m_httpd.clear();
	#endif // CONFIG_HTTP
	m_timefuses.clear();
	#ifdef CONFIG_SIGNAL_PROC
	m_signals.clear();
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	m_functions.clear();
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	m_statemachs.clear();
	#endif // CONFIG_STATEMACHINES
	m_max_on_time = 0;
	m_threshold_off = 0;
	m_threshold_on = 0;
	m_dim_step = 0;
	m_lightctrl = 0;
	m_pwm_freq = 0;
	#ifdef CONFIG_APP_PARAMS
	m_app_params.clear();
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	m_thresholds.clear();
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	m_luafiles.clear();
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	m_owdevices.clear();
	#endif // CONFIG_ONEWIRE
	p_validbits = 0;
}

void NodeConfig::toASCII(std::ostream &o, size_t indent) const
{
	o << "NodeConfig {";
	++indent;
	ascii_numeric(o, indent, "magic", m_magic);
	ascii_string(o,indent,m_nodename.data(),m_nodename.size(),"nodename");
	ascii_bytes(o,(const uint8_t*)m_pass_hash.data(),m_pass_hash.size(),indent,"pass_hash");
	ascii_numeric(o, indent, "cpu_freq", m_cpu_freq);
	ascii_indent(o,indent,"station");
	m_station.toASCII(o,indent);
	ascii_indent(o,indent,"softap");
	m_softap.toASCII(o,indent);
	ascii_indent(o,indent);
	size_t s_dns_server = m_dns_server.size();
	o << "dns_server[" << s_dns_server << "] = {";
	++indent;
	for (size_t i = 0, e = s_dns_server; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,indent,m_dns_server[i].data(),m_dns_server[i].size(),0);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_string(o,indent,m_syslog_host.data(),m_syslog_host.size(),"syslog_host");
	ascii_string(o,indent,m_sntp_server.data(),m_sntp_server.size(),"sntp_server");
	ascii_string(o,indent,m_timezone.data(),m_timezone.size(),"timezone");
	#ifdef CONFIG_MQTT
	ascii_indent(o,indent,"mqtt");
	m_mqtt.toASCII(o,indent);
	#endif // CONFIG_MQTT
	ascii_numeric(o, indent, "dmesg_size", m_dmesg_size);
	#ifdef CONFIG_INFLUX
	ascii_indent(o,indent,"influx");
	m_influx.toASCII(o,indent);
	#endif // CONFIG_INFLUX
	ascii_numeric(o, indent, "station2ap_time", m_station2ap_time);
	ascii_string(o,indent,m_domainname.data(),m_domainname.size(),"domainname");
	ascii_indent(o,indent);
	size_t s_holidays = m_holidays.size();
	o << "holidays[" << s_holidays << "] = {";
	++indent;
	for (size_t i = 0, e = s_holidays; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_holidays[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent);
	size_t s_at_actions = m_at_actions.size();
	o << "at_actions[" << s_at_actions << "] = {";
	++indent;
	for (size_t i = 0, e = s_at_actions; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_at_actions[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_numeric(o, indent, "actions_enable", m_actions_enable);
	ascii_indent(o,indent);
	size_t s_triggers = m_triggers.size();
	o << "triggers[" << s_triggers << "] = {";
	++indent;
	for (size_t i = 0, e = s_triggers; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_triggers[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent);
	size_t s_uart = m_uart.size();
	o << "uart[" << s_uart << "] = {";
	++indent;
	for (size_t i = 0, e = s_uart; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_uart[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_TERMSERV
	ascii_indent(o,indent);
	size_t s_terminal = m_terminal.size();
	o << "terminal[" << s_terminal << "] = {";
	++indent;
	for (size_t i = 0, e = s_terminal; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_terminal[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_TERMSERV
	ascii_numeric(o, indent, "udp_ctrl_port", m_udp_ctrl_port);
	ascii_indent(o,indent);
	size_t s_debugs = m_debugs.size();
	o << "debugs[" << s_debugs << "] = {";
	++indent;
	for (size_t i = 0, e = s_debugs; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,indent,m_debugs[i].data(),m_debugs[i].size(),0);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_FTP
	ascii_indent(o,indent,"ftpd");
	m_ftpd.toASCII(o,indent);
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	ascii_indent(o,indent,"httpd");
	m_httpd.toASCII(o,indent);
	#endif // CONFIG_HTTP
	ascii_indent(o,indent);
	size_t s_timefuses = m_timefuses.size();
	o << "timefuses[" << s_timefuses << "] = {";
	++indent;
	for (size_t i = 0, e = s_timefuses; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_timefuses[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_SIGNAL_PROC
	ascii_indent(o,indent);
	size_t s_signals = m_signals.size();
	o << "signals[" << s_signals << "] = {";
	++indent;
	for (size_t i = 0, e = s_signals; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_signals[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	ascii_indent(o,indent);
	size_t s_functions = m_functions.size();
	o << "functions[" << s_functions << "] = {";
	++indent;
	for (size_t i = 0, e = s_functions; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_functions[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	ascii_indent(o,indent);
	size_t s_statemachs = m_statemachs.size();
	o << "statemachs[" << s_statemachs << "] = {";
	++indent;
	for (size_t i = 0, e = s_statemachs; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_statemachs[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_STATEMACHINES
	ascii_numeric(o, indent, "max_on_time", m_max_on_time);
	ascii_numeric(o, indent, "threshold_off", m_threshold_off);
	ascii_numeric(o, indent, "threshold_on", m_threshold_on);
	ascii_numeric(o, indent, "dim_step", m_dim_step);
	ascii_bool(o, indent, "lightctrl", m_lightctrl);
	ascii_numeric(o, indent, "pwm_freq", m_pwm_freq);
	#ifdef CONFIG_APP_PARAMS
	ascii_indent(o,indent);
	size_t s_app_params = m_app_params.size();
	o << "app_params[" << s_app_params << "] = {";
	++indent;
	for (size_t i = 0, e = s_app_params; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_app_params[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	ascii_indent(o,indent);
	size_t s_thresholds = m_thresholds.size();
	o << "thresholds[" << s_thresholds << "] = {";
	++indent;
	for (size_t i = 0, e = s_thresholds; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_thresholds[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	ascii_indent(o,indent);
	size_t s_luafiles = m_luafiles.size();
	o << "luafiles[" << s_luafiles << "] = {";
	++indent;
	for (size_t i = 0, e = s_luafiles; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,indent,m_luafiles[i].data(),m_luafiles[i].size(),0);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	ascii_indent(o,indent);
	size_t s_owdevices = m_owdevices.size();
	o << "owdevices[" << s_owdevices << "] = {";
	++indent;
	for (size_t i = 0, e = s_owdevices; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_owdevices[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_ONEWIRE
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t NodeConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -284;
		a += fn;
		switch (fid) {
		case 0x5:	// magic id 0, type uint32_t, coding 32bit
			if ((a+3) >= e)
				return -285;
			set_magic((uint32_t) read_u32(a));
			a += 4;
			break;
		case 0xa:	// nodename id 1, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -286;
				m_nodename.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x12:	// pass_hash id 2, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -287;
				m_pass_hash.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint32_t)1U << 1);
			break;
		case 0x18:	// cpu_freq id 3, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -288;
				a += n;
				set_cpu_freq(v);
			}
			break;
		case 0x22:	// station id 4, type WifiConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -289;
				if (v != 0) {
					n = m_station.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -290;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 3);
			break;
		case 0x2a:	// softap id 5, type WifiConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -291;
				if (v != 0) {
					n = m_softap.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -292;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 4);
			break;
		case 0x32:	// dns_server id 6, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -293;
				m_dns_server.emplace_back((const char*)a,v);
				a += v;
			}
			break;
		case 0x3a:	// syslog_host id 7, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -294;
				m_syslog_host.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x42:	// sntp_server id 8, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -295;
				m_sntp_server.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x4a:	// timezone id 9, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -296;
				m_timezone.assign((const char*)a,v);
				a += v;
			}
			break;
			#ifdef CONFIG_MQTT
		case 0x52:	// mqtt id 10, type MQTT, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -297;
				if (v != 0) {
					n = m_mqtt.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -298;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 5);
			break;
			#endif // CONFIG_MQTT
		case 0x5c:	// dmesg_size id 11, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -299;
			set_dmesg_size((uint16_t) read_u16(a));
			a += 2;
			break;
			#ifdef CONFIG_INFLUX
		case 0x62:	// influx id 12, type Influx, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -300;
				if (v != 0) {
					n = m_influx.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -301;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 7);
			break;
			#endif // CONFIG_INFLUX
		case 0x68:	// station2ap_time id 13, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -302;
				a += n;
				set_station2ap_time(v);
			}
			break;
		case 0x7a:	// domainname id 15, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -303;
				m_domainname.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x82:	// holidays id 16, type Date, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -304;
				m_holidays.emplace_back();
				if (v != 0) {
					n = m_holidays.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -305;
					a += v;
				}
			}
			break;
		case 0x8a:	// at_actions id 17, type AtAction, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -306;
				m_at_actions.emplace_back();
				if (v != 0) {
					n = m_at_actions.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -307;
					a += v;
				}
			}
			break;
		case 0x90:	// actions_enable id 18, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -308;
				a += n;
				set_actions_enable(v);
			}
			break;
		case 0x9a:	// triggers id 19, type Trigger, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -309;
				m_triggers.emplace_back();
				if (v != 0) {
					n = m_triggers.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -310;
					a += v;
				}
			}
			break;
		case 0xa2:	// uart id 20, type UartSettings, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -311;
				m_uart.emplace_back();
				if (v != 0) {
					n = m_uart.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -312;
					a += v;
				}
			}
			break;
			#ifdef CONFIG_TERMSERV
		case 0xaa:	// terminal id 21, type TerminalConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -313;
				m_terminal.emplace_back();
				if (v != 0) {
					n = m_terminal.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -314;
					a += v;
				}
			}
			break;
			#endif // CONFIG_TERMSERV
		case 0xb4:	// udp_ctrl_port id 22, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -315;
			set_udp_ctrl_port((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0xba:	// debugs id 23, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -316;
				m_debugs.emplace_back((const char*)a,v);
				a += v;
			}
			break;
			#ifdef CONFIG_FTP
		case 0xc2:	// ftpd id 24, type FtpHttpConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -317;
				if (v != 0) {
					n = m_ftpd.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -318;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 11);
			break;
			#endif // CONFIG_FTP
			#ifdef CONFIG_HTTP
		case 0xca:	// httpd id 25, type FtpHttpConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -319;
				if (v != 0) {
					n = m_httpd.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -320;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 12);
			break;
			#endif // CONFIG_HTTP
		case 0xf2:	// timefuses id 30, type EventTimer, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -321;
				m_timefuses.emplace_back();
				if (v != 0) {
					n = m_timefuses.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -322;
					a += v;
				}
			}
			break;
			#ifdef CONFIG_SIGNAL_PROC
		case 0xfa:	// signals id 31, type SignalConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -323;
				m_signals.emplace_back();
				if (v != 0) {
					n = m_signals.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -324;
					a += v;
				}
			}
			break;
			#endif // CONFIG_SIGNAL_PROC
			#ifdef CONFIG_SIGNAL_PROC
		case 0x102:	// functions id 32, type FunctionConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -325;
				m_functions.emplace_back();
				if (v != 0) {
					n = m_functions.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -326;
					a += v;
				}
			}
			break;
			#endif // CONFIG_SIGNAL_PROC
			#ifdef CONFIG_STATEMACHINES
		case 0x10a:	// statemachs id 33, type StateMachineConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -327;
				m_statemachs.emplace_back();
				if (v != 0) {
					n = m_statemachs.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -328;
					a += v;
				}
			}
			break;
			#endif // CONFIG_STATEMACHINES
		case 0x110:	// max_on_time id 34, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -329;
				a += n;
				set_max_on_time(v);
			}
			break;
		case 0x118:	// threshold_off id 35, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -330;
				a += n;
				set_threshold_off(v);
			}
			break;
		case 0x120:	// threshold_on id 36, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -331;
				a += n;
				set_threshold_on(v);
			}
			break;
		case 0x128:	// dim_step id 37, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -332;
				a += n;
				set_dim_step(v);
			}
			break;
		case 0x133:	// lightctrl id 38, type bool, coding 8bit
			if (a >= e)
				return -333;
			set_lightctrl(*a++);
			break;
		case 0x138:	// pwm_freq id 39, type uint64_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -334;
				a += n;
				set_pwm_freq(v);
			}
			break;
			#ifdef CONFIG_APP_PARAMS
		case 0x142:	// app_params id 40, type AppParam, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -335;
				m_app_params.emplace_back();
				if (v != 0) {
					n = m_app_params.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -336;
					a += v;
				}
			}
			break;
			#endif // CONFIG_APP_PARAMS
			#ifdef CONFIG_THRESHOLDS
		case 0x14a:	// thresholds id 41, type ThresholdConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -337;
				m_thresholds.emplace_back();
				if (v != 0) {
					n = m_thresholds.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -338;
					a += v;
				}
			}
			break;
			#endif // CONFIG_THRESHOLDS
			#ifdef CONFIG_LUA
		case 0x152:	// luafiles id 42, type std::string, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -339;
				m_luafiles.emplace_back((const char*)a,v);
				a += v;
			}
			break;
			#endif // CONFIG_LUA
			#ifdef CONFIG_ONEWIRE
		case 0x192:	// owdevices id 50, type OwDeviceConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -340;
				m_owdevices.emplace_back();
				if (v != 0) {
					n = m_owdevices.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -341;
					a += v;
				}
			}
			break;
			#endif // CONFIG_ONEWIRE
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -342;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -343;
	return a-(const uint8_t *)b;
}

ssize_t NodeConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has magic?
	if (0 != (p_validbits & ((uint32_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		if (5 > (e-a))
			return -344;
		*a++ = 0x5;
		if ((e-a) < 4)
			return -345;
		write_u32(a,(uint32_t)m_magic);
		a += 4;
	}
	// has nodename?
	if (!m_nodename.empty()) {
		// 'nodename': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -346;
		*a++ = 0xa;
		ssize_t nodename_s = m_nodename.size();
		n = write_varint(a,e-a,nodename_s);
		a += n;
		if ((n <= 0) || ((e-a) < nodename_s))
			return -347;
		memcpy(a,m_nodename.data(),nodename_s);
		a += nodename_s;
	}
	// has pass_hash?
	if (0 != (p_validbits & ((uint32_t)1U << 1))) {
		// 'pass_hash': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -348;
		*a++ = 0x12;
		ssize_t pass_hash_s = m_pass_hash.size();
		n = write_varint(a,e-a,pass_hash_s);
		a += n;
		if ((n <= 0) || ((e-a) < pass_hash_s))
			return -349;
		memcpy(a,m_pass_hash.data(),pass_hash_s);
		a += pass_hash_s;
	}
	// has cpu_freq?
	if (0 != (p_validbits & ((uint32_t)1U << 2))) {
		// 'cpu_freq': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -350;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_cpu_freq);
		if (n <= 0)
			return -351;
		a += n;
	}
	// has station?
	if (0 != (p_validbits & ((uint32_t)1U << 3))) {
		// 'station': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -352;
		*a++ = 0x22;
		ssize_t station_ws = m_station.calcSize();
		n = write_varint(a,e-a,station_ws);
		a += n;
		if ((n <= 0) || (station_ws > (e-a)))
			return -353;
		n = m_station.toMemory(a,e-a);
		a += n;
		assert(n == station_ws);
	}
	// has softap?
	if (0 != (p_validbits & ((uint32_t)1U << 4))) {
		// 'softap': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -354;
		*a++ = 0x2a;
		ssize_t softap_ws = m_softap.calcSize();
		n = write_varint(a,e-a,softap_ws);
		a += n;
		if ((n <= 0) || (softap_ws > (e-a)))
			return -355;
		n = m_softap.toMemory(a,e-a);
		a += n;
		assert(n == softap_ws);
	}
	for (const auto &x : m_dns_server) {
		// 'dns_server': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -356;
		*a++ = 0x32;
		ssize_t dns_server_s = x.size();
		n = write_varint(a,e-a,dns_server_s);
		a += n;
		if ((n <= 0) || ((e-a) < dns_server_s))
			return -357;
		memcpy(a,x.data(),dns_server_s);
		a += dns_server_s;
	}
	// has syslog_host?
	if (!m_syslog_host.empty()) {
		// 'syslog_host': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -358;
		*a++ = 0x3a;
		ssize_t syslog_host_s = m_syslog_host.size();
		n = write_varint(a,e-a,syslog_host_s);
		a += n;
		if ((n <= 0) || ((e-a) < syslog_host_s))
			return -359;
		memcpy(a,m_syslog_host.data(),syslog_host_s);
		a += syslog_host_s;
	}
	// has sntp_server?
	if (!m_sntp_server.empty()) {
		// 'sntp_server': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -360;
		*a++ = 0x42;
		ssize_t sntp_server_s = m_sntp_server.size();
		n = write_varint(a,e-a,sntp_server_s);
		a += n;
		if ((n <= 0) || ((e-a) < sntp_server_s))
			return -361;
		memcpy(a,m_sntp_server.data(),sntp_server_s);
		a += sntp_server_s;
	}
	// has timezone?
	if (!m_timezone.empty()) {
		// 'timezone': id=9, encoding=lenpfx, tag=0x4a
		if (a >= e)
			return -362;
		*a++ = 0x4a;
		ssize_t timezone_s = m_timezone.size();
		n = write_varint(a,e-a,timezone_s);
		a += n;
		if ((n <= 0) || ((e-a) < timezone_s))
			return -363;
		memcpy(a,m_timezone.data(),timezone_s);
		a += timezone_s;
	}
	#ifdef CONFIG_MQTT
	// has mqtt?
	if (0 != (p_validbits & ((uint32_t)1U << 5))) {
		// 'mqtt': id=10, encoding=lenpfx, tag=0x52
		if (a >= e)
			return -364;
		*a++ = 0x52;
		ssize_t mqtt_ws = m_mqtt.calcSize();
		n = write_varint(a,e-a,mqtt_ws);
		a += n;
		if ((n <= 0) || (mqtt_ws > (e-a)))
			return -365;
		n = m_mqtt.toMemory(a,e-a);
		a += n;
		assert(n == mqtt_ws);
	}
	#endif // CONFIG_MQTT
	// has dmesg_size?
	if (0 != (p_validbits & ((uint32_t)1U << 6))) {
		// 'dmesg_size': id=11, encoding=16bit, tag=0x5c
		if (3 > (e-a))
			return -366;
		*a++ = 0x5c;
		write_u16(a,m_dmesg_size);
		a += 2;
	}
	#ifdef CONFIG_INFLUX
	// has influx?
	if (0 != (p_validbits & ((uint32_t)1U << 7))) {
		// 'influx': id=12, encoding=lenpfx, tag=0x62
		if (a >= e)
			return -367;
		*a++ = 0x62;
		ssize_t influx_ws = m_influx.calcSize();
		n = write_varint(a,e-a,influx_ws);
		a += n;
		if ((n <= 0) || (influx_ws > (e-a)))
			return -368;
		n = m_influx.toMemory(a,e-a);
		a += n;
		assert(n == influx_ws);
	}
	#endif // CONFIG_INFLUX
	// has station2ap_time?
	if (0 != (p_validbits & ((uint32_t)1U << 8))) {
		// 'station2ap_time': id=13, encoding=varint, tag=0x68
		if (a >= e)
			return -369;
		*a++ = 0x68;
		n = write_varint(a,e-a,m_station2ap_time);
		if (n <= 0)
			return -370;
		a += n;
	}
	// has domainname?
	if (!m_domainname.empty()) {
		// 'domainname': id=15, encoding=lenpfx, tag=0x7a
		if (a >= e)
			return -371;
		*a++ = 0x7a;
		ssize_t domainname_s = m_domainname.size();
		n = write_varint(a,e-a,domainname_s);
		a += n;
		if ((n <= 0) || ((e-a) < domainname_s))
			return -372;
		memcpy(a,m_domainname.data(),domainname_s);
		a += domainname_s;
	}
	for (const auto &x : m_holidays) {
		// 'holidays': id=16, encoding=lenpfx, tag=0x82
		if (2 > (e-a))
			return -373;
		*a++ = 0x82;
		*a++ = 0x1;
		ssize_t holidays_ws = x.calcSize();
		n = write_varint(a,e-a,holidays_ws);
		a += n;
		if ((n <= 0) || (holidays_ws > (e-a)))
			return -374;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == holidays_ws);
	}
	for (const auto &x : m_at_actions) {
		// 'at_actions': id=17, encoding=lenpfx, tag=0x8a
		if (2 > (e-a))
			return -375;
		*a++ = 0x8a;
		*a++ = 0x1;
		ssize_t at_actions_ws = x.calcSize();
		n = write_varint(a,e-a,at_actions_ws);
		a += n;
		if ((n <= 0) || (at_actions_ws > (e-a)))
			return -376;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == at_actions_ws);
	}
	// has actions_enable?
	if (0 != (p_validbits & ((uint32_t)1U << 9))) {
		// 'actions_enable': id=18, encoding=varint, tag=0x90
		if (2 > (e-a))
			return -377;
		*a++ = 0x90;
		*a++ = 0x1;
		n = write_varint(a,e-a,m_actions_enable);
		if (n <= 0)
			return -378;
		a += n;
	}
	for (const auto &x : m_triggers) {
		// 'triggers': id=19, encoding=lenpfx, tag=0x9a
		if (2 > (e-a))
			return -379;
		*a++ = 0x9a;
		*a++ = 0x1;
		ssize_t triggers_ws = x.calcSize();
		n = write_varint(a,e-a,triggers_ws);
		a += n;
		if ((n <= 0) || (triggers_ws > (e-a)))
			return -380;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == triggers_ws);
	}
	for (const auto &x : m_uart) {
		// 'uart': id=20, encoding=lenpfx, tag=0xa2
		if (2 > (e-a))
			return -381;
		*a++ = 0xa2;
		*a++ = 0x1;
		ssize_t uart_ws = x.calcSize();
		n = write_varint(a,e-a,uart_ws);
		a += n;
		if ((n <= 0) || (uart_ws > (e-a)))
			return -382;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == uart_ws);
	}
	#ifdef CONFIG_TERMSERV
	for (const auto &x : m_terminal) {
		// 'terminal': id=21, encoding=lenpfx, tag=0xaa
		if (2 > (e-a))
			return -383;
		*a++ = 0xaa;
		*a++ = 0x1;
		ssize_t terminal_ws = x.calcSize();
		n = write_varint(a,e-a,terminal_ws);
		a += n;
		if ((n <= 0) || (terminal_ws > (e-a)))
			return -384;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == terminal_ws);
	}
	#endif // CONFIG_TERMSERV
	// has udp_ctrl_port?
	if (0 != (p_validbits & ((uint32_t)1U << 10))) {
		// 'udp_ctrl_port': id=22, encoding=16bit, tag=0xb4
		if (4 > (e-a))
			return -385;
		*a++ = 0xb4;
		*a++ = 0x1;
		write_u16(a,m_udp_ctrl_port);
		a += 2;
	}
	for (const auto &x : m_debugs) {
		// 'debugs': id=23, encoding=lenpfx, tag=0xba
		if (2 > (e-a))
			return -386;
		*a++ = 0xba;
		*a++ = 0x1;
		ssize_t debugs_s = x.size();
		n = write_varint(a,e-a,debugs_s);
		a += n;
		if ((n <= 0) || ((e-a) < debugs_s))
			return -387;
		memcpy(a,x.data(),debugs_s);
		a += debugs_s;
	}
	#ifdef CONFIG_FTP
	// has ftpd?
	if (0 != (p_validbits & ((uint32_t)1U << 11))) {
		// 'ftpd': id=24, encoding=lenpfx, tag=0xc2
		if (2 > (e-a))
			return -388;
		*a++ = 0xc2;
		*a++ = 0x1;
		ssize_t ftpd_ws = m_ftpd.calcSize();
		n = write_varint(a,e-a,ftpd_ws);
		a += n;
		if ((n <= 0) || (ftpd_ws > (e-a)))
			return -389;
		n = m_ftpd.toMemory(a,e-a);
		a += n;
		assert(n == ftpd_ws);
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	// has httpd?
	if (0 != (p_validbits & ((uint32_t)1U << 12))) {
		// 'httpd': id=25, encoding=lenpfx, tag=0xca
		if (2 > (e-a))
			return -390;
		*a++ = 0xca;
		*a++ = 0x1;
		ssize_t httpd_ws = m_httpd.calcSize();
		n = write_varint(a,e-a,httpd_ws);
		a += n;
		if ((n <= 0) || (httpd_ws > (e-a)))
			return -391;
		n = m_httpd.toMemory(a,e-a);
		a += n;
		assert(n == httpd_ws);
	}
	#endif // CONFIG_HTTP
	for (const auto &x : m_timefuses) {
		// 'timefuses': id=30, encoding=lenpfx, tag=0xf2
		if (2 > (e-a))
			return -392;
		*a++ = 0xf2;
		*a++ = 0x1;
		ssize_t timefuses_ws = x.calcSize();
		n = write_varint(a,e-a,timefuses_ws);
		a += n;
		if ((n <= 0) || (timefuses_ws > (e-a)))
			return -393;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == timefuses_ws);
	}
	#ifdef CONFIG_SIGNAL_PROC
	for (const auto &x : m_signals) {
		// 'signals': id=31, encoding=lenpfx, tag=0xfa
		if (2 > (e-a))
			return -394;
		*a++ = 0xfa;
		*a++ = 0x1;
		ssize_t signals_ws = x.calcSize();
		n = write_varint(a,e-a,signals_ws);
		a += n;
		if ((n <= 0) || (signals_ws > (e-a)))
			return -395;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == signals_ws);
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	for (const auto &x : m_functions) {
		// 'functions': id=32, encoding=lenpfx, tag=0x102
		if (2 > (e-a))
			return -396;
		*a++ = 0x82;
		*a++ = 0x2;
		ssize_t functions_ws = x.calcSize();
		n = write_varint(a,e-a,functions_ws);
		a += n;
		if ((n <= 0) || (functions_ws > (e-a)))
			return -397;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == functions_ws);
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	for (const auto &x : m_statemachs) {
		// 'statemachs': id=33, encoding=lenpfx, tag=0x10a
		if (2 > (e-a))
			return -398;
		*a++ = 0x8a;
		*a++ = 0x2;
		ssize_t statemachs_ws = x.calcSize();
		n = write_varint(a,e-a,statemachs_ws);
		a += n;
		if ((n <= 0) || (statemachs_ws > (e-a)))
			return -399;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == statemachs_ws);
	}
	#endif // CONFIG_STATEMACHINES
	// 'max_on_time' is deprecated. Therefore no data will be written.
	// has threshold_off?
	if (0 != (p_validbits & ((uint32_t)1U << 13))) {
		// 'threshold_off': id=35, encoding=varint, tag=0x118
		if (2 > (e-a))
			return -400;
		*a++ = 0x98;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_threshold_off);
		if (n <= 0)
			return -401;
		a += n;
	}
	// has threshold_on?
	if (0 != (p_validbits & ((uint32_t)1U << 14))) {
		// 'threshold_on': id=36, encoding=varint, tag=0x120
		if (2 > (e-a))
			return -402;
		*a++ = 0xa0;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_threshold_on);
		if (n <= 0)
			return -403;
		a += n;
	}
	// has dim_step?
	if (0 != (p_validbits & ((uint32_t)1U << 15))) {
		// 'dim_step': id=37, encoding=varint, tag=0x128
		if (2 > (e-a))
			return -404;
		*a++ = 0xa8;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_dim_step);
		if (n <= 0)
			return -405;
		a += n;
	}
	// has lightctrl?
	if (0 != (p_validbits & ((uint32_t)1U << 16))) {
		// 'lightctrl': id=38, encoding=8bit, tag=0x133
		if (3 > (e-a))
			return -406;
		*a++ = 0xb3;
		*a++ = 0x2;
		*a++ = m_lightctrl;
	}
	// has pwm_freq?
	if (0 != (p_validbits & ((uint32_t)1U << 17))) {
		// 'pwm_freq': id=39, encoding=varint, tag=0x138
		if (2 > (e-a))
			return -407;
		*a++ = 0xb8;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_pwm_freq);
		if (n <= 0)
			return -408;
		a += n;
	}
	#ifdef CONFIG_APP_PARAMS
	for (const auto &x : m_app_params) {
		// 'app_params': id=40, encoding=lenpfx, tag=0x142
		if (2 > (e-a))
			return -409;
		*a++ = 0xc2;
		*a++ = 0x2;
		ssize_t app_params_ws = x.calcSize();
		n = write_varint(a,e-a,app_params_ws);
		a += n;
		if ((n <= 0) || (app_params_ws > (e-a)))
			return -410;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == app_params_ws);
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	for (const auto &x : m_thresholds) {
		// 'thresholds': id=41, encoding=lenpfx, tag=0x14a
		if (2 > (e-a))
			return -411;
		*a++ = 0xca;
		*a++ = 0x2;
		ssize_t thresholds_ws = x.calcSize();
		n = write_varint(a,e-a,thresholds_ws);
		a += n;
		if ((n <= 0) || (thresholds_ws > (e-a)))
			return -412;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == thresholds_ws);
	}
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	for (const auto &x : m_luafiles) {
		// 'luafiles': id=42, encoding=lenpfx, tag=0x152
		if (2 > (e-a))
			return -413;
		*a++ = 0xd2;
		*a++ = 0x2;
		ssize_t luafiles_s = x.size();
		n = write_varint(a,e-a,luafiles_s);
		a += n;
		if ((n <= 0) || ((e-a) < luafiles_s))
			return -414;
		memcpy(a,x.data(),luafiles_s);
		a += luafiles_s;
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	for (const auto &x : m_owdevices) {
		// 'owdevices': id=50, encoding=lenpfx, tag=0x192
		if (2 > (e-a))
			return -415;
		*a++ = 0x92;
		*a++ = 0x3;
		ssize_t owdevices_ws = x.calcSize();
		n = write_varint(a,e-a,owdevices_ws);
		a += n;
		if ((n <= 0) || (owdevices_ws > (e-a)))
			return -416;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == owdevices_ws);
	}
	#endif // CONFIG_ONEWIRE
	assert(a <= e);
	return a-b;
}

void NodeConfig::toWire(void (*put)(uint8_t)) const
{
	if (0 != (p_validbits & ((uint32_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		put(0x5);	// 'magic': id=0
		send_u32(put,(uint32_t)m_magic);
	}
	if (!m_nodename.empty()) {
		// 'nodename': id=1, encoding=lenpfx, tag=0xa
		put(0xa);	// 'nodename': id=1
		size_t nodename_s = m_nodename.size();
		send_varint(put,nodename_s);
		send_bytes(put,(const uint8_t*) m_nodename.data(),nodename_s);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 1))) {
		// 'pass_hash': id=2, encoding=lenpfx, tag=0x12
		put(0x12);	// 'pass_hash': id=2
		size_t pass_hash_s = m_pass_hash.size();
		send_varint(put,pass_hash_s);
		send_bytes(put,(const uint8_t*) m_pass_hash.data(),pass_hash_s);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 2))) {
		// 'cpu_freq': id=3, encoding=varint, tag=0x18
		put(0x18);	// 'cpu_freq': id=3
		send_varint(put,m_cpu_freq);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 3))) {
		// 'station': id=4, encoding=lenpfx, tag=0x22
		put(0x22);	// 'station': id=4
		send_varint(put,m_station.calcSize());
		m_station.toWire(put);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 4))) {
		// 'softap': id=5, encoding=lenpfx, tag=0x2a
		put(0x2a);	// 'softap': id=5
		send_varint(put,m_softap.calcSize());
		m_softap.toWire(put);
	}
	for (size_t x = 0, y = m_dns_server.size(); x != y; ++x) {
		// 'dns_server': id=6, encoding=lenpfx, tag=0x32
		put(0x32);	// 'dns_server': id=6
		size_t dns_server_s = m_dns_server[x].size();
		send_varint(put,dns_server_s);
		send_bytes(put,(const uint8_t*) m_dns_server[x].data(),dns_server_s);
	}
	if (!m_syslog_host.empty()) {
		// 'syslog_host': id=7, encoding=lenpfx, tag=0x3a
		put(0x3a);	// 'syslog_host': id=7
		size_t syslog_host_s = m_syslog_host.size();
		send_varint(put,syslog_host_s);
		send_bytes(put,(const uint8_t*) m_syslog_host.data(),syslog_host_s);
	}
	if (!m_sntp_server.empty()) {
		// 'sntp_server': id=8, encoding=lenpfx, tag=0x42
		put(0x42);	// 'sntp_server': id=8
		size_t sntp_server_s = m_sntp_server.size();
		send_varint(put,sntp_server_s);
		send_bytes(put,(const uint8_t*) m_sntp_server.data(),sntp_server_s);
	}
	if (!m_timezone.empty()) {
		// 'timezone': id=9, encoding=lenpfx, tag=0x4a
		put(0x4a);	// 'timezone': id=9
		size_t timezone_s = m_timezone.size();
		send_varint(put,timezone_s);
		send_bytes(put,(const uint8_t*) m_timezone.data(),timezone_s);
	}
	#ifdef CONFIG_MQTT
	if (0 != (p_validbits & ((uint32_t)1U << 5))) {
		// 'mqtt': id=10, encoding=lenpfx, tag=0x52
		put(0x52);	// 'mqtt': id=10
		send_varint(put,m_mqtt.calcSize());
		m_mqtt.toWire(put);
	}
	#endif // CONFIG_MQTT
	if (0 != (p_validbits & ((uint32_t)1U << 6))) {
		// 'dmesg_size': id=11, encoding=16bit, tag=0x5c
		put(0x5c);	// 'dmesg_size': id=11
		send_u16(put,m_dmesg_size);
	}
	#ifdef CONFIG_INFLUX
	if (0 != (p_validbits & ((uint32_t)1U << 7))) {
		// 'influx': id=12, encoding=lenpfx, tag=0x62
		put(0x62);	// 'influx': id=12
		send_varint(put,m_influx.calcSize());
		m_influx.toWire(put);
	}
	#endif // CONFIG_INFLUX
	if (0 != (p_validbits & ((uint32_t)1U << 8))) {
		// 'station2ap_time': id=13, encoding=varint, tag=0x68
		put(0x68);	// 'station2ap_time': id=13
		send_varint(put,m_station2ap_time);
	}
	if (!m_domainname.empty()) {
		// 'domainname': id=15, encoding=lenpfx, tag=0x7a
		put(0x7a);	// 'domainname': id=15
		size_t domainname_s = m_domainname.size();
		send_varint(put,domainname_s);
		send_bytes(put,(const uint8_t*) m_domainname.data(),domainname_s);
	}
	for (size_t x = 0, y = m_holidays.size(); x != y; ++x) {
		// 'holidays': id=16, encoding=lenpfx, tag=0x82
		put(0x82);
		put(0x1);
		send_varint(put,m_holidays[x].calcSize());
		m_holidays[x].toWire(put);
	}
	for (size_t x = 0, y = m_at_actions.size(); x != y; ++x) {
		// 'at_actions': id=17, encoding=lenpfx, tag=0x8a
		put(0x8a);
		put(0x1);
		send_varint(put,m_at_actions[x].calcSize());
		m_at_actions[x].toWire(put);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 9))) {
		// 'actions_enable': id=18, encoding=varint, tag=0x90
		put(0x90);
		put(0x1);
		send_varint(put,m_actions_enable);
	}
	for (size_t x = 0, y = m_triggers.size(); x != y; ++x) {
		// 'triggers': id=19, encoding=lenpfx, tag=0x9a
		put(0x9a);
		put(0x1);
		send_varint(put,m_triggers[x].calcSize());
		m_triggers[x].toWire(put);
	}
	for (size_t x = 0, y = m_uart.size(); x != y; ++x) {
		// 'uart': id=20, encoding=lenpfx, tag=0xa2
		put(0xa2);
		put(0x1);
		send_varint(put,m_uart[x].calcSize());
		m_uart[x].toWire(put);
	}
	#ifdef CONFIG_TERMSERV
	for (size_t x = 0, y = m_terminal.size(); x != y; ++x) {
		// 'terminal': id=21, encoding=lenpfx, tag=0xaa
		put(0xaa);
		put(0x1);
		send_varint(put,m_terminal[x].calcSize());
		m_terminal[x].toWire(put);
	}
	#endif // CONFIG_TERMSERV
	if (0 != (p_validbits & ((uint32_t)1U << 10))) {
		// 'udp_ctrl_port': id=22, encoding=16bit, tag=0xb4
		put(0xb4);
		put(0x1);
		send_u16(put,m_udp_ctrl_port);
	}
	for (size_t x = 0, y = m_debugs.size(); x != y; ++x) {
		// 'debugs': id=23, encoding=lenpfx, tag=0xba
		put(0xba);
		put(0x1);
		size_t debugs_s = m_debugs[x].size();
		send_varint(put,debugs_s);
		send_bytes(put,(const uint8_t*) m_debugs[x].data(),debugs_s);
	}
	#ifdef CONFIG_FTP
	if (0 != (p_validbits & ((uint32_t)1U << 11))) {
		// 'ftpd': id=24, encoding=lenpfx, tag=0xc2
		put(0xc2);
		put(0x1);
		send_varint(put,m_ftpd.calcSize());
		m_ftpd.toWire(put);
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (0 != (p_validbits & ((uint32_t)1U << 12))) {
		// 'httpd': id=25, encoding=lenpfx, tag=0xca
		put(0xca);
		put(0x1);
		send_varint(put,m_httpd.calcSize());
		m_httpd.toWire(put);
	}
	#endif // CONFIG_HTTP
	for (size_t x = 0, y = m_timefuses.size(); x != y; ++x) {
		// 'timefuses': id=30, encoding=lenpfx, tag=0xf2
		put(0xf2);
		put(0x1);
		send_varint(put,m_timefuses[x].calcSize());
		m_timefuses[x].toWire(put);
	}
	#ifdef CONFIG_SIGNAL_PROC
	for (size_t x = 0, y = m_signals.size(); x != y; ++x) {
		// 'signals': id=31, encoding=lenpfx, tag=0xfa
		put(0xfa);
		put(0x1);
		send_varint(put,m_signals[x].calcSize());
		m_signals[x].toWire(put);
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	for (size_t x = 0, y = m_functions.size(); x != y; ++x) {
		// 'functions': id=32, encoding=lenpfx, tag=0x102
		put(0x82);
		put(0x2);
		send_varint(put,m_functions[x].calcSize());
		m_functions[x].toWire(put);
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	for (size_t x = 0, y = m_statemachs.size(); x != y; ++x) {
		// 'statemachs': id=33, encoding=lenpfx, tag=0x10a
		put(0x8a);
		put(0x2);
		send_varint(put,m_statemachs[x].calcSize());
		m_statemachs[x].toWire(put);
	}
	#endif // CONFIG_STATEMACHINES
	// 'max_on_time' is deprecated. Therefore no data will be written.
	if (0 != (p_validbits & ((uint32_t)1U << 13))) {
		// 'threshold_off': id=35, encoding=varint, tag=0x118
		put(0x98);
		put(0x2);
		send_varint(put,m_threshold_off);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 14))) {
		// 'threshold_on': id=36, encoding=varint, tag=0x120
		put(0xa0);
		put(0x2);
		send_varint(put,m_threshold_on);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 15))) {
		// 'dim_step': id=37, encoding=varint, tag=0x128
		put(0xa8);
		put(0x2);
		send_varint(put,m_dim_step);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 16))) {
		// 'lightctrl': id=38, encoding=8bit, tag=0x133
		put(0xb3);
		put(0x2);
		put(m_lightctrl);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 17))) {
		// 'pwm_freq': id=39, encoding=varint, tag=0x138
		put(0xb8);
		put(0x2);
		send_varint(put,m_pwm_freq);
	}
	#ifdef CONFIG_APP_PARAMS
	for (size_t x = 0, y = m_app_params.size(); x != y; ++x) {
		// 'app_params': id=40, encoding=lenpfx, tag=0x142
		put(0xc2);
		put(0x2);
		send_varint(put,m_app_params[x].calcSize());
		m_app_params[x].toWire(put);
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	for (size_t x = 0, y = m_thresholds.size(); x != y; ++x) {
		// 'thresholds': id=41, encoding=lenpfx, tag=0x14a
		put(0xca);
		put(0x2);
		send_varint(put,m_thresholds[x].calcSize());
		m_thresholds[x].toWire(put);
	}
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	for (size_t x = 0, y = m_luafiles.size(); x != y; ++x) {
		// 'luafiles': id=42, encoding=lenpfx, tag=0x152
		put(0xd2);
		put(0x2);
		size_t luafiles_s = m_luafiles[x].size();
		send_varint(put,luafiles_s);
		send_bytes(put,(const uint8_t*) m_luafiles[x].data(),luafiles_s);
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	for (size_t x = 0, y = m_owdevices.size(); x != y; ++x) {
		// 'owdevices': id=50, encoding=lenpfx, tag=0x192
		put(0x92);
		put(0x3);
		send_varint(put,m_owdevices[x].calcSize());
		m_owdevices[x].toWire(put);
	}
	#endif // CONFIG_ONEWIRE
}

void NodeConfig::toString(std::string &put) const
{
	if (0 != (p_validbits & ((uint32_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		put.push_back(0x5);	// 'magic': id=0
		send_u32(put,(uint32_t)m_magic);
	}
	if (!m_nodename.empty()) {
		// 'nodename': id=1, encoding=lenpfx, tag=0xa
		put.push_back(0xa);	// 'nodename': id=1
		size_t nodename_s = m_nodename.size();
		send_varint(put,nodename_s);
		put.append((const char *)(const uint8_t*) m_nodename.data(),nodename_s);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 1))) {
		// 'pass_hash': id=2, encoding=lenpfx, tag=0x12
		put.push_back(0x12);	// 'pass_hash': id=2
		size_t pass_hash_s = m_pass_hash.size();
		send_varint(put,pass_hash_s);
		put.append((const char *)(const uint8_t*) m_pass_hash.data(),pass_hash_s);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 2))) {
		// 'cpu_freq': id=3, encoding=varint, tag=0x18
		put.push_back(0x18);	// 'cpu_freq': id=3
		send_varint(put,m_cpu_freq);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 3))) {
		// 'station': id=4, encoding=lenpfx, tag=0x22
		put.push_back(0x22);	// 'station': id=4
		send_varint(put,m_station.calcSize());
		m_station.toString(put);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 4))) {
		// 'softap': id=5, encoding=lenpfx, tag=0x2a
		put.push_back(0x2a);	// 'softap': id=5
		send_varint(put,m_softap.calcSize());
		m_softap.toString(put);
	}
	for (size_t x = 0, y = m_dns_server.size(); x != y; ++x) {
		// 'dns_server': id=6, encoding=lenpfx, tag=0x32
		put.push_back(0x32);	// 'dns_server': id=6
		size_t dns_server_s = m_dns_server[x].size();
		send_varint(put,dns_server_s);
		put.append((const char *)(const uint8_t*) m_dns_server[x].data(),dns_server_s);
	}
	if (!m_syslog_host.empty()) {
		// 'syslog_host': id=7, encoding=lenpfx, tag=0x3a
		put.push_back(0x3a);	// 'syslog_host': id=7
		size_t syslog_host_s = m_syslog_host.size();
		send_varint(put,syslog_host_s);
		put.append((const char *)(const uint8_t*) m_syslog_host.data(),syslog_host_s);
	}
	if (!m_sntp_server.empty()) {
		// 'sntp_server': id=8, encoding=lenpfx, tag=0x42
		put.push_back(0x42);	// 'sntp_server': id=8
		size_t sntp_server_s = m_sntp_server.size();
		send_varint(put,sntp_server_s);
		put.append((const char *)(const uint8_t*) m_sntp_server.data(),sntp_server_s);
	}
	if (!m_timezone.empty()) {
		// 'timezone': id=9, encoding=lenpfx, tag=0x4a
		put.push_back(0x4a);	// 'timezone': id=9
		size_t timezone_s = m_timezone.size();
		send_varint(put,timezone_s);
		put.append((const char *)(const uint8_t*) m_timezone.data(),timezone_s);
	}
	#ifdef CONFIG_MQTT
	if (0 != (p_validbits & ((uint32_t)1U << 5))) {
		// 'mqtt': id=10, encoding=lenpfx, tag=0x52
		put.push_back(0x52);	// 'mqtt': id=10
		send_varint(put,m_mqtt.calcSize());
		m_mqtt.toString(put);
	}
	#endif // CONFIG_MQTT
	if (0 != (p_validbits & ((uint32_t)1U << 6))) {
		// 'dmesg_size': id=11, encoding=16bit, tag=0x5c
		put.push_back(0x5c);	// 'dmesg_size': id=11
		send_u16(put,m_dmesg_size);
	}
	#ifdef CONFIG_INFLUX
	if (0 != (p_validbits & ((uint32_t)1U << 7))) {
		// 'influx': id=12, encoding=lenpfx, tag=0x62
		put.push_back(0x62);	// 'influx': id=12
		send_varint(put,m_influx.calcSize());
		m_influx.toString(put);
	}
	#endif // CONFIG_INFLUX
	if (0 != (p_validbits & ((uint32_t)1U << 8))) {
		// 'station2ap_time': id=13, encoding=varint, tag=0x68
		put.push_back(0x68);	// 'station2ap_time': id=13
		send_varint(put,m_station2ap_time);
	}
	if (!m_domainname.empty()) {
		// 'domainname': id=15, encoding=lenpfx, tag=0x7a
		put.push_back(0x7a);	// 'domainname': id=15
		size_t domainname_s = m_domainname.size();
		send_varint(put,domainname_s);
		put.append((const char *)(const uint8_t*) m_domainname.data(),domainname_s);
	}
	for (size_t x = 0, y = m_holidays.size(); x != y; ++x) {
		// 'holidays': id=16, encoding=lenpfx, tag=0x82
		put.push_back(0x82);
		put.push_back(0x1);
		send_varint(put,m_holidays[x].calcSize());
		m_holidays[x].toString(put);
	}
	for (size_t x = 0, y = m_at_actions.size(); x != y; ++x) {
		// 'at_actions': id=17, encoding=lenpfx, tag=0x8a
		put.push_back(0x8a);
		put.push_back(0x1);
		send_varint(put,m_at_actions[x].calcSize());
		m_at_actions[x].toString(put);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 9))) {
		// 'actions_enable': id=18, encoding=varint, tag=0x90
		put.push_back(0x90);
		put.push_back(0x1);
		send_varint(put,m_actions_enable);
	}
	for (size_t x = 0, y = m_triggers.size(); x != y; ++x) {
		// 'triggers': id=19, encoding=lenpfx, tag=0x9a
		put.push_back(0x9a);
		put.push_back(0x1);
		send_varint(put,m_triggers[x].calcSize());
		m_triggers[x].toString(put);
	}
	for (size_t x = 0, y = m_uart.size(); x != y; ++x) {
		// 'uart': id=20, encoding=lenpfx, tag=0xa2
		put.push_back(0xa2);
		put.push_back(0x1);
		send_varint(put,m_uart[x].calcSize());
		m_uart[x].toString(put);
	}
	#ifdef CONFIG_TERMSERV
	for (size_t x = 0, y = m_terminal.size(); x != y; ++x) {
		// 'terminal': id=21, encoding=lenpfx, tag=0xaa
		put.push_back(0xaa);
		put.push_back(0x1);
		send_varint(put,m_terminal[x].calcSize());
		m_terminal[x].toString(put);
	}
	#endif // CONFIG_TERMSERV
	if (0 != (p_validbits & ((uint32_t)1U << 10))) {
		// 'udp_ctrl_port': id=22, encoding=16bit, tag=0xb4
		put.push_back(0xb4);
		put.push_back(0x1);
		send_u16(put,m_udp_ctrl_port);
	}
	for (size_t x = 0, y = m_debugs.size(); x != y; ++x) {
		// 'debugs': id=23, encoding=lenpfx, tag=0xba
		put.push_back(0xba);
		put.push_back(0x1);
		size_t debugs_s = m_debugs[x].size();
		send_varint(put,debugs_s);
		put.append((const char *)(const uint8_t*) m_debugs[x].data(),debugs_s);
	}
	#ifdef CONFIG_FTP
	if (0 != (p_validbits & ((uint32_t)1U << 11))) {
		// 'ftpd': id=24, encoding=lenpfx, tag=0xc2
		put.push_back(0xc2);
		put.push_back(0x1);
		send_varint(put,m_ftpd.calcSize());
		m_ftpd.toString(put);
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (0 != (p_validbits & ((uint32_t)1U << 12))) {
		// 'httpd': id=25, encoding=lenpfx, tag=0xca
		put.push_back(0xca);
		put.push_back(0x1);
		send_varint(put,m_httpd.calcSize());
		m_httpd.toString(put);
	}
	#endif // CONFIG_HTTP
	for (size_t x = 0, y = m_timefuses.size(); x != y; ++x) {
		// 'timefuses': id=30, encoding=lenpfx, tag=0xf2
		put.push_back(0xf2);
		put.push_back(0x1);
		send_varint(put,m_timefuses[x].calcSize());
		m_timefuses[x].toString(put);
	}
	#ifdef CONFIG_SIGNAL_PROC
	for (size_t x = 0, y = m_signals.size(); x != y; ++x) {
		// 'signals': id=31, encoding=lenpfx, tag=0xfa
		put.push_back(0xfa);
		put.push_back(0x1);
		send_varint(put,m_signals[x].calcSize());
		m_signals[x].toString(put);
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	for (size_t x = 0, y = m_functions.size(); x != y; ++x) {
		// 'functions': id=32, encoding=lenpfx, tag=0x102
		put.push_back(0x82);
		put.push_back(0x2);
		send_varint(put,m_functions[x].calcSize());
		m_functions[x].toString(put);
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	for (size_t x = 0, y = m_statemachs.size(); x != y; ++x) {
		// 'statemachs': id=33, encoding=lenpfx, tag=0x10a
		put.push_back(0x8a);
		put.push_back(0x2);
		send_varint(put,m_statemachs[x].calcSize());
		m_statemachs[x].toString(put);
	}
	#endif // CONFIG_STATEMACHINES
	// 'max_on_time' is deprecated. Therefore no data will be written.
	if (0 != (p_validbits & ((uint32_t)1U << 13))) {
		// 'threshold_off': id=35, encoding=varint, tag=0x118
		put.push_back(0x98);
		put.push_back(0x2);
		send_varint(put,m_threshold_off);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 14))) {
		// 'threshold_on': id=36, encoding=varint, tag=0x120
		put.push_back(0xa0);
		put.push_back(0x2);
		send_varint(put,m_threshold_on);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 15))) {
		// 'dim_step': id=37, encoding=varint, tag=0x128
		put.push_back(0xa8);
		put.push_back(0x2);
		send_varint(put,m_dim_step);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 16))) {
		// 'lightctrl': id=38, encoding=8bit, tag=0x133
		put.push_back(0xb3);
		put.push_back(0x2);
		put.push_back(m_lightctrl);
	}
	if (0 != (p_validbits & ((uint32_t)1U << 17))) {
		// 'pwm_freq': id=39, encoding=varint, tag=0x138
		put.push_back(0xb8);
		put.push_back(0x2);
		send_varint(put,m_pwm_freq);
	}
	#ifdef CONFIG_APP_PARAMS
	for (size_t x = 0, y = m_app_params.size(); x != y; ++x) {
		// 'app_params': id=40, encoding=lenpfx, tag=0x142
		put.push_back(0xc2);
		put.push_back(0x2);
		send_varint(put,m_app_params[x].calcSize());
		m_app_params[x].toString(put);
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	for (size_t x = 0, y = m_thresholds.size(); x != y; ++x) {
		// 'thresholds': id=41, encoding=lenpfx, tag=0x14a
		put.push_back(0xca);
		put.push_back(0x2);
		send_varint(put,m_thresholds[x].calcSize());
		m_thresholds[x].toString(put);
	}
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	for (size_t x = 0, y = m_luafiles.size(); x != y; ++x) {
		// 'luafiles': id=42, encoding=lenpfx, tag=0x152
		put.push_back(0xd2);
		put.push_back(0x2);
		size_t luafiles_s = m_luafiles[x].size();
		send_varint(put,luafiles_s);
		put.append((const char *)(const uint8_t*) m_luafiles[x].data(),luafiles_s);
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	for (size_t x = 0, y = m_owdevices.size(); x != y; ++x) {
		// 'owdevices': id=50, encoding=lenpfx, tag=0x192
		put.push_back(0x92);
		put.push_back(0x3);
		send_varint(put,m_owdevices[x].calcSize());
		m_owdevices[x].toString(put);
	}
	#endif // CONFIG_ONEWIRE
}

void NodeConfig::toJSON(std::ostream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_magic()) {
		fsep = json_indent(json,indLvl,fsep,"magic");
		json << m_magic;
	}
	if (has_nodename()) {
		fsep = json_indent(json,indLvl,fsep,"nodename");
		json_cstr(json,m_nodename.c_str());
	}
	if (has_pass_hash()) {
		fsep = json_indent(json,indLvl,fsep,"pass_hash");
		json_string(json,m_pass_hash);
	}
	if (has_cpu_freq()) {
		fsep = json_indent(json,indLvl,fsep,"cpu_freq");
		json << m_cpu_freq;
	}
	if (has_station()) {
		fsep = json_indent(json,indLvl,fsep,"station");
		m_station.toJSON(json,indLvl);
	}
	if (has_softap()) {
		fsep = json_indent(json,indLvl,fsep,"softap");
		m_softap.toJSON(json,indLvl);
	}
	if (size_t s = m_dns_server.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"dns_server\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_dns_server[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (has_syslog_host()) {
		fsep = json_indent(json,indLvl,fsep,"syslog_host");
		json_cstr(json,m_syslog_host.c_str());
	}
	if (has_sntp_server()) {
		fsep = json_indent(json,indLvl,fsep,"sntp_server");
		json_cstr(json,m_sntp_server.c_str());
	}
	if (has_timezone()) {
		fsep = json_indent(json,indLvl,fsep,"timezone");
		json_cstr(json,m_timezone.c_str());
	}
	#ifdef CONFIG_MQTT
	if (has_mqtt()) {
		fsep = json_indent(json,indLvl,fsep,"mqtt");
		m_mqtt.toJSON(json,indLvl);
	}
	#endif // CONFIG_MQTT
	if (has_dmesg_size()) {
		fsep = json_indent(json,indLvl,fsep,"dmesg_size");
		json << m_dmesg_size;
	}
	#ifdef CONFIG_INFLUX
	if (has_influx()) {
		fsep = json_indent(json,indLvl,fsep,"influx");
		m_influx.toJSON(json,indLvl);
	}
	#endif // CONFIG_INFLUX
	if (has_station2ap_time()) {
		fsep = json_indent(json,indLvl,fsep,"station2ap_time");
		json << m_station2ap_time;
	}
	if (has_domainname()) {
		fsep = json_indent(json,indLvl,fsep,"domainname");
		json_cstr(json,m_domainname.c_str());
	}
	if (size_t s = m_holidays.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"holidays\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_holidays[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_at_actions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"at_actions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_at_actions[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (has_actions_enable()) {
		fsep = json_indent(json,indLvl,fsep,"actions_enable");
		json << m_actions_enable;
	}
	if (size_t s = m_triggers.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"triggers\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_triggers[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_uart.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"uart\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_uart[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_TERMSERV
	if (size_t s = m_terminal.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"terminal\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_terminal[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_TERMSERV
	if (has_udp_ctrl_port()) {
		fsep = json_indent(json,indLvl,fsep,"udp_ctrl_port");
		json << m_udp_ctrl_port;
	}
	if (size_t s = m_debugs.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"debugs\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_debugs[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_FTP
	if (has_ftpd()) {
		fsep = json_indent(json,indLvl,fsep,"ftpd");
		m_ftpd.toJSON(json,indLvl);
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (has_httpd()) {
		fsep = json_indent(json,indLvl,fsep,"httpd");
		m_httpd.toJSON(json,indLvl);
	}
	#endif // CONFIG_HTTP
	if (size_t s = m_timefuses.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"timefuses\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_timefuses[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_SIGNAL_PROC
	if (size_t s = m_signals.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"signals\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_signals[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	if (size_t s = m_functions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"functions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_functions[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	if (size_t s = m_statemachs.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"statemachs\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_statemachs[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_STATEMACHINES
	if (has_max_on_time()) {
		fsep = json_indent(json,indLvl,fsep,"max_on_time");
		json << m_max_on_time;
	}
	if (has_threshold_off()) {
		fsep = json_indent(json,indLvl,fsep,"threshold_off");
		json << m_threshold_off;
	}
	if (has_threshold_on()) {
		fsep = json_indent(json,indLvl,fsep,"threshold_on");
		json << m_threshold_on;
	}
	if (has_dim_step()) {
		fsep = json_indent(json,indLvl,fsep,"dim_step");
		json << m_dim_step;
	}
	if (has_lightctrl()) {
		fsep = json_indent(json,indLvl,fsep,"lightctrl");
		json << (m_lightctrl ? "true" : "false");
	}
	if (has_pwm_freq()) {
		fsep = json_indent(json,indLvl,fsep,"pwm_freq");
		json << m_pwm_freq;
	}
	#ifdef CONFIG_APP_PARAMS
	if (size_t s = m_app_params.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"app_params\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_app_params[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	if (size_t s = m_thresholds.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"thresholds\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_thresholds[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	if (size_t s = m_luafiles.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"luafiles\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_luafiles[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	if (size_t s = m_owdevices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"owdevices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_owdevices[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_ONEWIRE
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t NodeConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed32 magic, id 0
	if (0 != (p_validbits & ((uint32_t)1U << 0))) {
		r += 5;
	}
	// optional string nodename, id 1
	if (!m_nodename.empty()) {
		size_t nodename_s = m_nodename.size();
		r += nodename_s + wiresize(nodename_s) + 1 /* tag(nodename) 0x8 */;
	}
	// optional bytes pass_hash, id 2
	if (0 != (p_validbits & ((uint32_t)1U << 1))) {
		size_t pass_hash_s = m_pass_hash.size();
		r += pass_hash_s + wiresize(pass_hash_s) + 1 /* tag(pass_hash) 0x10 */;
	}
	// optional unsigned cpu_freq, id 3
	if (0 != (p_validbits & ((uint32_t)1U << 2))) {
		r += wiresize((varint_t)m_cpu_freq) + 1 /* tag(cpu_freq) 0x18 */;
	}
	// optional WifiConfig station, id 4
	if (0 != (p_validbits & ((uint32_t)1U << 3))) {
		size_t station_s = m_station.calcSize();
		r += station_s + wiresize(station_s) + 1 /* tag(station) 0x20 */;
	}
	// optional WifiConfig softap, id 5
	if (0 != (p_validbits & ((uint32_t)1U << 4))) {
		size_t softap_s = m_softap.calcSize();
		r += softap_s + wiresize(softap_s) + 1 /* tag(softap) 0x28 */;
	}
	// repeated string dns_server, id 6
	if (!m_dns_server.empty()) {
		// dns_server: repeated std::string
		for (size_t x = 0, y = m_dns_server.size(); x < y; ++x) {
			size_t s = m_dns_server[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(dns_server) 0x30 */;
		}
	}
	// optional string syslog_host, id 7
	if (!m_syslog_host.empty()) {
		size_t syslog_host_s = m_syslog_host.size();
		r += syslog_host_s + wiresize(syslog_host_s) + 1 /* tag(syslog_host) 0x38 */;
	}
	// optional string sntp_server, id 8
	if (!m_sntp_server.empty()) {
		size_t sntp_server_s = m_sntp_server.size();
		r += sntp_server_s + wiresize(sntp_server_s) + 1 /* tag(sntp_server) 0x40 */;
	}
	// optional string timezone, id 9
	if (!m_timezone.empty()) {
		size_t timezone_s = m_timezone.size();
		r += timezone_s + wiresize(timezone_s) + 1 /* tag(timezone) 0x48 */;
	}
	#ifdef CONFIG_MQTT
	// optional MQTT mqtt, id 10
	if (0 != (p_validbits & ((uint32_t)1U << 5))) {
		size_t mqtt_s = m_mqtt.calcSize();
		r += mqtt_s + wiresize(mqtt_s) + 1 /* tag(mqtt) 0x50 */;
	}
	#endif // CONFIG_MQTT
	// optional fixed16 dmesg_size, id 11
	if (0 != (p_validbits & ((uint32_t)1U << 6))) {
		r += 3;
	}
	#ifdef CONFIG_INFLUX
	// optional Influx influx, id 12
	if (0 != (p_validbits & ((uint32_t)1U << 7))) {
		size_t influx_s = m_influx.calcSize();
		r += influx_s + wiresize(influx_s) + 1 /* tag(influx) 0x60 */;
	}
	#endif // CONFIG_INFLUX
	// optional unsigned station2ap_time, id 13
	if (0 != (p_validbits & ((uint32_t)1U << 8))) {
		r += wiresize((varint_t)m_station2ap_time) + 1 /* tag(station2ap_time) 0x68 */;
	}
	// optional string domainname, id 15
	if (!m_domainname.empty()) {
		size_t domainname_s = m_domainname.size();
		r += domainname_s + wiresize(domainname_s) + 1 /* tag(domainname) 0x78 */;
	}
	// repeated Date holidays, id 16
	// repeated message holidays
	for (size_t x = 0, y = m_holidays.size(); x < y; ++x) {
		size_t s = m_holidays[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(holidays) 0x80 */;
	}
	// repeated AtAction at_actions, id 17
	// repeated message at_actions
	for (size_t x = 0, y = m_at_actions.size(); x < y; ++x) {
		size_t s = m_at_actions[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(at_actions) 0x88 */;
	}
	// optional unsigned actions_enable, id 18
	if (0 != (p_validbits & ((uint32_t)1U << 9))) {
		r += wiresize((varint_t)m_actions_enable) + 2 /* tag(actions_enable) 0x90 */;
	}
	// repeated Trigger triggers, id 19
	// repeated message triggers
	for (size_t x = 0, y = m_triggers.size(); x < y; ++x) {
		size_t s = m_triggers[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(triggers) 0x98 */;
	}
	// repeated UartSettings uart, id 20
	// repeated message uart
	for (size_t x = 0, y = m_uart.size(); x < y; ++x) {
		size_t s = m_uart[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(uart) 0xa0 */;
	}
	#ifdef CONFIG_TERMSERV
	// repeated TerminalConfig terminal, id 21
	// repeated message terminal
	for (size_t x = 0, y = m_terminal.size(); x < y; ++x) {
		size_t s = m_terminal[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(terminal) 0xa8 */;
	}
	#endif // CONFIG_TERMSERV
	// optional fixed16 udp_ctrl_port, id 22
	if (0 != (p_validbits & ((uint32_t)1U << 10))) {
		r += 4;
	}
	// repeated string debugs, id 23
	if (!m_debugs.empty()) {
		// debugs: repeated std::string
		for (size_t x = 0, y = m_debugs.size(); x < y; ++x) {
			size_t s = m_debugs[x].size();
			r += wiresize(s);
			r += s + 2 /* tag(debugs) 0xb8 */;
		}
	}
	#ifdef CONFIG_FTP
	// optional FtpHttpConfig ftpd, id 24
	if (0 != (p_validbits & ((uint32_t)1U << 11))) {
		size_t ftpd_s = m_ftpd.calcSize();
		r += ftpd_s + wiresize(ftpd_s) + 2 /* tag(ftpd) 0xc0 */;
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	// optional FtpHttpConfig httpd, id 25
	if (0 != (p_validbits & ((uint32_t)1U << 12))) {
		size_t httpd_s = m_httpd.calcSize();
		r += httpd_s + wiresize(httpd_s) + 2 /* tag(httpd) 0xc8 */;
	}
	#endif // CONFIG_HTTP
	// repeated EventTimer timefuses, id 30
	// repeated message timefuses
	for (size_t x = 0, y = m_timefuses.size(); x < y; ++x) {
		size_t s = m_timefuses[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(timefuses) 0xf0 */;
	}
	#ifdef CONFIG_SIGNAL_PROC
	// repeated SignalConfig signals, id 31
	// repeated message signals
	for (size_t x = 0, y = m_signals.size(); x < y; ++x) {
		size_t s = m_signals[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(signals) 0xf8 */;
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	// repeated FunctionConfig functions, id 32
	// repeated message functions
	for (size_t x = 0, y = m_functions.size(); x < y; ++x) {
		size_t s = m_functions[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(functions) 0x100 */;
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	// repeated StateMachineConfig statemachs, id 33
	// repeated message statemachs
	for (size_t x = 0, y = m_statemachs.size(); x < y; ++x) {
		size_t s = m_statemachs[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(statemachs) 0x108 */;
	}
	#endif // CONFIG_STATEMACHINES
	// deprecated optional unsigned max_on_time, id 34
	// optional unsigned threshold_off, id 35
	if (0 != (p_validbits & ((uint32_t)1U << 13))) {
		r += wiresize((varint_t)m_threshold_off) + 2 /* tag(threshold_off) 0x118 */;
	}
	// optional unsigned threshold_on, id 36
	if (0 != (p_validbits & ((uint32_t)1U << 14))) {
		r += wiresize((varint_t)m_threshold_on) + 2 /* tag(threshold_on) 0x120 */;
	}
	// optional unsigned dim_step, id 37
	if (0 != (p_validbits & ((uint32_t)1U << 15))) {
		r += wiresize((varint_t)m_dim_step) + 2 /* tag(dim_step) 0x128 */;
	}
	// optional bool lightctrl, id 38
	if (0 != (p_validbits & ((uint32_t)1U << 16))) {
		r += 3;
	}
	// optional unsigned pwm_freq, id 39
	if (0 != (p_validbits & ((uint32_t)1U << 17))) {
		r += wiresize((varint_t)m_pwm_freq) + 2 /* tag(pwm_freq) 0x138 */;
	}
	#ifdef CONFIG_APP_PARAMS
	// repeated AppParam app_params, id 40
	// repeated message app_params
	for (size_t x = 0, y = m_app_params.size(); x < y; ++x) {
		size_t s = m_app_params[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(app_params) 0x140 */;
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	// repeated ThresholdConfig thresholds, id 41
	// repeated message thresholds
	for (size_t x = 0, y = m_thresholds.size(); x < y; ++x) {
		size_t s = m_thresholds[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(thresholds) 0x148 */;
	}
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	// repeated string luafiles, id 42
	if (!m_luafiles.empty()) {
		// luafiles: repeated std::string
		for (size_t x = 0, y = m_luafiles.size(); x < y; ++x) {
			size_t s = m_luafiles[x].size();
			r += wiresize(s);
			r += s + 2 /* tag(luafiles) 0x150 */;
		}
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	// repeated OwDeviceConfig owdevices, id 50
	// repeated message owdevices
	for (size_t x = 0, y = m_owdevices.size(); x < y; ++x) {
		size_t s = m_owdevices[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(owdevices) 0x190 */;
	}
	#endif // CONFIG_ONEWIRE
	return r;
}

bool NodeConfig::operator != (const NodeConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_magic() && (m_magic != r.m_magic))
		return true;
	if (has_nodename() && (m_nodename != r.m_nodename))
		return true;
	if (has_pass_hash() && (m_pass_hash != r.m_pass_hash))
		return true;
	if (has_cpu_freq() && (m_cpu_freq != r.m_cpu_freq))
		return true;
	if (has_station() && (m_station != r.m_station))
		return true;
	if (has_softap() && (m_softap != r.m_softap))
		return true;
	if (m_dns_server != r.m_dns_server)
		return true;
	if (has_syslog_host() && (m_syslog_host != r.m_syslog_host))
		return true;
	if (has_sntp_server() && (m_sntp_server != r.m_sntp_server))
		return true;
	if (has_timezone() && (m_timezone != r.m_timezone))
		return true;
	#ifdef CONFIG_MQTT
	if (has_mqtt() && (m_mqtt != r.m_mqtt))
		return true;
	#endif // CONFIG_MQTT
	if (has_dmesg_size() && (m_dmesg_size != r.m_dmesg_size))
		return true;
	#ifdef CONFIG_INFLUX
	if (has_influx() && (m_influx != r.m_influx))
		return true;
	#endif // CONFIG_INFLUX
	if (has_station2ap_time() && (m_station2ap_time != r.m_station2ap_time))
		return true;
	if (has_domainname() && (m_domainname != r.m_domainname))
		return true;
	if (m_holidays != r.m_holidays)
		return true;
	if (m_at_actions != r.m_at_actions)
		return true;
	if (has_actions_enable() && (m_actions_enable != r.m_actions_enable))
		return true;
	if (m_triggers != r.m_triggers)
		return true;
	if (m_uart != r.m_uart)
		return true;
	#ifdef CONFIG_TERMSERV
	if (m_terminal != r.m_terminal)
		return true;
	#endif // CONFIG_TERMSERV
	if (has_udp_ctrl_port() && (m_udp_ctrl_port != r.m_udp_ctrl_port))
		return true;
	if (m_debugs != r.m_debugs)
		return true;
	#ifdef CONFIG_FTP
	if (has_ftpd() && (m_ftpd != r.m_ftpd))
		return true;
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (has_httpd() && (m_httpd != r.m_httpd))
		return true;
	#endif // CONFIG_HTTP
	if (m_timefuses != r.m_timefuses)
		return true;
	#ifdef CONFIG_SIGNAL_PROC
	if (m_signals != r.m_signals)
		return true;
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	if (m_functions != r.m_functions)
		return true;
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	if (m_statemachs != r.m_statemachs)
		return true;
	#endif // CONFIG_STATEMACHINES
	if (has_max_on_time() && (m_max_on_time != r.m_max_on_time))
		return true;
	if (has_threshold_off() && (m_threshold_off != r.m_threshold_off))
		return true;
	if (has_threshold_on() && (m_threshold_on != r.m_threshold_on))
		return true;
	if (has_dim_step() && (m_dim_step != r.m_dim_step))
		return true;
	if (has_lightctrl() && (m_lightctrl != r.m_lightctrl))
		return true;
	if (has_pwm_freq() && (m_pwm_freq != r.m_pwm_freq))
		return true;
	#ifdef CONFIG_APP_PARAMS
	if (m_app_params != r.m_app_params)
		return true;
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	if (m_thresholds != r.m_thresholds)
		return true;
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	if (m_luafiles != r.m_luafiles)
		return true;
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	if (m_owdevices != r.m_owdevices)
		return true;
	#endif // CONFIG_ONEWIRE
	return false;
}


bool NodeConfig::operator == (const NodeConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int NodeConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"magic")) {
		if (value == 0) {
			clear_magic();
			return 0;
		}
		int r = parse_ascii_u32(&m_magic,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"nodename")) {
		if (value == 0) {
			clear_nodename();
			return 0;
		}
		m_nodename = value;
		int r = m_nodename.size();
		return r;
	}
	if (0 == strcmp(name,"pass_hash")) {
		if (value == 0) {
			clear_pass_hash();
			return 0;
		}
		int r = parse_ascii_bytes(m_pass_hash,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"cpu_freq")) {
		if (value == 0) {
			clear_cpu_freq();
			return 0;
		}
		int r = parse_ascii_u64(&m_cpu_freq,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 2);
		return r;
	}
	if (0 == memcmp(name,"station",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_station();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint32_t)1U << 3);
			return m_station.setByName(name+8,value);
		}
	}
	if (0 == memcmp(name,"softap",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_softap();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint32_t)1U << 4);
			return m_softap.setByName(name+7,value);
		}
	}
	if (0 == memcmp(name,"dns_server",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_dns_server();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_dns_server.size();
				m_dns_server.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -417;
				if (m_dns_server.size() <= x)
					return -418;
				if ((idxe[1] == 0) && (value == 0)) {
					m_dns_server.erase(m_dns_server.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -419;
			m_dns_server[x] = value;
			return m_dns_server[x].size();
		}
	}
	if (0 == strcmp(name,"syslog_host")) {
		if (value == 0) {
			clear_syslog_host();
			return 0;
		}
		m_syslog_host = value;
		int r = m_syslog_host.size();
		return r;
	}
	if (0 == strcmp(name,"sntp_server")) {
		if (value == 0) {
			clear_sntp_server();
			return 0;
		}
		m_sntp_server = value;
		int r = m_sntp_server.size();
		return r;
	}
	if (0 == strcmp(name,"timezone")) {
		if (value == 0) {
			clear_timezone();
			return 0;
		}
		m_timezone = value;
		int r = m_timezone.size();
		return r;
	}
	#ifdef CONFIG_MQTT
	if (0 == memcmp(name,"mqtt",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_mqtt();
			return 0;
		} else if (name[4] == '.') {
			p_validbits |= ((uint32_t)1U << 5);
			return m_mqtt.setByName(name+5,value);
		}
	}
	#endif // CONFIG_MQTT
	if (0 == strcmp(name,"dmesg_size")) {
		if (value == 0) {
			clear_dmesg_size();
			return 0;
		}
		int r = parse_ascii_u16(&m_dmesg_size,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 6);
		return r;
	}
	#ifdef CONFIG_INFLUX
	if (0 == memcmp(name,"influx",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_influx();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint32_t)1U << 7);
			return m_influx.setByName(name+7,value);
		}
	}
	#endif // CONFIG_INFLUX
	if (0 == strcmp(name,"station2ap_time")) {
		if (value == 0) {
			clear_station2ap_time();
			return 0;
		}
		int r = parse_ascii_u64(&m_station2ap_time,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 8);
		return r;
	}
	if (0 == strcmp(name,"domainname")) {
		if (value == 0) {
			clear_domainname();
			return 0;
		}
		m_domainname = value;
		int r = m_domainname.size();
		return r;
	}
	if (0 == memcmp(name,"holidays",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_holidays();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_holidays.size();
				m_holidays.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -420;
				if (m_holidays.size() <= x)
					return -421;
				if ((idxe[1] == 0) && (value == 0)) {
					m_holidays.erase(m_holidays.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -422;
			return m_holidays[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"at_actions",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_at_actions();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_at_actions.size();
				m_at_actions.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -423;
				if (m_at_actions.size() <= x)
					return -424;
				if ((idxe[1] == 0) && (value == 0)) {
					m_at_actions.erase(m_at_actions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -425;
			return m_at_actions[x].setByName(idxe+2,value);
		}
	}
	if (0 == strcmp(name,"actions_enable")) {
		if (value == 0) {
			clear_actions_enable();
			return 0;
		}
		int r = parse_ascii_u64(&m_actions_enable,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 9);
		return r;
	}
	if (0 == memcmp(name,"triggers",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_triggers();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_triggers.size();
				m_triggers.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -426;
				if (m_triggers.size() <= x)
					return -427;
				if ((idxe[1] == 0) && (value == 0)) {
					m_triggers.erase(m_triggers.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -428;
			return m_triggers[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"uart",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_uart();
			return 0;
		} else if (name[4] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[5] == '+') && (name[6] == ']')) {
				x = m_uart.size();
				m_uart.resize(x+1);
				idxe = (char*)(name + 6);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+5,&idxe,0);
				if (idxe[0] != ']')
					return -429;
				if (m_uart.size() <= x)
					return -430;
				if ((idxe[1] == 0) && (value == 0)) {
					m_uart.erase(m_uart.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -431;
			return m_uart[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_TERMSERV
	if (0 == memcmp(name,"terminal",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_terminal();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_terminal.size();
				m_terminal.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -432;
				if (m_terminal.size() <= x)
					return -433;
				if ((idxe[1] == 0) && (value == 0)) {
					m_terminal.erase(m_terminal.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -434;
			return m_terminal[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_TERMSERV
	if (0 == strcmp(name,"udp_ctrl_port")) {
		if (value == 0) {
			clear_udp_ctrl_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_udp_ctrl_port,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 10);
		return r;
	}
	if (0 == memcmp(name,"debugs",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_debugs();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_debugs.size();
				m_debugs.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -435;
				if (m_debugs.size() <= x)
					return -436;
				if ((idxe[1] == 0) && (value == 0)) {
					m_debugs.erase(m_debugs.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -437;
			m_debugs[x] = value;
			return m_debugs[x].size();
		}
	}
	#ifdef CONFIG_FTP
	if (0 == memcmp(name,"ftpd",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_ftpd();
			return 0;
		} else if (name[4] == '.') {
			p_validbits |= ((uint32_t)1U << 11);
			return m_ftpd.setByName(name+5,value);
		}
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (0 == memcmp(name,"httpd",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_httpd();
			return 0;
		} else if (name[5] == '.') {
			p_validbits |= ((uint32_t)1U << 12);
			return m_httpd.setByName(name+6,value);
		}
	}
	#endif // CONFIG_HTTP
	if (0 == memcmp(name,"timefuses",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_timefuses();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_timefuses.size();
				m_timefuses.resize(x+1);
				idxe = (char*)(name + 11);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if (idxe[0] != ']')
					return -438;
				if (m_timefuses.size() <= x)
					return -439;
				if ((idxe[1] == 0) && (value == 0)) {
					m_timefuses.erase(m_timefuses.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -440;
			return m_timefuses[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_SIGNAL_PROC
	if (0 == memcmp(name,"signals",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_signals();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_signals.size();
				m_signals.resize(x+1);
				idxe = (char*)(name + 9);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if (idxe[0] != ']')
					return -441;
				if (m_signals.size() <= x)
					return -442;
				if ((idxe[1] == 0) && (value == 0)) {
					m_signals.erase(m_signals.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -443;
			return m_signals[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	if (0 == memcmp(name,"functions",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_functions();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_functions.size();
				m_functions.resize(x+1);
				idxe = (char*)(name + 11);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if (idxe[0] != ']')
					return -444;
				if (m_functions.size() <= x)
					return -445;
				if ((idxe[1] == 0) && (value == 0)) {
					m_functions.erase(m_functions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -446;
			return m_functions[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	if (0 == memcmp(name,"statemachs",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_statemachs();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_statemachs.size();
				m_statemachs.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -447;
				if (m_statemachs.size() <= x)
					return -448;
				if ((idxe[1] == 0) && (value == 0)) {
					m_statemachs.erase(m_statemachs.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -449;
			return m_statemachs[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_STATEMACHINES
	if (0 == strcmp(name,"max_on_time")) {
		if (value == 0) {
			clear_max_on_time();
			return 0;
		}
		int r = parse_ascii_u64(&m_max_on_time,value);
		return r;
	}
	if (0 == strcmp(name,"threshold_off")) {
		if (value == 0) {
			clear_threshold_off();
			return 0;
		}
		int r = parse_ascii_u64(&m_threshold_off,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 13);
		return r;
	}
	if (0 == strcmp(name,"threshold_on")) {
		if (value == 0) {
			clear_threshold_on();
			return 0;
		}
		int r = parse_ascii_u64(&m_threshold_on,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 14);
		return r;
	}
	if (0 == strcmp(name,"dim_step")) {
		if (value == 0) {
			clear_dim_step();
			return 0;
		}
		int r = parse_ascii_u64(&m_dim_step,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 15);
		return r;
	}
	if (0 == strcmp(name,"lightctrl")) {
		if (value == 0) {
			clear_lightctrl();
			return 0;
		}
		int r = parse_ascii_bool(&m_lightctrl,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 16);
		return r;
	}
	if (0 == strcmp(name,"pwm_freq")) {
		if (value == 0) {
			clear_pwm_freq();
			return 0;
		}
		int r = parse_ascii_u64(&m_pwm_freq,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 17);
		return r;
	}
	#ifdef CONFIG_APP_PARAMS
	if (0 == memcmp(name,"app_params",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_app_params();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_app_params.size();
				m_app_params.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -450;
				if (m_app_params.size() <= x)
					return -451;
				if ((idxe[1] == 0) && (value == 0)) {
					m_app_params.erase(m_app_params.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -452;
			return m_app_params[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	if (0 == memcmp(name,"thresholds",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_thresholds();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_thresholds.size();
				m_thresholds.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -453;
				if (m_thresholds.size() <= x)
					return -454;
				if ((idxe[1] == 0) && (value == 0)) {
					m_thresholds.erase(m_thresholds.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -455;
			return m_thresholds[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	if (0 == memcmp(name,"luafiles",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_luafiles();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_luafiles.size();
				m_luafiles.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -456;
				if (m_luafiles.size() <= x)
					return -457;
				if ((idxe[1] == 0) && (value == 0)) {
					m_luafiles.erase(m_luafiles.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -458;
			m_luafiles[x] = value;
			return m_luafiles[x].size();
		}
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	if (0 == memcmp(name,"owdevices",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_owdevices();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_owdevices.size();
				m_owdevices.resize(x+1);
				idxe = (char*)(name + 11);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if (idxe[0] != ']')
					return -459;
				if (m_owdevices.size() <= x)
					return -460;
				if ((idxe[1] == 0) && (value == 0)) {
					m_owdevices.erase(m_owdevices.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -461;
			return m_owdevices[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_ONEWIRE
	return -462;
}

