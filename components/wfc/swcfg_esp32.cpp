/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: R2104.15 (hg:403/b1f5b8e6c836)
 * WFC is Copyright 2015-2021, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : swcfg.wfc
 * Copyright: 2018-2021
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2021-06-27, 23:06:09 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from esp32:
 * endian          : "little"
 * Optimize        : "speed"
 * 
 * options from esp:
 * bytestype       : "estring"
 * intsize         : 32
 * stringtype      : "estring"
 * toASCII         : "toASCII"
 * toSink          : ""
 * toString        : ""
 * toWire          : ""
 * varintbits      : 32
 * 
 * options from common:
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * BaseClass       : ""
 * calcSize        : "calcSize"
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * copyright       : ""
 * email           : ""
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * SortMembers     : "id"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * UnknownField    : "skip"
 * wireput         : ""
 * wiresize        : ""
 * 
 * enabled flags from esp32:
 * 	withUnequal
 * enabled flags from esp:
 * 	enumnames, withEqual
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, enummap, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux
 */

#include <map>
#include <stdlib.h>
#include <string.h>
#include "swcfg.h"

#include "wfccore.h"

#if !defined(WFC_ENDIAN) || (WFC_ENDIAN != 0)
#error wfc: incompatible settings concerning endian
#endif


const char *strReset(rstrsn_t e)
{
	switch (e) {
	default:
		return 0;
	case unknown:
		return "unknown";
	case powerup:
		return "powerup";
	case external:
		return "external";
	case software:
		return "software";
	case panic:
		return "panic";
	case internal_wdt:
		return "internal_wdt";
	case task_wdt:
		return "task_wdt";
	case watchdog:
		return "watchdog";
	case deepsleep:
		return "deepsleep";
	case brownout:
		return "brownout";
	case sdio:
		return "sdio";
	}
}

size_t parse_ascii_rstrsn_t(rstrsn_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (rstrsn_t)ull;
		return e-s;
	} else if (0 == strcmp(s,"unknown")) {
		*v = unknown;
		return 7;
	} else if (0 == strcmp(s,"powerup")) {
		*v = powerup;
		return 7;
	} else if (0 == strcmp(s,"external")) {
		*v = external;
		return 8;
	} else if (0 == strcmp(s,"software")) {
		*v = software;
		return 8;
	} else if (0 == strcmp(s,"panic")) {
		*v = panic;
		return 5;
	} else if (0 == strcmp(s,"internal_wdt")) {
		*v = internal_wdt;
		return 12;
	} else if (0 == strcmp(s,"task_wdt")) {
		*v = task_wdt;
		return 8;
	} else if (0 == strcmp(s,"watchdog")) {
		*v = watchdog;
		return 8;
	} else if (0 == strcmp(s,"deepsleep")) {
		*v = deepsleep;
		return 9;
	} else if (0 == strcmp(s,"brownout")) {
		*v = brownout;
		return 8;
	} else if (0 == strcmp(s,"sdio")) {
		*v = sdio;
		return 4;
	} else {
		return 0;
	}
	return 0;
}

const char *WeekDay_str(WeekDay e)
{
	switch (e) {
	default:
		return 0;
	case Sunday:
		return "Sunday";
	case Monday:
		return "Monday";
	case Tuesday:
		return "Tuesday";
	case Wednesday:
		return "Wednesday";
	case Thursday:
		return "Thursday";
	case Friday:
		return "Friday";
	case Saturday:
		return "Saturday";
	case WorkDay:
		return "WorkDay";
	case WeekEnd:
		return "WeekEnd";
	case EveryDay:
		return "EveryDay";
	case Holiday:
		return "Holiday";
	}
}

size_t parse_ascii_WeekDay(WeekDay *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (WeekDay)ull;
		return e-s;
	} else if (0 == strcmp(s,"Sunday")) {
		*v = Sunday;
		return 6;
	} else if (0 == strcmp(s,"Monday")) {
		*v = Monday;
		return 6;
	} else if (0 == strcmp(s,"Tuesday")) {
		*v = Tuesday;
		return 7;
	} else if (0 == strcmp(s,"Wednesday")) {
		*v = Wednesday;
		return 9;
	} else if (0 == strcmp(s,"Thursday")) {
		*v = Thursday;
		return 8;
	} else if (0 == strcmp(s,"Friday")) {
		*v = Friday;
		return 6;
	} else if (0 == strcmp(s,"Saturday")) {
		*v = Saturday;
		return 8;
	} else if (0 == strcmp(s,"WorkDay")) {
		*v = WorkDay;
		return 7;
	} else if (0 == strcmp(s,"WeekEnd")) {
		*v = WeekEnd;
		return 7;
	} else if (0 == strcmp(s,"EveryDay")) {
		*v = EveryDay;
		return 8;
	} else if (0 == strcmp(s,"Holiday")) {
		*v = Holiday;
		return 7;
	} else {
		return 0;
	}
	return 0;
}

const char *uart_wl_t_str(uart_wl_t e)
{
	switch (e) {
	default:
		return 0;
	case uart_wl_5:
		return "uart_wl_5";
	case uart_wl_6:
		return "uart_wl_6";
	case uart_wl_7:
		return "uart_wl_7";
	case uart_wl_8:
		return "uart_wl_8";
	}
}

size_t parse_ascii_uart_wl_t(uart_wl_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (uart_wl_t)ull;
		return e-s;
	} else if (0 == strcmp(s,"uart_wl_5")) {
		*v = uart_wl_5;
		return 9;
	} else if (0 == strcmp(s,"uart_wl_6")) {
		*v = uart_wl_6;
		return 9;
	} else if (0 == strcmp(s,"uart_wl_7")) {
		*v = uart_wl_7;
		return 9;
	} else if (0 == strcmp(s,"uart_wl_8")) {
		*v = uart_wl_8;
		return 9;
	} else {
		return 0;
	}
	return 0;
}

const char *uart_sb_t_str(uart_sb_t e)
{
	switch (e) {
	default:
		return 0;
	case uart_sb_none:
		return "uart_sb_none";
	case uart_sb_1:
		return "uart_sb_1";
	case uart_sb_1_5:
		return "uart_sb_1_5";
	case uart_sb_2:
		return "uart_sb_2";
	}
}

size_t parse_ascii_uart_sb_t(uart_sb_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (uart_sb_t)ull;
		return e-s;
	} else if (0 == strcmp(s,"uart_sb_none")) {
		*v = uart_sb_none;
		return 12;
	} else if (0 == strcmp(s,"uart_sb_1")) {
		*v = uart_sb_1;
		return 9;
	} else if (0 == strcmp(s,"uart_sb_1_5")) {
		*v = uart_sb_1_5;
		return 11;
	} else if (0 == strcmp(s,"uart_sb_2")) {
		*v = uart_sb_2;
		return 9;
	} else {
		return 0;
	}
	return 0;
}

const char *uart_p_t_str(uart_p_t e)
{
	switch (e) {
	default:
		return 0;
	case uart_p_n:
		return "uart_p_n";
	case uart_p_e:
		return "uart_p_e";
	case uart_p_o:
		return "uart_p_o";
	}
}

size_t parse_ascii_uart_p_t(uart_p_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (uart_p_t)ull;
		return e-s;
	} else if (0 == strcmp(s,"uart_p_n")) {
		*v = uart_p_n;
		return 8;
	} else if (0 == strcmp(s,"uart_p_e")) {
		*v = uart_p_e;
		return 8;
	} else if (0 == strcmp(s,"uart_p_o")) {
		*v = uart_p_o;
		return 8;
	} else {
		return 0;
	}
	return 0;
}

const char *sigtype_t_str(sigtype_t e)
{
	switch (e) {
	default:
		return 0;
	case st_invalid:
		return "st_invalid";
	case st_int:
		return "st_int";
	case st_float:
		return "st_float";
	case st_string:
		return "st_string";
	}
}

size_t parse_ascii_sigtype_t(sigtype_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (sigtype_t)ull;
		return e-s;
	} else if (0 == strcmp(s,"st_invalid")) {
		*v = st_invalid;
		return 10;
	} else if (0 == strcmp(s,"st_int")) {
		*v = st_int;
		return 6;
	} else if (0 == strcmp(s,"st_float")) {
		*v = st_float;
		return 8;
	} else if (0 == strcmp(s,"st_string")) {
		*v = st_string;
		return 9;
	} else {
		return 0;
	}
	return 0;
}

WifiConfig::WifiConfig()
: m_ssid("")
, m_pass("")
, m_mac()
, m_activate(false)
, m_addr4(0)
, m_netmask4(0)
, m_gateway4(0)
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void WifiConfig::clear()
{
	m_ssid = "";
	m_pass = "";
	m_mac.clear();
	m_activate = false;
	m_addr4 = 0;
	m_netmask4 = 0;
	m_gateway4 = 0;
	p_validbits = 0;
}

void WifiConfig::toASCII(stream &o, size_t indent) const
{
	o << "WifiConfig {";
	++indent;
	ascii_indent(o,indent,"ssid");
	ascii_string(o,m_ssid.data(),m_ssid.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"pass");
	ascii_string(o,m_pass.data(),m_pass.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"mac");
	ascii_bytes(o,(const uint8_t*)m_mac.data(),m_mac.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"activate");
	o << (m_activate ? "true" : "false") << ';';
	ascii_indent(o,indent,"addr4");
	ip4_to_ascii(o,m_addr4);
	o << ';';
	ascii_numeric(o, indent, "netmask4", (unsigned) m_netmask4);
	ascii_indent(o,indent,"gateway4");
	ip4_to_ascii(o,m_gateway4);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t WifiConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -1;
		a += fn;
		switch (fid) {
		case 0xa:	// ssid id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -2;
				m_ssid.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x12:	// pass id 2, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -3;
				m_pass.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x1a:	// mac id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -4;
				m_mac.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x23:	// activate id 4, type bool, coding 8bit
			if (a >= e)
				return -5;
			m_activate = *a++;
			break;
		case 0x2d:	// addr4 id 5, type uint32_t, coding 32bit
			if ((a+3) >= e)
				return -6;
			set_addr4((uint32_t) read_u32(a));
			a += 4;
			break;
		case 0x33:	// netmask4 id 6, type uint8_t, coding 8bit
			if (a >= e)
				return -7;
			set_netmask4(*a++);
			break;
		case 0x3d:	// gateway4 id 7, type uint32_t, coding 32bit
			if ((a+3) >= e)
				return -8;
			set_gateway4((uint32_t) read_u32(a));
			a += 4;
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -9;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -10;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t WifiConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has ssid?
	if (!m_ssid.empty()) {
		// 'ssid': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -11;
		*a++ = 0xa;
		ssize_t ssid_s = m_ssid.size();
		n = write_varint(a,e-a,ssid_s);
		a += n;
		if ((n <= 0) || ((e-a) < ssid_s))
			return -12;
		memcpy(a,m_ssid.data(),ssid_s);
		a += ssid_s;
	}
	// has pass?
	if (!m_pass.empty()) {
		// 'pass': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -13;
		*a++ = 0x12;
		ssize_t pass_s = m_pass.size();
		n = write_varint(a,e-a,pass_s);
		a += n;
		if ((n <= 0) || ((e-a) < pass_s))
			return -14;
		memcpy(a,m_pass.data(),pass_s);
		a += pass_s;
	}
	// has mac?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'mac': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -15;
		*a++ = 0x1a;
		ssize_t mac_s = m_mac.size();
		n = write_varint(a,e-a,mac_s);
		a += n;
		if ((n <= 0) || ((e-a) < mac_s))
			return -16;
		memcpy(a,m_mac.data(),mac_s);
		a += mac_s;
	}
	// 'activate': id=4, encoding=8bit, tag=0x23
	if (2 > (e-a))
		return -17;
	*a++ = 0x23;
	*a++ = m_activate;
	// has addr4?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'addr4': id=5, encoding=32bit, tag=0x2d
		if (5 > (e-a))
			return -18;
		*a++ = 0x2d;
		if ((e-a) < 4)
			return -19;
		write_u32(a,(uint32_t)m_addr4);
		a += 4;
	}
	// has netmask4?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'netmask4': id=6, encoding=8bit, tag=0x33
		if (2 > (e-a))
			return -20;
		*a++ = 0x33;
		*a++ = m_netmask4;
	}
	// has gateway4?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'gateway4': id=7, encoding=32bit, tag=0x3d
		if (5 > (e-a))
			return -21;
		*a++ = 0x3d;
		if ((e-a) < 4)
			return -22;
		write_u32(a,(uint32_t)m_gateway4);
		a += 4;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void WifiConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_ssid()) {
		fsep = json_indent(json,indLvl,fsep,"ssid");
		json_cstr(json,m_ssid.c_str());
	}
	if (has_pass()) {
		fsep = json_indent(json,indLvl,fsep,"pass");
		json_cstr(json,m_pass.c_str());
	}
	if (has_mac()) {
		fsep = json_indent(json,indLvl,fsep,"mac");
		json_string(json,m_mac);
	}
	fsep = json_indent(json,indLvl,fsep,"activate");
	json << (m_activate ? "true" : "false");
	if (has_addr4()) {
		fsep = json_indent(json,indLvl,fsep,"addr4");
		json.put('"');
		ip4_to_ascii(json,m_addr4);
		json.put('"');
	}
	if (has_netmask4()) {
		fsep = json_indent(json,indLvl,fsep,"netmask4");
		json << (unsigned) m_netmask4;
	}
	if (has_gateway4()) {
		fsep = json_indent(json,indLvl,fsep,"gateway4");
		json.put('"');
		ip4_to_ascii(json,m_gateway4);
		json.put('"');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t WifiConfig::calcSize() const
{
	// bool activate: tagsize 1, data size 1
	size_t r = 2;	// required size, default is fixed length
	// string ssid
	if (!m_ssid.empty()) {
		size_t ssid_s = m_ssid.size();
		r += ssid_s + wiresize(ssid_s) + 1 /* tag(ssid) 0x8 */;
	}
	// string pass
	if (!m_pass.empty()) {
		size_t pass_s = m_pass.size();
		r += pass_s + wiresize(pass_s) + 1 /* tag(pass) 0x10 */;
	}
	// bytes mac
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t mac_s = m_mac.size();
		r += mac_s + wiresize(mac_s) + 1 /* tag(mac) 0x18 */;
	}
	// fixed32 addr4
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += 5;
	}
	// fixed8 netmask4
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += 2;
	}
	// fixed32 gateway4
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		r += 5;
	}
	return r;
}

bool WifiConfig::operator != (const WifiConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_ssid() && (m_ssid != r.m_ssid))
		return true;
	if (has_pass() && (m_pass != r.m_pass))
		return true;
	if (has_mac() && (m_mac != r.m_mac))
		return true;
	if (m_activate != r.m_activate)
		return true;
	if (has_addr4() && (m_addr4 != r.m_addr4))
		return true;
	if (has_netmask4() && (m_netmask4 != r.m_netmask4))
		return true;
	if (has_gateway4() && (m_gateway4 != r.m_gateway4))
		return true;
	return false;
}


bool WifiConfig::operator == (const WifiConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int WifiConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"ssid")) {
		if (value == 0) {
			clear_ssid();
			return 0;
		}
		m_ssid = value;
		int r = m_ssid.size();
		return r;
	}
	if (0 == strcmp(name,"pass")) {
		if (value == 0) {
			clear_pass();
			return 0;
		}
		m_pass = value;
		int r = m_pass.size();
		return r;
	}
	if (0 == strcmp(name,"mac")) {
		if (value == 0) {
			clear_mac();
			return 0;
		}
		int r = parse_ascii_bytes(m_mac,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"activate")) {
		int r = parse_ascii_bool(&m_activate,value);
		return r;
	}
	if (0 == strcmp(name,"addr4")) {
		if (value == 0) {
			clear_addr4();
			return 0;
		}
		int r = parse_ipv4(&m_addr4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"netmask4")) {
		if (value == 0) {
			clear_netmask4();
			return 0;
		}
		int r = parse_ascii_u8(&m_netmask4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"gateway4")) {
		if (value == 0) {
			clear_gateway4();
			return 0;
		}
		int r = parse_ipv4(&m_gateway4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	return -23;
}

MQTT::MQTT()
: m_uri("")
, m_enable(false)
, m_username("")
, m_password("")
, m_subscribtions()
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void MQTT::clear()
{
	m_uri = "";
	m_enable = false;
	m_username = "";
	m_password = "";
	m_subscribtions.clear();
}

void MQTT::toASCII(stream &o, size_t indent) const
{
	o << "MQTT {";
	++indent;
	ascii_indent(o,indent,"uri");
	ascii_string(o,m_uri.data(),m_uri.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"enable");
	o << (m_enable ? "true" : "false") << ';';
	ascii_indent(o,indent,"username");
	ascii_string(o,m_username.data(),m_username.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"password");
	ascii_string(o,m_password.data(),m_password.size(),indent+2);
	o << ';';
	ascii_indent(o,indent);
	size_t s_subscribtions = m_subscribtions.size();
	o << "subscribtions[" << s_subscribtions << "] = {";
	++indent;
	for (size_t i = 0, e = s_subscribtions; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,m_subscribtions[i].data(),m_subscribtions[i].size(),indent+2);
		o << ';';
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t MQTT::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -24;
		a += fn;
		switch (fid) {
		case 0xa:	// uri id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -25;
				m_uri.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x13:	// enable id 2, type bool, coding 8bit
			if (a >= e)
				return -26;
			set_enable(*a++);
			break;
		case 0x1a:	// username id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -27;
				m_username.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x22:	// password id 4, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -28;
				m_password.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x2a:	// subscribtions id 5, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -29;
				m_subscribtions.emplace_back((const char*)a,v);
				a += v;
			}
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -30;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -31;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t MQTT::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has uri?
	if (!m_uri.empty()) {
		// 'uri': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -32;
		*a++ = 0xa;
		ssize_t uri_s = m_uri.size();
		n = write_varint(a,e-a,uri_s);
		a += n;
		if ((n <= 0) || ((e-a) < uri_s))
			return -33;
		memcpy(a,m_uri.data(),uri_s);
		a += uri_s;
	}
	// has enable?
	if (m_enable != false) {
		// 'enable': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -34;
		*a++ = 0x13;
		*a++ = m_enable;
	}
	// has username?
	if (!m_username.empty()) {
		// 'username': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -35;
		*a++ = 0x1a;
		ssize_t username_s = m_username.size();
		n = write_varint(a,e-a,username_s);
		a += n;
		if ((n <= 0) || ((e-a) < username_s))
			return -36;
		memcpy(a,m_username.data(),username_s);
		a += username_s;
	}
	// has password?
	if (!m_password.empty()) {
		// 'password': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -37;
		*a++ = 0x22;
		ssize_t password_s = m_password.size();
		n = write_varint(a,e-a,password_s);
		a += n;
		if ((n <= 0) || ((e-a) < password_s))
			return -38;
		memcpy(a,m_password.data(),password_s);
		a += password_s;
	}
	for (const auto &x : m_subscribtions) {
		// 'subscribtions': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -39;
		*a++ = 0x2a;
		ssize_t subscribtions_s = x.size();
		n = write_varint(a,e-a,subscribtions_s);
		a += n;
		if ((n <= 0) || ((e-a) < subscribtions_s))
			return -40;
		memcpy(a,x.data(),subscribtions_s);
		a += subscribtions_s;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void MQTT::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_uri()) {
		fsep = json_indent(json,indLvl,fsep,"uri");
		json_cstr(json,m_uri.c_str());
	}
	if (has_enable()) {
		fsep = json_indent(json,indLvl,fsep,"enable");
		json << (m_enable ? "true" : "false");
	}
	if (has_username()) {
		fsep = json_indent(json,indLvl,fsep,"username");
		json_cstr(json,m_username.c_str());
	}
	if (has_password()) {
		fsep = json_indent(json,indLvl,fsep,"password");
		json_cstr(json,m_password.c_str());
	}
	if (size_t s = m_subscribtions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"subscribtions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_subscribtions[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t MQTT::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// string uri
	if (!m_uri.empty()) {
		size_t uri_s = m_uri.size();
		r += uri_s + wiresize(uri_s) + 1 /* tag(uri) 0x8 */;
	}
	// bool enable
	if (m_enable != false) {
		r += 2;
	}
	// string username
	if (!m_username.empty()) {
		size_t username_s = m_username.size();
		r += username_s + wiresize(username_s) + 1 /* tag(username) 0x18 */;
	}
	// string password
	if (!m_password.empty()) {
		size_t password_s = m_password.size();
		r += password_s + wiresize(password_s) + 1 /* tag(password) 0x20 */;
	}
	// string subscribtions
	if (!m_subscribtions.empty()) {
		// subscribtions: repeated estring
		for (size_t x = 0, y = m_subscribtions.size(); x < y; ++x) {
			size_t s = m_subscribtions[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(subscribtions) 0x28 */;
		}
	}
	return r;
}

bool MQTT::operator != (const MQTT &r) const
{
	if (has_uri() && (m_uri != r.m_uri))
		return true;
	if (has_enable() && (m_enable != r.m_enable))
		return true;
	if (has_username() && (m_username != r.m_username))
		return true;
	if (has_password() && (m_password != r.m_password))
		return true;
	if (m_subscribtions != r.m_subscribtions)
		return true;
	return false;
}


bool MQTT::operator == (const MQTT &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int MQTT::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"uri")) {
		if (value == 0) {
			clear_uri();
			return 0;
		}
		m_uri = value;
		int r = m_uri.size();
		return r;
	}
	if (0 == strcmp(name,"enable")) {
		if (value == 0) {
			clear_enable();
			return 0;
		}
		int r = parse_ascii_bool(&m_enable,value);
		return r;
	}
	if (0 == strcmp(name,"username")) {
		if (value == 0) {
			clear_username();
			return 0;
		}
		m_username = value;
		int r = m_username.size();
		return r;
	}
	if (0 == strcmp(name,"password")) {
		if (value == 0) {
			clear_password();
			return 0;
		}
		m_password = value;
		int r = m_password.size();
		return r;
	}
	if (0 == memcmp(name,"subscribtions",13)) {
		if ((name[13] == 0) && (value == 0)) {
			clear_subscribtions();
			return 0;
		} else if (name[13] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[14] == '+') && (name[15] == ']')) {
				x = m_subscribtions.size();
				m_subscribtions.resize(x+1);
				idxe = (char*)(name + 15);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+14,&idxe,0);
				if (idxe[0] != ']')
					return -41;
				if (m_subscribtions.size() <= x)
					return -42;
				if ((idxe[1] == 0) && (value == 0)) {
					m_subscribtions.erase(m_subscribtions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -43;
			m_subscribtions[x] = value;
			return m_subscribtions[x].size();
		}
	}
	return -44;
}

Date::Date()
: m_day(0)
, m_month(0)
, m_year(0)
, m_endday(0)
, m_endmonth(0)
, m_endyear(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void Date::clear()
{
	m_day = 0;
	m_month = 0;
	m_year = 0;
	m_endday = 0;
	m_endmonth = 0;
	m_endyear = 0;
}

void Date::toASCII(stream &o, size_t indent) const
{
	o << "Date {";
	++indent;
	ascii_numeric(o, indent, "day", (unsigned) m_day);
	ascii_numeric(o, indent, "month", (unsigned) m_month);
	ascii_numeric(o, indent, "year", m_year);
	ascii_numeric(o, indent, "endday", (unsigned) m_endday);
	ascii_numeric(o, indent, "endmonth", (unsigned) m_endmonth);
	ascii_numeric(o, indent, "endyear", (unsigned) m_endyear);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t Date::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -45;
		a += fn;
		switch (fid) {
		case 0xb:	// day id 1, type uint8_t, coding 8bit
			if (a >= e)
				return -46;
			set_day(*a++);
			break;
		case 0x13:	// month id 2, type uint8_t, coding 8bit
			if (a >= e)
				return -47;
			set_month(*a++);
			break;
		case 0x1c:	// year id 3, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -48;
			set_year((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x23:	// endday id 4, type uint8_t, coding 8bit
			if (a >= e)
				return -49;
			set_endday(*a++);
			break;
		case 0x2b:	// endmonth id 5, type uint8_t, coding 8bit
			if (a >= e)
				return -50;
			set_endmonth(*a++);
			break;
		case 0x33:	// endyear id 6, type uint8_t, coding 8bit
			if (a >= e)
				return -51;
			set_endyear(*a++);
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -52;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -53;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t Date::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	// has day?
	if (m_day != 0) {
		// 'day': id=1, encoding=8bit, tag=0xb
		if (2 > (e-a))
			return -54;
		*a++ = 0xb;
		*a++ = m_day;
	}
	// has month?
	if (m_month != 0) {
		// 'month': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -55;
		*a++ = 0x13;
		*a++ = m_month;
	}
	// has year?
	if (m_year != 0) {
		// 'year': id=3, encoding=16bit, tag=0x1c
		if (3 > (e-a))
			return -56;
		*a++ = 0x1c;
		write_u16(a,m_year);
		a += 2;
	}
	// has endday?
	if (m_endday != 0) {
		// 'endday': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -57;
		*a++ = 0x23;
		*a++ = m_endday;
	}
	// has endmonth?
	if (m_endmonth != 0) {
		// 'endmonth': id=5, encoding=8bit, tag=0x2b
		if (2 > (e-a))
			return -58;
		*a++ = 0x2b;
		*a++ = m_endmonth;
	}
	// has endyear?
	if (m_endyear != 0) {
		// 'endyear': id=6, encoding=8bit, tag=0x33
		if (2 > (e-a))
			return -59;
		*a++ = 0x33;
		*a++ = m_endyear;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void Date::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_day()) {
		fsep = json_indent(json,indLvl,fsep,"day");
		json << (unsigned) m_day;
	}
	if (has_month()) {
		fsep = json_indent(json,indLvl,fsep,"month");
		json << (unsigned) m_month;
	}
	if (has_year()) {
		fsep = json_indent(json,indLvl,fsep,"year");
		json << m_year;
	}
	if (has_endday()) {
		fsep = json_indent(json,indLvl,fsep,"endday");
		json << (unsigned) m_endday;
	}
	if (has_endmonth()) {
		fsep = json_indent(json,indLvl,fsep,"endmonth");
		json << (unsigned) m_endmonth;
	}
	if (has_endyear()) {
		fsep = json_indent(json,indLvl,fsep,"endyear");
		json << (unsigned) m_endyear;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t Date::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// fixed8 day
	if (m_day != 0) {
		r += 2;
	}
	// fixed8 month
	if (m_month != 0) {
		r += 2;
	}
	// fixed16 year
	if (m_year != 0) {
		r += 3;
	}
	// fixed8 endday
	if (m_endday != 0) {
		r += 2;
	}
	// fixed8 endmonth
	if (m_endmonth != 0) {
		r += 2;
	}
	// fixed8 endyear
	if (m_endyear != 0) {
		r += 2;
	}
	return r;
}

bool Date::operator != (const Date &r) const
{
	if (has_day() && (m_day != r.m_day))
		return true;
	if (has_month() && (m_month != r.m_month))
		return true;
	if (has_year() && (m_year != r.m_year))
		return true;
	if (has_endday() && (m_endday != r.m_endday))
		return true;
	if (has_endmonth() && (m_endmonth != r.m_endmonth))
		return true;
	if (has_endyear() && (m_endyear != r.m_endyear))
		return true;
	return false;
}


bool Date::operator == (const Date &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Date::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"day")) {
		if (value == 0) {
			clear_day();
			return 0;
		}
		int r = parse_ascii_u8(&m_day,value);
		return r;
	}
	if (0 == strcmp(name,"month")) {
		if (value == 0) {
			clear_month();
			return 0;
		}
		int r = parse_ascii_u8(&m_month,value);
		return r;
	}
	if (0 == strcmp(name,"year")) {
		if (value == 0) {
			clear_year();
			return 0;
		}
		int r = parse_ascii_u16(&m_year,value);
		return r;
	}
	if (0 == strcmp(name,"endday")) {
		if (value == 0) {
			clear_endday();
			return 0;
		}
		int r = parse_ascii_u8(&m_endday,value);
		return r;
	}
	if (0 == strcmp(name,"endmonth")) {
		if (value == 0) {
			clear_endmonth();
			return 0;
		}
		int r = parse_ascii_u8(&m_endmonth,value);
		return r;
	}
	if (0 == strcmp(name,"endyear")) {
		if (value == 0) {
			clear_endyear();
			return 0;
		}
		int r = parse_ascii_u8(&m_endyear,value);
		return r;
	}
	return -60;
}

AtAction::AtAction()
: m_day(Sunday)
, m_min_of_day(0)
, m_action()
, m_enable(true)
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void AtAction::clear()
{
	m_day = Sunday;
	m_min_of_day = 0;
	m_action.clear();
	m_enable = true;
	p_validbits = 0;
}

void AtAction::toASCII(stream &o, size_t indent) const
{
	o << "AtAction {";
	++indent;
	ascii_indent(o,indent,"day");
	if (const char *v = WeekDay_str(m_day))
		o << v;
	else
		o << m_day;
	o << ';';
	ascii_numeric(o, indent, "min_of_day", m_min_of_day);
	ascii_indent(o,indent,"action");
	ascii_string(o,m_action.data(),m_action.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"enable");
	o << (m_enable ? "true" : "false") << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t AtAction::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -61;
		a += fn;
		switch (fid) {
		case 0x8:	// day id 1, type WeekDay, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -62;
				a += n;
				set_day((WeekDay) v);
			}
			break;
		case 0x10:	// min_of_day id 2, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -63;
				a += n;
				set_min_of_day(v);
			}
			break;
		case 0x1a:	// action id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -64;
				m_action.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 2);
			break;
		case 0x23:	// enable id 4, type bool, coding 8bit
			if (a >= e)
				return -65;
			m_enable = *a++;
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -66;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -67;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t AtAction::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has day?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'day': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -68;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_day);
		if (n <= 0)
			return -69;
		a += n;
	}
	// has min_of_day?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'min_of_day': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -70;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_min_of_day);
		if (n <= 0)
			return -71;
		a += n;
	}
	// has action?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'action': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -72;
		*a++ = 0x1a;
		ssize_t action_s = m_action.size();
		n = write_varint(a,e-a,action_s);
		a += n;
		if ((n <= 0) || ((e-a) < action_s))
			return -73;
		memcpy(a,m_action.data(),action_s);
		a += action_s;
	}
	// 'enable': id=4, encoding=8bit, tag=0x23
	if (2 > (e-a))
		return -74;
	*a++ = 0x23;
	*a++ = m_enable;
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void AtAction::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_day()) {
		fsep = json_indent(json,indLvl,fsep,"day");
		if (const char *v = WeekDay_str(m_day)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_day;
		}
	}
	if (has_min_of_day()) {
		fsep = json_indent(json,indLvl,fsep,"min_of_day");
		json.put('"');
		min_of_day_to_ascii(json,m_min_of_day);
		json.put('"');
	}
	if (has_action()) {
		fsep = json_indent(json,indLvl,fsep,"action");
		json_cstr(json,m_action.c_str());
	}
	fsep = json_indent(json,indLvl,fsep,"enable");
	json << (m_enable ? "true" : "false");
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t AtAction::calcSize() const
{
	// bool enable: tagsize 1, data size 1
	size_t r = 2;	// required size, default is fixed length
	// WeekDay day
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_day) + 1 /* tag(day) 0x8 */;
	}
	// unsigned min_of_day
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_min_of_day) + 1 /* tag(min_of_day) 0x10 */;
	}
	// string action
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		size_t action_s = m_action.size();
		r += action_s + wiresize(action_s) + 1 /* tag(action) 0x18 */;
	}
	return r;
}

bool AtAction::operator != (const AtAction &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_day() && (m_day != r.m_day))
		return true;
	if (has_min_of_day() && (m_min_of_day != r.m_min_of_day))
		return true;
	if (has_action() && (m_action != r.m_action))
		return true;
	if (m_enable != r.m_enable)
		return true;
	return false;
}


bool AtAction::operator == (const AtAction &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AtAction::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"day")) {
		if (value == 0) {
			clear_day();
			return 0;
		}
		WeekDay v;
		size_t r = parse_ascii_WeekDay(&v,value);
		if (r == 0)
			return -75;
		set_day(v);
		return r;
	}
	if (0 == strcmp(name,"min_of_day")) {
		if (value == 0) {
			clear_min_of_day();
			return 0;
		}
		int r = parse_ascii_u32(&m_min_of_day,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"action")) {
		if (value == 0) {
			clear_action();
			return 0;
		}
		m_action = value;
		int r = m_action.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"enable")) {
		int r = parse_ascii_bool(&m_enable,value);
		return r;
	}
	return -76;
}

Influx::Influx()
: m_hostname("")
, m_port(0)
, m_measurement("")
// omitted obsolete member interval
, m_database("")
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void Influx::clear()
{
	m_hostname = "";
	m_port = 0;
	m_measurement = "";
	m_database = "";
}

void Influx::toASCII(stream &o, size_t indent) const
{
	o << "Influx {";
	++indent;
	ascii_indent(o,indent,"hostname");
	ascii_string(o,m_hostname.data(),m_hostname.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "port", m_port);
	ascii_indent(o,indent,"measurement");
	ascii_string(o,m_measurement.data(),m_measurement.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"database");
	ascii_string(o,m_database.data(),m_database.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t Influx::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -77;
		a += fn;
		switch (fid) {
		case 0xa:	// hostname id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -78;
				m_hostname.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x14:	// port id 2, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -79;
			set_port((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x1a:	// measurement id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -80;
				m_measurement.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x2a:	// database id 5, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -81;
				m_database.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -82;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -83;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t Influx::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has hostname?
	if (!m_hostname.empty()) {
		// 'hostname': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -84;
		*a++ = 0xa;
		ssize_t hostname_s = m_hostname.size();
		n = write_varint(a,e-a,hostname_s);
		a += n;
		if ((n <= 0) || ((e-a) < hostname_s))
			return -85;
		memcpy(a,m_hostname.data(),hostname_s);
		a += hostname_s;
	}
	// has port?
	if (m_port != 0) {
		// 'port': id=2, encoding=16bit, tag=0x14
		if (3 > (e-a))
			return -86;
		*a++ = 0x14;
		write_u16(a,m_port);
		a += 2;
	}
	// has measurement?
	if (!m_measurement.empty()) {
		// 'measurement': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -87;
		*a++ = 0x1a;
		ssize_t measurement_s = m_measurement.size();
		n = write_varint(a,e-a,measurement_s);
		a += n;
		if ((n <= 0) || ((e-a) < measurement_s))
			return -88;
		memcpy(a,m_measurement.data(),measurement_s);
		a += measurement_s;
	}
	// 'interval' is obsolete. Therefore no data will be written.
	// has database?
	if (!m_database.empty()) {
		// 'database': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -89;
		*a++ = 0x2a;
		ssize_t database_s = m_database.size();
		n = write_varint(a,e-a,database_s);
		a += n;
		if ((n <= 0) || ((e-a) < database_s))
			return -90;
		memcpy(a,m_database.data(),database_s);
		a += database_s;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void Influx::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_hostname()) {
		fsep = json_indent(json,indLvl,fsep,"hostname");
		json_cstr(json,m_hostname.c_str());
	}
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << m_port;
	}
	if (has_measurement()) {
		fsep = json_indent(json,indLvl,fsep,"measurement");
		json_cstr(json,m_measurement.c_str());
	}
	if (has_database()) {
		fsep = json_indent(json,indLvl,fsep,"database");
		json_cstr(json,m_database.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t Influx::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// string hostname
	if (!m_hostname.empty()) {
		size_t hostname_s = m_hostname.size();
		r += hostname_s + wiresize(hostname_s) + 1 /* tag(hostname) 0x8 */;
	}
	// fixed16 port
	if (m_port != 0) {
		r += 3;
	}
	// string measurement
	if (!m_measurement.empty()) {
		size_t measurement_s = m_measurement.size();
		r += measurement_s + wiresize(measurement_s) + 1 /* tag(measurement) 0x18 */;
	}
	// obsolete unsigned interval
	// string database
	if (!m_database.empty()) {
		size_t database_s = m_database.size();
		r += database_s + wiresize(database_s) + 1 /* tag(database) 0x28 */;
	}
	return r;
}

bool Influx::operator != (const Influx &r) const
{
	if (has_hostname() && (m_hostname != r.m_hostname))
		return true;
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_measurement() && (m_measurement != r.m_measurement))
		return true;
	if (has_database() && (m_database != r.m_database))
		return true;
	return false;
}


bool Influx::operator == (const Influx &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Influx::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"hostname")) {
		if (value == 0) {
			clear_hostname();
			return 0;
		}
		m_hostname = value;
		int r = m_hostname.size();
		return r;
	}
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_port,value);
		return r;
	}
	if (0 == strcmp(name,"measurement")) {
		if (value == 0) {
			clear_measurement();
			return 0;
		}
		m_measurement = value;
		int r = m_measurement.size();
		return r;
	}
	if (0 == strcmp(name,"database")) {
		if (value == 0) {
			clear_database();
			return 0;
		}
		m_database = value;
		int r = m_database.size();
		return r;
	}
	return -91;
}

UartSettings::UartSettings()
: m_port(0)
, m_baudrate(0)
, m_config(0)
, m_rx_thresh(0)
, m_tx_bufsize(0)
, m_rx_bufsize(0)
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void UartSettings::clear()
{
	m_port = 0;
	m_baudrate = 0;
	m_config = 0;
	m_rx_thresh = 0;
	m_tx_bufsize = 0;
	m_rx_bufsize = 0;
	p_validbits = 0;
}

void UartSettings::toASCII(stream &o, size_t indent) const
{
	o << "UartSettings {";
	++indent;
	ascii_numeric(o, indent, "port", (unsigned) m_port);
	ascii_numeric(o, indent, "baudrate", m_baudrate);
	ascii_indent(o,indent,"config");
	ascii_numeric(o, indent, "config", m_config);
	++indent;
	ascii_indent(o,indent);
	o << "wl = " ;
	o << uart_wl_t_str(config_wl());
	o << ';';
	ascii_indent(o,indent);
	o << "sb = " ;
	o << uart_sb_t_str(config_sb());
	o << ';';
	ascii_indent(o,indent);
	o << "rts = " ;
	o << (config_rts() ? "true" : "false");
	o << ';';
	ascii_indent(o,indent);
	o << "cts = " ;
	o << (config_cts() ? "true" : "false");
	o << ';';
	ascii_indent(o,indent);
	o << "p = " ;
	o << uart_p_t_str(config_p());
	o << ';';
	ascii_indent(o,indent);
	o << "ref_tick = " ;
	o << (config_ref_tick() ? "true" : "false");
	o << ';';
	--indent;
	ascii_numeric(o, indent, "rx_thresh", (unsigned) m_rx_thresh);
	ascii_numeric(o, indent, "tx_bufsize", m_tx_bufsize);
	ascii_numeric(o, indent, "rx_bufsize", m_rx_bufsize);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t UartSettings::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -92;
		a += fn;
		switch (fid) {
		case 0x8:	// port id 1, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -93;
				a += n;
				set_port(v);
			}
			break;
		case 0x10:	// baudrate id 2, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -94;
				a += n;
				set_baudrate(v);
			}
			break;
		case 0x1c:	// config id 3, type uartcfg_t, coding 16bit
			if ((a+1) >= e)
				return -95;
			set_config((uartcfg_t) (uartcfg_t) read_u16(a));
			a += 2;
			break;
		case 0x23:	// rx_thresh id 4, type uint8_t, coding 8bit
			if (a >= e)
				return -96;
			set_rx_thresh(*a++);
			break;
		case 0x30:	// tx_bufsize id 6, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -97;
				a += n;
				set_tx_bufsize(v);
			}
			break;
		case 0x38:	// rx_bufsize id 7, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -98;
				a += n;
				set_rx_bufsize(v);
			}
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -99;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -100;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t UartSettings::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -101;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_port);
		if (n <= 0)
			return -102;
		a += n;
	}
	// has baudrate?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'baudrate': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -103;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_baudrate);
		if (n <= 0)
			return -104;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'config': id=3, encoding=16bit, tag=0x1c
		if (a >= e)
			return -105;
		*a++ = 0x1c;
		write_u16(a,m_config);
		a += 2;
	}
	// has rx_thresh?
	if (m_rx_thresh != 0) {
		// 'rx_thresh': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -106;
		*a++ = 0x23;
		*a++ = m_rx_thresh;
	}
	// has tx_bufsize?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'tx_bufsize': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -107;
		*a++ = 0x30;
		n = write_varint(a,e-a,m_tx_bufsize);
		if (n <= 0)
			return -108;
		a += n;
	}
	// has rx_bufsize?
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'rx_bufsize': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -109;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_rx_bufsize);
		if (n <= 0)
			return -110;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void UartSettings::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << (unsigned) m_port;
	}
	if (has_baudrate()) {
		fsep = json_indent(json,indLvl,fsep,"baudrate");
		json << m_baudrate;
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (has_rx_thresh()) {
		fsep = json_indent(json,indLvl,fsep,"rx_thresh");
		json << (unsigned) m_rx_thresh;
	}
	if (has_tx_bufsize()) {
		fsep = json_indent(json,indLvl,fsep,"tx_bufsize");
		json << m_tx_bufsize;
	}
	if (has_rx_bufsize()) {
		fsep = json_indent(json,indLvl,fsep,"rx_bufsize");
		json << m_rx_bufsize;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t UartSettings::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// uint8 port
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// unsigned baudrate
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_baudrate) + 1 /* tag(baudrate) 0x10 */;
	}
	// uartcfg_t config
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	// fixed8 rx_thresh
	if (m_rx_thresh != 0) {
		r += 2;
	}
	// unsigned tx_bufsize
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		r += wiresize((varint_t)m_tx_bufsize) + 1 /* tag(tx_bufsize) 0x30 */;
	}
	// unsigned rx_bufsize
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		r += wiresize((varint_t)m_rx_bufsize) + 1 /* tag(rx_bufsize) 0x38 */;
	}
	return r;
}

bool UartSettings::operator != (const UartSettings &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_baudrate() && (m_baudrate != r.m_baudrate))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	if (has_rx_thresh() && (m_rx_thresh != r.m_rx_thresh))
		return true;
	if (has_tx_bufsize() && (m_tx_bufsize != r.m_tx_bufsize))
		return true;
	if (has_rx_bufsize() && (m_rx_bufsize != r.m_rx_bufsize))
		return true;
	return false;
}


bool UartSettings::operator == (const UartSettings &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int UartSettings::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u8(&m_port,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"baudrate")) {
		if (value == 0) {
			clear_baudrate();
			return 0;
		}
		int r = parse_ascii_u32(&m_baudrate,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((uartcfg_t)ull);
			else if (!strcmp(name,"wl"))
				set_config_wl((uart_wl_t)ull);
			else if (!strcmp(name,"sb"))
				set_config_sb((uart_sb_t)ull);
			else if (!strcmp(name,"rts"))
				set_config_rts((bool)ull);
			else if (!strcmp(name,"cts"))
				set_config_cts((bool)ull);
			else if (!strcmp(name,"p"))
				set_config_p((uart_p_t)ull);
			else if (!strcmp(name,"ref_tick"))
				set_config_ref_tick((bool)ull);
			return eptr - value;
		} else {
			return -111;
		}
	}
	if (0 == strcmp(name,"rx_thresh")) {
		if (value == 0) {
			clear_rx_thresh();
			return 0;
		}
		int r = parse_ascii_u8(&m_rx_thresh,value);
		return r;
	}
	if (0 == strcmp(name,"tx_bufsize")) {
		if (value == 0) {
			clear_tx_bufsize();
			return 0;
		}
		int r = parse_ascii_u32(&m_tx_bufsize,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	if (0 == strcmp(name,"rx_bufsize")) {
		if (value == 0) {
			clear_rx_bufsize();
			return 0;
		}
		int r = parse_ascii_u32(&m_rx_bufsize,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 4);
		return r;
	}
	return -112;
}

FtpHttpConfig::FtpHttpConfig()
: m_port(80)
, m_start(true)
, m_root("")
, m_uploaddir("")
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void FtpHttpConfig::clear()
{
	m_port = 80;
	m_start = true;
	m_root = "";
	m_uploaddir = "";
	p_validbits = 0;
}

void FtpHttpConfig::toASCII(stream &o, size_t indent) const
{
	o << "FtpHttpConfig {";
	++indent;
	ascii_numeric(o, indent, "port", m_port);
	ascii_indent(o,indent,"start");
	o << (m_start ? "true" : "false") << ';';
	ascii_indent(o,indent,"root");
	ascii_string(o,m_root.data(),m_root.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"uploaddir");
	ascii_string(o,m_uploaddir.data(),m_uploaddir.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t FtpHttpConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -113;
		a += fn;
		switch (fid) {
		case 0xc:	// port id 1, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -114;
			set_port((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x13:	// start id 2, type bool, coding 8bit
			if (a >= e)
				return -115;
			set_start(*a++);
			break;
		case 0x1a:	// root id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -116;
				m_root.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x22:	// uploaddir id 4, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -117;
				m_uploaddir.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -118;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -119;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t FtpHttpConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=16bit, tag=0xc
		if (3 > (e-a))
			return -120;
		*a++ = 0xc;
		write_u16(a,m_port);
		a += 2;
	}
	// has start?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'start': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -121;
		*a++ = 0x13;
		*a++ = m_start;
	}
	// has root?
	if (!m_root.empty()) {
		// 'root': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -122;
		*a++ = 0x1a;
		ssize_t root_s = m_root.size();
		n = write_varint(a,e-a,root_s);
		a += n;
		if ((n <= 0) || ((e-a) < root_s))
			return -123;
		memcpy(a,m_root.data(),root_s);
		a += root_s;
	}
	// has uploaddir?
	if (!m_uploaddir.empty()) {
		// 'uploaddir': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -124;
		*a++ = 0x22;
		ssize_t uploaddir_s = m_uploaddir.size();
		n = write_varint(a,e-a,uploaddir_s);
		a += n;
		if ((n <= 0) || ((e-a) < uploaddir_s))
			return -125;
		memcpy(a,m_uploaddir.data(),uploaddir_s);
		a += uploaddir_s;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void FtpHttpConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << m_port;
	}
	if (has_start()) {
		fsep = json_indent(json,indLvl,fsep,"start");
		json << (m_start ? "true" : "false");
	}
	if (has_root()) {
		fsep = json_indent(json,indLvl,fsep,"root");
		json_cstr(json,m_root.c_str());
	}
	if (has_uploaddir()) {
		fsep = json_indent(json,indLvl,fsep,"uploaddir");
		json_cstr(json,m_uploaddir.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t FtpHttpConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// fixed16 port
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += 3;
	}
	// bool start
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += 2;
	}
	// string root
	if (!m_root.empty()) {
		size_t root_s = m_root.size();
		r += root_s + wiresize(root_s) + 1 /* tag(root) 0x18 */;
	}
	// string uploaddir
	if (!m_uploaddir.empty()) {
		size_t uploaddir_s = m_uploaddir.size();
		r += uploaddir_s + wiresize(uploaddir_s) + 1 /* tag(uploaddir) 0x20 */;
	}
	return r;
}

bool FtpHttpConfig::operator != (const FtpHttpConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_start() && (m_start != r.m_start))
		return true;
	if (has_root() && (m_root != r.m_root))
		return true;
	if (has_uploaddir() && (m_uploaddir != r.m_uploaddir))
		return true;
	return false;
}


bool FtpHttpConfig::operator == (const FtpHttpConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int FtpHttpConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_port,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"start")) {
		if (value == 0) {
			clear_start();
			return 0;
		}
		int r = parse_ascii_bool(&m_start,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"root")) {
		if (value == 0) {
			clear_root();
			return 0;
		}
		m_root = value;
		int r = m_root.size();
		return r;
	}
	if (0 == strcmp(name,"uploaddir")) {
		if (value == 0) {
			clear_uploaddir();
			return 0;
		}
		m_uploaddir = value;
		int r = m_uploaddir.size();
		return r;
	}
	return -126;
}

TerminalConfig::TerminalConfig()
: m_uart_rx(-1)
, m_uart_tx(-1)
, m_name()
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void TerminalConfig::clear()
{
	m_uart_rx = -1;
	m_uart_tx = -1;
	m_name.clear();
	p_validbits = 0;
}

void TerminalConfig::toASCII(stream &o, size_t indent) const
{
	o << "TerminalConfig {";
	++indent;
	ascii_numeric(o, indent, "uart_rx", (signed) m_uart_rx);
	ascii_numeric(o, indent, "uart_tx", (signed) m_uart_tx);
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t TerminalConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -127;
		a += fn;
		switch (fid) {
		case 0x8:	// uart_rx id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -128;
				a += n;
				set_uart_rx(varint_sint(v));
			}
			break;
		case 0x10:	// uart_tx id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -129;
				a += n;
				set_uart_tx(varint_sint(v));
			}
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -130;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -131;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -132;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t TerminalConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has uart_rx?
	if (m_uart_rx != -1) {
		// 'uart_rx': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -133;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_uart_rx));
		if (n <= 0)
			return -134;
		a += n;
	}
	// has uart_tx?
	if (m_uart_tx != -1) {
		// 'uart_tx': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -135;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_uart_tx));
		if (n <= 0)
			return -136;
		a += n;
	}
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -137;
		*a++ = 0x1a;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -138;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void TerminalConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_uart_rx()) {
		fsep = json_indent(json,indLvl,fsep,"uart_rx");
		json << (int) m_uart_rx;
	}
	if (has_uart_tx()) {
		fsep = json_indent(json,indLvl,fsep,"uart_tx");
		json << (int) m_uart_tx;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t TerminalConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// sint8 uart_rx
	if (m_uart_rx != -1) {
		r += wiresize_s((varint_t)m_uart_rx) + 1 /* tag(uart_rx) 0x8 */;
	}
	// sint8 uart_tx
	if (m_uart_tx != -1) {
		r += wiresize_s((varint_t)m_uart_tx) + 1 /* tag(uart_tx) 0x10 */;
	}
	// string name
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	return r;
}

bool TerminalConfig::operator != (const TerminalConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_uart_rx() && (m_uart_rx != r.m_uart_rx))
		return true;
	if (has_uart_tx() && (m_uart_tx != r.m_uart_tx))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	return false;
}


bool TerminalConfig::operator == (const TerminalConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TerminalConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"uart_rx")) {
		if (value == 0) {
			clear_uart_rx();
			return 0;
		}
		int r = parse_ascii_s8(&m_uart_rx,value);
		return r;
	}
	if (0 == strcmp(name,"uart_tx")) {
		if (value == 0) {
			clear_uart_tx();
			return 0;
		}
		int r = parse_ascii_s8(&m_uart_tx,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	return -139;
}

Trigger::Trigger()
: m_event()
, m_action()
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void Trigger::clear()
{
	m_event.clear();
	m_action.clear();
	p_validbits = 0;
}

void Trigger::toASCII(stream &o, size_t indent) const
{
	o << "Trigger {";
	++indent;
	ascii_indent(o,indent,"event");
	ascii_string(o,m_event.data(),m_event.size(),indent+2);
	o << ';';
	ascii_indent(o,indent);
	size_t s_action = m_action.size();
	o << "action[" << s_action << "] = {";
	++indent;
	for (size_t i = 0, e = s_action; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,m_action[i].data(),m_action[i].size(),indent+2);
		o << ';';
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t Trigger::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -140;
		a += fn;
		switch (fid) {
		case 0xa:	// event id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -141;
				m_event.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x12:	// action id 2, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -142;
				m_action.emplace_back((const char*)a,v);
				a += v;
			}
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -143;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -144;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t Trigger::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has event?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'event': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -145;
		*a++ = 0xa;
		ssize_t event_s = m_event.size();
		n = write_varint(a,e-a,event_s);
		a += n;
		if ((n <= 0) || ((e-a) < event_s))
			return -146;
		memcpy(a,m_event.data(),event_s);
		a += event_s;
	}
	for (const auto &x : m_action) {
		// 'action': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -147;
		*a++ = 0x12;
		ssize_t action_s = x.size();
		n = write_varint(a,e-a,action_s);
		a += n;
		if ((n <= 0) || ((e-a) < action_s))
			return -148;
		memcpy(a,x.data(),action_s);
		a += action_s;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void Trigger::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_event()) {
		fsep = json_indent(json,indLvl,fsep,"event");
		json_cstr(json,m_event.c_str());
	}
	if (size_t s = m_action.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"action\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_action[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t Trigger::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// string event
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t event_s = m_event.size();
		r += event_s + wiresize(event_s) + 1 /* tag(event) 0x8 */;
	}
	// string action
	if (!m_action.empty()) {
		// action: repeated estring
		for (size_t x = 0, y = m_action.size(); x < y; ++x) {
			size_t s = m_action[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(action) 0x10 */;
		}
	}
	return r;
}

bool Trigger::operator != (const Trigger &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_event() && (m_event != r.m_event))
		return true;
	if (m_action != r.m_action)
		return true;
	return false;
}


bool Trigger::operator == (const Trigger &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Trigger::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"event")) {
		if (value == 0) {
			clear_event();
			return 0;
		}
		m_event = value;
		int r = m_event.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == memcmp(name,"action",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_action();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_action.size();
				m_action.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -149;
				if (m_action.size() <= x)
					return -150;
				if ((idxe[1] == 0) && (value == 0)) {
					m_action.erase(m_action.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -151;
			m_action[x] = value;
			return m_action[x].size();
		}
	}
	return -152;
}

AppParam::AppParam()
: m_key()
, m_uValue(0)
, m_sValue()
, m_dValue(0)
, m_fValue(0)
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void AppParam::clear()
{
	m_key.clear();
	m_uValue = 0;
	m_sValue.clear();
	m_dValue = 0;
	m_fValue = 0;
	p_validbits = 0;
}

void AppParam::toASCII(stream &o, size_t indent) const
{
	o << "AppParam {";
	++indent;
	ascii_indent(o,indent,"key");
	ascii_string(o,m_key.data(),m_key.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "uValue", m_uValue);
	ascii_indent(o,indent,"sValue");
	ascii_string(o,m_sValue.data(),m_sValue.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "dValue", m_dValue);
	ascii_indent(o,indent,"fValue");
	ascii_numeric(o, indent, "fValue", m_fValue);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t AppParam::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -153;
		a += fn;
		switch (fid) {
		case 0xa:	// key id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -154;
				m_key.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x10:	// uValue id 2, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -155;
				a += n;
				set_uValue(v);
			}
			break;
		case 0x1a:	// sValue id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -156;
				m_sValue.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 2);
			break;
		case 0x20:	// dValue id 4, type int32_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -157;
				a += n;
				set_dValue(varint_sint(v));
			}
			break;
		case 0x29:	// fValue id 5, type double, coding 64bit
			if ((a+7) >= e)
				return -158;
			set_fValue(read_double(a));
			a += 8;
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -159;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -160;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t AppParam::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has key?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'key': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -161;
		*a++ = 0xa;
		ssize_t key_s = m_key.size();
		n = write_varint(a,e-a,key_s);
		a += n;
		if ((n <= 0) || ((e-a) < key_s))
			return -162;
		memcpy(a,m_key.data(),key_s);
		a += key_s;
	}
	// has uValue?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'uValue': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -163;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_uValue);
		if (n <= 0)
			return -164;
		a += n;
	}
	// has sValue?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'sValue': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -165;
		*a++ = 0x1a;
		ssize_t sValue_s = m_sValue.size();
		n = write_varint(a,e-a,sValue_s);
		a += n;
		if ((n <= 0) || ((e-a) < sValue_s))
			return -166;
		memcpy(a,m_sValue.data(),sValue_s);
		a += sValue_s;
	}
	// has dValue?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'dValue': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -167;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_dValue));
		if (n <= 0)
			return -168;
		a += n;
	}
	// has fValue?
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'fValue': id=5, encoding=64bit, tag=0x29
		if (9 > (e-a))
			return -169;
		*a++ = 0x29;
		write_u64(a,mangle_double(m_fValue));
		a += 8;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void AppParam::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_key()) {
		fsep = json_indent(json,indLvl,fsep,"key");
		json_cstr(json,m_key.c_str());
	}
	if (has_uValue()) {
		fsep = json_indent(json,indLvl,fsep,"uValue");
		json << m_uValue;
	}
	if (has_sValue()) {
		fsep = json_indent(json,indLvl,fsep,"sValue");
		json_cstr(json,m_sValue.c_str());
	}
	if (has_dValue()) {
		fsep = json_indent(json,indLvl,fsep,"dValue");
		json << m_dValue;
	}
	if (has_fValue()) {
		fsep = json_indent(json,indLvl,fsep,"fValue");
		to_dblstr(json,m_fValue);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t AppParam::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// string key
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t key_s = m_key.size();
		r += key_s + wiresize(key_s) + 1 /* tag(key) 0x8 */;
	}
	// unsigned uValue
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_uValue) + 1 /* tag(uValue) 0x10 */;
	}
	// string sValue
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		size_t sValue_s = m_sValue.size();
		r += sValue_s + wiresize(sValue_s) + 1 /* tag(sValue) 0x18 */;
	}
	// signed dValue
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		r += wiresize_s((varint_t)m_dValue) + 1 /* tag(dValue) 0x20 */;
	}
	// double fValue
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		r += 9;
	}
	return r;
}

bool AppParam::operator != (const AppParam &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_key() && (m_key != r.m_key))
		return true;
	if (has_uValue() && (m_uValue != r.m_uValue))
		return true;
	if (has_sValue() && (m_sValue != r.m_sValue))
		return true;
	if (has_dValue() && (m_dValue != r.m_dValue))
		return true;
	if (has_fValue() && (m_fValue != r.m_fValue))
		return true;
	return false;
}


bool AppParam::operator == (const AppParam &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AppParam::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"key")) {
		if (value == 0) {
			clear_key();
			return 0;
		}
		m_key = value;
		int r = m_key.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"uValue")) {
		if (value == 0) {
			clear_uValue();
			return 0;
		}
		int r = parse_ascii_u32(&m_uValue,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"sValue")) {
		if (value == 0) {
			clear_sValue();
			return 0;
		}
		m_sValue = value;
		int r = m_sValue.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"dValue")) {
		if (value == 0) {
			clear_dValue();
			return 0;
		}
		int r = parse_ascii_s32(&m_dValue,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	if (0 == strcmp(name,"fValue")) {
		if (value == 0) {
			clear_fValue();
			return 0;
		}
		int r = parse_ascii_dbl(&m_fValue,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 4);
		return r;
	}
	return -170;
}

EventTimer::EventTimer()
: m_name("")
, m_time(0)
, m_config(0)
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void EventTimer::clear()
{
	m_name = "";
	m_time = 0;
	m_config = 0;
	p_validbits = 0;
}

void EventTimer::toASCII(stream &o, size_t indent) const
{
	o << "EventTimer {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "time", m_time);
	ascii_numeric(o, indent, "config", m_config);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t EventTimer::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -171;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -172;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// time id 2, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -173;
				a += n;
				set_time(v);
			}
			break;
		case 0x18:	// config id 3, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -174;
				a += n;
				set_config(v);
			}
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -175;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -176;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t EventTimer::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -177;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -178;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has time?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'time': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -179;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_time);
		if (n <= 0)
			return -180;
		a += n;
	}
	// has config?
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -181;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -182;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void EventTimer::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_time()) {
		fsep = json_indent(json,indLvl,fsep,"time");
		json << m_time;
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t EventTimer::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// string name
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// unsigned time
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_time) + 1 /* tag(time) 0x10 */;
	}
	// unsigned config
	if (m_config != 0) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	return r;
}

bool EventTimer::operator != (const EventTimer &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_time() && (m_time != r.m_time))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	return false;
}


bool EventTimer::operator == (const EventTimer &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int EventTimer::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"time")) {
		if (value == 0) {
			clear_time();
			return 0;
		}
		int r = parse_ascii_u32(&m_time,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"config")) {
		if (value == 0) {
			clear_config();
			return 0;
		}
		int r = parse_ascii_u32(&m_config,value);
		return r;
	}
	return -183;
}

FunctionConfig::FunctionConfig()
: m_name()
, m_func()
, m_params()
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void FunctionConfig::clear()
{
	m_name.clear();
	m_func.clear();
	m_params.clear();
	p_validbits = 0;
}

void FunctionConfig::toASCII(stream &o, size_t indent) const
{
	o << "FunctionConfig {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"func");
	ascii_string(o,m_func.data(),m_func.size(),indent+2);
	o << ';';
	ascii_indent(o,indent);
	size_t s_params = m_params.size();
	o << "params[" << s_params << "] = {";
	++indent;
	for (size_t i = 0, e = s_params; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,m_params[i].data(),m_params[i].size(),indent+2);
		o << ';';
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t FunctionConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -184;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -185;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x12:	// func id 2, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -186;
				m_func.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 1);
			break;
		case 0x1a:	// params id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -187;
				m_params.emplace_back((const char*)a,v);
				a += v;
			}
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -188;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -189;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t FunctionConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -190;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -191;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has func?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'func': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -192;
		*a++ = 0x12;
		ssize_t func_s = m_func.size();
		n = write_varint(a,e-a,func_s);
		a += n;
		if ((n <= 0) || ((e-a) < func_s))
			return -193;
		memcpy(a,m_func.data(),func_s);
		a += func_s;
	}
	for (const auto &x : m_params) {
		// 'params': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -194;
		*a++ = 0x1a;
		ssize_t params_s = x.size();
		n = write_varint(a,e-a,params_s);
		a += n;
		if ((n <= 0) || ((e-a) < params_s))
			return -195;
		memcpy(a,x.data(),params_s);
		a += params_s;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void FunctionConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_func()) {
		fsep = json_indent(json,indLvl,fsep,"func");
		json_cstr(json,m_func.c_str());
	}
	if (size_t s = m_params.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"params\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_params[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t FunctionConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// string name
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// string func
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		size_t func_s = m_func.size();
		r += func_s + wiresize(func_s) + 1 /* tag(func) 0x10 */;
	}
	// string params
	if (!m_params.empty()) {
		// params: repeated estring
		for (size_t x = 0, y = m_params.size(); x < y; ++x) {
			size_t s = m_params[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(params) 0x18 */;
		}
	}
	return r;
}

bool FunctionConfig::operator != (const FunctionConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_func() && (m_func != r.m_func))
		return true;
	if (m_params != r.m_params)
		return true;
	return false;
}


bool FunctionConfig::operator == (const FunctionConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int FunctionConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"func")) {
		if (value == 0) {
			clear_func();
			return 0;
		}
		m_func = value;
		int r = m_func.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == memcmp(name,"params",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_params();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_params.size();
				m_params.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -196;
				if (m_params.size() <= x)
					return -197;
				if ((idxe[1] == 0) && (value == 0)) {
					m_params.erase(m_params.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -198;
			m_params[x] = value;
			return m_params[x].size();
		}
	}
	return -199;
}

SignalConfig::SignalConfig()
: m_name("")
, m_type(st_invalid)
, m_iv("")
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void SignalConfig::clear()
{
	m_name = "";
	m_type = st_invalid;
	m_iv = "";
}

void SignalConfig::toASCII(stream &o, size_t indent) const
{
	o << "SignalConfig {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"type");
	if (const char *v = sigtype_t_str(m_type))
		o << v;
	else
		o << m_type;
	o << ';';
	ascii_indent(o,indent,"iv");
	ascii_string(o,m_iv.data(),m_iv.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t SignalConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -200;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -201;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// type id 2, type sigtype_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -202;
				a += n;
				set_type((sigtype_t) v);
			}
			break;
		case 0x1a:	// iv id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -203;
				m_iv.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -204;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -205;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t SignalConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -206;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -207;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has type?
	if (m_type != st_invalid) {
		// 'type': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -208;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_type);
		if (n <= 0)
			return -209;
		a += n;
	}
	// has iv?
	if (!m_iv.empty()) {
		// 'iv': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -210;
		*a++ = 0x1a;
		ssize_t iv_s = m_iv.size();
		n = write_varint(a,e-a,iv_s);
		a += n;
		if ((n <= 0) || ((e-a) < iv_s))
			return -211;
		memcpy(a,m_iv.data(),iv_s);
		a += iv_s;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void SignalConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_type()) {
		fsep = json_indent(json,indLvl,fsep,"type");
		if (const char *v = sigtype_t_str(m_type)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_type;
		}
	}
	if (has_iv()) {
		fsep = json_indent(json,indLvl,fsep,"iv");
		json_cstr(json,m_iv.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t SignalConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// string name
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// sigtype_t type
	if (m_type != st_invalid) {
		r += wiresize((varint_t)m_type) + 1 /* tag(type) 0x10 */;
	}
	// string iv
	if (!m_iv.empty()) {
		size_t iv_s = m_iv.size();
		r += iv_s + wiresize(iv_s) + 1 /* tag(iv) 0x18 */;
	}
	return r;
}

bool SignalConfig::operator != (const SignalConfig &r) const
{
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_type() && (m_type != r.m_type))
		return true;
	if (has_iv() && (m_iv != r.m_iv))
		return true;
	return false;
}


bool SignalConfig::operator == (const SignalConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SignalConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"type")) {
		if (value == 0) {
			clear_type();
			return 0;
		}
		sigtype_t v;
		size_t r = parse_ascii_sigtype_t(&v,value);
		if (r == 0)
			return -212;
		set_type(v);
		return r;
	}
	if (0 == strcmp(name,"iv")) {
		if (value == 0) {
			clear_iv();
			return 0;
		}
		m_iv = value;
		int r = m_iv.size();
		return r;
	}
	return -213;
}

OwDeviceConfig::OwDeviceConfig()
: m_id(0)
, m_name()
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void OwDeviceConfig::clear()
{
	m_id = 0;
	m_name.clear();
	p_validbits = 0;
}

void OwDeviceConfig::toASCII(stream &o, size_t indent) const
{
	o << "OwDeviceConfig {";
	++indent;
	ascii_indent(o,indent,"id");
	id64_to_ascii(o,m_id);
	o << ';';
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t OwDeviceConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -214;
		a += fn;
		switch (fid) {
		case 0x9:	// id id 1, type uint64_t, coding 64bit
			if ((a+7) >= e)
				return -215;
			set_id((uint64_t) read_u64(a));
			a += 8;
			break;
		case 0x12:	// name id 2, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -216;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 1);
			break;
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -217;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -218;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t OwDeviceConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has id?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'id': id=1, encoding=64bit, tag=0x9
		if (9 > (e-a))
			return -219;
		*a++ = 0x9;
		write_u64(a,(uint64_t)m_id);
		a += 8;
	}
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'name': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -220;
		*a++ = 0x12;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -221;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void OwDeviceConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_id()) {
		fsep = json_indent(json,indLvl,fsep,"id");
		json << m_id;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t OwDeviceConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// fixed64 id
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += 9;
	}
	// string name
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x10 */;
	}
	return r;
}

bool OwDeviceConfig::operator != (const OwDeviceConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_id() && (m_id != r.m_id))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	return false;
}


bool OwDeviceConfig::operator == (const OwDeviceConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int OwDeviceConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"id")) {
		if (value == 0) {
			clear_id();
			return 0;
		}
		int r = parse_ascii_u64(&m_id,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	return -222;
}

NodeConfig::NodeConfig()
: m_magic(0)
, m_nodename("")
, m_pass_hash()
, m_cpu_freq(0)
, m_station()
, m_softap()
, m_dns_server("")
, m_syslog_host("")
, m_sntp_server("")
, m_timezone("")
#ifdef CONFIG_MQTT
, m_mqtt()
#endif //CONFIG_MQTT
, m_dmesg_size(1024)
#ifdef CONFIG_INFLUX
, m_influx()
#endif //CONFIG_INFLUX
, m_station2ap_time(0)
, m_domainname("")
, m_holidays()
, m_at_actions()
, m_actions_enable(1)
, m_triggers()
, m_uart()
, m_terminal()
, m_udp_ctrl_port(12719)
, m_debugs()
#ifdef CONFIG_FTP
, m_ftpd()
#endif //CONFIG_FTP
, m_httpd()
, m_timefuses()
#ifdef CONFIG_SIGNAL_PROC
, m_signals()
#endif //CONFIG_SIGNAL_PROC
#ifdef CONFIG_SIGNAL_PROC
, m_functions()
#endif //CONFIG_SIGNAL_PROC
, m_max_on_time(0)
, m_threshold_off(0)
, m_threshold_on(0)
, m_dim_step(0)
, m_lightctrl(0)
, m_pwm_freq(0)
#ifdef CONFIG_SIGNAL_PROC
, m_app_params()
#endif //CONFIG_SIGNAL_PROC
#ifdef CONFIG_ONEWIRE
, m_owdevices()
#endif //CONFIG_ONEWIRE
, p_validbits(0)
{
}

/*!
 * Function for resetting all members of this object to their default values.
 */
void NodeConfig::clear()
{
	m_magic = 0;
	m_nodename = "";
	m_pass_hash.clear();
	m_cpu_freq = 0;
	m_station.clear();
	m_softap.clear();
	m_dns_server = "";
	m_syslog_host = "";
	m_sntp_server = "";
	m_timezone = "";
	#ifdef CONFIG_MQTT
	m_mqtt.clear();
	#endif //CONFIG_MQTT
	m_dmesg_size = 1024;
	#ifdef CONFIG_INFLUX
	m_influx.clear();
	#endif //CONFIG_INFLUX
	m_station2ap_time = 0;
	m_domainname = "";
	m_holidays.clear();
	m_at_actions.clear();
	m_actions_enable = 1;
	m_triggers.clear();
	m_uart.clear();
	m_terminal.clear();
	m_udp_ctrl_port = 12719;
	m_debugs.clear();
	#ifdef CONFIG_FTP
	m_ftpd.clear();
	#endif //CONFIG_FTP
	m_httpd.clear();
	m_timefuses.clear();
	#ifdef CONFIG_SIGNAL_PROC
	m_signals.clear();
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	m_functions.clear();
	#endif //CONFIG_SIGNAL_PROC
	m_max_on_time = 0;
	m_threshold_off = 0;
	m_threshold_on = 0;
	m_dim_step = 0;
	m_lightctrl = 0;
	m_pwm_freq = 0;
	#ifdef CONFIG_SIGNAL_PROC
	m_app_params.clear();
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_ONEWIRE
	m_owdevices.clear();
	#endif //CONFIG_ONEWIRE
	p_validbits = 0;
}

void NodeConfig::toASCII(stream &o, size_t indent) const
{
	o << "NodeConfig {";
	++indent;
	ascii_numeric(o, indent, "magic", m_magic);
	ascii_indent(o,indent,"nodename");
	ascii_string(o,m_nodename.data(),m_nodename.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"pass_hash");
	ascii_bytes(o,(const uint8_t*)m_pass_hash.data(),m_pass_hash.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "cpu_freq", m_cpu_freq);
	ascii_indent(o,indent,"station");
	m_station.toASCII(o,indent);
	ascii_indent(o,indent,"softap");
	m_softap.toASCII(o,indent);
	ascii_indent(o,indent,"dns_server");
	ascii_string(o,m_dns_server.data(),m_dns_server.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"syslog_host");
	ascii_string(o,m_syslog_host.data(),m_syslog_host.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"sntp_server");
	ascii_string(o,m_sntp_server.data(),m_sntp_server.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"timezone");
	ascii_string(o,m_timezone.data(),m_timezone.size(),indent+2);
	o << ';';
	#ifdef CONFIG_MQTT
	ascii_indent(o,indent,"mqtt");
	m_mqtt.toASCII(o,indent);
	#endif //CONFIG_MQTT
	ascii_numeric(o, indent, "dmesg_size", m_dmesg_size);
	#ifdef CONFIG_INFLUX
	ascii_indent(o,indent,"influx");
	m_influx.toASCII(o,indent);
	#endif //CONFIG_INFLUX
	ascii_numeric(o, indent, "station2ap_time", m_station2ap_time);
	ascii_indent(o,indent,"domainname");
	ascii_string(o,m_domainname.data(),m_domainname.size(),indent+2);
	o << ';';
	ascii_indent(o,indent);
	size_t s_holidays = m_holidays.size();
	o << "holidays[" << s_holidays << "] = {";
	++indent;
	for (size_t i = 0, e = s_holidays; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_holidays[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent);
	size_t s_at_actions = m_at_actions.size();
	o << "at_actions[" << s_at_actions << "] = {";
	++indent;
	for (size_t i = 0, e = s_at_actions; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_at_actions[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_numeric(o, indent, "actions_enable", m_actions_enable);
	ascii_indent(o,indent);
	size_t s_triggers = m_triggers.size();
	o << "triggers[" << s_triggers << "] = {";
	++indent;
	for (size_t i = 0, e = s_triggers; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_triggers[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent);
	size_t s_uart = m_uart.size();
	o << "uart[" << s_uart << "] = {";
	++indent;
	for (size_t i = 0, e = s_uart; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_uart[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent);
	size_t s_terminal = m_terminal.size();
	o << "terminal[" << s_terminal << "] = {";
	++indent;
	for (size_t i = 0, e = s_terminal; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_terminal[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_numeric(o, indent, "udp_ctrl_port", m_udp_ctrl_port);
	ascii_indent(o,indent);
	size_t s_debugs = m_debugs.size();
	o << "debugs[" << s_debugs << "] = {";
	++indent;
	for (size_t i = 0, e = s_debugs; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,m_debugs[i].data(),m_debugs[i].size(),indent+2);
		o << ';';
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_FTP
	ascii_indent(o,indent,"ftpd");
	m_ftpd.toASCII(o,indent);
	#endif //CONFIG_FTP
	ascii_indent(o,indent,"httpd");
	m_httpd.toASCII(o,indent);
	ascii_indent(o,indent);
	size_t s_timefuses = m_timefuses.size();
	o << "timefuses[" << s_timefuses << "] = {";
	++indent;
	for (size_t i = 0, e = s_timefuses; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_timefuses[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_SIGNAL_PROC
	ascii_indent(o,indent);
	size_t s_signals = m_signals.size();
	o << "signals[" << s_signals << "] = {";
	++indent;
	for (size_t i = 0, e = s_signals; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_signals[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	ascii_indent(o,indent);
	size_t s_functions = m_functions.size();
	o << "functions[" << s_functions << "] = {";
	++indent;
	for (size_t i = 0, e = s_functions; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_functions[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif //CONFIG_SIGNAL_PROC
	ascii_numeric(o, indent, "max_on_time", m_max_on_time);
	ascii_numeric(o, indent, "threshold_off", m_threshold_off);
	ascii_numeric(o, indent, "threshold_on", m_threshold_on);
	ascii_numeric(o, indent, "dim_step", m_dim_step);
	ascii_indent(o,indent,"lightctrl");
	o << (m_lightctrl ? "true" : "false") << ';';
	ascii_numeric(o, indent, "pwm_freq", m_pwm_freq);
	#ifdef CONFIG_SIGNAL_PROC
	ascii_indent(o,indent);
	size_t s_app_params = m_app_params.size();
	o << "app_params[" << s_app_params << "] = {";
	++indent;
	for (size_t i = 0, e = s_app_params; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_app_params[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_ONEWIRE
	ascii_indent(o,indent);
	size_t s_owdevices = m_owdevices.size();
	o << "owdevices[" << s_owdevices << "] = {";
	++indent;
	for (size_t i = 0, e = s_owdevices; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_owdevices[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif //CONFIG_ONEWIRE
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

/*!
 * Function for parsing an object from serialized data.
 * @param b buffer containg the data to be parsed
 * @param s number of bytes in buffer
 * @return number of bytes successfully parsed (can be < s)
 *         or a negative value indicating the error encountered
 */
ssize_t NodeConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -223;
		a += fn;
		switch (fid) {
		case 0x5:	// magic id 0, type uint32_t, coding 32bit
			if ((a+3) >= e)
				return -224;
			set_magic((uint32_t) read_u32(a));
			a += 4;
			break;
		case 0xa:	// nodename id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -225;
				m_nodename.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x12:	// pass_hash id 2, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -226;
				m_pass_hash.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint32_t)1U << 1);
			break;
		case 0x18:	// cpu_freq id 3, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -227;
				a += n;
				set_cpu_freq(v);
			}
			break;
		case 0x22:	// station id 4, type WifiConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -228;
				if (v != 0) {
					n = m_station.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -229;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 3);
			break;
		case 0x2a:	// softap id 5, type WifiConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -230;
				if (v != 0) {
					n = m_softap.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -231;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 4);
			break;
		case 0x32:	// dns_server id 6, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -232;
				m_dns_server.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x3a:	// syslog_host id 7, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -233;
				m_syslog_host.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x42:	// sntp_server id 8, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -234;
				m_sntp_server.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x4a:	// timezone id 9, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -235;
				m_timezone.assign((const char*)a,v);
				a += v;
			}
			break;
			#ifdef CONFIG_MQTT
		case 0x52:	// mqtt id 10, type MQTT, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -236;
				if (v != 0) {
					n = m_mqtt.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -237;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 5);
			break;
			#endif //CONFIG_MQTT
		case 0x5c:	// dmesg_size id 11, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -238;
			set_dmesg_size((uint16_t) read_u16(a));
			a += 2;
			break;
			#ifdef CONFIG_INFLUX
		case 0x62:	// influx id 12, type Influx, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -239;
				if (v != 0) {
					n = m_influx.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -240;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 7);
			break;
			#endif //CONFIG_INFLUX
		case 0x68:	// station2ap_time id 13, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -241;
				a += n;
				set_station2ap_time(v);
			}
			break;
		case 0x7a:	// domainname id 15, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -242;
				m_domainname.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x82:	// holidays id 16, type Date, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -243;
				m_holidays.emplace_back();
				if (v != 0) {
					n = m_holidays.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -244;
					a += v;
				}
			}
			break;
		case 0x8a:	// at_actions id 17, type AtAction, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -245;
				m_at_actions.emplace_back();
				if (v != 0) {
					n = m_at_actions.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -246;
					a += v;
				}
			}
			break;
		case 0x90:	// actions_enable id 18, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -247;
				a += n;
				set_actions_enable(v);
			}
			break;
		case 0x9a:	// triggers id 19, type Trigger, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -248;
				m_triggers.emplace_back();
				if (v != 0) {
					n = m_triggers.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -249;
					a += v;
				}
			}
			break;
		case 0xa2:	// uart id 20, type UartSettings, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -250;
				m_uart.emplace_back();
				if (v != 0) {
					n = m_uart.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -251;
					a += v;
				}
			}
			break;
		case 0xaa:	// terminal id 21, type TerminalConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -252;
				m_terminal.emplace_back();
				if (v != 0) {
					n = m_terminal.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -253;
					a += v;
				}
			}
			break;
		case 0xb4:	// udp_ctrl_port id 22, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -254;
			set_udp_ctrl_port((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0xba:	// debugs id 23, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -255;
				m_debugs.emplace_back((const char*)a,v);
				a += v;
			}
			break;
			#ifdef CONFIG_FTP
		case 0xc2:	// ftpd id 24, type FtpHttpConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -256;
				if (v != 0) {
					n = m_ftpd.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -257;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 11);
			break;
			#endif //CONFIG_FTP
		case 0xca:	// httpd id 25, type FtpHttpConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -258;
				if (v != 0) {
					n = m_httpd.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -259;
					a += v;
				}
			}
			p_validbits |= ((uint32_t)1U << 12);
			break;
		case 0xf2:	// timefuses id 30, type EventTimer, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -260;
				m_timefuses.emplace_back();
				if (v != 0) {
					n = m_timefuses.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -261;
					a += v;
				}
			}
			break;
			#ifdef CONFIG_SIGNAL_PROC
		case 0xfa:	// signals id 31, type SignalConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -262;
				m_signals.emplace_back();
				if (v != 0) {
					n = m_signals.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -263;
					a += v;
				}
			}
			break;
			#endif //CONFIG_SIGNAL_PROC
			#ifdef CONFIG_SIGNAL_PROC
		case 0x102:	// functions id 32, type FunctionConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -264;
				m_functions.emplace_back();
				if (v != 0) {
					n = m_functions.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -265;
					a += v;
				}
			}
			break;
			#endif //CONFIG_SIGNAL_PROC
		case 0x110:	// max_on_time id 34, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -266;
				a += n;
				set_max_on_time(v);
			}
			break;
		case 0x118:	// threshold_off id 35, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -267;
				a += n;
				set_threshold_off(v);
			}
			break;
		case 0x120:	// threshold_on id 36, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -268;
				a += n;
				set_threshold_on(v);
			}
			break;
		case 0x128:	// dim_step id 37, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -269;
				a += n;
				set_dim_step(v);
			}
			break;
		case 0x133:	// lightctrl id 38, type bool, coding 8bit
			if (a >= e)
				return -270;
			set_lightctrl(*a++);
			break;
		case 0x138:	// pwm_freq id 39, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -271;
				a += n;
				set_pwm_freq(v);
			}
			break;
			#ifdef CONFIG_SIGNAL_PROC
		case 0x142:	// app_params id 40, type AppParam, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -272;
				m_app_params.emplace_back();
				if (v != 0) {
					n = m_app_params.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -273;
					a += v;
				}
			}
			break;
			#endif //CONFIG_SIGNAL_PROC
			#ifdef CONFIG_ONEWIRE
		case 0x192:	// owdevices id 50, type OwDeviceConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -274;
				m_owdevices.emplace_back();
				if (v != 0) {
					n = m_owdevices.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -275;
					a += v;
				}
			}
			break;
			#endif //CONFIG_ONEWIRE
		default:
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -276;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -277;
	return a-(const uint8_t *)b;
}

/*!
 * Function for serializing the object to memory.
 * @param b buffer to serialize the object to
 * @param s number of bytes available in the buffer
 * @return number of bytes successfully serialized
 */
ssize_t NodeConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has magic?
	if (0 != (p_validbits & ((uint32_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		if (5 > (e-a))
			return -278;
		*a++ = 0x5;
		if ((e-a) < 4)
			return -279;
		write_u32(a,(uint32_t)m_magic);
		a += 4;
	}
	// has nodename?
	if (!m_nodename.empty()) {
		// 'nodename': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -280;
		*a++ = 0xa;
		ssize_t nodename_s = m_nodename.size();
		n = write_varint(a,e-a,nodename_s);
		a += n;
		if ((n <= 0) || ((e-a) < nodename_s))
			return -281;
		memcpy(a,m_nodename.data(),nodename_s);
		a += nodename_s;
	}
	// has pass_hash?
	if (0 != (p_validbits & ((uint32_t)1U << 1))) {
		// 'pass_hash': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -282;
		*a++ = 0x12;
		ssize_t pass_hash_s = m_pass_hash.size();
		n = write_varint(a,e-a,pass_hash_s);
		a += n;
		if ((n <= 0) || ((e-a) < pass_hash_s))
			return -283;
		memcpy(a,m_pass_hash.data(),pass_hash_s);
		a += pass_hash_s;
	}
	// has cpu_freq?
	if (0 != (p_validbits & ((uint32_t)1U << 2))) {
		// 'cpu_freq': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -284;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_cpu_freq);
		if (n <= 0)
			return -285;
		a += n;
	}
	// has station?
	if (0 != (p_validbits & ((uint32_t)1U << 3))) {
		// 'station': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -286;
		*a++ = 0x22;
		ssize_t station_ws = m_station.calcSize();
		n = write_varint(a,e-a,station_ws);
		a += n;
		if ((n <= 0) || (station_ws > (e-a)))
			return -287;
		n = m_station.toMemory(a,e-a);
		a += n;
		assert(n == station_ws);
	}
	// has softap?
	if (0 != (p_validbits & ((uint32_t)1U << 4))) {
		// 'softap': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -288;
		*a++ = 0x2a;
		ssize_t softap_ws = m_softap.calcSize();
		n = write_varint(a,e-a,softap_ws);
		a += n;
		if ((n <= 0) || (softap_ws > (e-a)))
			return -289;
		n = m_softap.toMemory(a,e-a);
		a += n;
		assert(n == softap_ws);
	}
	// has dns_server?
	if (!m_dns_server.empty()) {
		// 'dns_server': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -290;
		*a++ = 0x32;
		ssize_t dns_server_s = m_dns_server.size();
		n = write_varint(a,e-a,dns_server_s);
		a += n;
		if ((n <= 0) || ((e-a) < dns_server_s))
			return -291;
		memcpy(a,m_dns_server.data(),dns_server_s);
		a += dns_server_s;
	}
	// has syslog_host?
	if (!m_syslog_host.empty()) {
		// 'syslog_host': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -292;
		*a++ = 0x3a;
		ssize_t syslog_host_s = m_syslog_host.size();
		n = write_varint(a,e-a,syslog_host_s);
		a += n;
		if ((n <= 0) || ((e-a) < syslog_host_s))
			return -293;
		memcpy(a,m_syslog_host.data(),syslog_host_s);
		a += syslog_host_s;
	}
	// has sntp_server?
	if (!m_sntp_server.empty()) {
		// 'sntp_server': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -294;
		*a++ = 0x42;
		ssize_t sntp_server_s = m_sntp_server.size();
		n = write_varint(a,e-a,sntp_server_s);
		a += n;
		if ((n <= 0) || ((e-a) < sntp_server_s))
			return -295;
		memcpy(a,m_sntp_server.data(),sntp_server_s);
		a += sntp_server_s;
	}
	// has timezone?
	if (!m_timezone.empty()) {
		// 'timezone': id=9, encoding=lenpfx, tag=0x4a
		if (a >= e)
			return -296;
		*a++ = 0x4a;
		ssize_t timezone_s = m_timezone.size();
		n = write_varint(a,e-a,timezone_s);
		a += n;
		if ((n <= 0) || ((e-a) < timezone_s))
			return -297;
		memcpy(a,m_timezone.data(),timezone_s);
		a += timezone_s;
	}
	#ifdef CONFIG_MQTT
	// has mqtt?
	if (0 != (p_validbits & ((uint32_t)1U << 5))) {
		// 'mqtt': id=10, encoding=lenpfx, tag=0x52
		if (a >= e)
			return -298;
		*a++ = 0x52;
		ssize_t mqtt_ws = m_mqtt.calcSize();
		n = write_varint(a,e-a,mqtt_ws);
		a += n;
		if ((n <= 0) || (mqtt_ws > (e-a)))
			return -299;
		n = m_mqtt.toMemory(a,e-a);
		a += n;
		assert(n == mqtt_ws);
	}
	#endif //CONFIG_MQTT
	// has dmesg_size?
	if (0 != (p_validbits & ((uint32_t)1U << 6))) {
		// 'dmesg_size': id=11, encoding=16bit, tag=0x5c
		if (3 > (e-a))
			return -300;
		*a++ = 0x5c;
		write_u16(a,m_dmesg_size);
		a += 2;
	}
	#ifdef CONFIG_INFLUX
	// has influx?
	if (0 != (p_validbits & ((uint32_t)1U << 7))) {
		// 'influx': id=12, encoding=lenpfx, tag=0x62
		if (a >= e)
			return -301;
		*a++ = 0x62;
		ssize_t influx_ws = m_influx.calcSize();
		n = write_varint(a,e-a,influx_ws);
		a += n;
		if ((n <= 0) || (influx_ws > (e-a)))
			return -302;
		n = m_influx.toMemory(a,e-a);
		a += n;
		assert(n == influx_ws);
	}
	#endif //CONFIG_INFLUX
	// has station2ap_time?
	if (0 != (p_validbits & ((uint32_t)1U << 8))) {
		// 'station2ap_time': id=13, encoding=varint, tag=0x68
		if (a >= e)
			return -303;
		*a++ = 0x68;
		n = write_varint(a,e-a,m_station2ap_time);
		if (n <= 0)
			return -304;
		a += n;
	}
	// has domainname?
	if (!m_domainname.empty()) {
		// 'domainname': id=15, encoding=lenpfx, tag=0x7a
		if (a >= e)
			return -305;
		*a++ = 0x7a;
		ssize_t domainname_s = m_domainname.size();
		n = write_varint(a,e-a,domainname_s);
		a += n;
		if ((n <= 0) || ((e-a) < domainname_s))
			return -306;
		memcpy(a,m_domainname.data(),domainname_s);
		a += domainname_s;
	}
	for (const auto &x : m_holidays) {
		// 'holidays': id=16, encoding=lenpfx, tag=0x82
		if (2 > (e-a))
			return -307;
		*a++ = 0x82;
		*a++ = 0x1;
		ssize_t holidays_ws = x.calcSize();
		n = write_varint(a,e-a,holidays_ws);
		a += n;
		if ((n <= 0) || (holidays_ws > (e-a)))
			return -308;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == holidays_ws);
	}
	for (const auto &x : m_at_actions) {
		// 'at_actions': id=17, encoding=lenpfx, tag=0x8a
		if (2 > (e-a))
			return -309;
		*a++ = 0x8a;
		*a++ = 0x1;
		ssize_t at_actions_ws = x.calcSize();
		n = write_varint(a,e-a,at_actions_ws);
		a += n;
		if ((n <= 0) || (at_actions_ws > (e-a)))
			return -310;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == at_actions_ws);
	}
	// has actions_enable?
	if (0 != (p_validbits & ((uint32_t)1U << 9))) {
		// 'actions_enable': id=18, encoding=varint, tag=0x90
		if (2 > (e-a))
			return -311;
		*a++ = 0x90;
		*a++ = 0x1;
		n = write_varint(a,e-a,m_actions_enable);
		if (n <= 0)
			return -312;
		a += n;
	}
	for (const auto &x : m_triggers) {
		// 'triggers': id=19, encoding=lenpfx, tag=0x9a
		if (2 > (e-a))
			return -313;
		*a++ = 0x9a;
		*a++ = 0x1;
		ssize_t triggers_ws = x.calcSize();
		n = write_varint(a,e-a,triggers_ws);
		a += n;
		if ((n <= 0) || (triggers_ws > (e-a)))
			return -314;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == triggers_ws);
	}
	for (const auto &x : m_uart) {
		// 'uart': id=20, encoding=lenpfx, tag=0xa2
		if (2 > (e-a))
			return -315;
		*a++ = 0xa2;
		*a++ = 0x1;
		ssize_t uart_ws = x.calcSize();
		n = write_varint(a,e-a,uart_ws);
		a += n;
		if ((n <= 0) || (uart_ws > (e-a)))
			return -316;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == uart_ws);
	}
	for (const auto &x : m_terminal) {
		// 'terminal': id=21, encoding=lenpfx, tag=0xaa
		if (2 > (e-a))
			return -317;
		*a++ = 0xaa;
		*a++ = 0x1;
		ssize_t terminal_ws = x.calcSize();
		n = write_varint(a,e-a,terminal_ws);
		a += n;
		if ((n <= 0) || (terminal_ws > (e-a)))
			return -318;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == terminal_ws);
	}
	// has udp_ctrl_port?
	if (0 != (p_validbits & ((uint32_t)1U << 10))) {
		// 'udp_ctrl_port': id=22, encoding=16bit, tag=0xb4
		if (4 > (e-a))
			return -319;
		*a++ = 0xb4;
		*a++ = 0x1;
		write_u16(a,m_udp_ctrl_port);
		a += 2;
	}
	for (const auto &x : m_debugs) {
		// 'debugs': id=23, encoding=lenpfx, tag=0xba
		if (2 > (e-a))
			return -320;
		*a++ = 0xba;
		*a++ = 0x1;
		ssize_t debugs_s = x.size();
		n = write_varint(a,e-a,debugs_s);
		a += n;
		if ((n <= 0) || ((e-a) < debugs_s))
			return -321;
		memcpy(a,x.data(),debugs_s);
		a += debugs_s;
	}
	#ifdef CONFIG_FTP
	// has ftpd?
	if (0 != (p_validbits & ((uint32_t)1U << 11))) {
		// 'ftpd': id=24, encoding=lenpfx, tag=0xc2
		if (2 > (e-a))
			return -322;
		*a++ = 0xc2;
		*a++ = 0x1;
		ssize_t ftpd_ws = m_ftpd.calcSize();
		n = write_varint(a,e-a,ftpd_ws);
		a += n;
		if ((n <= 0) || (ftpd_ws > (e-a)))
			return -323;
		n = m_ftpd.toMemory(a,e-a);
		a += n;
		assert(n == ftpd_ws);
	}
	#endif //CONFIG_FTP
	// has httpd?
	if (0 != (p_validbits & ((uint32_t)1U << 12))) {
		// 'httpd': id=25, encoding=lenpfx, tag=0xca
		if (2 > (e-a))
			return -324;
		*a++ = 0xca;
		*a++ = 0x1;
		ssize_t httpd_ws = m_httpd.calcSize();
		n = write_varint(a,e-a,httpd_ws);
		a += n;
		if ((n <= 0) || (httpd_ws > (e-a)))
			return -325;
		n = m_httpd.toMemory(a,e-a);
		a += n;
		assert(n == httpd_ws);
	}
	for (const auto &x : m_timefuses) {
		// 'timefuses': id=30, encoding=lenpfx, tag=0xf2
		if (2 > (e-a))
			return -326;
		*a++ = 0xf2;
		*a++ = 0x1;
		ssize_t timefuses_ws = x.calcSize();
		n = write_varint(a,e-a,timefuses_ws);
		a += n;
		if ((n <= 0) || (timefuses_ws > (e-a)))
			return -327;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == timefuses_ws);
	}
	#ifdef CONFIG_SIGNAL_PROC
	for (const auto &x : m_signals) {
		// 'signals': id=31, encoding=lenpfx, tag=0xfa
		if (2 > (e-a))
			return -328;
		*a++ = 0xfa;
		*a++ = 0x1;
		ssize_t signals_ws = x.calcSize();
		n = write_varint(a,e-a,signals_ws);
		a += n;
		if ((n <= 0) || (signals_ws > (e-a)))
			return -329;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == signals_ws);
	}
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	for (const auto &x : m_functions) {
		// 'functions': id=32, encoding=lenpfx, tag=0x102
		if (2 > (e-a))
			return -330;
		*a++ = 0x82;
		*a++ = 0x2;
		ssize_t functions_ws = x.calcSize();
		n = write_varint(a,e-a,functions_ws);
		a += n;
		if ((n <= 0) || (functions_ws > (e-a)))
			return -331;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == functions_ws);
	}
	#endif //CONFIG_SIGNAL_PROC
	// 'max_on_time' is deprecated. Therefore no data will be written.
	// has threshold_off?
	if (0 != (p_validbits & ((uint32_t)1U << 13))) {
		// 'threshold_off': id=35, encoding=varint, tag=0x118
		if (2 > (e-a))
			return -332;
		*a++ = 0x98;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_threshold_off);
		if (n <= 0)
			return -333;
		a += n;
	}
	// has threshold_on?
	if (0 != (p_validbits & ((uint32_t)1U << 14))) {
		// 'threshold_on': id=36, encoding=varint, tag=0x120
		if (2 > (e-a))
			return -334;
		*a++ = 0xa0;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_threshold_on);
		if (n <= 0)
			return -335;
		a += n;
	}
	// has dim_step?
	if (0 != (p_validbits & ((uint32_t)1U << 15))) {
		// 'dim_step': id=37, encoding=varint, tag=0x128
		if (2 > (e-a))
			return -336;
		*a++ = 0xa8;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_dim_step);
		if (n <= 0)
			return -337;
		a += n;
	}
	// has lightctrl?
	if (0 != (p_validbits & ((uint32_t)1U << 16))) {
		// 'lightctrl': id=38, encoding=8bit, tag=0x133
		if (3 > (e-a))
			return -338;
		*a++ = 0xb3;
		*a++ = 0x2;
		*a++ = m_lightctrl;
	}
	// has pwm_freq?
	if (0 != (p_validbits & ((uint32_t)1U << 17))) {
		// 'pwm_freq': id=39, encoding=varint, tag=0x138
		if (2 > (e-a))
			return -339;
		*a++ = 0xb8;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_pwm_freq);
		if (n <= 0)
			return -340;
		a += n;
	}
	#ifdef CONFIG_SIGNAL_PROC
	for (const auto &x : m_app_params) {
		// 'app_params': id=40, encoding=lenpfx, tag=0x142
		if (2 > (e-a))
			return -341;
		*a++ = 0xc2;
		*a++ = 0x2;
		ssize_t app_params_ws = x.calcSize();
		n = write_varint(a,e-a,app_params_ws);
		a += n;
		if ((n <= 0) || (app_params_ws > (e-a)))
			return -342;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == app_params_ws);
	}
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_ONEWIRE
	for (const auto &x : m_owdevices) {
		// 'owdevices': id=50, encoding=lenpfx, tag=0x192
		if (2 > (e-a))
			return -343;
		*a++ = 0x92;
		*a++ = 0x3;
		ssize_t owdevices_ws = x.calcSize();
		n = write_varint(a,e-a,owdevices_ws);
		a += n;
		if ((n <= 0) || (owdevices_ws > (e-a)))
			return -344;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == owdevices_ws);
	}
	#endif //CONFIG_ONEWIRE
	assert(a <= e);
	return a-b;
}

/*!
 * Function for writing a JSON representation of the object to a stream.
 * @param json stream object the data should be serialized to
 * @param indLvl the indention level that should be used
 */
void NodeConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_magic()) {
		fsep = json_indent(json,indLvl,fsep,"magic");
		json << m_magic;
	}
	if (has_nodename()) {
		fsep = json_indent(json,indLvl,fsep,"nodename");
		json_cstr(json,m_nodename.c_str());
	}
	if (has_pass_hash()) {
		fsep = json_indent(json,indLvl,fsep,"pass_hash");
		json_string(json,m_pass_hash);
	}
	if (has_cpu_freq()) {
		fsep = json_indent(json,indLvl,fsep,"cpu_freq");
		json << m_cpu_freq;
	}
	if (has_station()) {
		fsep = json_indent(json,indLvl,fsep,"station");
		m_station.toJSON(json,indLvl);
	}
	if (has_softap()) {
		fsep = json_indent(json,indLvl,fsep,"softap");
		m_softap.toJSON(json,indLvl);
	}
	if (has_dns_server()) {
		fsep = json_indent(json,indLvl,fsep,"dns_server");
		json_cstr(json,m_dns_server.c_str());
	}
	if (has_syslog_host()) {
		fsep = json_indent(json,indLvl,fsep,"syslog_host");
		json_cstr(json,m_syslog_host.c_str());
	}
	if (has_sntp_server()) {
		fsep = json_indent(json,indLvl,fsep,"sntp_server");
		json_cstr(json,m_sntp_server.c_str());
	}
	if (has_timezone()) {
		fsep = json_indent(json,indLvl,fsep,"timezone");
		json_cstr(json,m_timezone.c_str());
	}
	#ifdef CONFIG_MQTT
	if (has_mqtt()) {
		fsep = json_indent(json,indLvl,fsep,"mqtt");
		m_mqtt.toJSON(json,indLvl);
	}
	#endif //CONFIG_MQTT
	if (has_dmesg_size()) {
		fsep = json_indent(json,indLvl,fsep,"dmesg_size");
		json << m_dmesg_size;
	}
	#ifdef CONFIG_INFLUX
	if (has_influx()) {
		fsep = json_indent(json,indLvl,fsep,"influx");
		m_influx.toJSON(json,indLvl);
	}
	#endif //CONFIG_INFLUX
	if (has_station2ap_time()) {
		fsep = json_indent(json,indLvl,fsep,"station2ap_time");
		json << m_station2ap_time;
	}
	if (has_domainname()) {
		fsep = json_indent(json,indLvl,fsep,"domainname");
		json_cstr(json,m_domainname.c_str());
	}
	if (size_t s = m_holidays.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"holidays\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_holidays[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_at_actions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"at_actions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_at_actions[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (has_actions_enable()) {
		fsep = json_indent(json,indLvl,fsep,"actions_enable");
		json << m_actions_enable;
	}
	if (size_t s = m_triggers.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"triggers\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_triggers[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_uart.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"uart\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_uart[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_terminal.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"terminal\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_terminal[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (has_udp_ctrl_port()) {
		fsep = json_indent(json,indLvl,fsep,"udp_ctrl_port");
		json << m_udp_ctrl_port;
	}
	if (size_t s = m_debugs.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"debugs\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_debugs[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_FTP
	if (has_ftpd()) {
		fsep = json_indent(json,indLvl,fsep,"ftpd");
		m_ftpd.toJSON(json,indLvl);
	}
	#endif //CONFIG_FTP
	if (has_httpd()) {
		fsep = json_indent(json,indLvl,fsep,"httpd");
		m_httpd.toJSON(json,indLvl);
	}
	if (size_t s = m_timefuses.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"timefuses\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_timefuses[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_SIGNAL_PROC
	if (size_t s = m_signals.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"signals\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_signals[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	if (size_t s = m_functions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"functions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_functions[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif //CONFIG_SIGNAL_PROC
	if (has_max_on_time()) {
		fsep = json_indent(json,indLvl,fsep,"max_on_time");
		json << m_max_on_time;
	}
	if (has_threshold_off()) {
		fsep = json_indent(json,indLvl,fsep,"threshold_off");
		json << m_threshold_off;
	}
	if (has_threshold_on()) {
		fsep = json_indent(json,indLvl,fsep,"threshold_on");
		json << m_threshold_on;
	}
	if (has_dim_step()) {
		fsep = json_indent(json,indLvl,fsep,"dim_step");
		json << m_dim_step;
	}
	if (has_lightctrl()) {
		fsep = json_indent(json,indLvl,fsep,"lightctrl");
		json << (m_lightctrl ? "true" : "false");
	}
	if (has_pwm_freq()) {
		fsep = json_indent(json,indLvl,fsep,"pwm_freq");
		json << m_pwm_freq;
	}
	#ifdef CONFIG_SIGNAL_PROC
	if (size_t s = m_app_params.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"app_params\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_app_params[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_ONEWIRE
	if (size_t s = m_owdevices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"owdevices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_owdevices[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif //CONFIG_ONEWIRE
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

/*!
 * Function for calculating the number of bytes needed for serializing
 * the related object with its associated data.
 * Changing the data may change the size of the serialized object.
 */
size_t NodeConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// fixed32 magic
	if (0 != (p_validbits & ((uint32_t)1U << 0))) {
		r += 5;
	}
	// string nodename
	if (!m_nodename.empty()) {
		size_t nodename_s = m_nodename.size();
		r += nodename_s + wiresize(nodename_s) + 1 /* tag(nodename) 0x8 */;
	}
	// bytes pass_hash
	if (0 != (p_validbits & ((uint32_t)1U << 1))) {
		size_t pass_hash_s = m_pass_hash.size();
		r += pass_hash_s + wiresize(pass_hash_s) + 1 /* tag(pass_hash) 0x10 */;
	}
	// unsigned cpu_freq
	if (0 != (p_validbits & ((uint32_t)1U << 2))) {
		r += wiresize((varint_t)m_cpu_freq) + 1 /* tag(cpu_freq) 0x18 */;
	}
	// WifiConfig station
	if (0 != (p_validbits & ((uint32_t)1U << 3))) {
		size_t station_s = m_station.calcSize();
		r += station_s + wiresize(station_s) + 1 /* tag(station) 0x20 */;
	}
	// WifiConfig softap
	if (0 != (p_validbits & ((uint32_t)1U << 4))) {
		size_t softap_s = m_softap.calcSize();
		r += softap_s + wiresize(softap_s) + 1 /* tag(softap) 0x28 */;
	}
	// string dns_server
	if (!m_dns_server.empty()) {
		size_t dns_server_s = m_dns_server.size();
		r += dns_server_s + wiresize(dns_server_s) + 1 /* tag(dns_server) 0x30 */;
	}
	// string syslog_host
	if (!m_syslog_host.empty()) {
		size_t syslog_host_s = m_syslog_host.size();
		r += syslog_host_s + wiresize(syslog_host_s) + 1 /* tag(syslog_host) 0x38 */;
	}
	// string sntp_server
	if (!m_sntp_server.empty()) {
		size_t sntp_server_s = m_sntp_server.size();
		r += sntp_server_s + wiresize(sntp_server_s) + 1 /* tag(sntp_server) 0x40 */;
	}
	// string timezone
	if (!m_timezone.empty()) {
		size_t timezone_s = m_timezone.size();
		r += timezone_s + wiresize(timezone_s) + 1 /* tag(timezone) 0x48 */;
	}
	// MQTT mqtt
	#ifdef CONFIG_MQTT
	if (0 != (p_validbits & ((uint32_t)1U << 5))) {
		size_t mqtt_s = m_mqtt.calcSize();
		r += mqtt_s + wiresize(mqtt_s) + 1 /* tag(mqtt) 0x50 */;
	}
	#endif //CONFIG_MQTT
	// fixed16 dmesg_size
	if (0 != (p_validbits & ((uint32_t)1U << 6))) {
		r += 3;
	}
	// Influx influx
	#ifdef CONFIG_INFLUX
	if (0 != (p_validbits & ((uint32_t)1U << 7))) {
		size_t influx_s = m_influx.calcSize();
		r += influx_s + wiresize(influx_s) + 1 /* tag(influx) 0x60 */;
	}
	#endif //CONFIG_INFLUX
	// unsigned station2ap_time
	if (0 != (p_validbits & ((uint32_t)1U << 8))) {
		r += wiresize((varint_t)m_station2ap_time) + 1 /* tag(station2ap_time) 0x68 */;
	}
	// string domainname
	if (!m_domainname.empty()) {
		size_t domainname_s = m_domainname.size();
		r += domainname_s + wiresize(domainname_s) + 1 /* tag(domainname) 0x78 */;
	}
	// Date holidays
	// repeated message holidays
	for (size_t x = 0, y = m_holidays.size(); x < y; ++x) {
		size_t s = m_holidays[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(holidays) 0x80 */;
	}
	// AtAction at_actions
	// repeated message at_actions
	for (size_t x = 0, y = m_at_actions.size(); x < y; ++x) {
		size_t s = m_at_actions[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(at_actions) 0x88 */;
	}
	// unsigned actions_enable
	if (0 != (p_validbits & ((uint32_t)1U << 9))) {
		r += wiresize((varint_t)m_actions_enable) + 2 /* tag(actions_enable) 0x90 */;
	}
	// Trigger triggers
	// repeated message triggers
	for (size_t x = 0, y = m_triggers.size(); x < y; ++x) {
		size_t s = m_triggers[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(triggers) 0x98 */;
	}
	// UartSettings uart
	// repeated message uart
	for (size_t x = 0, y = m_uart.size(); x < y; ++x) {
		size_t s = m_uart[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(uart) 0xa0 */;
	}
	// TerminalConfig terminal
	// repeated message terminal
	for (size_t x = 0, y = m_terminal.size(); x < y; ++x) {
		size_t s = m_terminal[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(terminal) 0xa8 */;
	}
	// fixed16 udp_ctrl_port
	if (0 != (p_validbits & ((uint32_t)1U << 10))) {
		r += 4;
	}
	// string debugs
	if (!m_debugs.empty()) {
		// debugs: repeated estring
		for (size_t x = 0, y = m_debugs.size(); x < y; ++x) {
			size_t s = m_debugs[x].size();
			r += wiresize(s);
			r += s + 2 /* tag(debugs) 0xb8 */;
		}
	}
	// FtpHttpConfig ftpd
	#ifdef CONFIG_FTP
	if (0 != (p_validbits & ((uint32_t)1U << 11))) {
		size_t ftpd_s = m_ftpd.calcSize();
		r += ftpd_s + wiresize(ftpd_s) + 2 /* tag(ftpd) 0xc0 */;
	}
	#endif //CONFIG_FTP
	// FtpHttpConfig httpd
	if (0 != (p_validbits & ((uint32_t)1U << 12))) {
		size_t httpd_s = m_httpd.calcSize();
		r += httpd_s + wiresize(httpd_s) + 2 /* tag(httpd) 0xc8 */;
	}
	// EventTimer timefuses
	// repeated message timefuses
	for (size_t x = 0, y = m_timefuses.size(); x < y; ++x) {
		size_t s = m_timefuses[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(timefuses) 0xf0 */;
	}
	// SignalConfig signals
	#ifdef CONFIG_SIGNAL_PROC
	// repeated message signals
	for (size_t x = 0, y = m_signals.size(); x < y; ++x) {
		size_t s = m_signals[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(signals) 0xf8 */;
	}
	#endif //CONFIG_SIGNAL_PROC
	// FunctionConfig functions
	#ifdef CONFIG_SIGNAL_PROC
	// repeated message functions
	for (size_t x = 0, y = m_functions.size(); x < y; ++x) {
		size_t s = m_functions[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(functions) 0x100 */;
	}
	#endif //CONFIG_SIGNAL_PROC
	// deprecated unsigned max_on_time
	// unsigned threshold_off
	if (0 != (p_validbits & ((uint32_t)1U << 13))) {
		r += wiresize((varint_t)m_threshold_off) + 2 /* tag(threshold_off) 0x118 */;
	}
	// unsigned threshold_on
	if (0 != (p_validbits & ((uint32_t)1U << 14))) {
		r += wiresize((varint_t)m_threshold_on) + 2 /* tag(threshold_on) 0x120 */;
	}
	// unsigned dim_step
	if (0 != (p_validbits & ((uint32_t)1U << 15))) {
		r += wiresize((varint_t)m_dim_step) + 2 /* tag(dim_step) 0x128 */;
	}
	// bool lightctrl
	if (0 != (p_validbits & ((uint32_t)1U << 16))) {
		r += 3;
	}
	// unsigned pwm_freq
	if (0 != (p_validbits & ((uint32_t)1U << 17))) {
		r += wiresize((varint_t)m_pwm_freq) + 2 /* tag(pwm_freq) 0x138 */;
	}
	// AppParam app_params
	#ifdef CONFIG_SIGNAL_PROC
	// repeated message app_params
	for (size_t x = 0, y = m_app_params.size(); x < y; ++x) {
		size_t s = m_app_params[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(app_params) 0x140 */;
	}
	#endif //CONFIG_SIGNAL_PROC
	// OwDeviceConfig owdevices
	#ifdef CONFIG_ONEWIRE
	// repeated message owdevices
	for (size_t x = 0, y = m_owdevices.size(); x < y; ++x) {
		size_t s = m_owdevices[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(owdevices) 0x190 */;
	}
	#endif //CONFIG_ONEWIRE
	return r;
}

bool NodeConfig::operator != (const NodeConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_magic() && (m_magic != r.m_magic))
		return true;
	if (has_nodename() && (m_nodename != r.m_nodename))
		return true;
	if (has_pass_hash() && (m_pass_hash != r.m_pass_hash))
		return true;
	if (has_cpu_freq() && (m_cpu_freq != r.m_cpu_freq))
		return true;
	if (has_station() && (m_station != r.m_station))
		return true;
	if (has_softap() && (m_softap != r.m_softap))
		return true;
	if (has_dns_server() && (m_dns_server != r.m_dns_server))
		return true;
	if (has_syslog_host() && (m_syslog_host != r.m_syslog_host))
		return true;
	if (has_sntp_server() && (m_sntp_server != r.m_sntp_server))
		return true;
	if (has_timezone() && (m_timezone != r.m_timezone))
		return true;
	#ifdef CONFIG_MQTT
	if (has_mqtt() && (m_mqtt != r.m_mqtt))
		return true;
	#endif //CONFIG_MQTT
	if (has_dmesg_size() && (m_dmesg_size != r.m_dmesg_size))
		return true;
	#ifdef CONFIG_INFLUX
	if (has_influx() && (m_influx != r.m_influx))
		return true;
	#endif //CONFIG_INFLUX
	if (has_station2ap_time() && (m_station2ap_time != r.m_station2ap_time))
		return true;
	if (has_domainname() && (m_domainname != r.m_domainname))
		return true;
	if (m_holidays != r.m_holidays)
		return true;
	if (m_at_actions != r.m_at_actions)
		return true;
	if (has_actions_enable() && (m_actions_enable != r.m_actions_enable))
		return true;
	if (m_triggers != r.m_triggers)
		return true;
	if (m_uart != r.m_uart)
		return true;
	if (m_terminal != r.m_terminal)
		return true;
	if (has_udp_ctrl_port() && (m_udp_ctrl_port != r.m_udp_ctrl_port))
		return true;
	if (m_debugs != r.m_debugs)
		return true;
	#ifdef CONFIG_FTP
	if (has_ftpd() && (m_ftpd != r.m_ftpd))
		return true;
	#endif //CONFIG_FTP
	if (has_httpd() && (m_httpd != r.m_httpd))
		return true;
	if (m_timefuses != r.m_timefuses)
		return true;
	#ifdef CONFIG_SIGNAL_PROC
	if (m_signals != r.m_signals)
		return true;
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	if (m_functions != r.m_functions)
		return true;
	#endif //CONFIG_SIGNAL_PROC
	if (has_max_on_time() && (m_max_on_time != r.m_max_on_time))
		return true;
	if (has_threshold_off() && (m_threshold_off != r.m_threshold_off))
		return true;
	if (has_threshold_on() && (m_threshold_on != r.m_threshold_on))
		return true;
	if (has_dim_step() && (m_dim_step != r.m_dim_step))
		return true;
	if (has_lightctrl() && (m_lightctrl != r.m_lightctrl))
		return true;
	if (has_pwm_freq() && (m_pwm_freq != r.m_pwm_freq))
		return true;
	#ifdef CONFIG_SIGNAL_PROC
	if (m_app_params != r.m_app_params)
		return true;
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_ONEWIRE
	if (m_owdevices != r.m_owdevices)
		return true;
	#endif //CONFIG_ONEWIRE
	return false;
}


bool NodeConfig::operator == (const NodeConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int NodeConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"magic")) {
		if (value == 0) {
			clear_magic();
			return 0;
		}
		int r = parse_ascii_u32(&m_magic,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"nodename")) {
		if (value == 0) {
			clear_nodename();
			return 0;
		}
		m_nodename = value;
		int r = m_nodename.size();
		return r;
	}
	if (0 == strcmp(name,"pass_hash")) {
		if (value == 0) {
			clear_pass_hash();
			return 0;
		}
		int r = parse_ascii_bytes(m_pass_hash,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"cpu_freq")) {
		if (value == 0) {
			clear_cpu_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_cpu_freq,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 2);
		return r;
	}
	if (0 == memcmp(name,"station",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_station();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint32_t)1U << 3);
			return m_station.setByName(name+8,value);
		}
	}
	if (0 == memcmp(name,"softap",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_softap();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint32_t)1U << 4);
			return m_softap.setByName(name+7,value);
		}
	}
	if (0 == strcmp(name,"dns_server")) {
		if (value == 0) {
			clear_dns_server();
			return 0;
		}
		m_dns_server = value;
		int r = m_dns_server.size();
		return r;
	}
	if (0 == strcmp(name,"syslog_host")) {
		if (value == 0) {
			clear_syslog_host();
			return 0;
		}
		m_syslog_host = value;
		int r = m_syslog_host.size();
		return r;
	}
	if (0 == strcmp(name,"sntp_server")) {
		if (value == 0) {
			clear_sntp_server();
			return 0;
		}
		m_sntp_server = value;
		int r = m_sntp_server.size();
		return r;
	}
	if (0 == strcmp(name,"timezone")) {
		if (value == 0) {
			clear_timezone();
			return 0;
		}
		m_timezone = value;
		int r = m_timezone.size();
		return r;
	}
	#ifdef CONFIG_MQTT
	if (0 == memcmp(name,"mqtt",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_mqtt();
			return 0;
		} else if (name[4] == '.') {
			p_validbits |= ((uint32_t)1U << 5);
			return m_mqtt.setByName(name+5,value);
		}
	}
	#endif //CONFIG_MQTT
	if (0 == strcmp(name,"dmesg_size")) {
		if (value == 0) {
			clear_dmesg_size();
			return 0;
		}
		int r = parse_ascii_u16(&m_dmesg_size,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 6);
		return r;
	}
	#ifdef CONFIG_INFLUX
	if (0 == memcmp(name,"influx",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_influx();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint32_t)1U << 7);
			return m_influx.setByName(name+7,value);
		}
	}
	#endif //CONFIG_INFLUX
	if (0 == strcmp(name,"station2ap_time")) {
		if (value == 0) {
			clear_station2ap_time();
			return 0;
		}
		int r = parse_ascii_u32(&m_station2ap_time,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 8);
		return r;
	}
	if (0 == strcmp(name,"domainname")) {
		if (value == 0) {
			clear_domainname();
			return 0;
		}
		m_domainname = value;
		int r = m_domainname.size();
		return r;
	}
	if (0 == memcmp(name,"holidays",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_holidays();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_holidays.size();
				m_holidays.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -345;
				if (m_holidays.size() <= x)
					return -346;
				if ((idxe[1] == 0) && (value == 0)) {
					m_holidays.erase(m_holidays.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -347;
			return m_holidays[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"at_actions",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_at_actions();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_at_actions.size();
				m_at_actions.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -348;
				if (m_at_actions.size() <= x)
					return -349;
				if ((idxe[1] == 0) && (value == 0)) {
					m_at_actions.erase(m_at_actions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -350;
			return m_at_actions[x].setByName(idxe+2,value);
		}
	}
	if (0 == strcmp(name,"actions_enable")) {
		if (value == 0) {
			clear_actions_enable();
			return 0;
		}
		int r = parse_ascii_u32(&m_actions_enable,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 9);
		return r;
	}
	if (0 == memcmp(name,"triggers",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_triggers();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_triggers.size();
				m_triggers.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -351;
				if (m_triggers.size() <= x)
					return -352;
				if ((idxe[1] == 0) && (value == 0)) {
					m_triggers.erase(m_triggers.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -353;
			return m_triggers[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"uart",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_uart();
			return 0;
		} else if (name[4] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[5] == '+') && (name[6] == ']')) {
				x = m_uart.size();
				m_uart.resize(x+1);
				idxe = (char*)(name + 6);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+5,&idxe,0);
				if (idxe[0] != ']')
					return -354;
				if (m_uart.size() <= x)
					return -355;
				if ((idxe[1] == 0) && (value == 0)) {
					m_uart.erase(m_uart.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -356;
			return m_uart[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"terminal",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_terminal();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_terminal.size();
				m_terminal.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -357;
				if (m_terminal.size() <= x)
					return -358;
				if ((idxe[1] == 0) && (value == 0)) {
					m_terminal.erase(m_terminal.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -359;
			return m_terminal[x].setByName(idxe+2,value);
		}
	}
	if (0 == strcmp(name,"udp_ctrl_port")) {
		if (value == 0) {
			clear_udp_ctrl_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_udp_ctrl_port,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 10);
		return r;
	}
	if (0 == memcmp(name,"debugs",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_debugs();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_debugs.size();
				m_debugs.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -360;
				if (m_debugs.size() <= x)
					return -361;
				if ((idxe[1] == 0) && (value == 0)) {
					m_debugs.erase(m_debugs.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -362;
			m_debugs[x] = value;
			return m_debugs[x].size();
		}
	}
	#ifdef CONFIG_FTP
	if (0 == memcmp(name,"ftpd",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_ftpd();
			return 0;
		} else if (name[4] == '.') {
			p_validbits |= ((uint32_t)1U << 11);
			return m_ftpd.setByName(name+5,value);
		}
	}
	#endif //CONFIG_FTP
	if (0 == memcmp(name,"httpd",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_httpd();
			return 0;
		} else if (name[5] == '.') {
			p_validbits |= ((uint32_t)1U << 12);
			return m_httpd.setByName(name+6,value);
		}
	}
	if (0 == memcmp(name,"timefuses",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_timefuses();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_timefuses.size();
				m_timefuses.resize(x+1);
				idxe = (char*)(name + 11);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if (idxe[0] != ']')
					return -363;
				if (m_timefuses.size() <= x)
					return -364;
				if ((idxe[1] == 0) && (value == 0)) {
					m_timefuses.erase(m_timefuses.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -365;
			return m_timefuses[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_SIGNAL_PROC
	if (0 == memcmp(name,"signals",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_signals();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_signals.size();
				m_signals.resize(x+1);
				idxe = (char*)(name + 9);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if (idxe[0] != ']')
					return -366;
				if (m_signals.size() <= x)
					return -367;
				if ((idxe[1] == 0) && (value == 0)) {
					m_signals.erase(m_signals.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -368;
			return m_signals[x].setByName(idxe+2,value);
		}
	}
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	if (0 == memcmp(name,"functions",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_functions();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_functions.size();
				m_functions.resize(x+1);
				idxe = (char*)(name + 11);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if (idxe[0] != ']')
					return -369;
				if (m_functions.size() <= x)
					return -370;
				if ((idxe[1] == 0) && (value == 0)) {
					m_functions.erase(m_functions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -371;
			return m_functions[x].setByName(idxe+2,value);
		}
	}
	#endif //CONFIG_SIGNAL_PROC
	if (0 == strcmp(name,"max_on_time")) {
		if (value == 0) {
			clear_max_on_time();
			return 0;
		}
		int r = parse_ascii_u32(&m_max_on_time,value);
		return r;
	}
	if (0 == strcmp(name,"threshold_off")) {
		if (value == 0) {
			clear_threshold_off();
			return 0;
		}
		int r = parse_ascii_u32(&m_threshold_off,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 13);
		return r;
	}
	if (0 == strcmp(name,"threshold_on")) {
		if (value == 0) {
			clear_threshold_on();
			return 0;
		}
		int r = parse_ascii_u32(&m_threshold_on,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 14);
		return r;
	}
	if (0 == strcmp(name,"dim_step")) {
		if (value == 0) {
			clear_dim_step();
			return 0;
		}
		int r = parse_ascii_u32(&m_dim_step,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 15);
		return r;
	}
	if (0 == strcmp(name,"lightctrl")) {
		if (value == 0) {
			clear_lightctrl();
			return 0;
		}
		int r = parse_ascii_bool(&m_lightctrl,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 16);
		return r;
	}
	if (0 == strcmp(name,"pwm_freq")) {
		if (value == 0) {
			clear_pwm_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_pwm_freq,value);
		if (r > 0)
			p_validbits |= ((uint32_t)1U << 17);
		return r;
	}
	#ifdef CONFIG_SIGNAL_PROC
	if (0 == memcmp(name,"app_params",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_app_params();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_app_params.size();
				m_app_params.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -372;
				if (m_app_params.size() <= x)
					return -373;
				if ((idxe[1] == 0) && (value == 0)) {
					m_app_params.erase(m_app_params.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -374;
			return m_app_params[x].setByName(idxe+2,value);
		}
	}
	#endif //CONFIG_SIGNAL_PROC
	#ifdef CONFIG_ONEWIRE
	if (0 == memcmp(name,"owdevices",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_owdevices();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_owdevices.size();
				m_owdevices.resize(x+1);
				idxe = (char*)(name + 11);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if (idxe[0] != ']')
					return -375;
				if (m_owdevices.size() <= x)
					return -376;
				if ((idxe[1] == 0) && (value == 0)) {
					m_owdevices.erase(m_owdevices.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -377;
			return m_owdevices[x].setByName(idxe+2,value);
		}
	}
	#endif //CONFIG_ONEWIRE
	return -378;
}

