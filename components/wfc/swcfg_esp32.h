/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: P2304.6 (hg:462/5e8253265d37)
 * WFC is Copyright 2015-2024, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : swcfg.wfc
 * Copyright: 2018-2024
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2024-04-27, 17:04:22 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from esp32:
 * endian          : "little"
 * Optimize        : "speed"
 * 
 * options from esp:
 * bytestype       : "estring"
 * intsize         : 32
 * stringtype      : "estring"
 * toASCII         : "toASCII"
 * toSink          : ""
 * toString        : ""
 * toWire          : ""
 * varintbits      : 32
 * 
 * options from common:
 * BaseClass       : "Message"
 * getMember       : "getMember"
 * SortMembers     : "size"
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bool      : "ascii_bool"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * calcSize        : "calcSize"
 * cfgdefs         : ""
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * ClearValue      : "compatible"
 * copyright       : ""
 * email           : ""
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * UnknownField    : "skip"
 * wireput         : ""
 * wiresize        : ""
 * 
 * enabled flags from esp32:
 * 	withUnequal
 * enabled flags from esp:
 * 	enumnames, withEqual
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux
 */

#ifndef SWCFG_ESP32_H
#define SWCFG_ESP32_H

#include <assert.h>
#define OUTPUT_TO_ASCII 1
#include <string>
/* std::map support not needed */
#include <vector>
/* array support not needed */
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>

/* user requested header files */
#include "estring.h"
#include <sdkconfig.h>
#include "stream.h"
#include "support.h"
#ifdef WFC_ENDIAN
#if WFC_ENDIAN != 0
#error WFC generated code incompatible due to endian
#endif
#else
#define WFC_ENDIAN     0 // little endian
#endif

#define HAVE_TO_MEMORY 1
#define HAVE_TO_ASCII 1
#define HAVE_TO_JSON 1
#define HAVE_GET_MEMBER 1
#define HAVE_FROM_MEMORY 1
#define ON_ERROR_CANCEL 1
#define HAVE_ENUM_NAMES 1

#include "wfccore_esp32.h"
/* wfc support functions not needed */

typedef uint32_t varint_t;

typedef int32_t varsint_t;


typedef enum {
	unknown = 0,
	powerup = 1,
	external = 2,
	software = 3,
	panic = 4,
	internal_wdt = 5,
	task_wdt = 6,
	watchdog = 7,
	deepsleep = 8,
	brownout = 9,
	sdio = 10,
} rstrsn_t;
//! Function to get an ASCII string from a value of a rstrsn_t.
const char *strReset(rstrsn_t e);
//! Function to parse the value of rstrsn_t from an ASCII string.
size_t parse_ascii_rstrsn_t(rstrsn_t *, const char *);

typedef enum {
	Sunday = 0,
	Monday = 1,
	Tuesday = 2,
	Wednesday = 3,
	Thursday = 4,
	Friday = 5,
	Saturday = 6,
	WorkDay = 7,
	WeekEnd = 8,
	EveryDay = 9,
	Holiday = 10,
} WeekDay;
//! Function to get an ASCII string from a value of a WeekDay.
const char *WeekDay_str(WeekDay e);
//! Function to parse the value of WeekDay from an ASCII string.
size_t parse_ascii_WeekDay(WeekDay *, const char *);

typedef enum {
	uart_wl_5 = 0,
	uart_wl_6 = 1,
	uart_wl_7 = 2,
	uart_wl_8 = 3,
} uart_wl_t;
//! Function to get an ASCII string from a value of a uart_wl_t.
const char *uart_wl_t_str(uart_wl_t e);
//! Function to parse the value of uart_wl_t from an ASCII string.
size_t parse_ascii_uart_wl_t(uart_wl_t *, const char *);

typedef enum {
	uart_sb_none = 0,
	uart_sb_1 = 1,
	uart_sb_1_5 = 2,
	uart_sb_2 = 3,
} uart_sb_t;
//! Function to get an ASCII string from a value of a uart_sb_t.
const char *uart_sb_t_str(uart_sb_t e);
//! Function to parse the value of uart_sb_t from an ASCII string.
size_t parse_ascii_uart_sb_t(uart_sb_t *, const char *);

typedef enum {
	uart_p_n = 0,
	uart_p_e = 2,
	uart_p_o = 3,
} uart_p_t;
//! Function to get an ASCII string from a value of a uart_p_t.
const char *uart_p_t_str(uart_p_t e);
//! Function to parse the value of uart_p_t from an ASCII string.
size_t parse_ascii_uart_p_t(uart_p_t *, const char *);

typedef enum {
	st_invalid = 0,
	st_int = 1,
	st_float = 2,
	st_string = 3,
} sigtype_t;
//! Function to get an ASCII string from a value of a sigtype_t.
const char *sigtype_t_str(sigtype_t e);
//! Function to parse the value of sigtype_t from an ASCII string.
size_t parse_ascii_sigtype_t(sigtype_t *, const char *);

typedef uint16_t uartcfg_t;
typedef uint8_t eventcfg_t;


class WifiConfig : public Message
{
	public:
	WifiConfig()
	{
	}
	
	bool operator != (const WifiConfig &r) const;
	bool operator == (const WifiConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string ssid, id 1
	/*!
	* Function for querying if ssid has been set.
	* @return true if ssid is set.
	*/
	bool has_ssid() const;
	//! Function to reset ssid to its default/unset value.
	void clear_ssid();
	//! Get value of ssid.
	const estring &ssid() const;
	/*!
	* Function for setting ssid using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_ssid(const void *data, size_t s);
	//! Set ssid using a constant reference
	void set_ssid(const estring &v);
	//! Set ssid using a pointer to a null-terminated C-string.
	void set_ssid(const char *);
	/*!
	* Provide mutable access to ssid.
	* @return pointer to member variable of ssid.
	*/
	estring *mutable_ssid();
	
	// optional string pass, id 2
	/*!
	* Function for querying if pass has been set.
	* @return true if pass is set.
	*/
	bool has_pass() const;
	//! Function to reset pass to its default/unset value.
	void clear_pass();
	//! Get value of pass.
	const estring &pass() const;
	/*!
	* Function for setting pass using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_pass(const void *data, size_t s);
	//! Set pass using a constant reference
	void set_pass(const estring &v);
	//! Set pass using a pointer to a null-terminated C-string.
	void set_pass(const char *);
	/*!
	* Provide mutable access to pass.
	* @return pointer to member variable of pass.
	*/
	estring *mutable_pass();
	
	// optional bytes mac, id 3
	/*!
	* Function for querying if mac has been set.
	* @return true if mac is set.
	*/
	bool has_mac() const;
	//! Function to reset mac to its default/unset value.
	void clear_mac();
	//! Get value of mac.
	const estring &mac() const;
	/*!
	* Function for setting mac using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_mac(const void *data, size_t s);
	//! Set mac using a constant reference
	void set_mac(const estring &v);
	/*!
	* Provide mutable access to mac.
	* @return pointer to member variable of mac.
	*/
	estring *mutable_mac();
	
	// required bool activate, id 4
	//! Get value of activate.
	bool activate() const;
	//! Set activate using a constant reference
	void set_activate(bool v);
	/*!
	* Provide mutable access to activate.
	* @return pointer to member variable of activate.
	*/
	bool *mutable_activate();
	
	// optional fixed32 addr4, id 5
	/*!
	* Function for querying if addr4 has been set.
	* @return true if addr4 is set.
	*/
	bool has_addr4() const;
	//! Function to reset addr4 to its default/unset value.
	void clear_addr4();
	//! Get value of addr4.
	uint32_t addr4() const;
	//! Set addr4 using a constant reference
	void set_addr4(uint32_t v);
	/*!
	* Provide mutable access to addr4.
	* @return pointer to member variable of addr4.
	*/
	uint32_t *mutable_addr4();
	
	// optional fixed8 netmask4, id 6
	/*!
	* Function for querying if netmask4 has been set.
	* @return true if netmask4 is set.
	*/
	bool has_netmask4() const;
	//! Function to reset netmask4 to its default/unset value.
	void clear_netmask4();
	//! Get value of netmask4.
	uint8_t netmask4() const;
	//! Set netmask4 using a constant reference
	void set_netmask4(uint8_t v);
	/*!
	* Provide mutable access to netmask4.
	* @return pointer to member variable of netmask4.
	*/
	uint8_t *mutable_netmask4();
	
	// optional fixed32 gateway4, id 7
	/*!
	* Function for querying if gateway4 has been set.
	* @return true if gateway4 is set.
	*/
	bool has_gateway4() const;
	//! Function to reset gateway4 to its default/unset value.
	void clear_gateway4();
	//! Get value of gateway4.
	uint32_t gateway4() const;
	//! Set gateway4 using a constant reference
	void set_gateway4(uint32_t v);
	/*!
	* Provide mutable access to gateway4.
	* @return pointer to member variable of gateway4.
	*/
	uint32_t *mutable_gateway4();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string ssid, id 1
	estring m_ssid;
	//! string pass, id 2
	estring m_pass;
	//! bytes mac, id 3
	estring m_mac;
	//! fixed32 addr4, id 5
	uint32_t m_addr4 = 0;
	//! fixed32 gateway4, id 7
	uint32_t m_gateway4 = 0;
	//! bool activate, id 4
	bool m_activate = false;
	//! fixed8 netmask4, id 6
	uint8_t m_netmask4 = 0;
	
	private:
	uint8_t p_validbits = 0;
};




class MQTT : public Message
{
	public:
	MQTT()
	{
	}
	
	bool operator != (const MQTT &r) const;
	bool operator == (const MQTT &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string uri, id 1
	/*!
	* Function for querying if uri has been set.
	* @return true if uri is set.
	*/
	bool has_uri() const;
	//! Function to reset uri to its default/unset value.
	void clear_uri();
	//! Get value of uri.
	const estring &uri() const;
	/*!
	* Function for setting uri using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_uri(const void *data, size_t s);
	//! Set uri using a constant reference
	void set_uri(const estring &v);
	//! Set uri using a pointer to a null-terminated C-string.
	void set_uri(const char *);
	/*!
	* Provide mutable access to uri.
	* @return pointer to member variable of uri.
	*/
	estring *mutable_uri();
	
	// optional bool enable, id 2
	/*!
	* Function for querying if enable has been set.
	* @return true if enable is set.
	*/
	bool has_enable() const;
	//! Function to reset enable to its default/unset value.
	void clear_enable();
	//! Get value of enable.
	bool enable() const;
	//! Set enable using a constant reference
	void set_enable(bool v);
	/*!
	* Provide mutable access to enable.
	* @return pointer to member variable of enable.
	*/
	bool *mutable_enable();
	
	// optional string username, id 3
	/*!
	* Function for querying if username has been set.
	* @return true if username is set.
	*/
	bool has_username() const;
	//! Function to reset username to its default/unset value.
	void clear_username();
	//! Get value of username.
	const estring &username() const;
	/*!
	* Function for setting username using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_username(const void *data, size_t s);
	//! Set username using a constant reference
	void set_username(const estring &v);
	//! Set username using a pointer to a null-terminated C-string.
	void set_username(const char *);
	/*!
	* Provide mutable access to username.
	* @return pointer to member variable of username.
	*/
	estring *mutable_username();
	
	// optional string password, id 4
	/*!
	* Function for querying if password has been set.
	* @return true if password is set.
	*/
	bool has_password() const;
	//! Function to reset password to its default/unset value.
	void clear_password();
	//! Get value of password.
	const estring &password() const;
	/*!
	* Function for setting password using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_password(const void *data, size_t s);
	//! Set password using a constant reference
	void set_password(const estring &v);
	//! Set password using a pointer to a null-terminated C-string.
	void set_password(const char *);
	/*!
	* Provide mutable access to password.
	* @return pointer to member variable of password.
	*/
	estring *mutable_password();
	
	// repeated string subscribtions, id 5
	//! Function get const-access to the elements of subscribtions.
	const std::vector<estring> &subscribtions() const;
	//! Function to get the number of elements in subscribtions.
	size_t subscribtions_size() const;
	/*!
	* Function to append a element to subscribtions.
	* @return point to newly added element.
	*/
	void add_subscribtions(const estring &v);
	//! Function to append an element to subscribtions initialized by a C-string.
	void add_subscribtions(const char*);
	//! Function to reset subscribtions to its default/unset value.
	void clear_subscribtions();
	//! Get value of element x of subscribtions.
	const estring &subscribtions(unsigned x) const;
	//! Set subscribtions using a constant reference
	void set_subscribtions(unsigned x, const estring &v);
	/*!
	* Provide mutable access to subscribtions.
	* @return pointer to member variable of subscribtions.
	*/
	estring *mutable_subscribtions(unsigned x);
	//! Function to get mutable access to all elements of subscribtions.
	std::vector<estring> *mutable_subscribtions();
	
	// optional uint16 keepalive, id 6
	/*!
	* Function for querying if keepalive has been set.
	* @return true if keepalive is set.
	*/
	bool has_keepalive() const;
	//! Function to reset keepalive to its default/unset value.
	void clear_keepalive();
	//! Get value of keepalive.
	uint16_t keepalive() const;
	//! Set keepalive using a constant reference
	void set_keepalive(uint16_t v);
	/*!
	* Provide mutable access to keepalive.
	* @return pointer to member variable of keepalive.
	*/
	uint16_t *mutable_keepalive();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string uri, id 1
	estring m_uri;
	//! string username, id 3
	estring m_username;
	//! string password, id 4
	estring m_password;
	//! string subscribtions, id 5
	std::vector<estring> m_subscribtions;
	//! uint16 keepalive, id 6
	uint16_t m_keepalive = 60;
	//! bool enable, id 2
	bool m_enable = false;
	
	private:
	uint8_t p_validbits = 0;
};




class Date : public Message
{
	public:
	Date()
	{
	}
	
	bool operator != (const Date &r) const;
	bool operator == (const Date &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional fixed8 day, id 1
	/*!
	* Function for querying if day has been set.
	* @return true if day is set.
	*/
	bool has_day() const;
	//! Function to reset day to its default/unset value.
	void clear_day();
	//! Get value of day.
	uint8_t day() const;
	//! Set day using a constant reference
	void set_day(uint8_t v);
	/*!
	* Provide mutable access to day.
	* @return pointer to member variable of day.
	*/
	uint8_t *mutable_day();
	
	// optional fixed8 month, id 2
	/*!
	* Function for querying if month has been set.
	* @return true if month is set.
	*/
	bool has_month() const;
	//! Function to reset month to its default/unset value.
	void clear_month();
	//! Get value of month.
	uint8_t month() const;
	//! Set month using a constant reference
	void set_month(uint8_t v);
	/*!
	* Provide mutable access to month.
	* @return pointer to member variable of month.
	*/
	uint8_t *mutable_month();
	
	// optional fixed16 year, id 3
	/*!
	* Function for querying if year has been set.
	* @return true if year is set.
	*/
	bool has_year() const;
	//! Function to reset year to its default/unset value.
	void clear_year();
	//! Get value of year.
	uint16_t year() const;
	//! Set year using a constant reference
	void set_year(uint16_t v);
	/*!
	* Provide mutable access to year.
	* @return pointer to member variable of year.
	*/
	uint16_t *mutable_year();
	
	// optional fixed8 endday, id 4
	/*!
	* Function for querying if endday has been set.
	* @return true if endday is set.
	*/
	bool has_endday() const;
	//! Function to reset endday to its default/unset value.
	void clear_endday();
	//! Get value of endday.
	uint8_t endday() const;
	//! Set endday using a constant reference
	void set_endday(uint8_t v);
	/*!
	* Provide mutable access to endday.
	* @return pointer to member variable of endday.
	*/
	uint8_t *mutable_endday();
	
	// optional fixed8 endmonth, id 5
	/*!
	* Function for querying if endmonth has been set.
	* @return true if endmonth is set.
	*/
	bool has_endmonth() const;
	//! Function to reset endmonth to its default/unset value.
	void clear_endmonth();
	//! Get value of endmonth.
	uint8_t endmonth() const;
	//! Set endmonth using a constant reference
	void set_endmonth(uint8_t v);
	/*!
	* Provide mutable access to endmonth.
	* @return pointer to member variable of endmonth.
	*/
	uint8_t *mutable_endmonth();
	
	// optional fixed8 endyear, id 6
	/*!
	* Function for querying if endyear has been set.
	* @return true if endyear is set.
	*/
	bool has_endyear() const;
	//! Function to reset endyear to its default/unset value.
	void clear_endyear();
	//! Get value of endyear.
	uint8_t endyear() const;
	//! Set endyear using a constant reference
	void set_endyear(uint8_t v);
	/*!
	* Provide mutable access to endyear.
	* @return pointer to member variable of endyear.
	*/
	uint8_t *mutable_endyear();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! fixed16 year, id 3
	uint16_t m_year = 0;
	//! fixed8 day, id 1
	uint8_t m_day = 0;
	//! fixed8 month, id 2
	uint8_t m_month = 0;
	//! fixed8 endday, id 4
	uint8_t m_endday = 0;
	//! fixed8 endmonth, id 5
	uint8_t m_endmonth = 0;
	//! fixed8 endyear, id 6
	uint8_t m_endyear = 0;
};




class AtAction : public Message
{
	public:
	AtAction()
	{
	}
	
	bool operator != (const AtAction &r) const;
	bool operator == (const AtAction &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional WeekDay day, id 1
	/*!
	* Function for querying if day has been set.
	* @return true if day is set.
	*/
	bool has_day() const;
	//! Function to reset day to its default/unset value.
	void clear_day();
	//! Get value of day.
	WeekDay day() const;
	//! Set day using a constant reference
	void set_day(WeekDay v);
	/*!
	* Provide mutable access to day.
	* @return pointer to member variable of day.
	*/
	WeekDay *mutable_day();
	
	// optional unsigned min_of_day, id 2
	/*!
	* Function for querying if min_of_day has been set.
	* @return true if min_of_day is set.
	*/
	bool has_min_of_day() const;
	//! Function to reset min_of_day to its default/unset value.
	void clear_min_of_day();
	//! Get value of min_of_day.
	uint32_t min_of_day() const;
	//! Set min_of_day using a constant reference
	void set_min_of_day(uint32_t v);
	/*!
	* Provide mutable access to min_of_day.
	* @return pointer to member variable of min_of_day.
	*/
	uint32_t *mutable_min_of_day();
	
	// optional string action, id 3
	/*!
	* Function for querying if action has been set.
	* @return true if action is set.
	*/
	bool has_action() const;
	//! Function to reset action to its default/unset value.
	void clear_action();
	//! Get value of action.
	const estring &action() const;
	/*!
	* Function for setting action using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_action(const void *data, size_t s);
	//! Set action using a constant reference
	void set_action(const estring &v);
	//! Set action using a pointer to a null-terminated C-string.
	void set_action(const char *);
	/*!
	* Provide mutable access to action.
	* @return pointer to member variable of action.
	*/
	estring *mutable_action();
	
	// required bool enable, id 4
	//! Get value of enable.
	bool enable() const;
	//! Set enable using a constant reference
	void set_enable(bool v);
	/*!
	* Provide mutable access to enable.
	* @return pointer to member variable of enable.
	*/
	bool *mutable_enable();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string action, id 3
	estring m_action;
	//! WeekDay day, id 1
	WeekDay m_day = Sunday;
	//! unsigned min_of_day, id 2
	uint32_t m_min_of_day = 0;
	//! bool enable, id 4
	bool m_enable = true;
	
	private:
	uint8_t p_validbits = 0;
};




class Influx : public Message
{
	public:
	Influx()
	{
	}
	
	bool operator != (const Influx &r) const;
	bool operator == (const Influx &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string hostname, id 1
	/*!
	* Function for querying if hostname has been set.
	* @return true if hostname is set.
	*/
	bool has_hostname() const;
	//! Function to reset hostname to its default/unset value.
	void clear_hostname();
	//! Get value of hostname.
	const estring &hostname() const;
	/*!
	* Function for setting hostname using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_hostname(const void *data, size_t s);
	//! Set hostname using a constant reference
	void set_hostname(const estring &v);
	//! Set hostname using a pointer to a null-terminated C-string.
	void set_hostname(const char *);
	/*!
	* Provide mutable access to hostname.
	* @return pointer to member variable of hostname.
	*/
	estring *mutable_hostname();
	
	// optional fixed16 port, id 2
	/*!
	* Function for querying if port has been set.
	* @return true if port is set.
	*/
	bool has_port() const;
	//! Function to reset port to its default/unset value.
	void clear_port();
	//! Get value of port.
	uint16_t port() const;
	//! Set port using a constant reference
	void set_port(uint16_t v);
	/*!
	* Provide mutable access to port.
	* @return pointer to member variable of port.
	*/
	uint16_t *mutable_port();
	
	// optional string measurement, id 3
	/*!
	* Function for querying if measurement has been set.
	* @return true if measurement is set.
	*/
	bool has_measurement() const;
	//! Function to reset measurement to its default/unset value.
	void clear_measurement();
	//! Get value of measurement.
	const estring &measurement() const;
	/*!
	* Function for setting measurement using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_measurement(const void *data, size_t s);
	//! Set measurement using a constant reference
	void set_measurement(const estring &v);
	//! Set measurement using a pointer to a null-terminated C-string.
	void set_measurement(const char *);
	/*!
	* Provide mutable access to measurement.
	* @return pointer to member variable of measurement.
	*/
	estring *mutable_measurement();
	
	// obsolete optional unsigned interval, id 4
	// optional string database, id 5
	/*!
	* Function for querying if database has been set.
	* @return true if database is set.
	*/
	bool has_database() const;
	//! Function to reset database to its default/unset value.
	void clear_database();
	//! Get value of database.
	const estring &database() const;
	/*!
	* Function for setting database using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_database(const void *data, size_t s);
	//! Set database using a constant reference
	void set_database(const estring &v);
	//! Set database using a pointer to a null-terminated C-string.
	void set_database(const char *);
	/*!
	* Provide mutable access to database.
	* @return pointer to member variable of database.
	*/
	estring *mutable_database();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string hostname, id 1
	estring m_hostname;
	//! string measurement, id 3
	estring m_measurement;
	//! string database, id 5
	estring m_database;
	//! fixed16 port, id 2
	uint16_t m_port = 0;
};




class UartSettings : public Message
{
	public:
	UartSettings()
	{
	}
	
	bool operator != (const UartSettings &r) const;
	bool operator == (const UartSettings &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 port, id 1
	/*!
	* Function for querying if port has been set.
	* @return true if port is set.
	*/
	bool has_port() const;
	//! Function to reset port to its default/unset value.
	void clear_port();
	//! Get value of port.
	int8_t port() const;
	//! Set port using a constant reference
	void set_port(int8_t v);
	/*!
	* Provide mutable access to port.
	* @return pointer to member variable of port.
	*/
	int8_t *mutable_port();
	
	// optional unsigned baudrate, id 2
	/*!
	* Function for querying if baudrate has been set.
	* @return true if baudrate is set.
	*/
	bool has_baudrate() const;
	//! Function to reset baudrate to its default/unset value.
	void clear_baudrate();
	//! Get value of baudrate.
	uint32_t baudrate() const;
	//! Set baudrate using a constant reference
	void set_baudrate(uint32_t v);
	/*!
	* Provide mutable access to baudrate.
	* @return pointer to member variable of baudrate.
	*/
	uint32_t *mutable_baudrate();
	
	// optional uartcfg_t config, id 3
	/*!
	* Function for querying if config has been set.
	* @return true if config is set.
	*/
	bool has_config() const;
	//! Function to reset config to its default/unset value.
	void clear_config();
	//! Get value of config.
	uartcfg_t config() const;
	//! Function to get the wl part of bitset config.
	uart_wl_t config_wl() const;
	//! Function to set the wl part of bitset config.
	void set_config_wl(uart_wl_t);
	//! Function to get the sb part of bitset config.
	uart_sb_t config_sb() const;
	//! Function to set the sb part of bitset config.
	void set_config_sb(uart_sb_t);
	//! Function to get the rts part of bitset config.
	bool config_rts() const;
	//! Function to set the rts part of bitset config.
	void set_config_rts(bool);
	//! Function to get the cts part of bitset config.
	bool config_cts() const;
	//! Function to set the cts part of bitset config.
	void set_config_cts(bool);
	//! Function to get the p part of bitset config.
	uart_p_t config_p() const;
	//! Function to set the p part of bitset config.
	void set_config_p(uart_p_t);
	//! Function to get the ref_tick part of bitset config.
	bool config_ref_tick() const;
	//! Function to set the ref_tick part of bitset config.
	void set_config_ref_tick(bool);
	//! Set config using a constant reference
	void set_config(uartcfg_t v);
	/*!
	* Provide mutable access to config.
	* @return pointer to member variable of config.
	*/
	uartcfg_t *mutable_config();
	
	// optional fixed8 rx_thresh, id 4
	/*!
	* Function for querying if rx_thresh has been set.
	* @return true if rx_thresh is set.
	*/
	bool has_rx_thresh() const;
	//! Function to reset rx_thresh to its default/unset value.
	void clear_rx_thresh();
	//! Get value of rx_thresh.
	uint8_t rx_thresh() const;
	//! Set rx_thresh using a constant reference
	void set_rx_thresh(uint8_t v);
	/*!
	* Provide mutable access to rx_thresh.
	* @return pointer to member variable of rx_thresh.
	*/
	uint8_t *mutable_rx_thresh();
	
	// optional unsigned tx_bufsize, id 6
	/*!
	* Function for querying if tx_bufsize has been set.
	* @return true if tx_bufsize is set.
	*/
	bool has_tx_bufsize() const;
	//! Function to reset tx_bufsize to its default/unset value.
	void clear_tx_bufsize();
	//! Get value of tx_bufsize.
	uint32_t tx_bufsize() const;
	//! Set tx_bufsize using a constant reference
	void set_tx_bufsize(uint32_t v);
	/*!
	* Provide mutable access to tx_bufsize.
	* @return pointer to member variable of tx_bufsize.
	*/
	uint32_t *mutable_tx_bufsize();
	
	// optional unsigned rx_bufsize, id 7
	/*!
	* Function for querying if rx_bufsize has been set.
	* @return true if rx_bufsize is set.
	*/
	bool has_rx_bufsize() const;
	//! Function to reset rx_bufsize to its default/unset value.
	void clear_rx_bufsize();
	//! Get value of rx_bufsize.
	uint32_t rx_bufsize() const;
	//! Set rx_bufsize using a constant reference
	void set_rx_bufsize(uint32_t v);
	/*!
	* Provide mutable access to rx_bufsize.
	* @return pointer to member variable of rx_bufsize.
	*/
	uint32_t *mutable_rx_bufsize();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! unsigned baudrate, id 2
	uint32_t m_baudrate = 115200;
	//! unsigned tx_bufsize, id 6
	uint32_t m_tx_bufsize = 0;
	//! unsigned rx_bufsize, id 7
	uint32_t m_rx_bufsize = 0;
	//! uartcfg_t config, id 3
	uartcfg_t m_config = 5;
	//! sint8 port, id 1
	int8_t m_port = -1;
	//! fixed8 rx_thresh, id 4
	uint8_t m_rx_thresh = 0;
	
	private:
	uint8_t p_validbits = 0;
};




class FtpHttpConfig : public Message
{
	public:
	FtpHttpConfig()
	{
	}
	
	bool operator != (const FtpHttpConfig &r) const;
	bool operator == (const FtpHttpConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional fixed16 port, id 1
	/*!
	* Function for querying if port has been set.
	* @return true if port is set.
	*/
	bool has_port() const;
	//! Function to reset port to its default/unset value.
	void clear_port();
	//! Get value of port.
	uint16_t port() const;
	//! Set port using a constant reference
	void set_port(uint16_t v);
	/*!
	* Provide mutable access to port.
	* @return pointer to member variable of port.
	*/
	uint16_t *mutable_port();
	
	// optional bool start, id 2
	/*!
	* Function for querying if start has been set.
	* @return true if start is set.
	*/
	bool has_start() const;
	//! Function to reset start to its default/unset value.
	void clear_start();
	//! Get value of start.
	bool start() const;
	//! Set start using a constant reference
	void set_start(bool v);
	/*!
	* Provide mutable access to start.
	* @return pointer to member variable of start.
	*/
	bool *mutable_start();
	
	// optional string root, id 3
	/*!
	* Function for querying if root has been set.
	* @return true if root is set.
	*/
	bool has_root() const;
	//! Function to reset root to its default/unset value.
	void clear_root();
	//! Get value of root.
	const estring &root() const;
	/*!
	* Function for setting root using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_root(const void *data, size_t s);
	//! Set root using a constant reference
	void set_root(const estring &v);
	//! Set root using a pointer to a null-terminated C-string.
	void set_root(const char *);
	/*!
	* Provide mutable access to root.
	* @return pointer to member variable of root.
	*/
	estring *mutable_root();
	
	// optional string uploaddir, id 4
	/*!
	* Function for querying if uploaddir has been set.
	* @return true if uploaddir is set.
	*/
	bool has_uploaddir() const;
	//! Function to reset uploaddir to its default/unset value.
	void clear_uploaddir();
	//! Get value of uploaddir.
	const estring &uploaddir() const;
	/*!
	* Function for setting uploaddir using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_uploaddir(const void *data, size_t s);
	//! Set uploaddir using a constant reference
	void set_uploaddir(const estring &v);
	//! Set uploaddir using a pointer to a null-terminated C-string.
	void set_uploaddir(const char *);
	/*!
	* Provide mutable access to uploaddir.
	* @return pointer to member variable of uploaddir.
	*/
	estring *mutable_uploaddir();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string root, id 3
	estring m_root;
	//! string uploaddir, id 4
	estring m_uploaddir;
	//! fixed16 port, id 1
	uint16_t m_port = 0;
	//! bool start, id 2
	bool m_start = true;
	
	private:
	uint8_t p_validbits = 0;
};




class TerminalConfig : public Message
{
	public:
	TerminalConfig()
	{
	}
	
	bool operator != (const TerminalConfig &r) const;
	bool operator == (const TerminalConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional sint8 uart_rx, id 1
	/*!
	* Function for querying if uart_rx has been set.
	* @return true if uart_rx is set.
	*/
	bool has_uart_rx() const;
	//! Function to reset uart_rx to its default/unset value.
	void clear_uart_rx();
	//! Get value of uart_rx.
	int8_t uart_rx() const;
	//! Set uart_rx using a constant reference
	void set_uart_rx(int8_t v);
	/*!
	* Provide mutable access to uart_rx.
	* @return pointer to member variable of uart_rx.
	*/
	int8_t *mutable_uart_rx();
	
	// optional sint8 uart_tx, id 2
	/*!
	* Function for querying if uart_tx has been set.
	* @return true if uart_tx is set.
	*/
	bool has_uart_tx() const;
	//! Function to reset uart_tx to its default/unset value.
	void clear_uart_tx();
	//! Get value of uart_tx.
	int8_t uart_tx() const;
	//! Set uart_tx using a constant reference
	void set_uart_tx(int8_t v);
	/*!
	* Provide mutable access to uart_tx.
	* @return pointer to member variable of uart_tx.
	*/
	int8_t *mutable_uart_tx();
	
	// optional string name, id 3
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const estring &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const estring &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	estring *mutable_name();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 3
	estring m_name;
	//! sint8 uart_rx, id 1
	int8_t m_uart_rx = -1;
	//! sint8 uart_tx, id 2
	int8_t m_uart_tx = -1;
};




class Trigger : public Message
{
	public:
	Trigger()
	{
	}
	
	bool operator != (const Trigger &r) const;
	bool operator == (const Trigger &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string event, id 1
	/*!
	* Function for querying if event has been set.
	* @return true if event is set.
	*/
	bool has_event() const;
	//! Function to reset event to its default/unset value.
	void clear_event();
	//! Get value of event.
	const estring &event() const;
	/*!
	* Function for setting event using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_event(const void *data, size_t s);
	//! Set event using a constant reference
	void set_event(const estring &v);
	//! Set event using a pointer to a null-terminated C-string.
	void set_event(const char *);
	/*!
	* Provide mutable access to event.
	* @return pointer to member variable of event.
	*/
	estring *mutable_event();
	
	// repeated string action, id 2
	//! Function get const-access to the elements of action.
	const std::vector<estring> &action() const;
	//! Function to get the number of elements in action.
	size_t action_size() const;
	/*!
	* Function to append a element to action.
	* @return point to newly added element.
	*/
	void add_action(const estring &v);
	//! Function to append an element to action initialized by a C-string.
	void add_action(const char*);
	//! Function to reset action to its default/unset value.
	void clear_action();
	//! Get value of element x of action.
	const estring &action(unsigned x) const;
	//! Set action using a constant reference
	void set_action(unsigned x, const estring &v);
	/*!
	* Provide mutable access to action.
	* @return pointer to member variable of action.
	*/
	estring *mutable_action(unsigned x);
	//! Function to get mutable access to all elements of action.
	std::vector<estring> *mutable_action();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string event, id 1
	estring m_event;
	//! string action, id 2
	std::vector<estring> m_action;
};




class AppParam : public Message
{
	public:
	AppParam()
	{
	}
	
	bool operator != (const AppParam &r) const;
	bool operator == (const AppParam &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string key, id 1
	/*!
	* Function for querying if key has been set.
	* @return true if key is set.
	*/
	bool has_key() const;
	//! Function to reset key to its default/unset value.
	void clear_key();
	//! Get value of key.
	const estring &key() const;
	/*!
	* Function for setting key using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_key(const void *data, size_t s);
	//! Set key using a constant reference
	void set_key(const estring &v);
	//! Set key using a pointer to a null-terminated C-string.
	void set_key(const char *);
	/*!
	* Provide mutable access to key.
	* @return pointer to member variable of key.
	*/
	estring *mutable_key();
	
	// optional unsigned uValue, id 2
	/*!
	* Function for querying if uValue has been set.
	* @return true if uValue is set.
	*/
	bool has_uValue() const;
	//! Function to reset uValue to its default/unset value.
	void clear_uValue();
	//! Get value of uValue.
	uint32_t uValue() const;
	//! Set uValue using a constant reference
	void set_uValue(uint32_t v);
	/*!
	* Provide mutable access to uValue.
	* @return pointer to member variable of uValue.
	*/
	uint32_t *mutable_uValue();
	
	// optional string sValue, id 3
	/*!
	* Function for querying if sValue has been set.
	* @return true if sValue is set.
	*/
	bool has_sValue() const;
	//! Function to reset sValue to its default/unset value.
	void clear_sValue();
	//! Get value of sValue.
	const estring &sValue() const;
	/*!
	* Function for setting sValue using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_sValue(const void *data, size_t s);
	//! Set sValue using a constant reference
	void set_sValue(const estring &v);
	//! Set sValue using a pointer to a null-terminated C-string.
	void set_sValue(const char *);
	/*!
	* Provide mutable access to sValue.
	* @return pointer to member variable of sValue.
	*/
	estring *mutable_sValue();
	
	// optional signed dValue, id 4
	/*!
	* Function for querying if dValue has been set.
	* @return true if dValue is set.
	*/
	bool has_dValue() const;
	//! Function to reset dValue to its default/unset value.
	void clear_dValue();
	//! Get value of dValue.
	int32_t dValue() const;
	//! Set dValue using a constant reference
	void set_dValue(int32_t v);
	/*!
	* Provide mutable access to dValue.
	* @return pointer to member variable of dValue.
	*/
	int32_t *mutable_dValue();
	
	// optional double fValue, id 5
	/*!
	* Function for querying if fValue has been set.
	* @return true if fValue is set.
	*/
	bool has_fValue() const;
	//! Function to reset fValue to its default/unset value.
	void clear_fValue();
	//! Get value of fValue.
	double fValue() const;
	//! Set fValue using a constant reference
	void set_fValue(double v);
	/*!
	* Provide mutable access to fValue.
	* @return pointer to member variable of fValue.
	*/
	double *mutable_fValue();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string key, id 1
	estring m_key;
	//! string sValue, id 3
	estring m_sValue;
	//! double fValue, id 5
	double m_fValue = 0;
	//! unsigned uValue, id 2
	uint32_t m_uValue = 0;
	//! signed dValue, id 4
	int32_t m_dValue = 0;
	
	private:
	uint8_t p_validbits = 0;
};




class EventTimer : public Message
{
	public:
	EventTimer()
	{
	}
	
	bool operator != (const EventTimer &r) const;
	bool operator == (const EventTimer &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const estring &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const estring &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	estring *mutable_name();
	
	// optional unsigned time, id 2
	/*!
	* Function for querying if time has been set.
	* @return true if time is set.
	*/
	bool has_time() const;
	//! Function to reset time to its default/unset value.
	void clear_time();
	//! Get value of time.
	uint32_t time() const;
	//! Set time using a constant reference
	void set_time(uint32_t v);
	/*!
	* Provide mutable access to time.
	* @return pointer to member variable of time.
	*/
	uint32_t *mutable_time();
	
	// optional eventcfg_t config, id 3
	/*!
	* Function for querying if config has been set.
	* @return true if config is set.
	*/
	bool has_config() const;
	//! Function to reset config to its default/unset value.
	void clear_config();
	//! Get value of config.
	eventcfg_t config() const;
	//! Function to get the restart part of bitset config.
	bool config_restart() const;
	//! Function to set the restart part of bitset config.
	void set_config_restart(bool);
	//! Function to get the autostart part of bitset config.
	bool config_autostart() const;
	//! Function to set the autostart part of bitset config.
	void set_config_autostart(bool);
	//! Set config using a constant reference
	void set_config(eventcfg_t v);
	/*!
	* Provide mutable access to config.
	* @return pointer to member variable of config.
	*/
	eventcfg_t *mutable_config();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	estring m_name;
	//! unsigned time, id 2
	uint32_t m_time = 0;
	//! eventcfg_t config, id 3
	eventcfg_t m_config = 0;
	
	private:
	uint8_t p_validbits = 0;
};




class FunctionConfig : public Message
{
	public:
	FunctionConfig()
	{
	}
	
	bool operator != (const FunctionConfig &r) const;
	bool operator == (const FunctionConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const estring &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const estring &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	estring *mutable_name();
	
	// optional string func, id 2
	/*!
	* Function for querying if func has been set.
	* @return true if func is set.
	*/
	bool has_func() const;
	//! Function to reset func to its default/unset value.
	void clear_func();
	//! Get value of func.
	const estring &func() const;
	/*!
	* Function for setting func using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_func(const void *data, size_t s);
	//! Set func using a constant reference
	void set_func(const estring &v);
	//! Set func using a pointer to a null-terminated C-string.
	void set_func(const char *);
	/*!
	* Provide mutable access to func.
	* @return pointer to member variable of func.
	*/
	estring *mutable_func();
	
	// repeated string params, id 3
	//! Function get const-access to the elements of params.
	const std::vector<estring> &params() const;
	//! Function to get the number of elements in params.
	size_t params_size() const;
	/*!
	* Function to append a element to params.
	* @return point to newly added element.
	*/
	void add_params(const estring &v);
	//! Function to append an element to params initialized by a C-string.
	void add_params(const char*);
	//! Function to reset params to its default/unset value.
	void clear_params();
	//! Get value of element x of params.
	const estring &params(unsigned x) const;
	//! Set params using a constant reference
	void set_params(unsigned x, const estring &v);
	/*!
	* Provide mutable access to params.
	* @return pointer to member variable of params.
	*/
	estring *mutable_params(unsigned x);
	//! Function to get mutable access to all elements of params.
	std::vector<estring> *mutable_params();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	estring m_name;
	//! string func, id 2
	estring m_func;
	//! string params, id 3
	std::vector<estring> m_params;
};




class SignalConfig : public Message
{
	public:
	SignalConfig()
	{
	}
	
	bool operator != (const SignalConfig &r) const;
	bool operator == (const SignalConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const estring &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const estring &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	estring *mutable_name();
	
	// optional sigtype_t type, id 2
	/*!
	* Function for querying if type has been set.
	* @return true if type is set.
	*/
	bool has_type() const;
	//! Function to reset type to its default/unset value.
	void clear_type();
	//! Get value of type.
	sigtype_t type() const;
	//! Set type using a constant reference
	void set_type(sigtype_t v);
	/*!
	* Provide mutable access to type.
	* @return pointer to member variable of type.
	*/
	sigtype_t *mutable_type();
	
	// optional string iv, id 3
	/*!
	* Function for querying if iv has been set.
	* @return true if iv is set.
	*/
	bool has_iv() const;
	//! Function to reset iv to its default/unset value.
	void clear_iv();
	//! Get value of iv.
	const estring &iv() const;
	/*!
	* Function for setting iv using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_iv(const void *data, size_t s);
	//! Set iv using a constant reference
	void set_iv(const estring &v);
	//! Set iv using a pointer to a null-terminated C-string.
	void set_iv(const char *);
	/*!
	* Provide mutable access to iv.
	* @return pointer to member variable of iv.
	*/
	estring *mutable_iv();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	estring m_name;
	//! string iv, id 3
	estring m_iv;
	//! sigtype_t type, id 2
	sigtype_t m_type = st_invalid;
};




class OwDeviceConfig : public Message
{
	public:
	OwDeviceConfig()
	{
	}
	
	bool operator != (const OwDeviceConfig &r) const;
	bool operator == (const OwDeviceConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional fixed64 id, id 1
	/*!
	* Function for querying if id has been set.
	* @return true if id is set.
	*/
	bool has_id() const;
	//! Function to reset id to its default/unset value.
	void clear_id();
	//! Get value of id.
	uint64_t id() const;
	//! Set id using a constant reference
	void set_id(uint64_t v);
	/*!
	* Provide mutable access to id.
	* @return pointer to member variable of id.
	*/
	uint64_t *mutable_id();
	
	// optional string name, id 2
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const estring &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const estring &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	estring *mutable_name();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 2
	estring m_name;
	//! fixed64 id, id 1
	uint64_t m_id = 0;
	
	private:
	uint8_t p_validbits = 0;
};




class StateConfig : public Message
{
	public:
	StateConfig()
	{
	}
	
	bool operator != (const StateConfig &r) const;
	bool operator == (const StateConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const estring &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const estring &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	estring *mutable_name();
	
	// repeated Trigger conds, id 2
	//! Function get const-access to the elements of conds.
	const std::vector<Trigger> &conds() const;
	//! Function to get the number of elements in conds.
	size_t conds_size() const;
	/*!
	* Function to append a element to conds.
	* @return point to newly added element.
	*/
	Trigger* add_conds();
	//! Function to reset conds to its default/unset value.
	void clear_conds();
	//! Get value of element x of conds.
	const Trigger &conds(unsigned x) const;
	//! Set conds using a constant reference
	void set_conds(unsigned x, const Trigger &v);
	/*!
	* Provide mutable access to conds.
	* @return pointer to member variable of conds.
	*/
	Trigger *mutable_conds(unsigned x);
	//! Function to get mutable access to all elements of conds.
	std::vector<Trigger> *mutable_conds();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	estring m_name;
	//! Trigger conds, id 2
	std::vector<Trigger> m_conds;
};




class StateMachineConfig : public Message
{
	public:
	StateMachineConfig()
	{
	}
	
	bool operator != (const StateMachineConfig &r) const;
	bool operator == (const StateMachineConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const estring &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const estring &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	estring *mutable_name();
	
	// optional uint8 ini_st, id 2
	/*!
	* Function for querying if ini_st has been set.
	* @return true if ini_st is set.
	*/
	bool has_ini_st() const;
	//! Function to reset ini_st to its default/unset value.
	void clear_ini_st();
	//! Get value of ini_st.
	uint8_t ini_st() const;
	//! Set ini_st using a constant reference
	void set_ini_st(uint8_t v);
	/*!
	* Provide mutable access to ini_st.
	* @return pointer to member variable of ini_st.
	*/
	uint8_t *mutable_ini_st();
	
	// repeated StateConfig states, id 3
	//! Function get const-access to the elements of states.
	const std::vector<StateConfig> &states() const;
	//! Function to get the number of elements in states.
	size_t states_size() const;
	/*!
	* Function to append a element to states.
	* @return point to newly added element.
	*/
	StateConfig* add_states();
	//! Function to reset states to its default/unset value.
	void clear_states();
	//! Get value of element x of states.
	const StateConfig &states(unsigned x) const;
	//! Set states using a constant reference
	void set_states(unsigned x, const StateConfig &v);
	/*!
	* Provide mutable access to states.
	* @return pointer to member variable of states.
	*/
	StateConfig *mutable_states(unsigned x);
	//! Function to get mutable access to all elements of states.
	std::vector<StateConfig> *mutable_states();
	
	// optional bool persistent, id 4
	/*!
	* Function for querying if persistent has been set.
	* @return true if persistent is set.
	*/
	bool has_persistent() const;
	//! Function to reset persistent to its default/unset value.
	void clear_persistent();
	//! Get value of persistent.
	bool persistent() const;
	//! Set persistent using a constant reference
	void set_persistent(bool v);
	/*!
	* Provide mutable access to persistent.
	* @return pointer to member variable of persistent.
	*/
	bool *mutable_persistent();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	estring m_name;
	//! uint8 ini_st, id 2
	uint8_t m_ini_st = 0;
	//! bool persistent, id 4
	bool m_persistent = false;
	//! StateConfig states, id 3
	std::vector<StateConfig> m_states;
	
	private:
	uint8_t p_validbits = 0;
};




class ThresholdConfig : public Message
{
	public:
	ThresholdConfig()
	{
	}
	
	bool operator != (const ThresholdConfig &r) const;
	bool operator == (const ThresholdConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string name, id 1
	/*!
	* Function for querying if name has been set.
	* @return true if name is set.
	*/
	bool has_name() const;
	//! Function to reset name to its default/unset value.
	void clear_name();
	//! Get value of name.
	const estring &name() const;
	/*!
	* Function for setting name using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_name(const void *data, size_t s);
	//! Set name using a constant reference
	void set_name(const estring &v);
	//! Set name using a pointer to a null-terminated C-string.
	void set_name(const char *);
	/*!
	* Provide mutable access to name.
	* @return pointer to member variable of name.
	*/
	estring *mutable_name();
	
	// optional float low, id 2
	/*!
	* Function for querying if low has been set.
	* @return true if low is set.
	*/
	bool has_low() const;
	//! Function to reset low to its default/unset value.
	void clear_low();
	//! Get value of low.
	float low() const;
	//! Set low using a constant reference
	void set_low(float v);
	/*!
	* Provide mutable access to low.
	* @return pointer to member variable of low.
	*/
	float *mutable_low();
	
	// optional float high, id 3
	/*!
	* Function for querying if high has been set.
	* @return true if high is set.
	*/
	bool has_high() const;
	//! Function to reset high to its default/unset value.
	void clear_high();
	//! Get value of high.
	float high() const;
	//! Set high using a constant reference
	void set_high(float v);
	/*!
	* Provide mutable access to high.
	* @return pointer to member variable of high.
	*/
	float *mutable_high();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string name, id 1
	estring m_name;
	//! float low, id 2
	float m_low = 0;
	//! float high, id 3
	float m_high = 0;
	
	private:
	uint8_t p_validbits = 0;
};




class EnvConfig : public Message
{
	public:
	EnvConfig()
	{
	}
	
	bool operator != (const EnvConfig &r) const;
	bool operator == (const EnvConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional string path, id 1
	/*!
	* Function for querying if path has been set.
	* @return true if path is set.
	*/
	bool has_path() const;
	//! Function to reset path to its default/unset value.
	void clear_path();
	//! Get value of path.
	const estring &path() const;
	/*!
	* Function for setting path using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_path(const void *data, size_t s);
	//! Set path using a constant reference
	void set_path(const estring &v);
	//! Set path using a pointer to a null-terminated C-string.
	void set_path(const char *);
	/*!
	* Provide mutable access to path.
	* @return pointer to member variable of path.
	*/
	estring *mutable_path();
	
	// optional string title, id 2
	/*!
	* Function for querying if title has been set.
	* @return true if title is set.
	*/
	bool has_title() const;
	//! Function to reset title to its default/unset value.
	void clear_title();
	//! Get value of title.
	const estring &title() const;
	/*!
	* Function for setting title using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_title(const void *data, size_t s);
	//! Set title using a constant reference
	void set_title(const estring &v);
	//! Set title using a pointer to a null-terminated C-string.
	void set_title(const char *);
	/*!
	* Provide mutable access to title.
	* @return pointer to member variable of title.
	*/
	estring *mutable_title();
	
	// optional string action, id 3
	/*!
	* Function for querying if action has been set.
	* @return true if action is set.
	*/
	bool has_action() const;
	//! Function to reset action to its default/unset value.
	void clear_action();
	//! Get value of action.
	const estring &action() const;
	/*!
	* Function for setting action using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_action(const void *data, size_t s);
	//! Set action using a constant reference
	void set_action(const estring &v);
	//! Set action using a pointer to a null-terminated C-string.
	void set_action(const char *);
	/*!
	* Provide mutable access to action.
	* @return pointer to member variable of action.
	*/
	estring *mutable_action();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string path, id 1
	estring m_path;
	//! string title, id 2
	estring m_title;
	//! string action, id 3
	estring m_action;
};




class ScreenConfig : public Message
{
	public:
	ScreenConfig()
	{
	}
	
	bool operator != (const ScreenConfig &r) const;
	bool operator == (const ScreenConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// repeated EnvConfig envs, id 1
	//! Function get const-access to the elements of envs.
	const std::vector<EnvConfig> &envs() const;
	//! Function to get the number of elements in envs.
	size_t envs_size() const;
	/*!
	* Function to append a element to envs.
	* @return point to newly added element.
	*/
	EnvConfig* add_envs();
	//! Function to reset envs to its default/unset value.
	void clear_envs();
	//! Get value of element x of envs.
	const EnvConfig &envs(unsigned x) const;
	//! Set envs using a constant reference
	void set_envs(unsigned x, const EnvConfig &v);
	/*!
	* Provide mutable access to envs.
	* @return pointer to member variable of envs.
	*/
	EnvConfig *mutable_envs(unsigned x);
	//! Function to get mutable access to all elements of envs.
	std::vector<EnvConfig> *mutable_envs();
	
	// optional string font_tiny, id 4
	/*!
	* Function for querying if font_tiny has been set.
	* @return true if font_tiny is set.
	*/
	bool has_font_tiny() const;
	//! Function to reset font_tiny to its default/unset value.
	void clear_font_tiny();
	//! Get value of font_tiny.
	const estring &font_tiny() const;
	/*!
	* Function for setting font_tiny using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_font_tiny(const void *data, size_t s);
	//! Set font_tiny using a constant reference
	void set_font_tiny(const estring &v);
	//! Set font_tiny using a pointer to a null-terminated C-string.
	void set_font_tiny(const char *);
	/*!
	* Provide mutable access to font_tiny.
	* @return pointer to member variable of font_tiny.
	*/
	estring *mutable_font_tiny();
	
	// optional string font_small, id 5
	/*!
	* Function for querying if font_small has been set.
	* @return true if font_small is set.
	*/
	bool has_font_small() const;
	//! Function to reset font_small to its default/unset value.
	void clear_font_small();
	//! Get value of font_small.
	const estring &font_small() const;
	/*!
	* Function for setting font_small using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_font_small(const void *data, size_t s);
	//! Set font_small using a constant reference
	void set_font_small(const estring &v);
	//! Set font_small using a pointer to a null-terminated C-string.
	void set_font_small(const char *);
	/*!
	* Provide mutable access to font_small.
	* @return pointer to member variable of font_small.
	*/
	estring *mutable_font_small();
	
	// optional string font_medium, id 6
	/*!
	* Function for querying if font_medium has been set.
	* @return true if font_medium is set.
	*/
	bool has_font_medium() const;
	//! Function to reset font_medium to its default/unset value.
	void clear_font_medium();
	//! Get value of font_medium.
	const estring &font_medium() const;
	/*!
	* Function for setting font_medium using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_font_medium(const void *data, size_t s);
	//! Set font_medium using a constant reference
	void set_font_medium(const estring &v);
	//! Set font_medium using a pointer to a null-terminated C-string.
	void set_font_medium(const char *);
	/*!
	* Provide mutable access to font_medium.
	* @return pointer to member variable of font_medium.
	*/
	estring *mutable_font_medium();
	
	// optional string font_large, id 7
	/*!
	* Function for querying if font_large has been set.
	* @return true if font_large is set.
	*/
	bool has_font_large() const;
	//! Function to reset font_large to its default/unset value.
	void clear_font_large();
	//! Get value of font_large.
	const estring &font_large() const;
	/*!
	* Function for setting font_large using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_font_large(const void *data, size_t s);
	//! Set font_large using a constant reference
	void set_font_large(const estring &v);
	//! Set font_large using a pointer to a null-terminated C-string.
	void set_font_large(const char *);
	/*!
	* Provide mutable access to font_large.
	* @return pointer to member variable of font_large.
	*/
	estring *mutable_font_large();
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string font_tiny, id 4
	estring m_font_tiny;
	//! string font_small, id 5
	estring m_font_small;
	//! string font_medium, id 6
	estring m_font_medium;
	//! string font_large, id 7
	estring m_font_large;
	//! EnvConfig envs, id 1
	std::vector<EnvConfig> m_envs;
};




class NodeConfig : public Message
{
	public:
	NodeConfig()
	{
	}
	
	bool operator != (const NodeConfig &r) const;
	bool operator == (const NodeConfig &r) const;
	
	//! Function for resetting all members to their default values.
	void clear();
	
	/*!
	* Calculates the required number of bytes for serializing this object.
	* If member variables of the object are modified, the number of bytes
	* needed for serialization may change, too.
	* @return bytes needed for a serialized object representation
	*/
	size_t calcSize() const;
	
	/*!
	* Function for parsing serialized data and update this object accordingly.
	* Member variables that are not in the serialized data are not reset.
	* @param b buffer of serialized data
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully parsed (can be < s)
	*         or a negative value indicating the error encountered
	*/
	ssize_t fromMemory(const void *b, ssize_t s);
	
	/*!
	* Function for serializing the object to memory.
	* @param b buffer to serialize the object to
	* @param s number of bytes available in the buffer
	* @return number of bytes successfully serialized
	*/
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	/*!
	* Function for writing a JSON representation of this object to a stream.
	* @param json stream object the JSON output shall be written to
	* @indLvl current indention level
	*/
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	/*!
	* Function for writing an ASCII representation of this object to a stream.
	* @param o output stream
	* @param indent initial indention level
	*/
	void toASCII(stream &o, size_t indent = 0) const;
	
	/*!
	* Function for determining the maximum size that the object may need for
	* its serialized representation
	* @return maximum number of bytes or SIZE_MAX if no limit can be determined
	*/
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// optional fixed32 magic, id 0
	/*!
	* Function for querying if magic has been set.
	* @return true if magic is set.
	*/
	bool has_magic() const;
	//! Function to reset magic to its default/unset value.
	void clear_magic();
	//! Get value of magic.
	uint32_t magic() const;
	//! Set magic using a constant reference
	void set_magic(uint32_t v);
	/*!
	* Provide mutable access to magic.
	* @return pointer to member variable of magic.
	*/
	uint32_t *mutable_magic();
	
	// optional string nodename, id 1
	/*!
	* Function for querying if nodename has been set.
	* @return true if nodename is set.
	*/
	bool has_nodename() const;
	//! Function to reset nodename to its default/unset value.
	void clear_nodename();
	//! Get value of nodename.
	const estring &nodename() const;
	/*!
	* Function for setting nodename using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_nodename(const void *data, size_t s);
	//! Set nodename using a constant reference
	void set_nodename(const estring &v);
	//! Set nodename using a pointer to a null-terminated C-string.
	void set_nodename(const char *);
	/*!
	* Provide mutable access to nodename.
	* @return pointer to member variable of nodename.
	*/
	estring *mutable_nodename();
	
	// optional bytes pass_hash, id 2
	/*!
	* Function for querying if pass_hash has been set.
	* @return true if pass_hash is set.
	*/
	bool has_pass_hash() const;
	//! Function to reset pass_hash to its default/unset value.
	void clear_pass_hash();
	//! Get value of pass_hash.
	const estring &pass_hash() const;
	/*!
	* Function for setting pass_hash using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_pass_hash(const void *data, size_t s);
	//! Set pass_hash using a constant reference
	void set_pass_hash(const estring &v);
	/*!
	* Provide mutable access to pass_hash.
	* @return pointer to member variable of pass_hash.
	*/
	estring *mutable_pass_hash();
	
	// optional unsigned cpu_freq, id 3
	/*!
	* Function for querying if cpu_freq has been set.
	* @return true if cpu_freq is set.
	*/
	bool has_cpu_freq() const;
	//! Function to reset cpu_freq to its default/unset value.
	void clear_cpu_freq();
	//! Get value of cpu_freq.
	uint32_t cpu_freq() const;
	//! Set cpu_freq using a constant reference
	void set_cpu_freq(uint32_t v);
	/*!
	* Provide mutable access to cpu_freq.
	* @return pointer to member variable of cpu_freq.
	*/
	uint32_t *mutable_cpu_freq();
	
	// optional WifiConfig station, id 4
	/*!
	* Function for querying if station has been set.
	* @return true if station is set.
	*/
	bool has_station() const;
	//! Function to reset station to its default/unset value.
	void clear_station();
	//! Get value of station.
	const WifiConfig &station() const;
	/*!
	* Function for setting members of station using data from a serialized object.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_station(const void *data, size_t s);
	//! Set station using a constant reference
	void set_station(const WifiConfig &v);
	/*!
	* Provide mutable access to station.
	* @return pointer to member variable of station.
	*/
	WifiConfig *mutable_station();
	
	// optional WifiConfig softap, id 5
	/*!
	* Function for querying if softap has been set.
	* @return true if softap is set.
	*/
	bool has_softap() const;
	//! Function to reset softap to its default/unset value.
	void clear_softap();
	//! Get value of softap.
	const WifiConfig &softap() const;
	/*!
	* Function for setting members of softap using data from a serialized object.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_softap(const void *data, size_t s);
	//! Set softap using a constant reference
	void set_softap(const WifiConfig &v);
	/*!
	* Provide mutable access to softap.
	* @return pointer to member variable of softap.
	*/
	WifiConfig *mutable_softap();
	
	// repeated string dns_server, id 6
	//! Function get const-access to the elements of dns_server.
	const std::vector<estring> &dns_server() const;
	//! Function to get the number of elements in dns_server.
	size_t dns_server_size() const;
	/*!
	* Function to append a element to dns_server.
	* @return point to newly added element.
	*/
	void add_dns_server(const estring &v);
	//! Function to append an element to dns_server initialized by a C-string.
	void add_dns_server(const char*);
	//! Function to reset dns_server to its default/unset value.
	void clear_dns_server();
	//! Get value of element x of dns_server.
	const estring &dns_server(unsigned x) const;
	//! Set dns_server using a constant reference
	void set_dns_server(unsigned x, const estring &v);
	/*!
	* Provide mutable access to dns_server.
	* @return pointer to member variable of dns_server.
	*/
	estring *mutable_dns_server(unsigned x);
	//! Function to get mutable access to all elements of dns_server.
	std::vector<estring> *mutable_dns_server();
	
	// optional string syslog_host, id 7
	/*!
	* Function for querying if syslog_host has been set.
	* @return true if syslog_host is set.
	*/
	bool has_syslog_host() const;
	//! Function to reset syslog_host to its default/unset value.
	void clear_syslog_host();
	//! Get value of syslog_host.
	const estring &syslog_host() const;
	/*!
	* Function for setting syslog_host using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_syslog_host(const void *data, size_t s);
	//! Set syslog_host using a constant reference
	void set_syslog_host(const estring &v);
	//! Set syslog_host using a pointer to a null-terminated C-string.
	void set_syslog_host(const char *);
	/*!
	* Provide mutable access to syslog_host.
	* @return pointer to member variable of syslog_host.
	*/
	estring *mutable_syslog_host();
	
	// optional string sntp_server, id 8
	/*!
	* Function for querying if sntp_server has been set.
	* @return true if sntp_server is set.
	*/
	bool has_sntp_server() const;
	//! Function to reset sntp_server to its default/unset value.
	void clear_sntp_server();
	//! Get value of sntp_server.
	const estring &sntp_server() const;
	/*!
	* Function for setting sntp_server using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_sntp_server(const void *data, size_t s);
	//! Set sntp_server using a constant reference
	void set_sntp_server(const estring &v);
	//! Set sntp_server using a pointer to a null-terminated C-string.
	void set_sntp_server(const char *);
	/*!
	* Provide mutable access to sntp_server.
	* @return pointer to member variable of sntp_server.
	*/
	estring *mutable_sntp_server();
	
	// optional string timezone, id 9
	/*!
	* Function for querying if timezone has been set.
	* @return true if timezone is set.
	*/
	bool has_timezone() const;
	//! Function to reset timezone to its default/unset value.
	void clear_timezone();
	//! Get value of timezone.
	const estring &timezone() const;
	/*!
	* Function for setting timezone using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_timezone(const void *data, size_t s);
	//! Set timezone using a constant reference
	void set_timezone(const estring &v);
	//! Set timezone using a pointer to a null-terminated C-string.
	void set_timezone(const char *);
	/*!
	* Provide mutable access to timezone.
	* @return pointer to member variable of timezone.
	*/
	estring *mutable_timezone();
	
	#ifdef CONFIG_MQTT
	// optional MQTT mqtt, id 10
	/*!
	* Function for querying if mqtt has been set.
	* @return true if mqtt is set.
	*/
	bool has_mqtt() const;
	//! Function to reset mqtt to its default/unset value.
	void clear_mqtt();
	//! Get value of mqtt.
	const MQTT &mqtt() const;
	/*!
	* Function for setting mqtt using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_mqtt(const void *data, size_t s);
	//! Set mqtt using a constant reference
	void set_mqtt(const MQTT &v);
	/*!
	* Provide mutable access to mqtt.
	* @return pointer to member variable of mqtt.
	*/
	MQTT *mutable_mqtt();
	#endif // CONFIG_MQTT
	
	// optional fixed16 dmesg_size, id 11
	/*!
	* Function for querying if dmesg_size has been set.
	* @return true if dmesg_size is set.
	*/
	bool has_dmesg_size() const;
	//! Function to reset dmesg_size to its default/unset value.
	void clear_dmesg_size();
	//! Get value of dmesg_size.
	uint16_t dmesg_size() const;
	//! Set dmesg_size using a constant reference
	void set_dmesg_size(uint16_t v);
	/*!
	* Provide mutable access to dmesg_size.
	* @return pointer to member variable of dmesg_size.
	*/
	uint16_t *mutable_dmesg_size();
	
	#ifdef CONFIG_INFLUX
	// optional Influx influx, id 12
	/*!
	* Function for querying if influx has been set.
	* @return true if influx is set.
	*/
	bool has_influx() const;
	//! Function to reset influx to its default/unset value.
	void clear_influx();
	//! Get value of influx.
	const Influx &influx() const;
	/*!
	* Function for setting influx using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_influx(const void *data, size_t s);
	//! Set influx using a constant reference
	void set_influx(const Influx &v);
	/*!
	* Provide mutable access to influx.
	* @return pointer to member variable of influx.
	*/
	Influx *mutable_influx();
	#endif // CONFIG_INFLUX
	
	// optional unsigned station2ap_time, id 13
	/*!
	* Function for querying if station2ap_time has been set.
	* @return true if station2ap_time is set.
	*/
	bool has_station2ap_time() const;
	//! Function to reset station2ap_time to its default/unset value.
	void clear_station2ap_time();
	//! Get value of station2ap_time.
	uint32_t station2ap_time() const;
	//! Set station2ap_time using a constant reference
	void set_station2ap_time(uint32_t v);
	/*!
	* Provide mutable access to station2ap_time.
	* @return pointer to member variable of station2ap_time.
	*/
	uint32_t *mutable_station2ap_time();
	
	// optional string domainname, id 15
	/*!
	* Function for querying if domainname has been set.
	* @return true if domainname is set.
	*/
	bool has_domainname() const;
	//! Function to reset domainname to its default/unset value.
	void clear_domainname();
	//! Get value of domainname.
	const estring &domainname() const;
	/*!
	* Function for setting domainname using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_domainname(const void *data, size_t s);
	//! Set domainname using a constant reference
	void set_domainname(const estring &v);
	//! Set domainname using a pointer to a null-terminated C-string.
	void set_domainname(const char *);
	/*!
	* Provide mutable access to domainname.
	* @return pointer to member variable of domainname.
	*/
	estring *mutable_domainname();
	
	// repeated Date holidays, id 16
	//! Function get const-access to the elements of holidays.
	const std::vector<Date> &holidays() const;
	//! Function to get the number of elements in holidays.
	size_t holidays_size() const;
	/*!
	* Function to append a element to holidays.
	* @return point to newly added element.
	*/
	Date* add_holidays();
	//! Function to reset holidays to its default/unset value.
	void clear_holidays();
	//! Get value of element x of holidays.
	const Date &holidays(unsigned x) const;
	//! Set holidays using a constant reference
	void set_holidays(unsigned x, const Date &v);
	/*!
	* Provide mutable access to holidays.
	* @return pointer to member variable of holidays.
	*/
	Date *mutable_holidays(unsigned x);
	//! Function to get mutable access to all elements of holidays.
	std::vector<Date> *mutable_holidays();
	
	// repeated AtAction at_actions, id 17
	//! Function get const-access to the elements of at_actions.
	const std::vector<AtAction> &at_actions() const;
	//! Function to get the number of elements in at_actions.
	size_t at_actions_size() const;
	/*!
	* Function to append a element to at_actions.
	* @return point to newly added element.
	*/
	AtAction* add_at_actions();
	//! Function to reset at_actions to its default/unset value.
	void clear_at_actions();
	//! Get value of element x of at_actions.
	const AtAction &at_actions(unsigned x) const;
	//! Set at_actions using a constant reference
	void set_at_actions(unsigned x, const AtAction &v);
	/*!
	* Provide mutable access to at_actions.
	* @return pointer to member variable of at_actions.
	*/
	AtAction *mutable_at_actions(unsigned x);
	//! Function to get mutable access to all elements of at_actions.
	std::vector<AtAction> *mutable_at_actions();
	
	// optional unsigned actions_enable, id 18
	/*!
	* Function for querying if actions_enable has been set.
	* @return true if actions_enable is set.
	*/
	bool has_actions_enable() const;
	//! Function to reset actions_enable to its default/unset value.
	void clear_actions_enable();
	//! Get value of actions_enable.
	uint32_t actions_enable() const;
	//! Set actions_enable using a constant reference
	void set_actions_enable(uint32_t v);
	/*!
	* Provide mutable access to actions_enable.
	* @return pointer to member variable of actions_enable.
	*/
	uint32_t *mutable_actions_enable();
	
	// repeated Trigger triggers, id 19
	//! Function get const-access to the elements of triggers.
	const std::vector<Trigger> &triggers() const;
	//! Function to get the number of elements in triggers.
	size_t triggers_size() const;
	/*!
	* Function to append a element to triggers.
	* @return point to newly added element.
	*/
	Trigger* add_triggers();
	//! Function to reset triggers to its default/unset value.
	void clear_triggers();
	//! Get value of element x of triggers.
	const Trigger &triggers(unsigned x) const;
	//! Set triggers using a constant reference
	void set_triggers(unsigned x, const Trigger &v);
	/*!
	* Provide mutable access to triggers.
	* @return pointer to member variable of triggers.
	*/
	Trigger *mutable_triggers(unsigned x);
	//! Function to get mutable access to all elements of triggers.
	std::vector<Trigger> *mutable_triggers();
	
	// repeated UartSettings uart, id 20
	//! Function get const-access to the elements of uart.
	const std::vector<UartSettings> &uart() const;
	//! Function to get the number of elements in uart.
	size_t uart_size() const;
	/*!
	* Function to append a element to uart.
	* @return point to newly added element.
	*/
	UartSettings* add_uart();
	//! Function to reset uart to its default/unset value.
	void clear_uart();
	//! Get value of element x of uart.
	const UartSettings &uart(unsigned x) const;
	//! Set uart using a constant reference
	void set_uart(unsigned x, const UartSettings &v);
	/*!
	* Provide mutable access to uart.
	* @return pointer to member variable of uart.
	*/
	UartSettings *mutable_uart(unsigned x);
	//! Function to get mutable access to all elements of uart.
	std::vector<UartSettings> *mutable_uart();
	
	#ifdef CONFIG_TERMSERV
	// repeated TerminalConfig terminal, id 21
	//! Function get const-access to the elements of terminal.
	const std::vector<TerminalConfig> &terminal() const;
	//! Function to get the number of elements in terminal.
	size_t terminal_size() const;
	/*!
	* Function to append a element to terminal.
	* @return point to newly added element.
	*/
	TerminalConfig* add_terminal();
	//! Function to reset terminal to its default/unset value.
	void clear_terminal();
	//! Get value of element x of terminal.
	const TerminalConfig &terminal(unsigned x) const;
	//! Set terminal using a constant reference
	void set_terminal(unsigned x, const TerminalConfig &v);
	/*!
	* Provide mutable access to terminal.
	* @return pointer to member variable of terminal.
	*/
	TerminalConfig *mutable_terminal(unsigned x);
	//! Function to get mutable access to all elements of terminal.
	std::vector<TerminalConfig> *mutable_terminal();
	#endif // CONFIG_TERMSERV
	
	// optional fixed16 udp_ctrl_port, id 22
	/*!
	* Function for querying if udp_ctrl_port has been set.
	* @return true if udp_ctrl_port is set.
	*/
	bool has_udp_ctrl_port() const;
	//! Function to reset udp_ctrl_port to its default/unset value.
	void clear_udp_ctrl_port();
	//! Get value of udp_ctrl_port.
	uint16_t udp_ctrl_port() const;
	//! Set udp_ctrl_port using a constant reference
	void set_udp_ctrl_port(uint16_t v);
	/*!
	* Provide mutable access to udp_ctrl_port.
	* @return pointer to member variable of udp_ctrl_port.
	*/
	uint16_t *mutable_udp_ctrl_port();
	
	// repeated string debugs, id 23
	//! Function get const-access to the elements of debugs.
	const std::vector<estring> &debugs() const;
	//! Function to get the number of elements in debugs.
	size_t debugs_size() const;
	/*!
	* Function to append a element to debugs.
	* @return point to newly added element.
	*/
	void add_debugs(const estring &v);
	//! Function to append an element to debugs initialized by a C-string.
	void add_debugs(const char*);
	//! Function to reset debugs to its default/unset value.
	void clear_debugs();
	//! Get value of element x of debugs.
	const estring &debugs(unsigned x) const;
	//! Set debugs using a constant reference
	void set_debugs(unsigned x, const estring &v);
	/*!
	* Provide mutable access to debugs.
	* @return pointer to member variable of debugs.
	*/
	estring *mutable_debugs(unsigned x);
	//! Function to get mutable access to all elements of debugs.
	std::vector<estring> *mutable_debugs();
	
	#ifdef CONFIG_FTP
	// optional FtpHttpConfig ftpd, id 24
	/*!
	* Function for querying if ftpd has been set.
	* @return true if ftpd is set.
	*/
	bool has_ftpd() const;
	//! Function to reset ftpd to its default/unset value.
	void clear_ftpd();
	//! Get value of ftpd.
	const FtpHttpConfig &ftpd() const;
	/*!
	* Function for setting ftpd using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_ftpd(const void *data, size_t s);
	//! Set ftpd using a constant reference
	void set_ftpd(const FtpHttpConfig &v);
	/*!
	* Provide mutable access to ftpd.
	* @return pointer to member variable of ftpd.
	*/
	FtpHttpConfig *mutable_ftpd();
	#endif // CONFIG_FTP
	
	#ifdef CONFIG_HTTP
	// optional FtpHttpConfig httpd, id 25
	/*!
	* Function for querying if httpd has been set.
	* @return true if httpd is set.
	*/
	bool has_httpd() const;
	//! Function to reset httpd to its default/unset value.
	void clear_httpd();
	//! Get value of httpd.
	const FtpHttpConfig &httpd() const;
	/*!
	* Function for setting httpd using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_httpd(const void *data, size_t s);
	//! Set httpd using a constant reference
	void set_httpd(const FtpHttpConfig &v);
	/*!
	* Provide mutable access to httpd.
	* @return pointer to member variable of httpd.
	*/
	FtpHttpConfig *mutable_httpd();
	#endif // CONFIG_HTTP
	
	// optional string otasrv, id 26
	/*!
	* Function for querying if otasrv has been set.
	* @return true if otasrv is set.
	*/
	bool has_otasrv() const;
	//! Function to reset otasrv to its default/unset value.
	void clear_otasrv();
	//! Get value of otasrv.
	const estring &otasrv() const;
	/*!
	* Function for setting otasrv using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_otasrv(const void *data, size_t s);
	//! Set otasrv using a constant reference
	void set_otasrv(const estring &v);
	//! Set otasrv using a pointer to a null-terminated C-string.
	void set_otasrv(const char *);
	/*!
	* Provide mutable access to otasrv.
	* @return pointer to member variable of otasrv.
	*/
	estring *mutable_otasrv();
	
	#ifdef CONFIG_DISPLAY
	// optional ScreenConfig screen, id 27
	/*!
	* Function for querying if screen has been set.
	* @return true if screen is set.
	*/
	bool has_screen() const;
	//! Function to reset screen to its default/unset value.
	void clear_screen();
	//! Get value of screen.
	const ScreenConfig &screen() const;
	/*!
	* Function for setting screen using binary data.
	* @param data pointer to binary data
	* @param s number of bytes at data pointer
	*/
	void set_screen(const void *data, size_t s);
	//! Set screen using a constant reference
	void set_screen(const ScreenConfig &v);
	/*!
	* Provide mutable access to screen.
	* @return pointer to member variable of screen.
	*/
	ScreenConfig *mutable_screen();
	#endif // CONFIG_DISPLAY
	
	// repeated EventTimer timefuses, id 30
	//! Function get const-access to the elements of timefuses.
	const std::vector<EventTimer> &timefuses() const;
	//! Function to get the number of elements in timefuses.
	size_t timefuses_size() const;
	/*!
	* Function to append a element to timefuses.
	* @return point to newly added element.
	*/
	EventTimer* add_timefuses();
	//! Function to reset timefuses to its default/unset value.
	void clear_timefuses();
	//! Get value of element x of timefuses.
	const EventTimer &timefuses(unsigned x) const;
	//! Set timefuses using a constant reference
	void set_timefuses(unsigned x, const EventTimer &v);
	/*!
	* Provide mutable access to timefuses.
	* @return pointer to member variable of timefuses.
	*/
	EventTimer *mutable_timefuses(unsigned x);
	//! Function to get mutable access to all elements of timefuses.
	std::vector<EventTimer> *mutable_timefuses();
	
	#ifdef CONFIG_SIGNAL_PROC
	// obsolete repeated SignalConfig signals, id 31
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	// obsolete repeated FunctionConfig functions, id 32
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	// repeated StateMachineConfig statemachs, id 33
	//! Function get const-access to the elements of statemachs.
	const std::vector<StateMachineConfig> &statemachs() const;
	//! Function to get the number of elements in statemachs.
	size_t statemachs_size() const;
	/*!
	* Function to append a element to statemachs.
	* @return point to newly added element.
	*/
	StateMachineConfig* add_statemachs();
	//! Function to reset statemachs to its default/unset value.
	void clear_statemachs();
	//! Get value of element x of statemachs.
	const StateMachineConfig &statemachs(unsigned x) const;
	//! Set statemachs using a constant reference
	void set_statemachs(unsigned x, const StateMachineConfig &v);
	/*!
	* Provide mutable access to statemachs.
	* @return pointer to member variable of statemachs.
	*/
	StateMachineConfig *mutable_statemachs(unsigned x);
	//! Function to get mutable access to all elements of statemachs.
	std::vector<StateMachineConfig> *mutable_statemachs();
	#endif // CONFIG_STATEMACHINES
	
	// obsolete optional unsigned max_on_time, id 34
	// obsolete optional unsigned threshold_off, id 35
	// obsolete optional unsigned threshold_on, id 36
	// optional unsigned dim_step, id 37
	/*!
	* Function for querying if dim_step has been set.
	* @return true if dim_step is set.
	*/
	bool has_dim_step() const;
	//! Function to reset dim_step to its default/unset value.
	void clear_dim_step();
	//! Get value of dim_step.
	uint32_t dim_step() const;
	//! Set dim_step using a constant reference
	void set_dim_step(uint32_t v);
	/*!
	* Provide mutable access to dim_step.
	* @return pointer to member variable of dim_step.
	*/
	uint32_t *mutable_dim_step();
	
	// obsolete optional bool lightctrl, id 38
	// optional unsigned pwm_freq, id 39
	/*!
	* Function for querying if pwm_freq has been set.
	* @return true if pwm_freq is set.
	*/
	bool has_pwm_freq() const;
	//! Function to reset pwm_freq to its default/unset value.
	void clear_pwm_freq();
	//! Get value of pwm_freq.
	uint32_t pwm_freq() const;
	//! Set pwm_freq using a constant reference
	void set_pwm_freq(uint32_t v);
	/*!
	* Provide mutable access to pwm_freq.
	* @return pointer to member variable of pwm_freq.
	*/
	uint32_t *mutable_pwm_freq();
	
	#ifdef CONFIG_APP_PARAMS
	// repeated AppParam app_params, id 40
	//! Function get const-access to the elements of app_params.
	const std::vector<AppParam> &app_params() const;
	//! Function to get the number of elements in app_params.
	size_t app_params_size() const;
	/*!
	* Function to append a element to app_params.
	* @return point to newly added element.
	*/
	AppParam* add_app_params();
	//! Function to reset app_params to its default/unset value.
	void clear_app_params();
	//! Get value of element x of app_params.
	const AppParam &app_params(unsigned x) const;
	//! Set app_params using a constant reference
	void set_app_params(unsigned x, const AppParam &v);
	/*!
	* Provide mutable access to app_params.
	* @return pointer to member variable of app_params.
	*/
	AppParam *mutable_app_params(unsigned x);
	//! Function to get mutable access to all elements of app_params.
	std::vector<AppParam> *mutable_app_params();
	#endif // CONFIG_APP_PARAMS
	
	#ifdef CONFIG_THRESHOLDS
	// repeated ThresholdConfig thresholds, id 41
	//! Function get const-access to the elements of thresholds.
	const std::vector<ThresholdConfig> &thresholds() const;
	//! Function to get the number of elements in thresholds.
	size_t thresholds_size() const;
	/*!
	* Function to append a element to thresholds.
	* @return point to newly added element.
	*/
	ThresholdConfig* add_thresholds();
	//! Function to reset thresholds to its default/unset value.
	void clear_thresholds();
	//! Get value of element x of thresholds.
	const ThresholdConfig &thresholds(unsigned x) const;
	//! Set thresholds using a constant reference
	void set_thresholds(unsigned x, const ThresholdConfig &v);
	/*!
	* Provide mutable access to thresholds.
	* @return pointer to member variable of thresholds.
	*/
	ThresholdConfig *mutable_thresholds(unsigned x);
	//! Function to get mutable access to all elements of thresholds.
	std::vector<ThresholdConfig> *mutable_thresholds();
	#endif // CONFIG_THRESHOLDS
	
	#ifdef CONFIG_LUA
	// repeated string luafiles, id 42
	//! Function get const-access to the elements of luafiles.
	const std::vector<estring> &luafiles() const;
	//! Function to get the number of elements in luafiles.
	size_t luafiles_size() const;
	/*!
	* Function to append a element to luafiles.
	* @return point to newly added element.
	*/
	void add_luafiles(const estring &v);
	//! Function to append an element to luafiles initialized by a C-string.
	void add_luafiles(const char*);
	//! Function to reset luafiles to its default/unset value.
	void clear_luafiles();
	//! Get value of element x of luafiles.
	const estring &luafiles(unsigned x) const;
	//! Set luafiles using a constant reference
	void set_luafiles(unsigned x, const estring &v);
	/*!
	* Provide mutable access to luafiles.
	* @return pointer to member variable of luafiles.
	*/
	estring *mutable_luafiles(unsigned x);
	//! Function to get mutable access to all elements of luafiles.
	std::vector<estring> *mutable_luafiles();
	#endif // CONFIG_LUA
	
	#ifdef CONFIG_LUA
	// optional bool lua_disable, id 43
	/*!
	* Function for querying if lua_disable has been set.
	* @return true if lua_disable is set.
	*/
	bool has_lua_disable() const;
	//! Function to reset lua_disable to its default/unset value.
	void clear_lua_disable();
	//! Get value of lua_disable.
	bool lua_disable() const;
	//! Set lua_disable using a constant reference
	void set_lua_disable(bool v);
	/*!
	* Provide mutable access to lua_disable.
	* @return pointer to member variable of lua_disable.
	*/
	bool *mutable_lua_disable();
	#endif // CONFIG_LUA
	
	#ifdef CONFIG_ONEWIRE
	// repeated OwDeviceConfig owdevices, id 50
	//! Function get const-access to the elements of owdevices.
	const std::vector<OwDeviceConfig> &owdevices() const;
	//! Function to get the number of elements in owdevices.
	size_t owdevices_size() const;
	/*!
	* Function to append a element to owdevices.
	* @return point to newly added element.
	*/
	OwDeviceConfig* add_owdevices();
	//! Function to reset owdevices to its default/unset value.
	void clear_owdevices();
	//! Get value of element x of owdevices.
	const OwDeviceConfig &owdevices(unsigned x) const;
	//! Set owdevices using a constant reference
	void set_owdevices(unsigned x, const OwDeviceConfig &v);
	/*!
	* Provide mutable access to owdevices.
	* @return pointer to member variable of owdevices.
	*/
	OwDeviceConfig *mutable_owdevices(unsigned x);
	//! Function to get mutable access to all elements of owdevices.
	std::vector<OwDeviceConfig> *mutable_owdevices();
	#endif // CONFIG_ONEWIRE
	
	
	protected:
	Message *p_getMember(const char *s, unsigned n);
	Message *p_getMember(const char *s, unsigned n, unsigned i);
	//! string nodename, id 1
	estring m_nodename;
	//! bytes pass_hash, id 2
	estring m_pass_hash;
	//! string debugs, id 23
	std::vector<estring> m_debugs;
	#ifdef CONFIG_LUA
	//! string luafiles, id 42
	std::vector<estring> m_luafiles;
	#endif // CONFIG_LUA
	//! string dns_server, id 6
	std::vector<estring> m_dns_server;
	//! string syslog_host, id 7
	estring m_syslog_host;
	//! string sntp_server, id 8
	estring m_sntp_server;
	//! string timezone, id 9
	estring m_timezone;
	//! string otasrv, id 26
	estring m_otasrv;
	//! string domainname, id 15
	estring m_domainname;
	//! fixed32 magic, id 0
	uint32_t m_magic = 0;
	//! unsigned actions_enable, id 18
	uint32_t m_actions_enable = 1;
	//! unsigned station2ap_time, id 13
	uint32_t m_station2ap_time = 0;
	//! unsigned dim_step, id 37
	uint32_t m_dim_step = 0;
	//! unsigned pwm_freq, id 39
	uint32_t m_pwm_freq = 0;
	//! unsigned cpu_freq, id 3
	uint32_t m_cpu_freq = 0;
	//! fixed16 udp_ctrl_port, id 22
	uint16_t m_udp_ctrl_port = 12719;
	//! fixed16 dmesg_size, id 11
	uint16_t m_dmesg_size = 2048;
	#ifdef CONFIG_LUA
	//! bool lua_disable, id 43
	bool m_lua_disable = false;
	#endif // CONFIG_LUA
	//! Date holidays, id 16
	std::vector<Date> m_holidays;
	#ifdef CONFIG_ONEWIRE
	//! OwDeviceConfig owdevices, id 50
	std::vector<OwDeviceConfig> m_owdevices;
	#endif // CONFIG_ONEWIRE
	//! WifiConfig station, id 4
	WifiConfig m_station;
	#ifdef CONFIG_THRESHOLDS
	//! ThresholdConfig thresholds, id 41
	std::vector<ThresholdConfig> m_thresholds;
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_APP_PARAMS
	//! AppParam app_params, id 40
	std::vector<AppParam> m_app_params;
	#endif // CONFIG_APP_PARAMS
	//! WifiConfig softap, id 5
	WifiConfig m_softap;
	#ifdef CONFIG_MQTT
	//! MQTT mqtt, id 10
	MQTT m_mqtt;
	#endif // CONFIG_MQTT
	#ifdef CONFIG_INFLUX
	//! Influx influx, id 12
	Influx m_influx;
	#endif // CONFIG_INFLUX
	#ifdef CONFIG_TERMSERV
	//! TerminalConfig terminal, id 21
	std::vector<TerminalConfig> m_terminal;
	#endif // CONFIG_TERMSERV
	#ifdef CONFIG_STATEMACHINES
	//! StateMachineConfig statemachs, id 33
	std::vector<StateMachineConfig> m_statemachs;
	#endif // CONFIG_STATEMACHINES
	//! EventTimer timefuses, id 30
	std::vector<EventTimer> m_timefuses;
	#ifdef CONFIG_DISPLAY
	//! ScreenConfig screen, id 27
	ScreenConfig m_screen;
	#endif // CONFIG_DISPLAY
	//! AtAction at_actions, id 17
	std::vector<AtAction> m_at_actions;
	#ifdef CONFIG_HTTP
	//! FtpHttpConfig httpd, id 25
	FtpHttpConfig m_httpd;
	#endif // CONFIG_HTTP
	#ifdef CONFIG_FTP
	//! FtpHttpConfig ftpd, id 24
	FtpHttpConfig m_ftpd;
	#endif // CONFIG_FTP
	//! Trigger triggers, id 19
	std::vector<Trigger> m_triggers;
	//! UartSettings uart, id 20
	std::vector<UartSettings> m_uart;
	
	private:
	uint16_t p_validbits = 0;
};


inline size_t WifiConfig::getMaxSize()
{
	// optional string ssid, id 1 has unlimited size
	// optional string pass, id 2 has unlimited size
	// optional bytes mac, id 3 has unlimited size
	// required bool activate, id 4 has maximum size 2
	// optional fixed32 addr4, id 5 has maximum size 5
	// optional fixed8 netmask4, id 6 has maximum size 2
	// optional fixed32 gateway4, id 7 has maximum size 5
	return SIZE_MAX;
}

inline const estring &WifiConfig::ssid() const
{
	return m_ssid;
}

inline bool WifiConfig::has_ssid() const
{
	return !m_ssid.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_ssid()
{
	m_ssid.clear();
}

inline estring *WifiConfig::mutable_ssid()
{
	return &m_ssid;
}

inline void WifiConfig::set_ssid(const void *data, size_t s)
{
	m_ssid.assign((const char *)data,s);
}

inline void WifiConfig::set_ssid(const char *data)
{
	m_ssid = data;
}

inline void WifiConfig::set_ssid(const estring &v)
{
	m_ssid = v;
}



inline const estring &WifiConfig::pass() const
{
	return m_pass;
}

inline bool WifiConfig::has_pass() const
{
	return !m_pass.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_pass()
{
	m_pass.clear();
}

inline estring *WifiConfig::mutable_pass()
{
	return &m_pass;
}

inline void WifiConfig::set_pass(const void *data, size_t s)
{
	m_pass.assign((const char *)data,s);
}

inline void WifiConfig::set_pass(const char *data)
{
	m_pass = data;
}

inline void WifiConfig::set_pass(const estring &v)
{
	m_pass = v;
}



inline const estring &WifiConfig::mac() const
{
	return m_mac;
}

inline bool WifiConfig::has_mac() const
{
	return !m_mac.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_mac()
{
	m_mac.clear();
}

inline estring *WifiConfig::mutable_mac()
{
	return &m_mac;
}

inline void WifiConfig::set_mac(const void *data, size_t s)
{
	m_mac.assign((const char *)data,s);
}

inline void WifiConfig::set_mac(const estring &v)
{
	m_mac = v;
}



inline bool WifiConfig::activate() const
{
	return m_activate;
}

inline bool *WifiConfig::mutable_activate()
{
	return &m_activate;
}

inline void WifiConfig::set_activate(bool v)
{
	m_activate = v;
}



inline uint32_t WifiConfig::addr4() const
{
	return m_addr4;
}

inline bool WifiConfig::has_addr4() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_addr4()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_addr4 = 0;
}

inline uint32_t *WifiConfig::mutable_addr4()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_addr4 = 0;
	}
	return &m_addr4;
}

inline void WifiConfig::set_addr4(uint32_t v)
{
	m_addr4 = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline uint8_t WifiConfig::netmask4() const
{
	return m_netmask4;
}

inline bool WifiConfig::has_netmask4() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_netmask4()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_netmask4 = 0;
}

inline uint8_t *WifiConfig::mutable_netmask4()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_netmask4 = 0;
	}
	return &m_netmask4;
}

inline void WifiConfig::set_netmask4(uint8_t v)
{
	m_netmask4 = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline uint32_t WifiConfig::gateway4() const
{
	return m_gateway4;
}

inline bool WifiConfig::has_gateway4() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void WifiConfig::clear_gateway4()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_gateway4 = 0;
}

inline uint32_t *WifiConfig::mutable_gateway4()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_gateway4 = 0;
	}
	return &m_gateway4;
}

inline void WifiConfig::set_gateway4(uint32_t v)
{
	m_gateway4 = v;
	p_validbits |= ((uint8_t)1U << 2);
}



inline size_t MQTT::getMaxSize()
{
	// optional string uri, id 1 has unlimited size
	// optional bool enable, id 2 has maximum size 2
	// optional string username, id 3 has unlimited size
	// optional string password, id 4 has unlimited size
	// repeated string subscribtions, id 5 has unlimited size
	// optional uint16 keepalive, id 6 has maximum size 4
	return SIZE_MAX;
}

inline const estring &MQTT::uri() const
{
	return m_uri;
}

inline bool MQTT::has_uri() const
{
	return !m_uri.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_uri()
{
	m_uri.clear();
}

inline estring *MQTT::mutable_uri()
{
	return &m_uri;
}

inline void MQTT::set_uri(const void *data, size_t s)
{
	m_uri.assign((const char *)data,s);
}

inline void MQTT::set_uri(const char *data)
{
	m_uri = data;
}

inline void MQTT::set_uri(const estring &v)
{
	m_uri = v;
}



inline bool MQTT::enable() const
{
	return m_enable;
}

inline bool MQTT::has_enable() const
{
	return m_enable != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_enable()
{
	m_enable = false;
}

inline bool *MQTT::mutable_enable()
{
	return &m_enable;
}

inline void MQTT::set_enable(bool v)
{
	m_enable = v;
}



inline const estring &MQTT::username() const
{
	return m_username;
}

inline bool MQTT::has_username() const
{
	return !m_username.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_username()
{
	m_username.clear();
}

inline estring *MQTT::mutable_username()
{
	return &m_username;
}

inline void MQTT::set_username(const void *data, size_t s)
{
	m_username.assign((const char *)data,s);
}

inline void MQTT::set_username(const char *data)
{
	m_username = data;
}

inline void MQTT::set_username(const estring &v)
{
	m_username = v;
}



inline const estring &MQTT::password() const
{
	return m_password;
}

inline bool MQTT::has_password() const
{
	return !m_password.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_password()
{
	m_password.clear();
}

inline estring *MQTT::mutable_password()
{
	return &m_password;
}

inline void MQTT::set_password(const void *data, size_t s)
{
	m_password.assign((const char *)data,s);
}

inline void MQTT::set_password(const char *data)
{
	m_password = data;
}

inline void MQTT::set_password(const estring &v)
{
	m_password = v;
}



inline const estring &MQTT::subscribtions(unsigned x) const
{
	return m_subscribtions[x];
}

inline const std::vector<estring> &MQTT::subscribtions() const
{
	return m_subscribtions;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_subscribtions()
{
	m_subscribtions.clear();
}

inline estring *MQTT::mutable_subscribtions(unsigned x)
{
	if (x >= m_subscribtions.size())
		m_subscribtions.resize(x+1);
	return &m_subscribtions[x];
}

inline std::vector<estring> *MQTT::mutable_subscribtions()
{
	return &m_subscribtions;
}

inline void MQTT::add_subscribtions(const estring &v)
{
	m_subscribtions.push_back(v);
}

inline void MQTT::add_subscribtions(const char *s)
{
	m_subscribtions.push_back(s);
}

inline void MQTT::set_subscribtions(unsigned x, const estring &v)
{
	assert(x < m_subscribtions.size());
	m_subscribtions[x] = v;
}

inline size_t MQTT::subscribtions_size() const
{
	return m_subscribtions.size();
}



inline uint16_t MQTT::keepalive() const
{
	return m_keepalive;
}

inline bool MQTT::has_keepalive() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void MQTT::clear_keepalive()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_keepalive = 60;
}

inline uint16_t *MQTT::mutable_keepalive()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_keepalive = 60;
	}
	return &m_keepalive;
}

inline void MQTT::set_keepalive(uint16_t v)
{
	m_keepalive = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline size_t Date::getMaxSize()
{
	// optional fixed8 day, id 1 has maximum size 2
	// optional fixed8 month, id 2 has maximum size 2
	// optional fixed16 year, id 3 has maximum size 3
	// optional fixed8 endday, id 4 has maximum size 2
	// optional fixed8 endmonth, id 5 has maximum size 2
	// optional fixed8 endyear, id 6 has maximum size 2
	return 13;
}

inline uint8_t Date::day() const
{
	return m_day;
}

inline bool Date::has_day() const
{
	return m_day != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_day()
{
	m_day = 0;
}

inline uint8_t *Date::mutable_day()
{
	return &m_day;
}

inline void Date::set_day(uint8_t v)
{
	m_day = v;
}



inline uint8_t Date::month() const
{
	return m_month;
}

inline bool Date::has_month() const
{
	return m_month != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_month()
{
	m_month = 0;
}

inline uint8_t *Date::mutable_month()
{
	return &m_month;
}

inline void Date::set_month(uint8_t v)
{
	m_month = v;
}



inline uint16_t Date::year() const
{
	return m_year;
}

inline bool Date::has_year() const
{
	return m_year != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_year()
{
	m_year = 0;
}

inline uint16_t *Date::mutable_year()
{
	return &m_year;
}

inline void Date::set_year(uint16_t v)
{
	m_year = v;
}



inline uint8_t Date::endday() const
{
	return m_endday;
}

inline bool Date::has_endday() const
{
	return m_endday != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_endday()
{
	m_endday = 0;
}

inline uint8_t *Date::mutable_endday()
{
	return &m_endday;
}

inline void Date::set_endday(uint8_t v)
{
	m_endday = v;
}



inline uint8_t Date::endmonth() const
{
	return m_endmonth;
}

inline bool Date::has_endmonth() const
{
	return m_endmonth != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_endmonth()
{
	m_endmonth = 0;
}

inline uint8_t *Date::mutable_endmonth()
{
	return &m_endmonth;
}

inline void Date::set_endmonth(uint8_t v)
{
	m_endmonth = v;
}



inline uint8_t Date::endyear() const
{
	return m_endyear;
}

inline bool Date::has_endyear() const
{
	return m_endyear != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Date::clear_endyear()
{
	m_endyear = 0;
}

inline uint8_t *Date::mutable_endyear()
{
	return &m_endyear;
}

inline void Date::set_endyear(uint8_t v)
{
	m_endyear = v;
}



inline size_t AtAction::getMaxSize()
{
	// optional WeekDay day, id 1 has maximum size 2
	// optional unsigned min_of_day, id 2 has maximum size 6
	// optional string action, id 3 has unlimited size
	// required bool enable, id 4 has maximum size 2
	return SIZE_MAX;
}

inline WeekDay AtAction::day() const
{
	return m_day;
}

inline bool AtAction::has_day() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AtAction::clear_day()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_day = Sunday;
}

inline WeekDay *AtAction::mutable_day()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_day = Sunday;
	}
	return &m_day;
}

inline void AtAction::set_day(WeekDay v)
{
	m_day = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline uint32_t AtAction::min_of_day() const
{
	return m_min_of_day;
}

inline bool AtAction::has_min_of_day() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AtAction::clear_min_of_day()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_min_of_day = 0;
}

inline uint32_t *AtAction::mutable_min_of_day()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_min_of_day = 0;
	}
	return &m_min_of_day;
}

inline void AtAction::set_min_of_day(uint32_t v)
{
	m_min_of_day = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline const estring &AtAction::action() const
{
	return m_action;
}

inline bool AtAction::has_action() const
{
	return !m_action.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AtAction::clear_action()
{
	m_action.clear();
}

inline estring *AtAction::mutable_action()
{
	return &m_action;
}

inline void AtAction::set_action(const void *data, size_t s)
{
	m_action.assign((const char *)data,s);
}

inline void AtAction::set_action(const char *data)
{
	m_action = data;
}

inline void AtAction::set_action(const estring &v)
{
	m_action = v;
}



inline bool AtAction::enable() const
{
	return m_enable;
}

inline bool *AtAction::mutable_enable()
{
	return &m_enable;
}

inline void AtAction::set_enable(bool v)
{
	m_enable = v;
}



inline size_t Influx::getMaxSize()
{
	// optional string hostname, id 1 has unlimited size
	// optional fixed16 port, id 2 has maximum size 3
	// optional string measurement, id 3 has unlimited size
	// obsolete optional unsigned interval, id 4
	// optional string database, id 5 has unlimited size
	return SIZE_MAX;
}

inline const estring &Influx::hostname() const
{
	return m_hostname;
}

inline bool Influx::has_hostname() const
{
	return !m_hostname.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Influx::clear_hostname()
{
	m_hostname.clear();
}

inline estring *Influx::mutable_hostname()
{
	return &m_hostname;
}

inline void Influx::set_hostname(const void *data, size_t s)
{
	m_hostname.assign((const char *)data,s);
}

inline void Influx::set_hostname(const char *data)
{
	m_hostname = data;
}

inline void Influx::set_hostname(const estring &v)
{
	m_hostname = v;
}



inline uint16_t Influx::port() const
{
	return m_port;
}

inline bool Influx::has_port() const
{
	return m_port != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Influx::clear_port()
{
	m_port = 0;
}

inline uint16_t *Influx::mutable_port()
{
	return &m_port;
}

inline void Influx::set_port(uint16_t v)
{
	m_port = v;
}



inline const estring &Influx::measurement() const
{
	return m_measurement;
}

inline bool Influx::has_measurement() const
{
	return !m_measurement.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Influx::clear_measurement()
{
	m_measurement.clear();
}

inline estring *Influx::mutable_measurement()
{
	return &m_measurement;
}

inline void Influx::set_measurement(const void *data, size_t s)
{
	m_measurement.assign((const char *)data,s);
}

inline void Influx::set_measurement(const char *data)
{
	m_measurement = data;
}

inline void Influx::set_measurement(const estring &v)
{
	m_measurement = v;
}



inline const estring &Influx::database() const
{
	return m_database;
}

inline bool Influx::has_database() const
{
	return !m_database.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Influx::clear_database()
{
	m_database.clear();
}

inline estring *Influx::mutable_database()
{
	return &m_database;
}

inline void Influx::set_database(const void *data, size_t s)
{
	m_database.assign((const char *)data,s);
}

inline void Influx::set_database(const char *data)
{
	m_database = data;
}

inline void Influx::set_database(const estring &v)
{
	m_database = v;
}



inline size_t UartSettings::getMaxSize()
{
	// optional sint8 port, id 1 has maximum size 3
	// optional unsigned baudrate, id 2 has maximum size 6
	// optional uartcfg_t config, id 3 has maximum size 3
	// optional fixed8 rx_thresh, id 4 has maximum size 2
	// optional unsigned tx_bufsize, id 6 has maximum size 6
	// optional unsigned rx_bufsize, id 7 has maximum size 6
	return 26;
}

inline int8_t UartSettings::port() const
{
	return m_port;
}

inline bool UartSettings::has_port() const
{
	return m_port != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_port()
{
	m_port = -1;
}

inline int8_t *UartSettings::mutable_port()
{
	return &m_port;
}

inline void UartSettings::set_port(int8_t v)
{
	m_port = v;
}



inline uint32_t UartSettings::baudrate() const
{
	return m_baudrate;
}

inline bool UartSettings::has_baudrate() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_baudrate()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_baudrate = 115200;
}

inline uint32_t *UartSettings::mutable_baudrate()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_baudrate = 115200;
	}
	return &m_baudrate;
}

inline void UartSettings::set_baudrate(uint32_t v)
{
	m_baudrate = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline uartcfg_t UartSettings::config() const
{
	return m_config;
}

inline uart_wl_t UartSettings::config_wl() const
{
	return (uart_wl_t)((m_config >> 0) & 0x3);
}

inline uart_sb_t UartSettings::config_sb() const
{
	return (uart_sb_t)((m_config >> 2) & 0x3);
}

inline bool UartSettings::config_rts() const
{
	return (bool)((m_config >> 4) & 0x1);
}

inline bool UartSettings::config_cts() const
{
	return (bool)((m_config >> 5) & 0x1);
}

inline uart_p_t UartSettings::config_p() const
{
	return (uart_p_t)((m_config >> 6) & 0x3);
}

inline bool UartSettings::config_ref_tick() const
{
	return (bool)((m_config >> 10) & 0x1);
}

inline bool UartSettings::has_config() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_config()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_config = 5;
}

inline uartcfg_t *UartSettings::mutable_config()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_config = 5;
	}
	return &m_config;
}

inline void UartSettings::set_config_wl(uart_wl_t v)
{
	m_config &= ~(0x3ULL << 0);
	m_config |= ((uint16_t) v << 0);
	p_validbits |= ((uint8_t)1U << 1);
}

inline void UartSettings::set_config_sb(uart_sb_t v)
{
	m_config &= ~(0x3ULL << 2);
	m_config |= ((uint16_t) v << 2);
	p_validbits |= ((uint8_t)1U << 1);
}

inline void UartSettings::set_config_rts(bool v)
{
	m_config &= ~(0x1ULL << 4);
	m_config |= ((uint16_t) v << 4);
	p_validbits |= ((uint8_t)1U << 1);
}

inline void UartSettings::set_config_cts(bool v)
{
	m_config &= ~(0x1ULL << 5);
	m_config |= ((uint16_t) v << 5);
	p_validbits |= ((uint8_t)1U << 1);
}

inline void UartSettings::set_config_p(uart_p_t v)
{
	m_config &= ~(0x3ULL << 6);
	m_config |= ((uint16_t) v << 6);
	p_validbits |= ((uint8_t)1U << 1);
}

inline void UartSettings::set_config_ref_tick(bool v)
{
	m_config &= ~(0x1ULL << 10);
	m_config |= ((uint16_t) v << 10);
	p_validbits |= ((uint8_t)1U << 1);
}

inline void UartSettings::set_config(uartcfg_t v)
{
	m_config = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline uint8_t UartSettings::rx_thresh() const
{
	return m_rx_thresh;
}

inline bool UartSettings::has_rx_thresh() const
{
	return m_rx_thresh != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_rx_thresh()
{
	m_rx_thresh = 0;
}

inline uint8_t *UartSettings::mutable_rx_thresh()
{
	return &m_rx_thresh;
}

inline void UartSettings::set_rx_thresh(uint8_t v)
{
	m_rx_thresh = v;
}



inline uint32_t UartSettings::tx_bufsize() const
{
	return m_tx_bufsize;
}

inline bool UartSettings::has_tx_bufsize() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_tx_bufsize()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_tx_bufsize = 0;
}

inline uint32_t *UartSettings::mutable_tx_bufsize()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_tx_bufsize = 0;
	}
	return &m_tx_bufsize;
}

inline void UartSettings::set_tx_bufsize(uint32_t v)
{
	m_tx_bufsize = v;
	p_validbits |= ((uint8_t)1U << 2);
}



inline uint32_t UartSettings::rx_bufsize() const
{
	return m_rx_bufsize;
}

inline bool UartSettings::has_rx_bufsize() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 3));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartSettings::clear_rx_bufsize()
{
	p_validbits &= ~((uint8_t)1U << 3);
	m_rx_bufsize = 0;
}

inline uint32_t *UartSettings::mutable_rx_bufsize()
{
	if (0 == (p_validbits & ((uint8_t)1U << 3))) {
		p_validbits |= ((uint8_t)1U << 3);
		m_rx_bufsize = 0;
	}
	return &m_rx_bufsize;
}

inline void UartSettings::set_rx_bufsize(uint32_t v)
{
	m_rx_bufsize = v;
	p_validbits |= ((uint8_t)1U << 3);
}



inline size_t FtpHttpConfig::getMaxSize()
{
	// optional fixed16 port, id 1 has maximum size 3
	// optional bool start, id 2 has maximum size 2
	// optional string root, id 3 has unlimited size
	// optional string uploaddir, id 4 has unlimited size
	return SIZE_MAX;
}

inline uint16_t FtpHttpConfig::port() const
{
	return m_port;
}

inline bool FtpHttpConfig::has_port() const
{
	return m_port != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FtpHttpConfig::clear_port()
{
	m_port = 0;
}

inline uint16_t *FtpHttpConfig::mutable_port()
{
	return &m_port;
}

inline void FtpHttpConfig::set_port(uint16_t v)
{
	m_port = v;
}



inline bool FtpHttpConfig::start() const
{
	return m_start;
}

inline bool FtpHttpConfig::has_start() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FtpHttpConfig::clear_start()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_start = true;
}

inline bool *FtpHttpConfig::mutable_start()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_start = true;
	}
	return &m_start;
}

inline void FtpHttpConfig::set_start(bool v)
{
	m_start = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline const estring &FtpHttpConfig::root() const
{
	return m_root;
}

inline bool FtpHttpConfig::has_root() const
{
	return !m_root.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FtpHttpConfig::clear_root()
{
	m_root.clear();
}

inline estring *FtpHttpConfig::mutable_root()
{
	return &m_root;
}

inline void FtpHttpConfig::set_root(const void *data, size_t s)
{
	m_root.assign((const char *)data,s);
}

inline void FtpHttpConfig::set_root(const char *data)
{
	m_root = data;
}

inline void FtpHttpConfig::set_root(const estring &v)
{
	m_root = v;
}



inline const estring &FtpHttpConfig::uploaddir() const
{
	return m_uploaddir;
}

inline bool FtpHttpConfig::has_uploaddir() const
{
	return !m_uploaddir.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FtpHttpConfig::clear_uploaddir()
{
	m_uploaddir.clear();
}

inline estring *FtpHttpConfig::mutable_uploaddir()
{
	return &m_uploaddir;
}

inline void FtpHttpConfig::set_uploaddir(const void *data, size_t s)
{
	m_uploaddir.assign((const char *)data,s);
}

inline void FtpHttpConfig::set_uploaddir(const char *data)
{
	m_uploaddir = data;
}

inline void FtpHttpConfig::set_uploaddir(const estring &v)
{
	m_uploaddir = v;
}



inline size_t TerminalConfig::getMaxSize()
{
	// optional sint8 uart_rx, id 1 has maximum size 3
	// optional sint8 uart_tx, id 2 has maximum size 3
	// optional string name, id 3 has unlimited size
	return SIZE_MAX;
}

inline int8_t TerminalConfig::uart_rx() const
{
	return m_uart_rx;
}

inline bool TerminalConfig::has_uart_rx() const
{
	return m_uart_rx != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TerminalConfig::clear_uart_rx()
{
	m_uart_rx = -1;
}

inline int8_t *TerminalConfig::mutable_uart_rx()
{
	return &m_uart_rx;
}

inline void TerminalConfig::set_uart_rx(int8_t v)
{
	m_uart_rx = v;
}



inline int8_t TerminalConfig::uart_tx() const
{
	return m_uart_tx;
}

inline bool TerminalConfig::has_uart_tx() const
{
	return m_uart_tx != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TerminalConfig::clear_uart_tx()
{
	m_uart_tx = -1;
}

inline int8_t *TerminalConfig::mutable_uart_tx()
{
	return &m_uart_tx;
}

inline void TerminalConfig::set_uart_tx(int8_t v)
{
	m_uart_tx = v;
}



inline const estring &TerminalConfig::name() const
{
	return m_name;
}

inline bool TerminalConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TerminalConfig::clear_name()
{
	m_name.clear();
}

inline estring *TerminalConfig::mutable_name()
{
	return &m_name;
}

inline void TerminalConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void TerminalConfig::set_name(const char *data)
{
	m_name = data;
}

inline void TerminalConfig::set_name(const estring &v)
{
	m_name = v;
}



inline size_t Trigger::getMaxSize()
{
	// optional string event, id 1 has unlimited size
	// repeated string action, id 2 has unlimited size
	return SIZE_MAX;
}

inline const estring &Trigger::event() const
{
	return m_event;
}

inline bool Trigger::has_event() const
{
	return !m_event.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Trigger::clear_event()
{
	m_event.clear();
}

inline estring *Trigger::mutable_event()
{
	return &m_event;
}

inline void Trigger::set_event(const void *data, size_t s)
{
	m_event.assign((const char *)data,s);
}

inline void Trigger::set_event(const char *data)
{
	m_event = data;
}

inline void Trigger::set_event(const estring &v)
{
	m_event = v;
}



inline const estring &Trigger::action(unsigned x) const
{
	return m_action[x];
}

inline const std::vector<estring> &Trigger::action() const
{
	return m_action;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Trigger::clear_action()
{
	m_action.clear();
}

inline estring *Trigger::mutable_action(unsigned x)
{
	if (x >= m_action.size())
		m_action.resize(x+1);
	return &m_action[x];
}

inline std::vector<estring> *Trigger::mutable_action()
{
	return &m_action;
}

inline void Trigger::add_action(const estring &v)
{
	m_action.push_back(v);
}

inline void Trigger::add_action(const char *s)
{
	m_action.push_back(s);
}

inline void Trigger::set_action(unsigned x, const estring &v)
{
	assert(x < m_action.size());
	m_action[x] = v;
}

inline size_t Trigger::action_size() const
{
	return m_action.size();
}



inline size_t AppParam::getMaxSize()
{
	// optional string key, id 1 has unlimited size
	// optional unsigned uValue, id 2 has maximum size 6
	// optional string sValue, id 3 has unlimited size
	// optional signed dValue, id 4 has maximum size 6
	// optional double fValue, id 5 has maximum size 9
	return SIZE_MAX;
}

inline const estring &AppParam::key() const
{
	return m_key;
}

inline bool AppParam::has_key() const
{
	return !m_key.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AppParam::clear_key()
{
	m_key.clear();
}

inline estring *AppParam::mutable_key()
{
	return &m_key;
}

inline void AppParam::set_key(const void *data, size_t s)
{
	m_key.assign((const char *)data,s);
}

inline void AppParam::set_key(const char *data)
{
	m_key = data;
}

inline void AppParam::set_key(const estring &v)
{
	m_key = v;
}



inline uint32_t AppParam::uValue() const
{
	return m_uValue;
}

inline bool AppParam::has_uValue() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AppParam::clear_uValue()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_uValue = 0;
}

inline uint32_t *AppParam::mutable_uValue()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_uValue = 0;
	}
	return &m_uValue;
}

inline void AppParam::set_uValue(uint32_t v)
{
	m_uValue = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline const estring &AppParam::sValue() const
{
	return m_sValue;
}

inline bool AppParam::has_sValue() const
{
	return !m_sValue.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AppParam::clear_sValue()
{
	m_sValue.clear();
}

inline estring *AppParam::mutable_sValue()
{
	return &m_sValue;
}

inline void AppParam::set_sValue(const void *data, size_t s)
{
	m_sValue.assign((const char *)data,s);
}

inline void AppParam::set_sValue(const char *data)
{
	m_sValue = data;
}

inline void AppParam::set_sValue(const estring &v)
{
	m_sValue = v;
}



inline int32_t AppParam::dValue() const
{
	return m_dValue;
}

inline bool AppParam::has_dValue() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AppParam::clear_dValue()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_dValue = 0;
}

inline int32_t *AppParam::mutable_dValue()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_dValue = 0;
	}
	return &m_dValue;
}

inline void AppParam::set_dValue(int32_t v)
{
	m_dValue = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline double AppParam::fValue() const
{
	return m_fValue;
}

inline bool AppParam::has_fValue() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AppParam::clear_fValue()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_fValue = 0;
}

inline double *AppParam::mutable_fValue()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_fValue = 0;
	}
	return &m_fValue;
}

inline void AppParam::set_fValue(double v)
{
	m_fValue = v;
	p_validbits |= ((uint8_t)1U << 2);
}



inline size_t EventTimer::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional unsigned time, id 2 has maximum size 6
	// optional eventcfg_t config, id 3 has maximum size 6
	return SIZE_MAX;
}

inline const estring &EventTimer::name() const
{
	return m_name;
}

inline bool EventTimer::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void EventTimer::clear_name()
{
	m_name.clear();
}

inline estring *EventTimer::mutable_name()
{
	return &m_name;
}

inline void EventTimer::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void EventTimer::set_name(const char *data)
{
	m_name = data;
}

inline void EventTimer::set_name(const estring &v)
{
	m_name = v;
}



inline uint32_t EventTimer::time() const
{
	return m_time;
}

inline bool EventTimer::has_time() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void EventTimer::clear_time()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_time = 0;
}

inline uint32_t *EventTimer::mutable_time()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_time = 0;
	}
	return &m_time;
}

inline void EventTimer::set_time(uint32_t v)
{
	m_time = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline eventcfg_t EventTimer::config() const
{
	return m_config;
}

inline bool EventTimer::config_restart() const
{
	return (bool)((m_config >> 0) & 0x1);
}

inline bool EventTimer::config_autostart() const
{
	return (bool)((m_config >> 1) & 0x1);
}

inline bool EventTimer::has_config() const
{
	return m_config != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void EventTimer::clear_config()
{
	m_config = 0;
}

inline eventcfg_t *EventTimer::mutable_config()
{
	return &m_config;
}

inline void EventTimer::set_config_restart(bool v)
{
	m_config &= ~(0x1ULL << 0);
	m_config |= ((uint8_t) v << 0);
}

inline void EventTimer::set_config_autostart(bool v)
{
	m_config &= ~(0x1ULL << 1);
	m_config |= ((uint8_t) v << 1);
}

inline void EventTimer::set_config(eventcfg_t v)
{
	m_config = v;
}



inline size_t FunctionConfig::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional string func, id 2 has unlimited size
	// repeated string params, id 3 has unlimited size
	return SIZE_MAX;
}

inline const estring &FunctionConfig::name() const
{
	return m_name;
}

inline bool FunctionConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FunctionConfig::clear_name()
{
	m_name.clear();
}

inline estring *FunctionConfig::mutable_name()
{
	return &m_name;
}

inline void FunctionConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void FunctionConfig::set_name(const char *data)
{
	m_name = data;
}

inline void FunctionConfig::set_name(const estring &v)
{
	m_name = v;
}



inline const estring &FunctionConfig::func() const
{
	return m_func;
}

inline bool FunctionConfig::has_func() const
{
	return !m_func.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FunctionConfig::clear_func()
{
	m_func.clear();
}

inline estring *FunctionConfig::mutable_func()
{
	return &m_func;
}

inline void FunctionConfig::set_func(const void *data, size_t s)
{
	m_func.assign((const char *)data,s);
}

inline void FunctionConfig::set_func(const char *data)
{
	m_func = data;
}

inline void FunctionConfig::set_func(const estring &v)
{
	m_func = v;
}



inline const estring &FunctionConfig::params(unsigned x) const
{
	return m_params[x];
}

inline const std::vector<estring> &FunctionConfig::params() const
{
	return m_params;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void FunctionConfig::clear_params()
{
	m_params.clear();
}

inline estring *FunctionConfig::mutable_params(unsigned x)
{
	if (x >= m_params.size())
		m_params.resize(x+1);
	return &m_params[x];
}

inline std::vector<estring> *FunctionConfig::mutable_params()
{
	return &m_params;
}

inline void FunctionConfig::add_params(const estring &v)
{
	m_params.push_back(v);
}

inline void FunctionConfig::add_params(const char *s)
{
	m_params.push_back(s);
}

inline void FunctionConfig::set_params(unsigned x, const estring &v)
{
	assert(x < m_params.size());
	m_params[x] = v;
}

inline size_t FunctionConfig::params_size() const
{
	return m_params.size();
}



inline size_t SignalConfig::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional sigtype_t type, id 2 has maximum size 2
	// optional string iv, id 3 has unlimited size
	return SIZE_MAX;
}

inline const estring &SignalConfig::name() const
{
	return m_name;
}

inline bool SignalConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SignalConfig::clear_name()
{
	m_name.clear();
}

inline estring *SignalConfig::mutable_name()
{
	return &m_name;
}

inline void SignalConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void SignalConfig::set_name(const char *data)
{
	m_name = data;
}

inline void SignalConfig::set_name(const estring &v)
{
	m_name = v;
}



inline sigtype_t SignalConfig::type() const
{
	return m_type;
}

inline bool SignalConfig::has_type() const
{
	return m_type != st_invalid;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SignalConfig::clear_type()
{
	m_type = st_invalid;
}

inline sigtype_t *SignalConfig::mutable_type()
{
	return &m_type;
}

inline void SignalConfig::set_type(sigtype_t v)
{
	m_type = v;
}



inline const estring &SignalConfig::iv() const
{
	return m_iv;
}

inline bool SignalConfig::has_iv() const
{
	return !m_iv.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SignalConfig::clear_iv()
{
	m_iv.clear();
}

inline estring *SignalConfig::mutable_iv()
{
	return &m_iv;
}

inline void SignalConfig::set_iv(const void *data, size_t s)
{
	m_iv.assign((const char *)data,s);
}

inline void SignalConfig::set_iv(const char *data)
{
	m_iv = data;
}

inline void SignalConfig::set_iv(const estring &v)
{
	m_iv = v;
}



inline size_t OwDeviceConfig::getMaxSize()
{
	// optional fixed64 id, id 1 has maximum size 9
	// optional string name, id 2 has unlimited size
	return SIZE_MAX;
}

inline uint64_t OwDeviceConfig::id() const
{
	return m_id;
}

inline bool OwDeviceConfig::has_id() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void OwDeviceConfig::clear_id()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_id = 0;
}

inline uint64_t *OwDeviceConfig::mutable_id()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_id = 0;
	}
	return &m_id;
}

inline void OwDeviceConfig::set_id(uint64_t v)
{
	m_id = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline const estring &OwDeviceConfig::name() const
{
	return m_name;
}

inline bool OwDeviceConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void OwDeviceConfig::clear_name()
{
	m_name.clear();
}

inline estring *OwDeviceConfig::mutable_name()
{
	return &m_name;
}

inline void OwDeviceConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void OwDeviceConfig::set_name(const char *data)
{
	m_name = data;
}

inline void OwDeviceConfig::set_name(const estring &v)
{
	m_name = v;
}



inline size_t StateConfig::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// repeated Trigger conds, id 2 has unlimited size
	return SIZE_MAX;
}

inline const estring &StateConfig::name() const
{
	return m_name;
}

inline bool StateConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void StateConfig::clear_name()
{
	m_name.clear();
}

inline estring *StateConfig::mutable_name()
{
	return &m_name;
}

inline void StateConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void StateConfig::set_name(const char *data)
{
	m_name = data;
}

inline void StateConfig::set_name(const estring &v)
{
	m_name = v;
}



inline const Trigger &StateConfig::conds(unsigned x) const
{
	return m_conds[x];
}

inline const std::vector<Trigger> &StateConfig::conds() const
{
	return m_conds;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void StateConfig::clear_conds()
{
	m_conds.clear();
}

inline Trigger *StateConfig::mutable_conds(unsigned x)
{
	if (x >= m_conds.size())
		m_conds.resize(x+1);
	return &m_conds[x];
}

inline std::vector<Trigger> *StateConfig::mutable_conds()
{
	return &m_conds;
}

inline Trigger *StateConfig::add_conds()
{
	m_conds.resize(m_conds.size()+1);
	return &m_conds.back();
}

inline void StateConfig::set_conds(unsigned x, const Trigger &v)
{
	assert(x < m_conds.size());
	m_conds[x] = v;
}

inline size_t StateConfig::conds_size() const
{
	return m_conds.size();
}



inline size_t StateMachineConfig::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional uint8 ini_st, id 2 has maximum size 3
	// repeated StateConfig states, id 3 has unlimited size
	// optional bool persistent, id 4 has maximum size 2
	return SIZE_MAX;
}

inline const estring &StateMachineConfig::name() const
{
	return m_name;
}

inline bool StateMachineConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void StateMachineConfig::clear_name()
{
	m_name.clear();
}

inline estring *StateMachineConfig::mutable_name()
{
	return &m_name;
}

inline void StateMachineConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void StateMachineConfig::set_name(const char *data)
{
	m_name = data;
}

inline void StateMachineConfig::set_name(const estring &v)
{
	m_name = v;
}



inline uint8_t StateMachineConfig::ini_st() const
{
	return m_ini_st;
}

inline bool StateMachineConfig::has_ini_st() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void StateMachineConfig::clear_ini_st()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_ini_st = 0;
}

inline uint8_t *StateMachineConfig::mutable_ini_st()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_ini_st = 0;
	}
	return &m_ini_st;
}

inline void StateMachineConfig::set_ini_st(uint8_t v)
{
	m_ini_st = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline const StateConfig &StateMachineConfig::states(unsigned x) const
{
	return m_states[x];
}

inline const std::vector<StateConfig> &StateMachineConfig::states() const
{
	return m_states;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void StateMachineConfig::clear_states()
{
	m_states.clear();
}

inline StateConfig *StateMachineConfig::mutable_states(unsigned x)
{
	if (x >= m_states.size())
		m_states.resize(x+1);
	return &m_states[x];
}

inline std::vector<StateConfig> *StateMachineConfig::mutable_states()
{
	return &m_states;
}

inline StateConfig *StateMachineConfig::add_states()
{
	m_states.resize(m_states.size()+1);
	return &m_states.back();
}

inline void StateMachineConfig::set_states(unsigned x, const StateConfig &v)
{
	assert(x < m_states.size());
	m_states[x] = v;
}

inline size_t StateMachineConfig::states_size() const
{
	return m_states.size();
}



inline bool StateMachineConfig::persistent() const
{
	return m_persistent;
}

inline bool StateMachineConfig::has_persistent() const
{
	return m_persistent != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void StateMachineConfig::clear_persistent()
{
	m_persistent = false;
}

inline bool *StateMachineConfig::mutable_persistent()
{
	return &m_persistent;
}

inline void StateMachineConfig::set_persistent(bool v)
{
	m_persistent = v;
}



inline size_t ThresholdConfig::getMaxSize()
{
	// optional string name, id 1 has unlimited size
	// optional float low, id 2 has maximum size 5
	// optional float high, id 3 has maximum size 5
	return SIZE_MAX;
}

inline const estring &ThresholdConfig::name() const
{
	return m_name;
}

inline bool ThresholdConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ThresholdConfig::clear_name()
{
	m_name.clear();
}

inline estring *ThresholdConfig::mutable_name()
{
	return &m_name;
}

inline void ThresholdConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void ThresholdConfig::set_name(const char *data)
{
	m_name = data;
}

inline void ThresholdConfig::set_name(const estring &v)
{
	m_name = v;
}



inline float ThresholdConfig::low() const
{
	return m_low;
}

inline bool ThresholdConfig::has_low() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ThresholdConfig::clear_low()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_low = 0;
}

inline float *ThresholdConfig::mutable_low()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_low = 0;
	}
	return &m_low;
}

inline void ThresholdConfig::set_low(float v)
{
	m_low = v;
	p_validbits |= ((uint8_t)1U << 0);
}



inline float ThresholdConfig::high() const
{
	return m_high;
}

inline bool ThresholdConfig::has_high() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ThresholdConfig::clear_high()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_high = 0;
}

inline float *ThresholdConfig::mutable_high()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_high = 0;
	}
	return &m_high;
}

inline void ThresholdConfig::set_high(float v)
{
	m_high = v;
	p_validbits |= ((uint8_t)1U << 1);
}



inline size_t EnvConfig::getMaxSize()
{
	// optional string path, id 1 has unlimited size
	// optional string title, id 2 has unlimited size
	// optional string action, id 3 has unlimited size
	return SIZE_MAX;
}

inline const estring &EnvConfig::path() const
{
	return m_path;
}

inline bool EnvConfig::has_path() const
{
	return !m_path.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void EnvConfig::clear_path()
{
	m_path.clear();
}

inline estring *EnvConfig::mutable_path()
{
	return &m_path;
}

inline void EnvConfig::set_path(const void *data, size_t s)
{
	m_path.assign((const char *)data,s);
}

inline void EnvConfig::set_path(const char *data)
{
	m_path = data;
}

inline void EnvConfig::set_path(const estring &v)
{
	m_path = v;
}



inline const estring &EnvConfig::title() const
{
	return m_title;
}

inline bool EnvConfig::has_title() const
{
	return !m_title.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void EnvConfig::clear_title()
{
	m_title.clear();
}

inline estring *EnvConfig::mutable_title()
{
	return &m_title;
}

inline void EnvConfig::set_title(const void *data, size_t s)
{
	m_title.assign((const char *)data,s);
}

inline void EnvConfig::set_title(const char *data)
{
	m_title = data;
}

inline void EnvConfig::set_title(const estring &v)
{
	m_title = v;
}



inline const estring &EnvConfig::action() const
{
	return m_action;
}

inline bool EnvConfig::has_action() const
{
	return !m_action.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void EnvConfig::clear_action()
{
	m_action.clear();
}

inline estring *EnvConfig::mutable_action()
{
	return &m_action;
}

inline void EnvConfig::set_action(const void *data, size_t s)
{
	m_action.assign((const char *)data,s);
}

inline void EnvConfig::set_action(const char *data)
{
	m_action = data;
}

inline void EnvConfig::set_action(const estring &v)
{
	m_action = v;
}



inline size_t ScreenConfig::getMaxSize()
{
	// repeated EnvConfig envs, id 1 has unlimited size
	// optional string font_tiny, id 4 has unlimited size
	// optional string font_small, id 5 has unlimited size
	// optional string font_medium, id 6 has unlimited size
	// optional string font_large, id 7 has unlimited size
	return SIZE_MAX;
}

inline const EnvConfig &ScreenConfig::envs(unsigned x) const
{
	return m_envs[x];
}

inline const std::vector<EnvConfig> &ScreenConfig::envs() const
{
	return m_envs;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ScreenConfig::clear_envs()
{
	m_envs.clear();
}

inline EnvConfig *ScreenConfig::mutable_envs(unsigned x)
{
	if (x >= m_envs.size())
		m_envs.resize(x+1);
	return &m_envs[x];
}

inline std::vector<EnvConfig> *ScreenConfig::mutable_envs()
{
	return &m_envs;
}

inline EnvConfig *ScreenConfig::add_envs()
{
	m_envs.resize(m_envs.size()+1);
	return &m_envs.back();
}

inline void ScreenConfig::set_envs(unsigned x, const EnvConfig &v)
{
	assert(x < m_envs.size());
	m_envs[x] = v;
}

inline size_t ScreenConfig::envs_size() const
{
	return m_envs.size();
}



inline const estring &ScreenConfig::font_tiny() const
{
	return m_font_tiny;
}

inline bool ScreenConfig::has_font_tiny() const
{
	return !m_font_tiny.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ScreenConfig::clear_font_tiny()
{
	m_font_tiny.clear();
}

inline estring *ScreenConfig::mutable_font_tiny()
{
	return &m_font_tiny;
}

inline void ScreenConfig::set_font_tiny(const void *data, size_t s)
{
	m_font_tiny.assign((const char *)data,s);
}

inline void ScreenConfig::set_font_tiny(const char *data)
{
	m_font_tiny = data;
}

inline void ScreenConfig::set_font_tiny(const estring &v)
{
	m_font_tiny = v;
}



inline const estring &ScreenConfig::font_small() const
{
	return m_font_small;
}

inline bool ScreenConfig::has_font_small() const
{
	return !m_font_small.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ScreenConfig::clear_font_small()
{
	m_font_small.clear();
}

inline estring *ScreenConfig::mutable_font_small()
{
	return &m_font_small;
}

inline void ScreenConfig::set_font_small(const void *data, size_t s)
{
	m_font_small.assign((const char *)data,s);
}

inline void ScreenConfig::set_font_small(const char *data)
{
	m_font_small = data;
}

inline void ScreenConfig::set_font_small(const estring &v)
{
	m_font_small = v;
}



inline const estring &ScreenConfig::font_medium() const
{
	return m_font_medium;
}

inline bool ScreenConfig::has_font_medium() const
{
	return !m_font_medium.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ScreenConfig::clear_font_medium()
{
	m_font_medium.clear();
}

inline estring *ScreenConfig::mutable_font_medium()
{
	return &m_font_medium;
}

inline void ScreenConfig::set_font_medium(const void *data, size_t s)
{
	m_font_medium.assign((const char *)data,s);
}

inline void ScreenConfig::set_font_medium(const char *data)
{
	m_font_medium = data;
}

inline void ScreenConfig::set_font_medium(const estring &v)
{
	m_font_medium = v;
}



inline const estring &ScreenConfig::font_large() const
{
	return m_font_large;
}

inline bool ScreenConfig::has_font_large() const
{
	return !m_font_large.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ScreenConfig::clear_font_large()
{
	m_font_large.clear();
}

inline estring *ScreenConfig::mutable_font_large()
{
	return &m_font_large;
}

inline void ScreenConfig::set_font_large(const void *data, size_t s)
{
	m_font_large.assign((const char *)data,s);
}

inline void ScreenConfig::set_font_large(const char *data)
{
	m_font_large = data;
}

inline void ScreenConfig::set_font_large(const estring &v)
{
	m_font_large = v;
}



inline size_t NodeConfig::getMaxSize()
{
	// optional fixed32 magic, id 0 has maximum size 5
	// optional string nodename, id 1 has unlimited size
	// optional bytes pass_hash, id 2 has unlimited size
	// optional unsigned cpu_freq, id 3 has maximum size 6
	// optional WifiConfig station, id 4 has maximum size 12
	// optional WifiConfig softap, id 5 has maximum size 12
	// repeated string dns_server, id 6 has unlimited size
	// optional string syslog_host, id 7 has unlimited size
	// optional string sntp_server, id 8 has unlimited size
	// optional string timezone, id 9 has unlimited size
	// optional MQTT mqtt, id 10 has maximum size 3
	// optional fixed16 dmesg_size, id 11 has maximum size 3
	// optional Influx influx, id 12 has maximum size 12
	// optional unsigned station2ap_time, id 13 has maximum size 6
	// optional string domainname, id 15 has unlimited size
	// repeated Date holidays, id 16 has unlimited size
	// repeated AtAction at_actions, id 17 has unlimited size
	// optional unsigned actions_enable, id 18 has maximum size 7
	// repeated Trigger triggers, id 19 has unlimited size
	// repeated UartSettings uart, id 20 has unlimited size
	// repeated TerminalConfig terminal, id 21 has unlimited size
	// optional fixed16 udp_ctrl_port, id 22 has maximum size 4
	// repeated string debugs, id 23 has unlimited size
	// optional FtpHttpConfig ftpd, id 24 has maximum size 5
	// optional FtpHttpConfig httpd, id 25 has maximum size 5
	// optional string otasrv, id 26 has unlimited size
	// optional ScreenConfig screen, id 27 has maximum size 4294967293
	// repeated EventTimer timefuses, id 30 has unlimited size
	// obsolete repeated SignalConfig signals, id 31
	// obsolete repeated FunctionConfig functions, id 32
	// repeated StateMachineConfig statemachs, id 33 has unlimited size
	// obsolete optional unsigned max_on_time, id 34
	// obsolete optional unsigned threshold_off, id 35
	// obsolete optional unsigned threshold_on, id 36
	// optional unsigned dim_step, id 37 has maximum size 7
	// obsolete optional bool lightctrl, id 38
	// optional unsigned pwm_freq, id 39 has maximum size 7
	// repeated AppParam app_params, id 40 has unlimited size
	// repeated ThresholdConfig thresholds, id 41 has unlimited size
	// repeated string luafiles, id 42 has unlimited size
	// optional bool lua_disable, id 43 has maximum size 3
	// repeated OwDeviceConfig owdevices, id 50 has unlimited size
	return SIZE_MAX;
}

inline uint32_t NodeConfig::magic() const
{
	return m_magic;
}

inline bool NodeConfig::has_magic() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_magic()
{
	p_validbits &= ~((uint16_t)1U << 0);
	m_magic = 0;
}

inline uint32_t *NodeConfig::mutable_magic()
{
	if (0 == (p_validbits & ((uint16_t)1U << 0))) {
		p_validbits |= ((uint16_t)1U << 0);
		m_magic = 0;
	}
	return &m_magic;
}

inline void NodeConfig::set_magic(uint32_t v)
{
	m_magic = v;
	p_validbits |= ((uint16_t)1U << 0);
}



inline const estring &NodeConfig::nodename() const
{
	return m_nodename;
}

inline bool NodeConfig::has_nodename() const
{
	return !m_nodename.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_nodename()
{
	m_nodename.clear();
}

inline estring *NodeConfig::mutable_nodename()
{
	return &m_nodename;
}

inline void NodeConfig::set_nodename(const void *data, size_t s)
{
	m_nodename.assign((const char *)data,s);
}

inline void NodeConfig::set_nodename(const char *data)
{
	m_nodename = data;
}

inline void NodeConfig::set_nodename(const estring &v)
{
	m_nodename = v;
}



inline const estring &NodeConfig::pass_hash() const
{
	return m_pass_hash;
}

inline bool NodeConfig::has_pass_hash() const
{
	return !m_pass_hash.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_pass_hash()
{
	m_pass_hash.clear();
}

inline estring *NodeConfig::mutable_pass_hash()
{
	return &m_pass_hash;
}

inline void NodeConfig::set_pass_hash(const void *data, size_t s)
{
	m_pass_hash.assign((const char *)data,s);
}

inline void NodeConfig::set_pass_hash(const estring &v)
{
	m_pass_hash = v;
}



inline uint32_t NodeConfig::cpu_freq() const
{
	return m_cpu_freq;
}

inline bool NodeConfig::has_cpu_freq() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_cpu_freq()
{
	p_validbits &= ~((uint16_t)1U << 1);
	m_cpu_freq = 0;
}

inline uint32_t *NodeConfig::mutable_cpu_freq()
{
	if (0 == (p_validbits & ((uint16_t)1U << 1))) {
		p_validbits |= ((uint16_t)1U << 1);
		m_cpu_freq = 0;
	}
	return &m_cpu_freq;
}

inline void NodeConfig::set_cpu_freq(uint32_t v)
{
	m_cpu_freq = v;
	p_validbits |= ((uint16_t)1U << 1);
}



inline const WifiConfig &NodeConfig::station() const
{
	return m_station;
}

inline bool NodeConfig::has_station() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_station()
{
	p_validbits &= ~((uint16_t)1U << 2);
	m_station.clear();
}

inline WifiConfig *NodeConfig::mutable_station()
{
	if (0 == (p_validbits & ((uint16_t)1U << 2))) {
		p_validbits |= ((uint16_t)1U << 2);
		m_station.clear();
	}
	return &m_station;
}

inline void NodeConfig::set_station(const void *data, size_t s)
{
	m_station.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 2);
}

inline void NodeConfig::set_station(const WifiConfig &v)
{
	m_station = v;
	p_validbits |= ((uint16_t)1U << 2);
}



inline const WifiConfig &NodeConfig::softap() const
{
	return m_softap;
}

inline bool NodeConfig::has_softap() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 3));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_softap()
{
	p_validbits &= ~((uint16_t)1U << 3);
	m_softap.clear();
}

inline WifiConfig *NodeConfig::mutable_softap()
{
	if (0 == (p_validbits & ((uint16_t)1U << 3))) {
		p_validbits |= ((uint16_t)1U << 3);
		m_softap.clear();
	}
	return &m_softap;
}

inline void NodeConfig::set_softap(const void *data, size_t s)
{
	m_softap.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 3);
}

inline void NodeConfig::set_softap(const WifiConfig &v)
{
	m_softap = v;
	p_validbits |= ((uint16_t)1U << 3);
}



inline const estring &NodeConfig::dns_server(unsigned x) const
{
	return m_dns_server[x];
}

inline const std::vector<estring> &NodeConfig::dns_server() const
{
	return m_dns_server;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_dns_server()
{
	m_dns_server.clear();
}

inline estring *NodeConfig::mutable_dns_server(unsigned x)
{
	if (x >= m_dns_server.size())
		m_dns_server.resize(x+1);
	return &m_dns_server[x];
}

inline std::vector<estring> *NodeConfig::mutable_dns_server()
{
	return &m_dns_server;
}

inline void NodeConfig::add_dns_server(const estring &v)
{
	m_dns_server.push_back(v);
}

inline void NodeConfig::add_dns_server(const char *s)
{
	m_dns_server.push_back(s);
}

inline void NodeConfig::set_dns_server(unsigned x, const estring &v)
{
	assert(x < m_dns_server.size());
	m_dns_server[x] = v;
}

inline size_t NodeConfig::dns_server_size() const
{
	return m_dns_server.size();
}



inline const estring &NodeConfig::syslog_host() const
{
	return m_syslog_host;
}

inline bool NodeConfig::has_syslog_host() const
{
	return !m_syslog_host.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_syslog_host()
{
	m_syslog_host.clear();
}

inline estring *NodeConfig::mutable_syslog_host()
{
	return &m_syslog_host;
}

inline void NodeConfig::set_syslog_host(const void *data, size_t s)
{
	m_syslog_host.assign((const char *)data,s);
}

inline void NodeConfig::set_syslog_host(const char *data)
{
	m_syslog_host = data;
}

inline void NodeConfig::set_syslog_host(const estring &v)
{
	m_syslog_host = v;
}



inline const estring &NodeConfig::sntp_server() const
{
	return m_sntp_server;
}

inline bool NodeConfig::has_sntp_server() const
{
	return !m_sntp_server.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_sntp_server()
{
	m_sntp_server.clear();
}

inline estring *NodeConfig::mutable_sntp_server()
{
	return &m_sntp_server;
}

inline void NodeConfig::set_sntp_server(const void *data, size_t s)
{
	m_sntp_server.assign((const char *)data,s);
}

inline void NodeConfig::set_sntp_server(const char *data)
{
	m_sntp_server = data;
}

inline void NodeConfig::set_sntp_server(const estring &v)
{
	m_sntp_server = v;
}



inline const estring &NodeConfig::timezone() const
{
	return m_timezone;
}

inline bool NodeConfig::has_timezone() const
{
	return !m_timezone.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_timezone()
{
	m_timezone.clear();
}

inline estring *NodeConfig::mutable_timezone()
{
	return &m_timezone;
}

inline void NodeConfig::set_timezone(const void *data, size_t s)
{
	m_timezone.assign((const char *)data,s);
}

inline void NodeConfig::set_timezone(const char *data)
{
	m_timezone = data;
}

inline void NodeConfig::set_timezone(const estring &v)
{
	m_timezone = v;
}



#ifdef CONFIG_MQTT
inline const MQTT &NodeConfig::mqtt() const
{
	return m_mqtt;
}

inline bool NodeConfig::has_mqtt() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 4));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_mqtt()
{
	p_validbits &= ~((uint16_t)1U << 4);
	m_mqtt.clear();
}

inline MQTT *NodeConfig::mutable_mqtt()
{
	if (0 == (p_validbits & ((uint16_t)1U << 4))) {
		p_validbits |= ((uint16_t)1U << 4);
		m_mqtt.clear();
	}
	return &m_mqtt;
}

inline void NodeConfig::set_mqtt(const void *data, size_t s)
{
	m_mqtt.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 4);
}

inline void NodeConfig::set_mqtt(const MQTT &v)
{
	m_mqtt = v;
	p_validbits |= ((uint16_t)1U << 4);
}

#endif // CONFIG_MQTT


inline uint16_t NodeConfig::dmesg_size() const
{
	return m_dmesg_size;
}

inline bool NodeConfig::has_dmesg_size() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 5));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_dmesg_size()
{
	p_validbits &= ~((uint16_t)1U << 5);
	m_dmesg_size = 2048;
}

inline uint16_t *NodeConfig::mutable_dmesg_size()
{
	if (0 == (p_validbits & ((uint16_t)1U << 5))) {
		p_validbits |= ((uint16_t)1U << 5);
		m_dmesg_size = 2048;
	}
	return &m_dmesg_size;
}

inline void NodeConfig::set_dmesg_size(uint16_t v)
{
	m_dmesg_size = v;
	p_validbits |= ((uint16_t)1U << 5);
}



#ifdef CONFIG_INFLUX
inline const Influx &NodeConfig::influx() const
{
	return m_influx;
}

inline bool NodeConfig::has_influx() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 6));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_influx()
{
	p_validbits &= ~((uint16_t)1U << 6);
	m_influx.clear();
}

inline Influx *NodeConfig::mutable_influx()
{
	if (0 == (p_validbits & ((uint16_t)1U << 6))) {
		p_validbits |= ((uint16_t)1U << 6);
		m_influx.clear();
	}
	return &m_influx;
}

inline void NodeConfig::set_influx(const void *data, size_t s)
{
	m_influx.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 6);
}

inline void NodeConfig::set_influx(const Influx &v)
{
	m_influx = v;
	p_validbits |= ((uint16_t)1U << 6);
}

#endif // CONFIG_INFLUX


inline uint32_t NodeConfig::station2ap_time() const
{
	return m_station2ap_time;
}

inline bool NodeConfig::has_station2ap_time() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 7));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_station2ap_time()
{
	p_validbits &= ~((uint16_t)1U << 7);
	m_station2ap_time = 0;
}

inline uint32_t *NodeConfig::mutable_station2ap_time()
{
	if (0 == (p_validbits & ((uint16_t)1U << 7))) {
		p_validbits |= ((uint16_t)1U << 7);
		m_station2ap_time = 0;
	}
	return &m_station2ap_time;
}

inline void NodeConfig::set_station2ap_time(uint32_t v)
{
	m_station2ap_time = v;
	p_validbits |= ((uint16_t)1U << 7);
}



inline const estring &NodeConfig::domainname() const
{
	return m_domainname;
}

inline bool NodeConfig::has_domainname() const
{
	return !m_domainname.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_domainname()
{
	m_domainname.clear();
}

inline estring *NodeConfig::mutable_domainname()
{
	return &m_domainname;
}

inline void NodeConfig::set_domainname(const void *data, size_t s)
{
	m_domainname.assign((const char *)data,s);
}

inline void NodeConfig::set_domainname(const char *data)
{
	m_domainname = data;
}

inline void NodeConfig::set_domainname(const estring &v)
{
	m_domainname = v;
}



inline const Date &NodeConfig::holidays(unsigned x) const
{
	return m_holidays[x];
}

inline const std::vector<Date> &NodeConfig::holidays() const
{
	return m_holidays;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_holidays()
{
	m_holidays.clear();
}

inline Date *NodeConfig::mutable_holidays(unsigned x)
{
	if (x >= m_holidays.size())
		m_holidays.resize(x+1);
	return &m_holidays[x];
}

inline std::vector<Date> *NodeConfig::mutable_holidays()
{
	return &m_holidays;
}

inline Date *NodeConfig::add_holidays()
{
	m_holidays.resize(m_holidays.size()+1);
	return &m_holidays.back();
}

inline void NodeConfig::set_holidays(unsigned x, const Date &v)
{
	assert(x < m_holidays.size());
	m_holidays[x] = v;
}

inline size_t NodeConfig::holidays_size() const
{
	return m_holidays.size();
}



inline const AtAction &NodeConfig::at_actions(unsigned x) const
{
	return m_at_actions[x];
}

inline const std::vector<AtAction> &NodeConfig::at_actions() const
{
	return m_at_actions;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_at_actions()
{
	m_at_actions.clear();
}

inline AtAction *NodeConfig::mutable_at_actions(unsigned x)
{
	if (x >= m_at_actions.size())
		m_at_actions.resize(x+1);
	return &m_at_actions[x];
}

inline std::vector<AtAction> *NodeConfig::mutable_at_actions()
{
	return &m_at_actions;
}

inline AtAction *NodeConfig::add_at_actions()
{
	m_at_actions.resize(m_at_actions.size()+1);
	return &m_at_actions.back();
}

inline void NodeConfig::set_at_actions(unsigned x, const AtAction &v)
{
	assert(x < m_at_actions.size());
	m_at_actions[x] = v;
}

inline size_t NodeConfig::at_actions_size() const
{
	return m_at_actions.size();
}



inline uint32_t NodeConfig::actions_enable() const
{
	return m_actions_enable;
}

inline bool NodeConfig::has_actions_enable() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 8));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_actions_enable()
{
	p_validbits &= ~((uint16_t)1U << 8);
	m_actions_enable = 1;
}

inline uint32_t *NodeConfig::mutable_actions_enable()
{
	if (0 == (p_validbits & ((uint16_t)1U << 8))) {
		p_validbits |= ((uint16_t)1U << 8);
		m_actions_enable = 1;
	}
	return &m_actions_enable;
}

inline void NodeConfig::set_actions_enable(uint32_t v)
{
	m_actions_enable = v;
	p_validbits |= ((uint16_t)1U << 8);
}



inline const Trigger &NodeConfig::triggers(unsigned x) const
{
	return m_triggers[x];
}

inline const std::vector<Trigger> &NodeConfig::triggers() const
{
	return m_triggers;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_triggers()
{
	m_triggers.clear();
}

inline Trigger *NodeConfig::mutable_triggers(unsigned x)
{
	if (x >= m_triggers.size())
		m_triggers.resize(x+1);
	return &m_triggers[x];
}

inline std::vector<Trigger> *NodeConfig::mutable_triggers()
{
	return &m_triggers;
}

inline Trigger *NodeConfig::add_triggers()
{
	m_triggers.resize(m_triggers.size()+1);
	return &m_triggers.back();
}

inline void NodeConfig::set_triggers(unsigned x, const Trigger &v)
{
	assert(x < m_triggers.size());
	m_triggers[x] = v;
}

inline size_t NodeConfig::triggers_size() const
{
	return m_triggers.size();
}



inline const UartSettings &NodeConfig::uart(unsigned x) const
{
	return m_uart[x];
}

inline const std::vector<UartSettings> &NodeConfig::uart() const
{
	return m_uart;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_uart()
{
	m_uart.clear();
}

inline UartSettings *NodeConfig::mutable_uart(unsigned x)
{
	if (x >= m_uart.size())
		m_uart.resize(x+1);
	return &m_uart[x];
}

inline std::vector<UartSettings> *NodeConfig::mutable_uart()
{
	return &m_uart;
}

inline UartSettings *NodeConfig::add_uart()
{
	m_uart.resize(m_uart.size()+1);
	return &m_uart.back();
}

inline void NodeConfig::set_uart(unsigned x, const UartSettings &v)
{
	assert(x < m_uart.size());
	m_uart[x] = v;
}

inline size_t NodeConfig::uart_size() const
{
	return m_uart.size();
}



#ifdef CONFIG_TERMSERV
inline const TerminalConfig &NodeConfig::terminal(unsigned x) const
{
	return m_terminal[x];
}

inline const std::vector<TerminalConfig> &NodeConfig::terminal() const
{
	return m_terminal;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_terminal()
{
	m_terminal.clear();
}

inline TerminalConfig *NodeConfig::mutable_terminal(unsigned x)
{
	if (x >= m_terminal.size())
		m_terminal.resize(x+1);
	return &m_terminal[x];
}

inline std::vector<TerminalConfig> *NodeConfig::mutable_terminal()
{
	return &m_terminal;
}

inline TerminalConfig *NodeConfig::add_terminal()
{
	m_terminal.resize(m_terminal.size()+1);
	return &m_terminal.back();
}

inline void NodeConfig::set_terminal(unsigned x, const TerminalConfig &v)
{
	assert(x < m_terminal.size());
	m_terminal[x] = v;
}

inline size_t NodeConfig::terminal_size() const
{
	return m_terminal.size();
}

#endif // CONFIG_TERMSERV


inline uint16_t NodeConfig::udp_ctrl_port() const
{
	return m_udp_ctrl_port;
}

inline bool NodeConfig::has_udp_ctrl_port() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 9));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_udp_ctrl_port()
{
	p_validbits &= ~((uint16_t)1U << 9);
	m_udp_ctrl_port = 12719;
}

inline uint16_t *NodeConfig::mutable_udp_ctrl_port()
{
	if (0 == (p_validbits & ((uint16_t)1U << 9))) {
		p_validbits |= ((uint16_t)1U << 9);
		m_udp_ctrl_port = 12719;
	}
	return &m_udp_ctrl_port;
}

inline void NodeConfig::set_udp_ctrl_port(uint16_t v)
{
	m_udp_ctrl_port = v;
	p_validbits |= ((uint16_t)1U << 9);
}



inline const estring &NodeConfig::debugs(unsigned x) const
{
	return m_debugs[x];
}

inline const std::vector<estring> &NodeConfig::debugs() const
{
	return m_debugs;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_debugs()
{
	m_debugs.clear();
}

inline estring *NodeConfig::mutable_debugs(unsigned x)
{
	if (x >= m_debugs.size())
		m_debugs.resize(x+1);
	return &m_debugs[x];
}

inline std::vector<estring> *NodeConfig::mutable_debugs()
{
	return &m_debugs;
}

inline void NodeConfig::add_debugs(const estring &v)
{
	m_debugs.push_back(v);
}

inline void NodeConfig::add_debugs(const char *s)
{
	m_debugs.push_back(s);
}

inline void NodeConfig::set_debugs(unsigned x, const estring &v)
{
	assert(x < m_debugs.size());
	m_debugs[x] = v;
}

inline size_t NodeConfig::debugs_size() const
{
	return m_debugs.size();
}



#ifdef CONFIG_FTP
inline const FtpHttpConfig &NodeConfig::ftpd() const
{
	return m_ftpd;
}

inline bool NodeConfig::has_ftpd() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 10));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_ftpd()
{
	p_validbits &= ~((uint16_t)1U << 10);
	m_ftpd.clear();
}

inline FtpHttpConfig *NodeConfig::mutable_ftpd()
{
	if (0 == (p_validbits & ((uint16_t)1U << 10))) {
		p_validbits |= ((uint16_t)1U << 10);
		m_ftpd.clear();
	}
	return &m_ftpd;
}

inline void NodeConfig::set_ftpd(const void *data, size_t s)
{
	m_ftpd.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 10);
}

inline void NodeConfig::set_ftpd(const FtpHttpConfig &v)
{
	m_ftpd = v;
	p_validbits |= ((uint16_t)1U << 10);
}

#endif // CONFIG_FTP


#ifdef CONFIG_HTTP
inline const FtpHttpConfig &NodeConfig::httpd() const
{
	return m_httpd;
}

inline bool NodeConfig::has_httpd() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 11));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_httpd()
{
	p_validbits &= ~((uint16_t)1U << 11);
	m_httpd.clear();
}

inline FtpHttpConfig *NodeConfig::mutable_httpd()
{
	if (0 == (p_validbits & ((uint16_t)1U << 11))) {
		p_validbits |= ((uint16_t)1U << 11);
		m_httpd.clear();
	}
	return &m_httpd;
}

inline void NodeConfig::set_httpd(const void *data, size_t s)
{
	m_httpd.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 11);
}

inline void NodeConfig::set_httpd(const FtpHttpConfig &v)
{
	m_httpd = v;
	p_validbits |= ((uint16_t)1U << 11);
}

#endif // CONFIG_HTTP


inline const estring &NodeConfig::otasrv() const
{
	return m_otasrv;
}

inline bool NodeConfig::has_otasrv() const
{
	return !m_otasrv.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_otasrv()
{
	m_otasrv.clear();
}

inline estring *NodeConfig::mutable_otasrv()
{
	return &m_otasrv;
}

inline void NodeConfig::set_otasrv(const void *data, size_t s)
{
	m_otasrv.assign((const char *)data,s);
}

inline void NodeConfig::set_otasrv(const char *data)
{
	m_otasrv = data;
}

inline void NodeConfig::set_otasrv(const estring &v)
{
	m_otasrv = v;
}



#ifdef CONFIG_DISPLAY
inline const ScreenConfig &NodeConfig::screen() const
{
	return m_screen;
}

inline bool NodeConfig::has_screen() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 12));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_screen()
{
	p_validbits &= ~((uint16_t)1U << 12);
	m_screen.clear();
}

inline ScreenConfig *NodeConfig::mutable_screen()
{
	if (0 == (p_validbits & ((uint16_t)1U << 12))) {
		p_validbits |= ((uint16_t)1U << 12);
		m_screen.clear();
	}
	return &m_screen;
}

inline void NodeConfig::set_screen(const void *data, size_t s)
{
	m_screen.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 12);
}

inline void NodeConfig::set_screen(const ScreenConfig &v)
{
	m_screen = v;
	p_validbits |= ((uint16_t)1U << 12);
}

#endif // CONFIG_DISPLAY


inline const EventTimer &NodeConfig::timefuses(unsigned x) const
{
	return m_timefuses[x];
}

inline const std::vector<EventTimer> &NodeConfig::timefuses() const
{
	return m_timefuses;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_timefuses()
{
	m_timefuses.clear();
}

inline EventTimer *NodeConfig::mutable_timefuses(unsigned x)
{
	if (x >= m_timefuses.size())
		m_timefuses.resize(x+1);
	return &m_timefuses[x];
}

inline std::vector<EventTimer> *NodeConfig::mutable_timefuses()
{
	return &m_timefuses;
}

inline EventTimer *NodeConfig::add_timefuses()
{
	m_timefuses.resize(m_timefuses.size()+1);
	return &m_timefuses.back();
}

inline void NodeConfig::set_timefuses(unsigned x, const EventTimer &v)
{
	assert(x < m_timefuses.size());
	m_timefuses[x] = v;
}

inline size_t NodeConfig::timefuses_size() const
{
	return m_timefuses.size();
}



#ifdef CONFIG_STATEMACHINES
inline const StateMachineConfig &NodeConfig::statemachs(unsigned x) const
{
	return m_statemachs[x];
}

inline const std::vector<StateMachineConfig> &NodeConfig::statemachs() const
{
	return m_statemachs;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_statemachs()
{
	m_statemachs.clear();
}

inline StateMachineConfig *NodeConfig::mutable_statemachs(unsigned x)
{
	if (x >= m_statemachs.size())
		m_statemachs.resize(x+1);
	return &m_statemachs[x];
}

inline std::vector<StateMachineConfig> *NodeConfig::mutable_statemachs()
{
	return &m_statemachs;
}

inline StateMachineConfig *NodeConfig::add_statemachs()
{
	m_statemachs.resize(m_statemachs.size()+1);
	return &m_statemachs.back();
}

inline void NodeConfig::set_statemachs(unsigned x, const StateMachineConfig &v)
{
	assert(x < m_statemachs.size());
	m_statemachs[x] = v;
}

inline size_t NodeConfig::statemachs_size() const
{
	return m_statemachs.size();
}

#endif // CONFIG_STATEMACHINES


inline uint32_t NodeConfig::dim_step() const
{
	return m_dim_step;
}

inline bool NodeConfig::has_dim_step() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 13));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_dim_step()
{
	p_validbits &= ~((uint16_t)1U << 13);
	m_dim_step = 0;
}

inline uint32_t *NodeConfig::mutable_dim_step()
{
	if (0 == (p_validbits & ((uint16_t)1U << 13))) {
		p_validbits |= ((uint16_t)1U << 13);
		m_dim_step = 0;
	}
	return &m_dim_step;
}

inline void NodeConfig::set_dim_step(uint32_t v)
{
	m_dim_step = v;
	p_validbits |= ((uint16_t)1U << 13);
}



inline uint32_t NodeConfig::pwm_freq() const
{
	return m_pwm_freq;
}

inline bool NodeConfig::has_pwm_freq() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 14));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_pwm_freq()
{
	p_validbits &= ~((uint16_t)1U << 14);
	m_pwm_freq = 0;
}

inline uint32_t *NodeConfig::mutable_pwm_freq()
{
	if (0 == (p_validbits & ((uint16_t)1U << 14))) {
		p_validbits |= ((uint16_t)1U << 14);
		m_pwm_freq = 0;
	}
	return &m_pwm_freq;
}

inline void NodeConfig::set_pwm_freq(uint32_t v)
{
	m_pwm_freq = v;
	p_validbits |= ((uint16_t)1U << 14);
}



#ifdef CONFIG_APP_PARAMS
inline const AppParam &NodeConfig::app_params(unsigned x) const
{
	return m_app_params[x];
}

inline const std::vector<AppParam> &NodeConfig::app_params() const
{
	return m_app_params;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_app_params()
{
	m_app_params.clear();
}

inline AppParam *NodeConfig::mutable_app_params(unsigned x)
{
	if (x >= m_app_params.size())
		m_app_params.resize(x+1);
	return &m_app_params[x];
}

inline std::vector<AppParam> *NodeConfig::mutable_app_params()
{
	return &m_app_params;
}

inline AppParam *NodeConfig::add_app_params()
{
	m_app_params.resize(m_app_params.size()+1);
	return &m_app_params.back();
}

inline void NodeConfig::set_app_params(unsigned x, const AppParam &v)
{
	assert(x < m_app_params.size());
	m_app_params[x] = v;
}

inline size_t NodeConfig::app_params_size() const
{
	return m_app_params.size();
}

#endif // CONFIG_APP_PARAMS


#ifdef CONFIG_THRESHOLDS
inline const ThresholdConfig &NodeConfig::thresholds(unsigned x) const
{
	return m_thresholds[x];
}

inline const std::vector<ThresholdConfig> &NodeConfig::thresholds() const
{
	return m_thresholds;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_thresholds()
{
	m_thresholds.clear();
}

inline ThresholdConfig *NodeConfig::mutable_thresholds(unsigned x)
{
	if (x >= m_thresholds.size())
		m_thresholds.resize(x+1);
	return &m_thresholds[x];
}

inline std::vector<ThresholdConfig> *NodeConfig::mutable_thresholds()
{
	return &m_thresholds;
}

inline ThresholdConfig *NodeConfig::add_thresholds()
{
	m_thresholds.resize(m_thresholds.size()+1);
	return &m_thresholds.back();
}

inline void NodeConfig::set_thresholds(unsigned x, const ThresholdConfig &v)
{
	assert(x < m_thresholds.size());
	m_thresholds[x] = v;
}

inline size_t NodeConfig::thresholds_size() const
{
	return m_thresholds.size();
}

#endif // CONFIG_THRESHOLDS


#ifdef CONFIG_LUA
inline const estring &NodeConfig::luafiles(unsigned x) const
{
	return m_luafiles[x];
}

inline const std::vector<estring> &NodeConfig::luafiles() const
{
	return m_luafiles;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_luafiles()
{
	m_luafiles.clear();
}

inline estring *NodeConfig::mutable_luafiles(unsigned x)
{
	if (x >= m_luafiles.size())
		m_luafiles.resize(x+1);
	return &m_luafiles[x];
}

inline std::vector<estring> *NodeConfig::mutable_luafiles()
{
	return &m_luafiles;
}

inline void NodeConfig::add_luafiles(const estring &v)
{
	m_luafiles.push_back(v);
}

inline void NodeConfig::add_luafiles(const char *s)
{
	m_luafiles.push_back(s);
}

inline void NodeConfig::set_luafiles(unsigned x, const estring &v)
{
	assert(x < m_luafiles.size());
	m_luafiles[x] = v;
}

inline size_t NodeConfig::luafiles_size() const
{
	return m_luafiles.size();
}

#endif // CONFIG_LUA


#ifdef CONFIG_LUA
inline bool NodeConfig::lua_disable() const
{
	return m_lua_disable;
}

inline bool NodeConfig::has_lua_disable() const
{
	return m_lua_disable != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_lua_disable()
{
	m_lua_disable = false;
}

inline bool *NodeConfig::mutable_lua_disable()
{
	return &m_lua_disable;
}

inline void NodeConfig::set_lua_disable(bool v)
{
	m_lua_disable = v;
}

#endif // CONFIG_LUA


#ifdef CONFIG_ONEWIRE
inline const OwDeviceConfig &NodeConfig::owdevices(unsigned x) const
{
	return m_owdevices[x];
}

inline const std::vector<OwDeviceConfig> &NodeConfig::owdevices() const
{
	return m_owdevices;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void NodeConfig::clear_owdevices()
{
	m_owdevices.clear();
}

inline OwDeviceConfig *NodeConfig::mutable_owdevices(unsigned x)
{
	if (x >= m_owdevices.size())
		m_owdevices.resize(x+1);
	return &m_owdevices[x];
}

inline std::vector<OwDeviceConfig> *NodeConfig::mutable_owdevices()
{
	return &m_owdevices;
}

inline OwDeviceConfig *NodeConfig::add_owdevices()
{
	m_owdevices.resize(m_owdevices.size()+1);
	return &m_owdevices.back();
}

inline void NodeConfig::set_owdevices(unsigned x, const OwDeviceConfig &v)
{
	assert(x < m_owdevices.size());
	m_owdevices[x] = v;
}

inline size_t NodeConfig::owdevices_size() const
{
	return m_owdevices.size();
}

#endif // CONFIG_ONEWIRE


#endif
