/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: P2304.21 (hg:477/6f02a2b83060)
 * WFC is Copyright 2015-2025, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : swcfg.wfc
 * Copyright: 2018-2025
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2025-05-13, 08:33:00 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from esp8285:
 * BaseClass       : ""
 * enummap         : ""
 * enumnames       : ""
 * getMember       : ""
 * toASCII         : ""
 * toPbt           : ""
 * 
 * options from esp8266:
 * Optimize        : "size"
 * 
 * options from esp:
 * bytestype       : "estring"
 * intsize         : 32
 * stringtype      : "estring"
 * toSink          : ""
 * toString        : ""
 * toWire          : ""
 * varintbits      : 32
 * 
 * options from common:
 * SortMembers     : "size"
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bool      : "ascii_bool"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * calcSize        : "calcSize"
 * cfgdefs         : ""
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * ClearValue      : "compatible"
 * copyright       : ""
 * email           : ""
 * endian          : "unknown"
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * pbt_indent      : "pbt_indent"
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * UnknownField    : "skip"
 * wireput         : ""
 * wiresize        : ""
 * 
 * disabled flags from esp8266:
 * 	withUnequal
 * enabled flags from esp:
 * 	withEqual
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux
 */

#include <stdlib.h>
#include <string.h>
#include "swcfg_esp8285.h"

#include "wfccore_esp8285.h"

#if !defined(WFC_ENDIAN) || (WFC_ENDIAN != 0)
#error wfc: incompatible settings concerning endian
#endif


const char *strReset(rstrsn_t e)
{
	switch (e) {
	default:
		return 0;
	case unknown:
		return "unknown";
	case powerup:
		return "powerup";
	case external:
		return "external";
	case software:
		return "software";
	case panic:
		return "panic";
	case internal_wdt:
		return "internal_wdt";
	case task_wdt:
		return "task_wdt";
	case watchdog:
		return "watchdog";
	case deepsleep:
		return "deepsleep";
	case brownout:
		return "brownout";
	case sdio:
		return "sdio";
	}
}

const char *WeekDay_str(WeekDay e)
{
	switch (e) {
	default:
		return 0;
	case Sunday:
		return "Sunday";
	case Monday:
		return "Monday";
	case Tuesday:
		return "Tuesday";
	case Wednesday:
		return "Wednesday";
	case Thursday:
		return "Thursday";
	case Friday:
		return "Friday";
	case Saturday:
		return "Saturday";
	case WorkDay:
		return "WorkDay";
	case WeekEnd:
		return "WeekEnd";
	case EveryDay:
		return "EveryDay";
	case Holiday:
		return "Holiday";
	}
}

const char *uart_wl_t_str(uart_wl_t e)
{
	switch (e) {
	default:
		return 0;
	case uart_wl_5:
		return "uart_wl_5";
	case uart_wl_6:
		return "uart_wl_6";
	case uart_wl_7:
		return "uart_wl_7";
	case uart_wl_8:
		return "uart_wl_8";
	}
}

const char *uart_sb_t_str(uart_sb_t e)
{
	switch (e) {
	default:
		return 0;
	case uart_sb_none:
		return "uart_sb_none";
	case uart_sb_1:
		return "uart_sb_1";
	case uart_sb_1_5:
		return "uart_sb_1_5";
	case uart_sb_2:
		return "uart_sb_2";
	}
}

const char *uart_p_t_str(uart_p_t e)
{
	switch (e) {
	default:
		return 0;
	case uart_p_n:
		return "uart_p_n";
	case uart_p_e:
		return "uart_p_e";
	case uart_p_o:
		return "uart_p_o";
	}
}

const char *sigtype_t_str(sigtype_t e)
{
	switch (e) {
	default:
		return 0;
	case st_invalid:
		return "st_invalid";
	case st_int:
		return "st_int";
	case st_float:
		return "st_float";
	case st_string:
		return "st_string";
	}
}

WifiConfig::WifiConfig()
{
}

void WifiConfig::clear()
{
	m_ssid.clear();
	m_pass.clear();
	m_mac.clear();
	m_activate = false;
	m_addr4 = 0;
	m_netmask4 = 0;
	m_gateway4 = 0;
	p_validbits = 0;
}

ssize_t WifiConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -1;
		a += x;
		switch (fid) {
		case 0xa:	// ssid id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -2;
			}
			m_ssid.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x12:	// pass id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -3;
			}
			m_pass.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x1a:	// mac id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -4;
			}
			m_mac.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x23:	// activate id 4, type bool, coding 8bit
			m_activate = ud.u8;
			break;
		case 0x2d:	// addr4 id 5, type uint32_t, coding 32bit
			set_addr4(ud.u32);
			break;
		case 0x33:	// netmask4 id 6, type uint8_t, coding 8bit
			set_netmask4(ud.u8);
			break;
		case 0x3d:	// gateway4 id 7, type uint32_t, coding 32bit
			set_gateway4(ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -5;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -6;
	return a-(const uint8_t *)b;
}

ssize_t WifiConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has ssid?
	if (!m_ssid.empty()) {
		// 'ssid': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -7;
		*a++ = 0xa;
		n = encode_bytes(m_ssid,a,e);
		if (n < 0)
			return -8;
		a += n;
	}
	// has pass?
	if (!m_pass.empty()) {
		// 'pass': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -9;
		*a++ = 0x12;
		n = encode_bytes(m_pass,a,e);
		if (n < 0)
			return -10;
		a += n;
	}
	// has mac?
	if (!m_mac.empty()) {
		// 'mac': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -11;
		*a++ = 0x1a;
		n = encode_bytes(m_mac,a,e);
		if (n < 0)
			return -12;
		a += n;
	}
	// 'activate': id=4, encoding=8bit, tag=0x23
	if (2 > (e-a))
		return -13;
	*a++ = 0x23;
	*a++ = m_activate;
	// has addr4?
	if (0 != (p_validbits & ((uint8_t)1U << vb_addr4))) {
		// 'addr4': id=5, encoding=32bit, tag=0x2d
		if (5 > (e-a))
			return -14;
		*a++ = 0x2d;
		if ((e-a) < 4)
			return -15;
		write_u32(a,(uint32_t)m_addr4);
		a += 4;
	}
	// has netmask4?
	if (0 != (p_validbits & ((uint8_t)1U << vb_netmask4))) {
		// 'netmask4': id=6, encoding=8bit, tag=0x33
		if (2 > (e-a))
			return -16;
		*a++ = 0x33;
		*a++ = m_netmask4;
	}
	// has gateway4?
	if (0 != (p_validbits & ((uint8_t)1U << vb_gateway4))) {
		// 'gateway4': id=7, encoding=32bit, tag=0x3d
		if (5 > (e-a))
			return -17;
		*a++ = 0x3d;
		if ((e-a) < 4)
			return -18;
		write_u32(a,(uint32_t)m_gateway4);
		a += 4;
	}
	assert(a <= e);
	return a-b;
}

void WifiConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_ssid()) {
		fsep = json_indent(json,indLvl,fsep,"ssid");
		json_cstr(json,m_ssid.c_str());
	}
	if (full || has_pass()) {
		fsep = json_indent(json,indLvl,fsep,"pass");
		json_cstr(json,m_pass.c_str());
	}
	if (full || has_mac()) {
		fsep = json_indent(json,indLvl,fsep,"mac");
		json_string(json,m_mac);
	}
	fsep = json_indent(json,indLvl,fsep,"activate");
	json << (m_activate ? "true" : "false");
	if (full || has_addr4()) {
		fsep = json_indent(json,indLvl,fsep,"addr4");
		json.put('"');
		ip4_to_ascii(json,m_addr4);
		json.put('"');
	}
	if (full || has_netmask4()) {
		fsep = json_indent(json,indLvl,fsep,"netmask4");
		to_decstr(json,(unsigned) m_netmask4);
	}
	if (full || has_gateway4()) {
		fsep = json_indent(json,indLvl,fsep,"gateway4");
		json.put('"');
		ip4_to_ascii(json,m_gateway4);
		json.put('"');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t WifiConfig::calcSize() const
{
	// bool activate: tagsize 1, data size 1
	size_t r = 2;	// required size, default is fixed length
	// optional string ssid, id 1
	if (has_ssid()) {
		size_t ssid_s = m_ssid.size();
		r += ssid_s + wiresize(ssid_s) + 1 /* tag(ssid) 0x8 */;
	}
	// optional string pass, id 2
	if (has_pass()) {
		size_t pass_s = m_pass.size();
		r += pass_s + wiresize(pass_s) + 1 /* tag(pass) 0x10 */;
	}
	// optional bytes mac, id 3
	if (has_mac()) {
		size_t mac_s = m_mac.size();
		r += mac_s + wiresize(mac_s) + 1 /* tag(mac) 0x18 */;
	}
	// optional fixed32 addr4, id 5
	if (has_addr4()) {
		r += 5;
	}
	// optional fixed8 netmask4, id 6
	if (has_netmask4()) {
		r += 2;
	}
	// optional fixed32 gateway4, id 7
	if (has_gateway4()) {
		r += 5;
	}
	return r;
}

bool WifiConfig::operator == (const WifiConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_ssid() && (!(m_ssid == r.m_ssid)))
		return false;
	if (has_pass() && (!(m_pass == r.m_pass)))
		return false;
	if (has_mac() && (!(m_mac == r.m_mac)))
		return false;
	if (!(m_activate == r.m_activate))
		return false;
	if (has_addr4() && (!(m_addr4 == r.m_addr4)))
		return false;
	if (has_netmask4() && (!(m_netmask4 == r.m_netmask4)))
		return false;
	if (has_gateway4() && (!(m_gateway4 == r.m_gateway4)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int WifiConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"ssid")) {
		if (value == 0) {
			m_ssid.clear();
			return 0;
		}
		m_ssid = value;
		int r = m_ssid.size();
		return r;
	}
	if (0 == strcmp(name,"pass")) {
		if (value == 0) {
			m_pass.clear();
			return 0;
		}
		m_pass = value;
		int r = m_pass.size();
		return r;
	}
	if (0 == strcmp(name,"mac")) {
		if (value == 0) {
			m_mac.clear();
			return 0;
		}
		int r = parse_ascii_bytes(m_mac,value);
		return r;
	}
	if (0 == strcmp(name,"activate")) {
		int r = parse_ascii_bool(&m_activate,value);
		return r;
	}
	if (0 == strcmp(name,"addr4")) {
		if (value == 0) {
			clear_addr4();
			return 0;
		}
		int r = parse_ipv4(&m_addr4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"netmask4")) {
		if (value == 0) {
			clear_netmask4();
			return 0;
		}
		int r = parse_ascii_u8(&m_netmask4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"gateway4")) {
		if (value == 0) {
			clear_gateway4();
			return 0;
		}
		int r = parse_ipv4(&m_gateway4,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	return -19;
}

MQTT::MQTT()
{
}

void MQTT::clear()
{
	m_uri.clear();
	m_enable = false;
	m_username.clear();
	m_password.clear();
	m_subscribtions.clear();
}

ssize_t MQTT::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -20;
		a += x;
		switch (fid) {
		case 0xa:	// uri id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -21;
			}
			m_uri.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x13:	// enable id 2, type bool, coding 8bit
			set_enable(ud.u8);
			break;
		case 0x1a:	// username id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -22;
			}
			m_username.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x22:	// password id 4, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -23;
			}
			m_password.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x2a:	// subscribtions id 5, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -24;
			}
			m_subscribtions.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -25;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -26;
	return a-(const uint8_t *)b;
}

ssize_t MQTT::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has uri?
	if (!m_uri.empty()) {
		// 'uri': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -27;
		*a++ = 0xa;
		n = encode_bytes(m_uri,a,e);
		if (n < 0)
			return -28;
		a += n;
	}
	// has enable?
	if (m_enable != false) {
		// 'enable': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -29;
		*a++ = 0x13;
		*a++ = m_enable;
	}
	// has username?
	if (!m_username.empty()) {
		// 'username': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -30;
		*a++ = 0x1a;
		n = encode_bytes(m_username,a,e);
		if (n < 0)
			return -31;
		a += n;
	}
	// has password?
	if (!m_password.empty()) {
		// 'password': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -32;
		*a++ = 0x22;
		n = encode_bytes(m_password,a,e);
		if (n < 0)
			return -33;
		a += n;
	}
	for (const auto &x : m_subscribtions) {
		// 'subscribtions': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -34;
		*a++ = 0x2a;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -35;
		a += n;
	}
	// 'keepalive' is unused. Therefore no data will be written.
	assert(a <= e);
	return a-b;
}

void MQTT::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_uri()) {
		fsep = json_indent(json,indLvl,fsep,"uri");
		json_cstr(json,m_uri.c_str());
	}
	if (full || has_enable()) {
		fsep = json_indent(json,indLvl,fsep,"enable");
		json << (m_enable ? "true" : "false");
	}
	if (full || has_username()) {
		fsep = json_indent(json,indLvl,fsep,"username");
		json_cstr(json,m_username.c_str());
	}
	if (full || has_password()) {
		fsep = json_indent(json,indLvl,fsep,"password");
		json_cstr(json,m_password.c_str());
	}
	if (size_t s = m_subscribtions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"subscribtions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_subscribtions[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t MQTT::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string uri, id 1
	if (has_uri()) {
		size_t uri_s = m_uri.size();
		r += uri_s + wiresize(uri_s) + 1 /* tag(uri) 0x8 */;
	}
	// optional bool enable, id 2
	if (has_enable()) {
		r += 2;
	}
	// optional string username, id 3
	if (has_username()) {
		size_t username_s = m_username.size();
		r += username_s + wiresize(username_s) + 1 /* tag(username) 0x18 */;
	}
	// optional string password, id 4
	if (has_password()) {
		size_t password_s = m_password.size();
		r += password_s + wiresize(password_s) + 1 /* tag(password) 0x20 */;
	}
	// repeated string subscribtions, id 5
	if (!m_subscribtions.empty()) {
		// subscribtions: repeated estring
		for (size_t x = 0, y = m_subscribtions.size(); x < y; ++x) {
			size_t s = m_subscribtions[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(subscribtions) 0x28 */;
		}
	}
	// unused optional uint16 keepalive, id 6
	return r;
}

bool MQTT::operator == (const MQTT &r) const
{
	if (has_uri() && (!(m_uri == r.m_uri)))
		return false;
	if (has_enable() && (!(m_enable == r.m_enable)))
		return false;
	if (has_username() && (!(m_username == r.m_username)))
		return false;
	if (has_password() && (!(m_password == r.m_password)))
		return false;
	if (!(m_subscribtions == r.m_subscribtions))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int MQTT::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"uri")) {
		if (value == 0) {
			m_uri.clear();
			return 0;
		}
		m_uri = value;
		int r = m_uri.size();
		return r;
	}
	if (0 == strcmp(name,"enable")) {
		if (value == 0) {
			clear_enable();
			return 0;
		}
		int r = parse_ascii_bool(&m_enable,value);
		return r;
	}
	if (0 == strcmp(name,"username")) {
		if (value == 0) {
			m_username.clear();
			return 0;
		}
		m_username = value;
		int r = m_username.size();
		return r;
	}
	if (0 == strcmp(name,"password")) {
		if (value == 0) {
			m_password.clear();
			return 0;
		}
		m_password = value;
		int r = m_password.size();
		return r;
	}
	if (0 == memcmp(name,"subscribtions",13)) {
		if ((name[13] == 0) && (value == 0)) {
			clear_subscribtions();
			return 0;
		} else if (name[13] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[14] == '+') && (name[15] == ']')) {
				x = m_subscribtions.size();
				m_subscribtions.resize(x+1);
				idxe = (char*)(name + 15);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+14,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+14)))
					return -36;
				if (m_subscribtions.size() <= x)
					return -37;
				if ((idxe[1] == 0) && (value == 0)) {
					m_subscribtions.erase(m_subscribtions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -38;
			m_subscribtions[x] = value;
			return m_subscribtions[x].size();
		}
	}
	return -39;
}

Date::Date()
{
}

void Date::clear()
{
	m_day = 0;
	m_month = 0;
	m_year = 0;
	m_endday = 0;
	m_endmonth = 0;
	m_endyear = 0;
}

ssize_t Date::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -40;
		a += x;
		switch (fid) {
		case 0xb:	// day id 1, type uint8_t, coding 8bit
			set_day(ud.u8);
			break;
		case 0x13:	// month id 2, type uint8_t, coding 8bit
			set_month(ud.u8);
			break;
		case 0x1c:	// year id 3, type uint16_t, coding 16bit
			set_year(ud.u16);
			break;
		case 0x23:	// endday id 4, type uint8_t, coding 8bit
			set_endday(ud.u8);
			break;
		case 0x2b:	// endmonth id 5, type uint8_t, coding 8bit
			set_endmonth(ud.u8);
			break;
		case 0x33:	// endyear id 6, type uint8_t, coding 8bit
			set_endyear(ud.u8);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -41;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -42;
	return a-(const uint8_t *)b;
}

ssize_t Date::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	// has day?
	if (m_day != 0) {
		// 'day': id=1, encoding=8bit, tag=0xb
		if (2 > (e-a))
			return -43;
		*a++ = 0xb;
		*a++ = m_day;
	}
	// has month?
	if (m_month != 0) {
		// 'month': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -44;
		*a++ = 0x13;
		*a++ = m_month;
	}
	// has year?
	if (m_year != 0) {
		// 'year': id=3, encoding=16bit, tag=0x1c
		if (3 > (e-a))
			return -45;
		*a++ = 0x1c;
		write_u16(a,m_year);
		a += 2;
	}
	// has endday?
	if (m_endday != 0) {
		// 'endday': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -46;
		*a++ = 0x23;
		*a++ = m_endday;
	}
	// has endmonth?
	if (m_endmonth != 0) {
		// 'endmonth': id=5, encoding=8bit, tag=0x2b
		if (2 > (e-a))
			return -47;
		*a++ = 0x2b;
		*a++ = m_endmonth;
	}
	// has endyear?
	if (m_endyear != 0) {
		// 'endyear': id=6, encoding=8bit, tag=0x33
		if (2 > (e-a))
			return -48;
		*a++ = 0x33;
		*a++ = m_endyear;
	}
	assert(a <= e);
	return a-b;
}

void Date::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_day()) {
		fsep = json_indent(json,indLvl,fsep,"day");
		to_decstr(json,(unsigned) m_day);
	}
	if (full || has_month()) {
		fsep = json_indent(json,indLvl,fsep,"month");
		to_decstr(json,(unsigned) m_month);
	}
	if (full || has_year()) {
		fsep = json_indent(json,indLvl,fsep,"year");
		to_decstr(json,m_year);
	}
	if (full || has_endday()) {
		fsep = json_indent(json,indLvl,fsep,"endday");
		to_decstr(json,(unsigned) m_endday);
	}
	if (full || has_endmonth()) {
		fsep = json_indent(json,indLvl,fsep,"endmonth");
		to_decstr(json,(unsigned) m_endmonth);
	}
	if (full || has_endyear()) {
		fsep = json_indent(json,indLvl,fsep,"endyear");
		to_decstr(json,(unsigned) m_endyear);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Date::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed8 day, id 1
	if (has_day()) {
		r += 2;
	}
	// optional fixed8 month, id 2
	if (has_month()) {
		r += 2;
	}
	// optional fixed16 year, id 3
	if (has_year()) {
		r += 3;
	}
	// optional fixed8 endday, id 4
	if (has_endday()) {
		r += 2;
	}
	// optional fixed8 endmonth, id 5
	if (has_endmonth()) {
		r += 2;
	}
	// optional fixed8 endyear, id 6
	if (has_endyear()) {
		r += 2;
	}
	return r;
}

bool Date::operator == (const Date &r) const
{
	if (has_day() && (!(m_day == r.m_day)))
		return false;
	if (has_month() && (!(m_month == r.m_month)))
		return false;
	if (has_year() && (!(m_year == r.m_year)))
		return false;
	if (has_endday() && (!(m_endday == r.m_endday)))
		return false;
	if (has_endmonth() && (!(m_endmonth == r.m_endmonth)))
		return false;
	if (has_endyear() && (!(m_endyear == r.m_endyear)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Date::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"day")) {
		if (value == 0) {
			clear_day();
			return 0;
		}
		int r = parse_ascii_u8(&m_day,value);
		return r;
	}
	if (0 == strcmp(name,"month")) {
		if (value == 0) {
			clear_month();
			return 0;
		}
		int r = parse_ascii_u8(&m_month,value);
		return r;
	}
	if (0 == strcmp(name,"year")) {
		if (value == 0) {
			clear_year();
			return 0;
		}
		int r = parse_ascii_u16(&m_year,value);
		return r;
	}
	if (0 == strcmp(name,"endday")) {
		if (value == 0) {
			clear_endday();
			return 0;
		}
		int r = parse_ascii_u8(&m_endday,value);
		return r;
	}
	if (0 == strcmp(name,"endmonth")) {
		if (value == 0) {
			clear_endmonth();
			return 0;
		}
		int r = parse_ascii_u8(&m_endmonth,value);
		return r;
	}
	if (0 == strcmp(name,"endyear")) {
		if (value == 0) {
			clear_endyear();
			return 0;
		}
		int r = parse_ascii_u8(&m_endyear,value);
		return r;
	}
	return -49;
}

AtAction::AtAction()
{
}

void AtAction::clear()
{
	m_day = Sunday;
	m_min_of_day = 0;
	m_action.clear();
	m_enable = true;
	p_validbits = 0;
}

ssize_t AtAction::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -50;
		a += x;
		switch (fid) {
		case 0x8:	// day id 1, type WeekDay, coding varint
			set_day((WeekDay) (WeekDay)ud.u32);
			break;
		case 0x10:	// min_of_day id 2, type uint32_t, coding varint
			set_min_of_day((uint32_t)ud.u32);
			break;
		case 0x1a:	// action id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -51;
			}
			m_action.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x23:	// enable id 4, type bool, coding 8bit
			m_enable = ud.u8;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -52;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -53;
	return a-(const uint8_t *)b;
}

ssize_t AtAction::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has day?
	if (0 != (p_validbits & ((uint8_t)1U << vb_day))) {
		// 'day': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -54;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_day);
		if (n <= 0)
			return -55;
		a += n;
	}
	// has min_of_day?
	if (0 != (p_validbits & ((uint8_t)1U << vb_min_of_day))) {
		// 'min_of_day': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -56;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_min_of_day);
		if (n <= 0)
			return -57;
		a += n;
	}
	// has action?
	if (!m_action.empty()) {
		// 'action': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -58;
		*a++ = 0x1a;
		n = encode_bytes(m_action,a,e);
		if (n < 0)
			return -59;
		a += n;
	}
	// 'enable': id=4, encoding=8bit, tag=0x23
	if (2 > (e-a))
		return -60;
	*a++ = 0x23;
	*a++ = m_enable;
	assert(a <= e);
	return a-b;
}

void AtAction::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_day()) {
		fsep = json_indent(json,indLvl,fsep,"day");
		json << m_day;
	}
	if (full || has_min_of_day()) {
		fsep = json_indent(json,indLvl,fsep,"min_of_day");
		json.put('"');
		min_of_day_to_ascii(json,m_min_of_day);
		json.put('"');
	}
	if (full || has_action()) {
		fsep = json_indent(json,indLvl,fsep,"action");
		json_cstr(json,m_action.c_str());
	}
	fsep = json_indent(json,indLvl,fsep,"enable");
	json << (m_enable ? "true" : "false");
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AtAction::calcSize() const
{
	// bool enable: tagsize 1, data size 1
	size_t r = 2;	// required size, default is fixed length
	// optional WeekDay day, id 1
	if (has_day()) {
		r += wiresize((varint_t)m_day) + 1 /* tag(day) 0x8 */;
	}
	// optional unsigned min_of_day, id 2
	if (has_min_of_day()) {
		r += wiresize((varint_t)m_min_of_day) + 1 /* tag(min_of_day) 0x10 */;
	}
	// optional string action, id 3
	if (has_action()) {
		size_t action_s = m_action.size();
		r += action_s + wiresize(action_s) + 1 /* tag(action) 0x18 */;
	}
	return r;
}

bool AtAction::operator == (const AtAction &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_day() && (!(m_day == r.m_day)))
		return false;
	if (has_min_of_day() && (!(m_min_of_day == r.m_min_of_day)))
		return false;
	if (has_action() && (!(m_action == r.m_action)))
		return false;
	if (!(m_enable == r.m_enable))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AtAction::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"day")) {
		if (value == 0) {
			clear_day();
			return 0;
		}
		char *eptr;
		long long ll = strtoll(value,&eptr,0);
		if (eptr == value)
			return -61;
		p_validbits |= ((uint8_t)1U << 0);
		m_day = (WeekDay) ll;
		return eptr - value;
	}
	if (0 == strcmp(name,"min_of_day")) {
		if (value == 0) {
			clear_min_of_day();
			return 0;
		}
		int r = parse_ascii_u32(&m_min_of_day,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"action")) {
		if (value == 0) {
			m_action.clear();
			return 0;
		}
		m_action = value;
		int r = m_action.size();
		return r;
	}
	if (0 == strcmp(name,"enable")) {
		int r = parse_ascii_bool(&m_enable,value);
		return r;
	}
	return -62;
}

Influx::Influx()
{
}

void Influx::clear()
{
	m_hostname.clear();
	m_port = 0;
	m_measurement.clear();
	m_database.clear();
}

ssize_t Influx::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -63;
		a += x;
		switch (fid) {
		case 0xa:	// hostname id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -64;
			}
			m_hostname.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x14:	// port id 2, type uint16_t, coding 16bit
			set_port(ud.u16);
			break;
		case 0x1a:	// measurement id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -65;
			}
			m_measurement.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x2a:	// database id 5, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -66;
			}
			m_database.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -67;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -68;
	return a-(const uint8_t *)b;
}

ssize_t Influx::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has hostname?
	if (!m_hostname.empty()) {
		// 'hostname': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -69;
		*a++ = 0xa;
		n = encode_bytes(m_hostname,a,e);
		if (n < 0)
			return -70;
		a += n;
	}
	// has port?
	if (m_port != 0) {
		// 'port': id=2, encoding=16bit, tag=0x14
		if (3 > (e-a))
			return -71;
		*a++ = 0x14;
		write_u16(a,m_port);
		a += 2;
	}
	// has measurement?
	if (!m_measurement.empty()) {
		// 'measurement': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -72;
		*a++ = 0x1a;
		n = encode_bytes(m_measurement,a,e);
		if (n < 0)
			return -73;
		a += n;
	}
	// 'interval' is obsolete. Therefore no data will be written.
	// has database?
	if (!m_database.empty()) {
		// 'database': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -74;
		*a++ = 0x2a;
		n = encode_bytes(m_database,a,e);
		if (n < 0)
			return -75;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Influx::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_hostname()) {
		fsep = json_indent(json,indLvl,fsep,"hostname");
		json_cstr(json,m_hostname.c_str());
	}
	if (full || has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		to_decstr(json,m_port);
	}
	if (full || has_measurement()) {
		fsep = json_indent(json,indLvl,fsep,"measurement");
		json_cstr(json,m_measurement.c_str());
	}
	if (full || has_database()) {
		fsep = json_indent(json,indLvl,fsep,"database");
		json_cstr(json,m_database.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Influx::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string hostname, id 1
	if (has_hostname()) {
		size_t hostname_s = m_hostname.size();
		r += hostname_s + wiresize(hostname_s) + 1 /* tag(hostname) 0x8 */;
	}
	// optional fixed16 port, id 2
	if (has_port()) {
		r += 3;
	}
	// optional string measurement, id 3
	if (has_measurement()) {
		size_t measurement_s = m_measurement.size();
		r += measurement_s + wiresize(measurement_s) + 1 /* tag(measurement) 0x18 */;
	}
	// obsolete optional unsigned interval, id 4
	// optional string database, id 5
	if (has_database()) {
		size_t database_s = m_database.size();
		r += database_s + wiresize(database_s) + 1 /* tag(database) 0x28 */;
	}
	return r;
}

bool Influx::operator == (const Influx &r) const
{
	if (has_hostname() && (!(m_hostname == r.m_hostname)))
		return false;
	if (has_port() && (!(m_port == r.m_port)))
		return false;
	if (has_measurement() && (!(m_measurement == r.m_measurement)))
		return false;
	// nothing to do for obsolete interval
	if (has_database() && (!(m_database == r.m_database)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Influx::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"hostname")) {
		if (value == 0) {
			m_hostname.clear();
			return 0;
		}
		m_hostname = value;
		int r = m_hostname.size();
		return r;
	}
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_port,value);
		return r;
	}
	if (0 == strcmp(name,"measurement")) {
		if (value == 0) {
			m_measurement.clear();
			return 0;
		}
		m_measurement = value;
		int r = m_measurement.size();
		return r;
	}
	if (0 == strcmp(name,"database")) {
		if (value == 0) {
			m_database.clear();
			return 0;
		}
		m_database = value;
		int r = m_database.size();
		return r;
	}
	return -76;
}

UartSettings::UartSettings()
{
}

void UartSettings::clear()
{
	m_port = -1;
	m_baudrate = 115200;
	m_config = 5;
	m_rx_thresh = 0;
	m_tx_bufsize = 0;
	m_rx_bufsize = 0;
	p_validbits = 0;
}

ssize_t UartSettings::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -77;
		a += x;
		switch (fid) {
		case 0x8:	// port id 1, type int8_t, coding signed varint
			set_port(varint_sint(ud.u8));
			break;
		case 0x10:	// baudrate id 2, type uint32_t, coding varint
			set_baudrate((uint32_t)ud.u32);
			break;
		case 0x1c:	// config id 3, type uartcfg_t, coding 16bit
			set_config((uartcfg_t) ud.u16);
			break;
		case 0x23:	// rx_thresh id 4, type uint8_t, coding 8bit
			set_rx_thresh(ud.u8);
			break;
		case 0x30:	// tx_bufsize id 6, type uint32_t, coding varint
			set_tx_bufsize((uint32_t)ud.u32);
			break;
		case 0x38:	// rx_bufsize id 7, type uint32_t, coding varint
			set_rx_bufsize((uint32_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -78;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -79;
	return a-(const uint8_t *)b;
}

ssize_t UartSettings::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (m_port != -1) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -80;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_port));
		if (n <= 0)
			return -81;
		a += n;
	}
	// has baudrate?
	if (0 != (p_validbits & ((uint8_t)1U << vb_baudrate))) {
		// 'baudrate': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -82;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_baudrate);
		if (n <= 0)
			return -83;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << vb_config))) {
		// 'config': id=3, encoding=16bit, tag=0x1c
		if (a >= e)
			return -84;
		*a++ = 0x1c;
		write_u16(a,m_config);
		a += 2;
	}
	// has rx_thresh?
	if (m_rx_thresh != 0) {
		// 'rx_thresh': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -85;
		*a++ = 0x23;
		*a++ = m_rx_thresh;
	}
	// has tx_bufsize?
	if (0 != (p_validbits & ((uint8_t)1U << vb_tx_bufsize))) {
		// 'tx_bufsize': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -86;
		*a++ = 0x30;
		n = write_varint(a,e-a,m_tx_bufsize);
		if (n <= 0)
			return -87;
		a += n;
	}
	// has rx_bufsize?
	if (0 != (p_validbits & ((uint8_t)1U << vb_rx_bufsize))) {
		// 'rx_bufsize': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -88;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_rx_bufsize);
		if (n <= 0)
			return -89;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void UartSettings::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		to_decstr(json,(int) m_port);
	}
	if (full || has_baudrate()) {
		fsep = json_indent(json,indLvl,fsep,"baudrate");
		to_decstr(json,m_baudrate);
	}
	if (full || has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (full || has_rx_thresh()) {
		fsep = json_indent(json,indLvl,fsep,"rx_thresh");
		to_decstr(json,(unsigned) m_rx_thresh);
	}
	if (full || has_tx_bufsize()) {
		fsep = json_indent(json,indLvl,fsep,"tx_bufsize");
		to_decstr(json,m_tx_bufsize);
	}
	if (full || has_rx_bufsize()) {
		fsep = json_indent(json,indLvl,fsep,"rx_bufsize");
		to_decstr(json,m_rx_bufsize);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t UartSettings::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 port, id 1
	if (has_port()) {
		r += wiresize_s((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional unsigned baudrate, id 2
	if (has_baudrate()) {
		r += wiresize((varint_t)m_baudrate) + 1 /* tag(baudrate) 0x10 */;
	}
	// optional uartcfg_t config, id 3
	if (has_config()) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	// optional fixed8 rx_thresh, id 4
	if (has_rx_thresh()) {
		r += 2;
	}
	// optional unsigned tx_bufsize, id 6
	if (has_tx_bufsize()) {
		r += wiresize((varint_t)m_tx_bufsize) + 1 /* tag(tx_bufsize) 0x30 */;
	}
	// optional unsigned rx_bufsize, id 7
	if (has_rx_bufsize()) {
		r += wiresize((varint_t)m_rx_bufsize) + 1 /* tag(rx_bufsize) 0x38 */;
	}
	return r;
}

bool UartSettings::operator == (const UartSettings &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_port() && (!(m_port == r.m_port)))
		return false;
	if (has_baudrate() && (!(m_baudrate == r.m_baudrate)))
		return false;
	if (has_config() && (!(m_config == r.m_config)))
		return false;
	if (has_rx_thresh() && (!(m_rx_thresh == r.m_rx_thresh)))
		return false;
	if (has_tx_bufsize() && (!(m_tx_bufsize == r.m_tx_bufsize)))
		return false;
	if (has_rx_bufsize() && (!(m_rx_bufsize == r.m_rx_bufsize)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int UartSettings::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_s8(&m_port,value);
		return r;
	}
	if (0 == strcmp(name,"baudrate")) {
		if (value == 0) {
			clear_baudrate();
			return 0;
		}
		int r = parse_ascii_u32(&m_baudrate,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((uartcfg_t)ull);
			else if (!strcmp(name,"wl"))
				set_config_wl((uart_wl_t)ull);
			else if (!strcmp(name,"sb"))
				set_config_sb((uart_sb_t)ull);
			else if (!strcmp(name,"rts"))
				set_config_rts((bool)ull);
			else if (!strcmp(name,"cts"))
				set_config_cts((bool)ull);
			else if (!strcmp(name,"p"))
				set_config_p((uart_p_t)ull);
			else if (!strcmp(name,"ref_tick"))
				set_config_ref_tick((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -90;
		} else if (!strcmp(name,"rts")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_rts(tmp);
			return r;
		} else if (!strcmp(name,"cts")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_cts(tmp);
			return r;
		} else if (!strcmp(name,"ref_tick")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_ref_tick(tmp);
			return r;
		}
	}
	if (0 == strcmp(name,"rx_thresh")) {
		if (value == 0) {
			clear_rx_thresh();
			return 0;
		}
		int r = parse_ascii_u8(&m_rx_thresh,value);
		return r;
	}
	if (0 == strcmp(name,"tx_bufsize")) {
		if (value == 0) {
			clear_tx_bufsize();
			return 0;
		}
		int r = parse_ascii_u32(&m_tx_bufsize,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"rx_bufsize")) {
		if (value == 0) {
			clear_rx_bufsize();
			return 0;
		}
		int r = parse_ascii_u32(&m_rx_bufsize,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	return -91;
}

FtpHttpConfig::FtpHttpConfig()
{
}

void FtpHttpConfig::clear()
{
	m_port = 0;
	m_start = true;
	m_root.clear();
	m_uploaddir.clear();
	p_validbits = 0;
}

ssize_t FtpHttpConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -92;
		a += x;
		switch (fid) {
		case 0xc:	// port id 1, type uint16_t, coding 16bit
			set_port(ud.u16);
			break;
		case 0x13:	// start id 2, type bool, coding 8bit
			set_start(ud.u8);
			break;
		case 0x1a:	// root id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -93;
			}
			m_root.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x22:	// uploaddir id 4, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -94;
			}
			m_uploaddir.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -95;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -96;
	return a-(const uint8_t *)b;
}

ssize_t FtpHttpConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (m_port != 0) {
		// 'port': id=1, encoding=16bit, tag=0xc
		if (3 > (e-a))
			return -97;
		*a++ = 0xc;
		write_u16(a,m_port);
		a += 2;
	}
	// has start?
	if (0 != (p_validbits & ((uint8_t)1U << vb_start))) {
		// 'start': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -98;
		*a++ = 0x13;
		*a++ = m_start;
	}
	// has root?
	if (!m_root.empty()) {
		// 'root': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -99;
		*a++ = 0x1a;
		n = encode_bytes(m_root,a,e);
		if (n < 0)
			return -100;
		a += n;
	}
	// has uploaddir?
	if (!m_uploaddir.empty()) {
		// 'uploaddir': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -101;
		*a++ = 0x22;
		n = encode_bytes(m_uploaddir,a,e);
		if (n < 0)
			return -102;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void FtpHttpConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		to_decstr(json,m_port);
	}
	if (full || has_start()) {
		fsep = json_indent(json,indLvl,fsep,"start");
		json << (m_start ? "true" : "false");
	}
	if (full || has_root()) {
		fsep = json_indent(json,indLvl,fsep,"root");
		json_cstr(json,m_root.c_str());
	}
	if (full || has_uploaddir()) {
		fsep = json_indent(json,indLvl,fsep,"uploaddir");
		json_cstr(json,m_uploaddir.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t FtpHttpConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed16 port, id 1
	if (has_port()) {
		r += 3;
	}
	// optional bool start, id 2
	if (has_start()) {
		r += 2;
	}
	// optional string root, id 3
	if (has_root()) {
		size_t root_s = m_root.size();
		r += root_s + wiresize(root_s) + 1 /* tag(root) 0x18 */;
	}
	// optional string uploaddir, id 4
	if (has_uploaddir()) {
		size_t uploaddir_s = m_uploaddir.size();
		r += uploaddir_s + wiresize(uploaddir_s) + 1 /* tag(uploaddir) 0x20 */;
	}
	return r;
}

bool FtpHttpConfig::operator == (const FtpHttpConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_port() && (!(m_port == r.m_port)))
		return false;
	if (has_start() && (!(m_start == r.m_start)))
		return false;
	if (has_root() && (!(m_root == r.m_root)))
		return false;
	if (has_uploaddir() && (!(m_uploaddir == r.m_uploaddir)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int FtpHttpConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_port,value);
		return r;
	}
	if (0 == strcmp(name,"start")) {
		if (value == 0) {
			clear_start();
			return 0;
		}
		int r = parse_ascii_bool(&m_start,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"root")) {
		if (value == 0) {
			m_root.clear();
			return 0;
		}
		m_root = value;
		int r = m_root.size();
		return r;
	}
	if (0 == strcmp(name,"uploaddir")) {
		if (value == 0) {
			m_uploaddir.clear();
			return 0;
		}
		m_uploaddir = value;
		int r = m_uploaddir.size();
		return r;
	}
	return -103;
}

TerminalConfig::TerminalConfig()
{
}

void TerminalConfig::clear()
{
	m_uart_rx = -1;
	m_uart_tx = -1;
	m_name.clear();
}

ssize_t TerminalConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -104;
		a += x;
		switch (fid) {
		case 0x8:	// uart_rx id 1, type int8_t, coding signed varint
			set_uart_rx(varint_sint(ud.u8));
			break;
		case 0x10:	// uart_tx id 2, type int8_t, coding signed varint
			set_uart_tx(varint_sint(ud.u8));
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -105;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -106;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -107;
	return a-(const uint8_t *)b;
}

ssize_t TerminalConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has uart_rx?
	if (m_uart_rx != -1) {
		// 'uart_rx': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -108;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_uart_rx));
		if (n <= 0)
			return -109;
		a += n;
	}
	// has uart_tx?
	if (m_uart_tx != -1) {
		// 'uart_tx': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -110;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_uart_tx));
		if (n <= 0)
			return -111;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -112;
		*a++ = 0x1a;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -113;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void TerminalConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_uart_rx()) {
		fsep = json_indent(json,indLvl,fsep,"uart_rx");
		to_decstr(json,(int) m_uart_rx);
	}
	if (full || has_uart_tx()) {
		fsep = json_indent(json,indLvl,fsep,"uart_tx");
		to_decstr(json,(int) m_uart_tx);
	}
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TerminalConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 uart_rx, id 1
	if (has_uart_rx()) {
		r += wiresize_s((varint_t)m_uart_rx) + 1 /* tag(uart_rx) 0x8 */;
	}
	// optional sint8 uart_tx, id 2
	if (has_uart_tx()) {
		r += wiresize_s((varint_t)m_uart_tx) + 1 /* tag(uart_tx) 0x10 */;
	}
	// optional string name, id 3
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	return r;
}

bool TerminalConfig::operator == (const TerminalConfig &r) const
{
	if (has_uart_rx() && (!(m_uart_rx == r.m_uart_rx)))
		return false;
	if (has_uart_tx() && (!(m_uart_tx == r.m_uart_tx)))
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TerminalConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"uart_rx")) {
		if (value == 0) {
			clear_uart_rx();
			return 0;
		}
		int r = parse_ascii_s8(&m_uart_rx,value);
		return r;
	}
	if (0 == strcmp(name,"uart_tx")) {
		if (value == 0) {
			clear_uart_tx();
			return 0;
		}
		int r = parse_ascii_s8(&m_uart_tx,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	return -114;
}

Trigger::Trigger()
{
}

void Trigger::clear()
{
	m_event.clear();
	m_action.clear();
}

ssize_t Trigger::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -115;
		a += x;
		switch (fid) {
		case 0xa:	// event id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -116;
			}
			m_event.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x12:	// action id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -117;
			}
			m_action.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -118;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -119;
	return a-(const uint8_t *)b;
}

ssize_t Trigger::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has event?
	if (!m_event.empty()) {
		// 'event': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -120;
		*a++ = 0xa;
		n = encode_bytes(m_event,a,e);
		if (n < 0)
			return -121;
		a += n;
	}
	for (const auto &x : m_action) {
		// 'action': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -122;
		*a++ = 0x12;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -123;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Trigger::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_event()) {
		fsep = json_indent(json,indLvl,fsep,"event");
		json_cstr(json,m_event.c_str());
	}
	if (size_t s = m_action.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"action\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_action[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Trigger::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string event, id 1
	if (has_event()) {
		size_t event_s = m_event.size();
		r += event_s + wiresize(event_s) + 1 /* tag(event) 0x8 */;
	}
	// repeated string action, id 2
	if (!m_action.empty()) {
		// action: repeated estring
		for (size_t x = 0, y = m_action.size(); x < y; ++x) {
			size_t s = m_action[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(action) 0x10 */;
		}
	}
	return r;
}

bool Trigger::operator == (const Trigger &r) const
{
	if (has_event() && (!(m_event == r.m_event)))
		return false;
	if (!(m_action == r.m_action))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Trigger::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"event")) {
		if (value == 0) {
			m_event.clear();
			return 0;
		}
		m_event = value;
		int r = m_event.size();
		return r;
	}
	if (0 == memcmp(name,"action",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_action();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_action.size();
				m_action.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -124;
				if (m_action.size() <= x)
					return -125;
				if ((idxe[1] == 0) && (value == 0)) {
					m_action.erase(m_action.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -126;
			m_action[x] = value;
			return m_action[x].size();
		}
	}
	return -127;
}

EventTimer::EventTimer()
{
}

void EventTimer::clear()
{
	m_name.clear();
	m_time = 0;
	m_config = 0;
	p_validbits = 0;
}

ssize_t EventTimer::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -128;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -129;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// time id 2, type uint32_t, coding varint
			set_time((uint32_t)ud.u32);
			break;
		case 0x18:	// config id 3, type eventcfg_t, coding varint
			set_config((eventcfg_t) (eventcfg_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -130;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -131;
	return a-(const uint8_t *)b;
}

ssize_t EventTimer::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -132;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -133;
		a += n;
	}
	// has time?
	if (0 != (p_validbits & ((uint8_t)1U << vb_time))) {
		// 'time': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -134;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_time);
		if (n <= 0)
			return -135;
		a += n;
	}
	// has config?
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -136;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -137;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void EventTimer::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (full || has_time()) {
		fsep = json_indent(json,indLvl,fsep,"time");
		to_decstr(json,m_time);
	}
	if (full || has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t EventTimer::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional unsigned time, id 2
	if (has_time()) {
		r += wiresize((varint_t)m_time) + 1 /* tag(time) 0x10 */;
	}
	// optional eventcfg_t config, id 3
	if (has_config()) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	return r;
}

bool EventTimer::operator == (const EventTimer &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_time() && (!(m_time == r.m_time)))
		return false;
	if (has_config() && (!(m_config == r.m_config)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int EventTimer::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"time")) {
		if (value == 0) {
			clear_time();
			return 0;
		}
		int r = parse_ascii_u32(&m_time,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((eventcfg_t)ull);
			else if (!strcmp(name,"restart"))
				set_config_restart((bool)ull);
			else if (!strcmp(name,"autostart"))
				set_config_autostart((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -138;
		} else if (!strcmp(name,"restart")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_restart(tmp);
			return r;
		} else if (!strcmp(name,"autostart")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_autostart(tmp);
			return r;
		}
	}
	return -139;
}

OwDeviceConfig::OwDeviceConfig()
{
}

void OwDeviceConfig::clear()
{
	m_id = 0;
	m_name.clear();
	p_validbits = 0;
}

ssize_t OwDeviceConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -140;
		a += x;
		switch (fid) {
		case 0x9:	// id id 1, type uint64_t, coding 64bit
			set_id(ud.u64);
			break;
		case 0x12:	// name id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -141;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -142;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -143;
	return a-(const uint8_t *)b;
}

ssize_t OwDeviceConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has id?
	if (0 != (p_validbits & ((uint8_t)1U << vb_id))) {
		// 'id': id=1, encoding=64bit, tag=0x9
		if (9 > (e-a))
			return -144;
		*a++ = 0x9;
		write_u64(a,(uint64_t)m_id);
		a += 8;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -145;
		*a++ = 0x12;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -146;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void OwDeviceConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_id()) {
		fsep = json_indent(json,indLvl,fsep,"id");
		to_decstr(json,m_id);
	}
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t OwDeviceConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed64 id, id 1
	if (has_id()) {
		r += 9;
	}
	// optional string name, id 2
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x10 */;
	}
	return r;
}

bool OwDeviceConfig::operator == (const OwDeviceConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_id() && (!(m_id == r.m_id)))
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int OwDeviceConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"id")) {
		if (value == 0) {
			clear_id();
			return 0;
		}
		int r = parse_ascii_u64(&m_id,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	return -147;
}

StateConfig::StateConfig()
{
}

void StateConfig::clear()
{
	m_name.clear();
	m_conds.clear();
}

ssize_t StateConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -148;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -149;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x12:	// conds id 2, type Trigger, coding byte[]
			m_conds.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_conds.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -150;
				a += ud.vi;
			}
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -151;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -152;
	return a-(const uint8_t *)b;
}

ssize_t StateConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -153;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -154;
		a += n;
	}
	for (const auto &x : m_conds) {
		// 'conds': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -155;
		*a++ = 0x12;
		ssize_t conds_ws = x.calcSize();
		n = write_varint(a,e-a,conds_ws);
		a += n;
		if ((n <= 0) || (conds_ws > (e-a)))
			return -156;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == conds_ws);
	}
	assert(a <= e);
	return a-b;
}

void StateConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (size_t s = m_conds.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"conds\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_conds[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t StateConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// repeated Trigger conds, id 2
	// repeated message conds
	for (size_t x = 0, y = m_conds.size(); x < y; ++x) {
		size_t s = m_conds[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(conds) 0x10 */;
	}
	return r;
}

bool StateConfig::operator == (const StateConfig &r) const
{
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (!(m_conds == r.m_conds))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int StateConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == memcmp(name,"conds",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_conds();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_conds.size();
				m_conds.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -157;
				if (m_conds.size() <= x)
					return -158;
				if ((idxe[1] == 0) && (value == 0)) {
					m_conds.erase(m_conds.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -159;
			return m_conds[x].setByName(idxe+2,value);
		}
	}
	return -160;
}

ThresholdConfig::ThresholdConfig()
{
}

void ThresholdConfig::clear()
{
	m_name.clear();
	m_low = 0;
	m_high = 0;
	p_validbits = 0;
}

ssize_t ThresholdConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -161;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -162;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x15:	// low id 2, type float, coding 32bit
			set_low(ud.f);
			break;
		case 0x1d:	// high id 3, type float, coding 32bit
			set_high(ud.f);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -163;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -164;
	return a-(const uint8_t *)b;
}

ssize_t ThresholdConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -165;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -166;
		a += n;
	}
	// has low?
	if (0 != (p_validbits & ((uint8_t)1U << vb_low))) {
		// 'low': id=2, encoding=32bit, tag=0x15
		if (5 > (e-a))
			return -167;
		*a++ = 0x15;
		if ((e-a) < 4)
			return -168;
		write_u32(a,mangle_float(m_low));
		a += 4;
	}
	// has high?
	if (0 != (p_validbits & ((uint8_t)1U << vb_high))) {
		// 'high': id=3, encoding=32bit, tag=0x1d
		if (5 > (e-a))
			return -169;
		*a++ = 0x1d;
		if ((e-a) < 4)
			return -170;
		write_u32(a,mangle_float(m_high));
		a += 4;
	}
	assert(a <= e);
	return a-b;
}

void ThresholdConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (full || has_low()) {
		fsep = json_indent(json,indLvl,fsep,"low");
		to_dblstr(json,m_low);
	}
	if (full || has_high()) {
		fsep = json_indent(json,indLvl,fsep,"high");
		to_dblstr(json,m_high);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t ThresholdConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional float low, id 2
	if (has_low()) {
		r += 5;
	}
	// optional float high, id 3
	if (has_high()) {
		r += 5;
	}
	return r;
}

bool ThresholdConfig::operator == (const ThresholdConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_low() && (!(m_low == r.m_low)))
		return false;
	if (has_high() && (!(m_high == r.m_high)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int ThresholdConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"low")) {
		if (value == 0) {
			clear_low();
			return 0;
		}
		int r = parse_ascii_flt(&m_low,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"high")) {
		if (value == 0) {
			clear_high();
			return 0;
		}
		int r = parse_ascii_flt(&m_high,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	return -171;
}

Dref::Dref()
{
}

void Dref::clear()
{
	m_name.clear();
	m_alias.clear();
	m_freq = 10;
	p_validbits = 0;
}

ssize_t Dref::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -172;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -173;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x12:	// alias id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -174;
			}
			m_alias.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x18:	// freq id 3, type uint32_t, coding varint
			set_freq((uint32_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -175;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -176;
	return a-(const uint8_t *)b;
}

ssize_t Dref::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -177;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -178;
		a += n;
	}
	// has alias?
	if (!m_alias.empty()) {
		// 'alias': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -179;
		*a++ = 0x12;
		n = encode_bytes(m_alias,a,e);
		if (n < 0)
			return -180;
		a += n;
	}
	// has freq?
	if (0 != (p_validbits & ((uint8_t)1U << vb_freq))) {
		// 'freq': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -181;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_freq);
		if (n <= 0)
			return -182;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Dref::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (full || has_alias()) {
		fsep = json_indent(json,indLvl,fsep,"alias");
		json_cstr(json,m_alias.c_str());
	}
	if (full || has_freq()) {
		fsep = json_indent(json,indLvl,fsep,"freq");
		to_decstr(json,m_freq);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Dref::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional string alias, id 2
	if (has_alias()) {
		size_t alias_s = m_alias.size();
		r += alias_s + wiresize(alias_s) + 1 /* tag(alias) 0x10 */;
	}
	// optional unsigned freq, id 3
	if (has_freq()) {
		r += wiresize((varint_t)m_freq) + 1 /* tag(freq) 0x18 */;
	}
	return r;
}

bool Dref::operator == (const Dref &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_alias() && (!(m_alias == r.m_alias)))
		return false;
	if (has_freq() && (!(m_freq == r.m_freq)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Dref::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"alias")) {
		if (value == 0) {
			m_alias.clear();
			return 0;
		}
		m_alias = value;
		int r = m_alias.size();
		return r;
	}
	if (0 == strcmp(name,"freq")) {
		if (value == 0) {
			clear_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_freq,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	return -183;
}

DataIdVar::DataIdVar()
{
}

void DataIdVar::clear()
{
	m_id = 0;
	m_idx = 0;
	m_varname.clear();
	p_validbits = 0;
}

ssize_t DataIdVar::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -184;
		a += x;
		switch (fid) {
		case 0x8:	// id id 1, type uint32_t, coding varint
			set_id((uint32_t)ud.u32);
			break;
		case 0x10:	// idx id 2, type uint32_t, coding varint
			set_idx((uint32_t)ud.u32);
			break;
		case 0x1a:	// varname id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -185;
			}
			m_varname.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -186;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -187;
	return a-(const uint8_t *)b;
}

ssize_t DataIdVar::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has id?
	if (0 != (p_validbits & ((uint8_t)1U << vb_id))) {
		// 'id': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -188;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_id);
		if (n <= 0)
			return -189;
		a += n;
	}
	// has idx?
	if (m_idx != 0) {
		// 'idx': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -190;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_idx);
		if (n <= 0)
			return -191;
		a += n;
	}
	// has varname?
	if (!m_varname.empty()) {
		// 'varname': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -192;
		*a++ = 0x1a;
		n = encode_bytes(m_varname,a,e);
		if (n < 0)
			return -193;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void DataIdVar::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_id()) {
		fsep = json_indent(json,indLvl,fsep,"id");
		to_decstr(json,m_id);
	}
	if (full || has_idx()) {
		fsep = json_indent(json,indLvl,fsep,"idx");
		to_decstr(json,m_idx);
	}
	if (full || has_varname()) {
		fsep = json_indent(json,indLvl,fsep,"varname");
		json_cstr(json,m_varname.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t DataIdVar::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional unsigned id, id 1
	if (has_id()) {
		r += wiresize((varint_t)m_id) + 1 /* tag(id) 0x8 */;
	}
	// optional unsigned idx, id 2
	if (has_idx()) {
		r += wiresize((varint_t)m_idx) + 1 /* tag(idx) 0x10 */;
	}
	// optional string varname, id 3
	if (has_varname()) {
		size_t varname_s = m_varname.size();
		r += varname_s + wiresize(varname_s) + 1 /* tag(varname) 0x18 */;
	}
	return r;
}

bool DataIdVar::operator == (const DataIdVar &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_id() && (!(m_id == r.m_id)))
		return false;
	if (has_idx() && (!(m_idx == r.m_idx)))
		return false;
	if (has_varname() && (!(m_varname == r.m_varname)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int DataIdVar::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"id")) {
		if (value == 0) {
			clear_id();
			return 0;
		}
		int r = parse_ascii_u32(&m_id,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"idx")) {
		if (value == 0) {
			clear_idx();
			return 0;
		}
		int r = parse_ascii_u32(&m_idx,value);
		return r;
	}
	if (0 == strcmp(name,"varname")) {
		if (value == 0) {
			m_varname.clear();
			return 0;
		}
		m_varname = value;
		int r = m_varname.size();
		return r;
	}
	return -194;
}

NodeConfig::NodeConfig()
{
}

void NodeConfig::clear()
{
	m_magic = 0xAE54EDC0;
	m_nodename.clear();
	m_pass_hash.clear();
	m_cpu_freq = 0;
	m_station.clear();
	m_softap.clear();
	m_dns_server.clear();
	m_syslog_host.clear();
	m_sntp_server.clear();
	m_timezone.clear();
	#ifdef CONFIG_MQTT
	m_mqtt.clear();
	#endif // CONFIG_MQTT
	m_dmesg_size = 2048;
	#ifdef CONFIG_INFLUX
	m_influx.clear();
	#endif // CONFIG_INFLUX
	m_station2ap_time = 0;
	m_domainname.clear();
	m_holidays.clear();
	m_at_actions.clear();
	m_actions_enable = 1;
	m_triggers.clear();
	m_uart.clear();
	#ifdef CONFIG_TERMSERV
	m_terminal.clear();
	#endif // CONFIG_TERMSERV
	m_udp_ctrl_port = 12719;
	m_debugs.clear();
	#ifdef CONFIG_FTP
	m_ftpd.clear();
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	m_httpd.clear();
	#endif // CONFIG_HTTP
	m_otasrv.clear();
	m_timefuses.clear();
	m_dim_step = 0;
	m_pwm_freq = 0;
	#ifdef CONFIG_APP_PARAMS
	m_app_params.clear();
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	m_thresholds.clear();
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	m_luafiles.clear();
	#endif // CONFIG_LUA
	#ifdef CONFIG_LUA
	m_lua_disable = false;
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	m_owdevices.clear();
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_XPLANE
	m_xplane.clear();
	#endif // CONFIG_XPLANE
	p_validbits = 0;
}

ssize_t NodeConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -195;
		a += x;
		switch (fid) {
		case 0x5:	// magic id 0, type uint32_t, coding 32bit
			set_magic(ud.u32);
			break;
		case 0xa:	// nodename id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -196;
			}
			m_nodename.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x12:	// pass_hash id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -197;
			}
			m_pass_hash.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x18:	// cpu_freq id 3, type uint32_t, coding varint
			set_cpu_freq((uint32_t)ud.u32);
			break;
		case 0x22:	// station id 4, type WifiConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_station.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -198;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 1);
			break;
		case 0x2a:	// softap id 5, type WifiConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_softap.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -199;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 2);
			break;
		case 0x32:	// dns_server id 6, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -200;
			}
			m_dns_server.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x3a:	// syslog_host id 7, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -201;
			}
			m_syslog_host.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x42:	// sntp_server id 8, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -202;
			}
			m_sntp_server.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x4a:	// timezone id 9, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -203;
			}
			m_timezone.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
			#ifdef CONFIG_MQTT
		case 0x52:	// mqtt id 10, type MQTT, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_mqtt.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -204;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 3);
			break;
			#endif // CONFIG_MQTT
		case 0x5c:	// dmesg_size id 11, type uint16_t, coding 16bit
			set_dmesg_size(ud.u16);
			break;
			#ifdef CONFIG_INFLUX
		case 0x62:	// influx id 12, type Influx, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_influx.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -205;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 5);
			break;
			#endif // CONFIG_INFLUX
		case 0x68:	// station2ap_time id 13, type uint32_t, coding varint
			set_station2ap_time((uint32_t)ud.u32);
			break;
		case 0x7a:	// domainname id 15, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -206;
			}
			m_domainname.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x82:	// holidays id 16, type Date, coding byte[]
			m_holidays.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_holidays.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -207;
				a += ud.vi;
			}
			break;
		case 0x8a:	// at_actions id 17, type AtAction, coding byte[]
			m_at_actions.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_at_actions.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -208;
				a += ud.vi;
			}
			break;
		case 0x90:	// actions_enable id 18, type uint32_t, coding varint
			set_actions_enable((uint32_t)ud.u32);
			break;
		case 0x9a:	// triggers id 19, type Trigger, coding byte[]
			m_triggers.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_triggers.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -209;
				a += ud.vi;
			}
			break;
		case 0xa2:	// uart id 20, type UartSettings, coding byte[]
			m_uart.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_uart.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -210;
				a += ud.vi;
			}
			break;
			#ifdef CONFIG_TERMSERV
		case 0xaa:	// terminal id 21, type TerminalConfig, coding byte[]
			m_terminal.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_terminal.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -211;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_TERMSERV
		case 0xb4:	// udp_ctrl_port id 22, type uint16_t, coding 16bit
			set_udp_ctrl_port(ud.u16);
			break;
		case 0xba:	// debugs id 23, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -212;
			}
			m_debugs.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
			#ifdef CONFIG_FTP
		case 0xc2:	// ftpd id 24, type FtpHttpConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_ftpd.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -213;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 9);
			break;
			#endif // CONFIG_FTP
			#ifdef CONFIG_HTTP
		case 0xca:	// httpd id 25, type FtpHttpConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_httpd.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -214;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 10);
			break;
			#endif // CONFIG_HTTP
		case 0xd2:	// otasrv id 26, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -215;
			}
			m_otasrv.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0xf2:	// timefuses id 30, type EventTimer, coding byte[]
			m_timefuses.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_timefuses.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -216;
				a += ud.vi;
			}
			break;
		case 0x128:	// dim_step id 37, type uint32_t, coding varint
			set_dim_step((uint32_t)ud.u32);
			break;
		case 0x138:	// pwm_freq id 39, type uint32_t, coding varint
			set_pwm_freq((uint32_t)ud.u32);
			break;
			#ifdef CONFIG_APP_PARAMS
		case 0x142:	// app_params id 40, type AppParam, coding byte[]
			m_app_params.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_app_params.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -217;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_APP_PARAMS
			#ifdef CONFIG_THRESHOLDS
		case 0x14a:	// thresholds id 41, type ThresholdConfig, coding byte[]
			m_thresholds.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_thresholds.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -218;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_THRESHOLDS
			#ifdef CONFIG_LUA
		case 0x152:	// luafiles id 42, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -219;
			}
			m_luafiles.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
			#endif // CONFIG_LUA
			#ifdef CONFIG_LUA
		case 0x15b:	// lua_disable id 43, type bool, coding 8bit
			set_lua_disable(ud.u8);
			break;
			#endif // CONFIG_LUA
			#ifdef CONFIG_ONEWIRE
		case 0x192:	// owdevices id 50, type OwDeviceConfig, coding byte[]
			m_owdevices.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_owdevices.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -220;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_ONEWIRE
			#ifdef CONFIG_XPLANE
		case 0x1e2:	// xplane id 60, type XPlaneConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_xplane.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -221;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 11);
			break;
			#endif // CONFIG_XPLANE
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -222;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -223;
	return a-(const uint8_t *)b;
}

ssize_t NodeConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has magic?
	if (0 != (p_validbits & ((uint16_t)1U << vb_magic))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		if (5 > (e-a))
			return -224;
		*a++ = 0x5;
		if ((e-a) < 4)
			return -225;
		write_u32(a,(uint32_t)m_magic);
		a += 4;
	}
	// has nodename?
	if (!m_nodename.empty()) {
		// 'nodename': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -226;
		*a++ = 0xa;
		n = encode_bytes(m_nodename,a,e);
		if (n < 0)
			return -227;
		a += n;
	}
	// has pass_hash?
	if (!m_pass_hash.empty()) {
		// 'pass_hash': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -228;
		*a++ = 0x12;
		n = encode_bytes(m_pass_hash,a,e);
		if (n < 0)
			return -229;
		a += n;
	}
	// has cpu_freq?
	if (m_cpu_freq != 0) {
		// 'cpu_freq': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -230;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_cpu_freq);
		if (n <= 0)
			return -231;
		a += n;
	}
	// has station?
	if (0 != (p_validbits & ((uint16_t)1U << vb_station))) {
		// 'station': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -232;
		*a++ = 0x22;
		ssize_t station_ws = m_station.calcSize();
		n = write_varint(a,e-a,station_ws);
		a += n;
		if ((n <= 0) || (station_ws > (e-a)))
			return -233;
		n = m_station.toMemory(a,e-a);
		a += n;
		assert(n == station_ws);
	}
	// has softap?
	if (0 != (p_validbits & ((uint16_t)1U << vb_softap))) {
		// 'softap': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -234;
		*a++ = 0x2a;
		ssize_t softap_ws = m_softap.calcSize();
		n = write_varint(a,e-a,softap_ws);
		a += n;
		if ((n <= 0) || (softap_ws > (e-a)))
			return -235;
		n = m_softap.toMemory(a,e-a);
		a += n;
		assert(n == softap_ws);
	}
	for (const auto &x : m_dns_server) {
		// 'dns_server': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -236;
		*a++ = 0x32;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -237;
		a += n;
	}
	// has syslog_host?
	if (!m_syslog_host.empty()) {
		// 'syslog_host': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -238;
		*a++ = 0x3a;
		n = encode_bytes(m_syslog_host,a,e);
		if (n < 0)
			return -239;
		a += n;
	}
	// has sntp_server?
	if (!m_sntp_server.empty()) {
		// 'sntp_server': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -240;
		*a++ = 0x42;
		n = encode_bytes(m_sntp_server,a,e);
		if (n < 0)
			return -241;
		a += n;
	}
	// has timezone?
	if (!m_timezone.empty()) {
		// 'timezone': id=9, encoding=lenpfx, tag=0x4a
		if (a >= e)
			return -242;
		*a++ = 0x4a;
		n = encode_bytes(m_timezone,a,e);
		if (n < 0)
			return -243;
		a += n;
	}
	#ifdef CONFIG_MQTT
	// has mqtt?
	if (0 != (p_validbits & ((uint16_t)1U << vb_mqtt))) {
		// 'mqtt': id=10, encoding=lenpfx, tag=0x52
		if (a >= e)
			return -244;
		*a++ = 0x52;
		ssize_t mqtt_ws = m_mqtt.calcSize();
		n = write_varint(a,e-a,mqtt_ws);
		a += n;
		if ((n <= 0) || (mqtt_ws > (e-a)))
			return -245;
		n = m_mqtt.toMemory(a,e-a);
		a += n;
		assert(n == mqtt_ws);
	}
	#endif // CONFIG_MQTT
	// has dmesg_size?
	if (0 != (p_validbits & ((uint16_t)1U << vb_dmesg_size))) {
		// 'dmesg_size': id=11, encoding=16bit, tag=0x5c
		if (3 > (e-a))
			return -246;
		*a++ = 0x5c;
		write_u16(a,m_dmesg_size);
		a += 2;
	}
	#ifdef CONFIG_INFLUX
	// has influx?
	if (0 != (p_validbits & ((uint16_t)1U << vb_influx))) {
		// 'influx': id=12, encoding=lenpfx, tag=0x62
		if (a >= e)
			return -247;
		*a++ = 0x62;
		ssize_t influx_ws = m_influx.calcSize();
		n = write_varint(a,e-a,influx_ws);
		a += n;
		if ((n <= 0) || (influx_ws > (e-a)))
			return -248;
		n = m_influx.toMemory(a,e-a);
		a += n;
		assert(n == influx_ws);
	}
	#endif // CONFIG_INFLUX
	// has station2ap_time?
	if (0 != (p_validbits & ((uint16_t)1U << vb_station2ap_time))) {
		// 'station2ap_time': id=13, encoding=varint, tag=0x68
		if (a >= e)
			return -249;
		*a++ = 0x68;
		n = write_varint(a,e-a,m_station2ap_time);
		if (n <= 0)
			return -250;
		a += n;
	}
	// has domainname?
	if (!m_domainname.empty()) {
		// 'domainname': id=15, encoding=lenpfx, tag=0x7a
		if (a >= e)
			return -251;
		*a++ = 0x7a;
		n = encode_bytes(m_domainname,a,e);
		if (n < 0)
			return -252;
		a += n;
	}
	for (const auto &x : m_holidays) {
		// 'holidays': id=16, encoding=lenpfx, tag=0x82
		if (2 > (e-a))
			return -253;
		*a++ = 0x82;
		*a++ = 0x1;
		ssize_t holidays_ws = x.calcSize();
		n = write_varint(a,e-a,holidays_ws);
		a += n;
		if ((n <= 0) || (holidays_ws > (e-a)))
			return -254;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == holidays_ws);
	}
	for (const auto &x : m_at_actions) {
		// 'at_actions': id=17, encoding=lenpfx, tag=0x8a
		if (2 > (e-a))
			return -255;
		*a++ = 0x8a;
		*a++ = 0x1;
		ssize_t at_actions_ws = x.calcSize();
		n = write_varint(a,e-a,at_actions_ws);
		a += n;
		if ((n <= 0) || (at_actions_ws > (e-a)))
			return -256;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == at_actions_ws);
	}
	// has actions_enable?
	if (0 != (p_validbits & ((uint16_t)1U << vb_actions_enable))) {
		// 'actions_enable': id=18, encoding=varint, tag=0x90
		if (2 > (e-a))
			return -257;
		*a++ = 0x90;
		*a++ = 0x1;
		n = write_varint(a,e-a,m_actions_enable);
		if (n <= 0)
			return -258;
		a += n;
	}
	for (const auto &x : m_triggers) {
		// 'triggers': id=19, encoding=lenpfx, tag=0x9a
		if (2 > (e-a))
			return -259;
		*a++ = 0x9a;
		*a++ = 0x1;
		ssize_t triggers_ws = x.calcSize();
		n = write_varint(a,e-a,triggers_ws);
		a += n;
		if ((n <= 0) || (triggers_ws > (e-a)))
			return -260;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == triggers_ws);
	}
	for (const auto &x : m_uart) {
		// 'uart': id=20, encoding=lenpfx, tag=0xa2
		if (2 > (e-a))
			return -261;
		*a++ = 0xa2;
		*a++ = 0x1;
		ssize_t uart_ws = x.calcSize();
		n = write_varint(a,e-a,uart_ws);
		a += n;
		if ((n <= 0) || (uart_ws > (e-a)))
			return -262;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == uart_ws);
	}
	#ifdef CONFIG_TERMSERV
	for (const auto &x : m_terminal) {
		// 'terminal': id=21, encoding=lenpfx, tag=0xaa
		if (2 > (e-a))
			return -263;
		*a++ = 0xaa;
		*a++ = 0x1;
		ssize_t terminal_ws = x.calcSize();
		n = write_varint(a,e-a,terminal_ws);
		a += n;
		if ((n <= 0) || (terminal_ws > (e-a)))
			return -264;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == terminal_ws);
	}
	#endif // CONFIG_TERMSERV
	// has udp_ctrl_port?
	if (0 != (p_validbits & ((uint16_t)1U << vb_udp_ctrl_port))) {
		// 'udp_ctrl_port': id=22, encoding=16bit, tag=0xb4
		if (4 > (e-a))
			return -265;
		a += write_varint(a,e-a,0xb4);	// 'udp_ctrl_port': id=22
		write_u16(a,m_udp_ctrl_port);
		a += 2;
	}
	for (const auto &x : m_debugs) {
		// 'debugs': id=23, encoding=lenpfx, tag=0xba
		if (2 > (e-a))
			return -266;
		*a++ = 0xba;
		*a++ = 0x1;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -267;
		a += n;
	}
	#ifdef CONFIG_FTP
	// has ftpd?
	if (0 != (p_validbits & ((uint16_t)1U << vb_ftpd))) {
		// 'ftpd': id=24, encoding=lenpfx, tag=0xc2
		if (2 > (e-a))
			return -268;
		*a++ = 0xc2;
		*a++ = 0x1;
		ssize_t ftpd_ws = m_ftpd.calcSize();
		n = write_varint(a,e-a,ftpd_ws);
		a += n;
		if ((n <= 0) || (ftpd_ws > (e-a)))
			return -269;
		n = m_ftpd.toMemory(a,e-a);
		a += n;
		assert(n == ftpd_ws);
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	// has httpd?
	if (0 != (p_validbits & ((uint16_t)1U << vb_httpd))) {
		// 'httpd': id=25, encoding=lenpfx, tag=0xca
		if (2 > (e-a))
			return -270;
		*a++ = 0xca;
		*a++ = 0x1;
		ssize_t httpd_ws = m_httpd.calcSize();
		n = write_varint(a,e-a,httpd_ws);
		a += n;
		if ((n <= 0) || (httpd_ws > (e-a)))
			return -271;
		n = m_httpd.toMemory(a,e-a);
		a += n;
		assert(n == httpd_ws);
	}
	#endif // CONFIG_HTTP
	// has otasrv?
	if (!m_otasrv.empty()) {
		// 'otasrv': id=26, encoding=lenpfx, tag=0xd2
		if (2 > (e-a))
			return -272;
		*a++ = 0xd2;
		*a++ = 0x1;
		n = encode_bytes(m_otasrv,a,e);
		if (n < 0)
			return -273;
		a += n;
	}
	#ifdef CONFIG_DISPLAY
	// 'screen' is unused. Therefore no data will be written.
	#endif // CONFIG_DISPLAY
	for (const auto &x : m_timefuses) {
		// 'timefuses': id=30, encoding=lenpfx, tag=0xf2
		if (2 > (e-a))
			return -274;
		*a++ = 0xf2;
		*a++ = 0x1;
		ssize_t timefuses_ws = x.calcSize();
		n = write_varint(a,e-a,timefuses_ws);
		a += n;
		if ((n <= 0) || (timefuses_ws > (e-a)))
			return -275;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == timefuses_ws);
	}
	#ifdef CONFIG_SIGNAL_PROC
	// 'signals' is unused. Therefore no data will be written.
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	// 'functions' is unused. Therefore no data will be written.
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	// 'statemachs' is unused. Therefore no data will be written.
	#endif // CONFIG_STATEMACHINES
	// 'max_on_time' is obsolete. Therefore no data will be written.
	// 'threshold_off' is obsolete. Therefore no data will be written.
	// 'threshold_on' is obsolete. Therefore no data will be written.
	// has dim_step?
	if (m_dim_step != 0) {
		// 'dim_step': id=37, encoding=varint, tag=0x128
		if (2 > (e-a))
			return -276;
		*a++ = 0xa8;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_dim_step);
		if (n <= 0)
			return -277;
		a += n;
	}
	// 'lightctrl' is obsolete. Therefore no data will be written.
	// has pwm_freq?
	if (m_pwm_freq != 0) {
		// 'pwm_freq': id=39, encoding=varint, tag=0x138
		if (2 > (e-a))
			return -278;
		*a++ = 0xb8;
		*a++ = 0x2;
		n = write_varint(a,e-a,m_pwm_freq);
		if (n <= 0)
			return -279;
		a += n;
	}
	#ifdef CONFIG_APP_PARAMS
	for (const auto &x : m_app_params) {
		// 'app_params': id=40, encoding=lenpfx, tag=0x142
		if (2 > (e-a))
			return -280;
		*a++ = 0xc2;
		*a++ = 0x2;
		ssize_t app_params_ws = x.calcSize();
		n = write_varint(a,e-a,app_params_ws);
		a += n;
		if ((n <= 0) || (app_params_ws > (e-a)))
			return -281;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == app_params_ws);
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	for (const auto &x : m_thresholds) {
		// 'thresholds': id=41, encoding=lenpfx, tag=0x14a
		if (2 > (e-a))
			return -282;
		*a++ = 0xca;
		*a++ = 0x2;
		ssize_t thresholds_ws = x.calcSize();
		n = write_varint(a,e-a,thresholds_ws);
		a += n;
		if ((n <= 0) || (thresholds_ws > (e-a)))
			return -283;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == thresholds_ws);
	}
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	for (const auto &x : m_luafiles) {
		// 'luafiles': id=42, encoding=lenpfx, tag=0x152
		if (2 > (e-a))
			return -284;
		*a++ = 0xd2;
		*a++ = 0x2;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -285;
		a += n;
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_LUA
	// has lua_disable?
	if (m_lua_disable != false) {
		// 'lua_disable': id=43, encoding=8bit, tag=0x15b
		if (3 > (e-a))
			return -286;
		a += write_varint(a,e-a,0x15b);	// 'lua_disable': id=43
		*a++ = m_lua_disable;
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	for (const auto &x : m_owdevices) {
		// 'owdevices': id=50, encoding=lenpfx, tag=0x192
		if (2 > (e-a))
			return -287;
		*a++ = 0x92;
		*a++ = 0x3;
		ssize_t owdevices_ws = x.calcSize();
		n = write_varint(a,e-a,owdevices_ws);
		a += n;
		if ((n <= 0) || (owdevices_ws > (e-a)))
			return -288;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == owdevices_ws);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_XPLANE
	// has xplane?
	if (0 != (p_validbits & ((uint16_t)1U << vb_xplane))) {
		// 'xplane': id=60, encoding=lenpfx, tag=0x1e2
		if (2 > (e-a))
			return -289;
		*a++ = 0xe2;
		*a++ = 0x3;
		ssize_t xplane_ws = m_xplane.calcSize();
		n = write_varint(a,e-a,xplane_ws);
		a += n;
		if ((n <= 0) || (xplane_ws > (e-a)))
			return -290;
		n = m_xplane.toMemory(a,e-a);
		a += n;
		assert(n == xplane_ws);
	}
	#endif // CONFIG_XPLANE
	assert(a <= e);
	return a-b;
}

void NodeConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_magic()) {
		fsep = json_indent(json,indLvl,fsep,"magic");
		to_decstr(json,m_magic);
	}
	if (full || has_nodename()) {
		fsep = json_indent(json,indLvl,fsep,"nodename");
		json_cstr(json,m_nodename.c_str());
	}
	if (full || has_pass_hash()) {
		fsep = json_indent(json,indLvl,fsep,"pass_hash");
		json_string(json,m_pass_hash);
	}
	if (full || has_cpu_freq()) {
		fsep = json_indent(json,indLvl,fsep,"cpu_freq");
		to_decstr(json,m_cpu_freq);
	}
	if (full || has_station()) {
		fsep = json_indent(json,indLvl,fsep,"station");
		m_station.toJSON(json,full,indLvl);
	}
	if (full || has_softap()) {
		fsep = json_indent(json,indLvl,fsep,"softap");
		m_softap.toJSON(json,full,indLvl);
	}
	if (size_t s = m_dns_server.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"dns_server\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_dns_server[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (full || has_syslog_host()) {
		fsep = json_indent(json,indLvl,fsep,"syslog_host");
		json_cstr(json,m_syslog_host.c_str());
	}
	if (full || has_sntp_server()) {
		fsep = json_indent(json,indLvl,fsep,"sntp_server");
		json_cstr(json,m_sntp_server.c_str());
	}
	if (full || has_timezone()) {
		fsep = json_indent(json,indLvl,fsep,"timezone");
		json_cstr(json,m_timezone.c_str());
	}
	#ifdef CONFIG_MQTT
	if (full || has_mqtt()) {
		fsep = json_indent(json,indLvl,fsep,"mqtt");
		m_mqtt.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_MQTT
	if (full || has_dmesg_size()) {
		fsep = json_indent(json,indLvl,fsep,"dmesg_size");
		to_decstr(json,m_dmesg_size);
	}
	#ifdef CONFIG_INFLUX
	if (full || has_influx()) {
		fsep = json_indent(json,indLvl,fsep,"influx");
		m_influx.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_INFLUX
	if (full || has_station2ap_time()) {
		fsep = json_indent(json,indLvl,fsep,"station2ap_time");
		to_decstr(json,m_station2ap_time);
	}
	if (full || has_domainname()) {
		fsep = json_indent(json,indLvl,fsep,"domainname");
		json_cstr(json,m_domainname.c_str());
	}
	if (size_t s = m_holidays.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"holidays\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_holidays[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_at_actions.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"at_actions\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_at_actions[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (full || has_actions_enable()) {
		fsep = json_indent(json,indLvl,fsep,"actions_enable");
		to_decstr(json,m_actions_enable);
	}
	if (size_t s = m_triggers.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"triggers\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_triggers[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_uart.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"uart\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_uart[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_TERMSERV
	if (size_t s = m_terminal.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"terminal\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_terminal[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_TERMSERV
	if (full || has_udp_ctrl_port()) {
		fsep = json_indent(json,indLvl,fsep,"udp_ctrl_port");
		to_decstr(json,m_udp_ctrl_port);
	}
	if (size_t s = m_debugs.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"debugs\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_debugs[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_FTP
	if (full || has_ftpd()) {
		fsep = json_indent(json,indLvl,fsep,"ftpd");
		m_ftpd.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (full || has_httpd()) {
		fsep = json_indent(json,indLvl,fsep,"httpd");
		m_httpd.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_HTTP
	if (full || has_otasrv()) {
		fsep = json_indent(json,indLvl,fsep,"otasrv");
		json_cstr(json,m_otasrv.c_str());
	}
	if (size_t s = m_timefuses.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"timefuses\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_timefuses[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (full || has_dim_step()) {
		fsep = json_indent(json,indLvl,fsep,"dim_step");
		to_decstr(json,m_dim_step);
	}
	if (full || has_pwm_freq()) {
		fsep = json_indent(json,indLvl,fsep,"pwm_freq");
		to_decstr(json,m_pwm_freq);
	}
	#ifdef CONFIG_APP_PARAMS
	if (size_t s = m_app_params.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"app_params\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_app_params[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	if (size_t s = m_thresholds.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"thresholds\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_thresholds[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	if (size_t s = m_luafiles.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"luafiles\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_luafiles[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_LUA
	if (full || has_lua_disable()) {
		fsep = json_indent(json,indLvl,fsep,"lua_disable");
		json << (m_lua_disable ? "true" : "false");
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	if (size_t s = m_owdevices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"owdevices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_owdevices[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_XPLANE
	if (full || has_xplane()) {
		fsep = json_indent(json,indLvl,fsep,"xplane");
		m_xplane.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_XPLANE
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t NodeConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed32 magic, id 0
	if (has_magic()) {
		r += 5;
	}
	// optional string nodename, id 1
	if (has_nodename()) {
		size_t nodename_s = m_nodename.size();
		r += nodename_s + wiresize(nodename_s) + 1 /* tag(nodename) 0x8 */;
	}
	// optional bytes pass_hash, id 2
	if (has_pass_hash()) {
		size_t pass_hash_s = m_pass_hash.size();
		r += pass_hash_s + wiresize(pass_hash_s) + 1 /* tag(pass_hash) 0x10 */;
	}
	// optional unsigned cpu_freq, id 3
	if (has_cpu_freq()) {
		r += wiresize((varint_t)m_cpu_freq) + 1 /* tag(cpu_freq) 0x18 */;
	}
	// optional WifiConfig station, id 4
	if (has_station()) {
		size_t station_s = m_station.calcSize();
		r += station_s + wiresize(station_s) + 1 /* tag(station) 0x20 */;
	}
	// optional WifiConfig softap, id 5
	if (has_softap()) {
		size_t softap_s = m_softap.calcSize();
		r += softap_s + wiresize(softap_s) + 1 /* tag(softap) 0x28 */;
	}
	// repeated string dns_server, id 6
	if (!m_dns_server.empty()) {
		// dns_server: repeated estring
		for (size_t x = 0, y = m_dns_server.size(); x < y; ++x) {
			size_t s = m_dns_server[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(dns_server) 0x30 */;
		}
	}
	// optional string syslog_host, id 7
	if (has_syslog_host()) {
		size_t syslog_host_s = m_syslog_host.size();
		r += syslog_host_s + wiresize(syslog_host_s) + 1 /* tag(syslog_host) 0x38 */;
	}
	// optional string sntp_server, id 8
	if (has_sntp_server()) {
		size_t sntp_server_s = m_sntp_server.size();
		r += sntp_server_s + wiresize(sntp_server_s) + 1 /* tag(sntp_server) 0x40 */;
	}
	// optional string timezone, id 9
	if (has_timezone()) {
		size_t timezone_s = m_timezone.size();
		r += timezone_s + wiresize(timezone_s) + 1 /* tag(timezone) 0x48 */;
	}
	#ifdef CONFIG_MQTT
	// optional MQTT mqtt, id 10
	if (has_mqtt()) {
		size_t mqtt_s = m_mqtt.calcSize();
		r += mqtt_s + wiresize(mqtt_s) + 1 /* tag(mqtt) 0x50 */;
	}
	#endif // CONFIG_MQTT
	// optional fixed16 dmesg_size, id 11
	if (has_dmesg_size()) {
		r += 3;
	}
	#ifdef CONFIG_INFLUX
	// optional Influx influx, id 12
	if (has_influx()) {
		size_t influx_s = m_influx.calcSize();
		r += influx_s + wiresize(influx_s) + 1 /* tag(influx) 0x60 */;
	}
	#endif // CONFIG_INFLUX
	// optional unsigned station2ap_time, id 13
	if (has_station2ap_time()) {
		r += wiresize((varint_t)m_station2ap_time) + 1 /* tag(station2ap_time) 0x68 */;
	}
	// optional string domainname, id 15
	if (has_domainname()) {
		size_t domainname_s = m_domainname.size();
		r += domainname_s + wiresize(domainname_s) + 1 /* tag(domainname) 0x78 */;
	}
	// repeated Date holidays, id 16
	// repeated message holidays
	for (size_t x = 0, y = m_holidays.size(); x < y; ++x) {
		size_t s = m_holidays[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(holidays) 0x80 */;
	}
	// repeated AtAction at_actions, id 17
	// repeated message at_actions
	for (size_t x = 0, y = m_at_actions.size(); x < y; ++x) {
		size_t s = m_at_actions[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(at_actions) 0x88 */;
	}
	// optional unsigned actions_enable, id 18
	if (has_actions_enable()) {
		r += wiresize((varint_t)m_actions_enable) + 2 /* tag(actions_enable) 0x90 */;
	}
	// repeated Trigger triggers, id 19
	// repeated message triggers
	for (size_t x = 0, y = m_triggers.size(); x < y; ++x) {
		size_t s = m_triggers[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(triggers) 0x98 */;
	}
	// repeated UartSettings uart, id 20
	// repeated message uart
	for (size_t x = 0, y = m_uart.size(); x < y; ++x) {
		size_t s = m_uart[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(uart) 0xa0 */;
	}
	#ifdef CONFIG_TERMSERV
	// repeated TerminalConfig terminal, id 21
	// repeated message terminal
	for (size_t x = 0, y = m_terminal.size(); x < y; ++x) {
		size_t s = m_terminal[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(terminal) 0xa8 */;
	}
	#endif // CONFIG_TERMSERV
	// optional fixed16 udp_ctrl_port, id 22
	if (has_udp_ctrl_port()) {
		r += 4;
	}
	// repeated string debugs, id 23
	if (!m_debugs.empty()) {
		// debugs: repeated estring
		for (size_t x = 0, y = m_debugs.size(); x < y; ++x) {
			size_t s = m_debugs[x].size();
			r += wiresize(s);
			r += s + 2 /* tag(debugs) 0xb8 */;
		}
	}
	#ifdef CONFIG_FTP
	// optional FtpHttpConfig ftpd, id 24
	if (has_ftpd()) {
		size_t ftpd_s = m_ftpd.calcSize();
		r += ftpd_s + wiresize(ftpd_s) + 2 /* tag(ftpd) 0xc0 */;
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	// optional FtpHttpConfig httpd, id 25
	if (has_httpd()) {
		size_t httpd_s = m_httpd.calcSize();
		r += httpd_s + wiresize(httpd_s) + 2 /* tag(httpd) 0xc8 */;
	}
	#endif // CONFIG_HTTP
	// optional string otasrv, id 26
	if (has_otasrv()) {
		size_t otasrv_s = m_otasrv.size();
		r += otasrv_s + wiresize(otasrv_s) + 2 /* tag(otasrv) 0xd0 */;
	}
	#ifdef CONFIG_DISPLAY
	// unused optional ScreenConfig screen, id 27
	#endif // CONFIG_DISPLAY
	// repeated EventTimer timefuses, id 30
	// repeated message timefuses
	for (size_t x = 0, y = m_timefuses.size(); x < y; ++x) {
		size_t s = m_timefuses[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(timefuses) 0xf0 */;
	}
	#ifdef CONFIG_SIGNAL_PROC
	// unused repeated SignalConfig signals, id 31
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_SIGNAL_PROC
	// unused repeated FunctionConfig functions, id 32
	#endif // CONFIG_SIGNAL_PROC
	#ifdef CONFIG_STATEMACHINES
	// unused repeated StateMachineConfig statemachs, id 33
	#endif // CONFIG_STATEMACHINES
	// obsolete optional unsigned max_on_time, id 34
	// obsolete optional unsigned threshold_off, id 35
	// obsolete optional unsigned threshold_on, id 36
	// optional unsigned dim_step, id 37
	if (has_dim_step()) {
		r += wiresize((varint_t)m_dim_step) + 2 /* tag(dim_step) 0x128 */;
	}
	// obsolete optional bool lightctrl, id 38
	// optional unsigned pwm_freq, id 39
	if (has_pwm_freq()) {
		r += wiresize((varint_t)m_pwm_freq) + 2 /* tag(pwm_freq) 0x138 */;
	}
	#ifdef CONFIG_APP_PARAMS
	// repeated AppParam app_params, id 40
	// repeated message app_params
	for (size_t x = 0, y = m_app_params.size(); x < y; ++x) {
		size_t s = m_app_params[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(app_params) 0x140 */;
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	// repeated ThresholdConfig thresholds, id 41
	// repeated message thresholds
	for (size_t x = 0, y = m_thresholds.size(); x < y; ++x) {
		size_t s = m_thresholds[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(thresholds) 0x148 */;
	}
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	// repeated string luafiles, id 42
	if (!m_luafiles.empty()) {
		// luafiles: repeated estring
		for (size_t x = 0, y = m_luafiles.size(); x < y; ++x) {
			size_t s = m_luafiles[x].size();
			r += wiresize(s);
			r += s + 2 /* tag(luafiles) 0x150 */;
		}
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_LUA
	// optional bool lua_disable, id 43
	if (has_lua_disable()) {
		r += 3;
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	// repeated OwDeviceConfig owdevices, id 50
	// repeated message owdevices
	for (size_t x = 0, y = m_owdevices.size(); x < y; ++x) {
		size_t s = m_owdevices[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(owdevices) 0x190 */;
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_XPLANE
	// optional XPlaneConfig xplane, id 60
	if (has_xplane()) {
		size_t xplane_s = m_xplane.calcSize();
		r += xplane_s + wiresize(xplane_s) + 2 /* tag(xplane) 0x1e0 */;
	}
	#endif // CONFIG_XPLANE
	return r;
}

bool NodeConfig::operator == (const NodeConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_magic() && (!(m_magic == r.m_magic)))
		return false;
	if (has_nodename() && (!(m_nodename == r.m_nodename)))
		return false;
	if (has_pass_hash() && (!(m_pass_hash == r.m_pass_hash)))
		return false;
	if (has_cpu_freq() && (!(m_cpu_freq == r.m_cpu_freq)))
		return false;
	if (has_station() && (!(m_station == r.m_station)))
		return false;
	if (has_softap() && (!(m_softap == r.m_softap)))
		return false;
	if (!(m_dns_server == r.m_dns_server))
		return false;
	if (has_syslog_host() && (!(m_syslog_host == r.m_syslog_host)))
		return false;
	if (has_sntp_server() && (!(m_sntp_server == r.m_sntp_server)))
		return false;
	if (has_timezone() && (!(m_timezone == r.m_timezone)))
		return false;
	#ifdef CONFIG_MQTT
	if (has_mqtt() && (!(m_mqtt == r.m_mqtt)))
		return false;
	#endif // CONFIG_MQTT
	if (has_dmesg_size() && (!(m_dmesg_size == r.m_dmesg_size)))
		return false;
	#ifdef CONFIG_INFLUX
	if (has_influx() && (!(m_influx == r.m_influx)))
		return false;
	#endif // CONFIG_INFLUX
	if (has_station2ap_time() && (!(m_station2ap_time == r.m_station2ap_time)))
		return false;
	if (has_domainname() && (!(m_domainname == r.m_domainname)))
		return false;
	if (!(m_holidays == r.m_holidays))
		return false;
	if (!(m_at_actions == r.m_at_actions))
		return false;
	if (has_actions_enable() && (!(m_actions_enable == r.m_actions_enable)))
		return false;
	if (!(m_triggers == r.m_triggers))
		return false;
	if (!(m_uart == r.m_uart))
		return false;
	#ifdef CONFIG_TERMSERV
	if (!(m_terminal == r.m_terminal))
		return false;
	#endif // CONFIG_TERMSERV
	if (has_udp_ctrl_port() && (!(m_udp_ctrl_port == r.m_udp_ctrl_port)))
		return false;
	if (!(m_debugs == r.m_debugs))
		return false;
	#ifdef CONFIG_FTP
	if (has_ftpd() && (!(m_ftpd == r.m_ftpd)))
		return false;
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (has_httpd() && (!(m_httpd == r.m_httpd)))
		return false;
	#endif // CONFIG_HTTP
	if (has_otasrv() && (!(m_otasrv == r.m_otasrv)))
		return false;
	if (!(m_timefuses == r.m_timefuses))
		return false;
	// nothing to do for obsolete max_on_time
	// nothing to do for obsolete threshold_off
	// nothing to do for obsolete threshold_on
	if (has_dim_step() && (!(m_dim_step == r.m_dim_step)))
		return false;
	// nothing to do for obsolete lightctrl
	if (has_pwm_freq() && (!(m_pwm_freq == r.m_pwm_freq)))
		return false;
	#ifdef CONFIG_APP_PARAMS
	if (!(m_app_params == r.m_app_params))
		return false;
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	if (!(m_thresholds == r.m_thresholds))
		return false;
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	if (!(m_luafiles == r.m_luafiles))
		return false;
	#endif // CONFIG_LUA
	#ifdef CONFIG_LUA
	if (has_lua_disable() && (!(m_lua_disable == r.m_lua_disable)))
		return false;
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	if (!(m_owdevices == r.m_owdevices))
		return false;
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_XPLANE
	if (has_xplane() && (!(m_xplane == r.m_xplane)))
		return false;
	#endif // CONFIG_XPLANE
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int NodeConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"magic")) {
		if (value == 0) {
			clear_magic();
			return 0;
		}
		int r = parse_ascii_u32(&m_magic,value);
		if (r > 0)
			p_validbits |= ((uint16_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"nodename")) {
		if (value == 0) {
			m_nodename.clear();
			return 0;
		}
		m_nodename = value;
		int r = m_nodename.size();
		return r;
	}
	if (0 == strcmp(name,"pass_hash")) {
		if (value == 0) {
			m_pass_hash.clear();
			return 0;
		}
		int r = parse_ascii_bytes(m_pass_hash,value);
		return r;
	}
	if (0 == strcmp(name,"cpu_freq")) {
		if (value == 0) {
			clear_cpu_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_cpu_freq,value);
		return r;
	}
	if (0 == memcmp(name,"station",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_station();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 1);
			return m_station.setByName(name+8,value);
		}
	}
	if (0 == memcmp(name,"softap",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_softap();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 2);
			return m_softap.setByName(name+7,value);
		}
	}
	if (0 == memcmp(name,"dns_server",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_dns_server();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_dns_server.size();
				m_dns_server.resize(x+1);
				idxe = (char*)(name + 12);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+11)))
					return -291;
				if (m_dns_server.size() <= x)
					return -292;
				if ((idxe[1] == 0) && (value == 0)) {
					m_dns_server.erase(m_dns_server.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -293;
			m_dns_server[x] = value;
			return m_dns_server[x].size();
		}
	}
	if (0 == strcmp(name,"syslog_host")) {
		if (value == 0) {
			m_syslog_host.clear();
			return 0;
		}
		m_syslog_host = value;
		int r = m_syslog_host.size();
		return r;
	}
	if (0 == strcmp(name,"sntp_server")) {
		if (value == 0) {
			m_sntp_server.clear();
			return 0;
		}
		m_sntp_server = value;
		int r = m_sntp_server.size();
		return r;
	}
	if (0 == strcmp(name,"timezone")) {
		if (value == 0) {
			m_timezone.clear();
			return 0;
		}
		m_timezone = value;
		int r = m_timezone.size();
		return r;
	}
	#ifdef CONFIG_MQTT
	if (0 == memcmp(name,"mqtt",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_mqtt();
			return 0;
		} else if (name[4] == '.') {
			p_validbits |= ((uint16_t)1U << 3);
			return m_mqtt.setByName(name+5,value);
		}
	}
	#endif // CONFIG_MQTT
	if (0 == strcmp(name,"dmesg_size")) {
		if (value == 0) {
			clear_dmesg_size();
			return 0;
		}
		int r = parse_ascii_u16(&m_dmesg_size,value);
		if (r > 0)
			p_validbits |= ((uint16_t)1U << 4);
		return r;
	}
	#ifdef CONFIG_INFLUX
	if (0 == memcmp(name,"influx",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_influx();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 5);
			return m_influx.setByName(name+7,value);
		}
	}
	#endif // CONFIG_INFLUX
	if (0 == strcmp(name,"station2ap_time")) {
		if (value == 0) {
			clear_station2ap_time();
			return 0;
		}
		int r = parse_ascii_u32(&m_station2ap_time,value);
		if (r > 0)
			p_validbits |= ((uint16_t)1U << 6);
		return r;
	}
	if (0 == strcmp(name,"domainname")) {
		if (value == 0) {
			m_domainname.clear();
			return 0;
		}
		m_domainname = value;
		int r = m_domainname.size();
		return r;
	}
	if (0 == memcmp(name,"holidays",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_holidays();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_holidays.size();
				m_holidays.resize(x+1);
				idxe = (char*)(name + 10);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+9)))
					return -294;
				if (m_holidays.size() <= x)
					return -295;
				if ((idxe[1] == 0) && (value == 0)) {
					m_holidays.erase(m_holidays.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -296;
			return m_holidays[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"at_actions",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_at_actions();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_at_actions.size();
				m_at_actions.resize(x+1);
				idxe = (char*)(name + 12);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+11)))
					return -297;
				if (m_at_actions.size() <= x)
					return -298;
				if ((idxe[1] == 0) && (value == 0)) {
					m_at_actions.erase(m_at_actions.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -299;
			return m_at_actions[x].setByName(idxe+2,value);
		}
	}
	if (0 == strcmp(name,"actions_enable")) {
		if (value == 0) {
			clear_actions_enable();
			return 0;
		}
		int r = parse_ascii_u32(&m_actions_enable,value);
		if (r > 0)
			p_validbits |= ((uint16_t)1U << 7);
		return r;
	}
	if (0 == memcmp(name,"triggers",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_triggers();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_triggers.size();
				m_triggers.resize(x+1);
				idxe = (char*)(name + 10);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+9)))
					return -300;
				if (m_triggers.size() <= x)
					return -301;
				if ((idxe[1] == 0) && (value == 0)) {
					m_triggers.erase(m_triggers.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -302;
			return m_triggers[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"uart",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_uart();
			return 0;
		} else if (name[4] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[5] == '+') && (name[6] == ']')) {
				x = m_uart.size();
				m_uart.resize(x+1);
				idxe = (char*)(name + 6);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+5,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+5)))
					return -303;
				if (m_uart.size() <= x)
					return -304;
				if ((idxe[1] == 0) && (value == 0)) {
					m_uart.erase(m_uart.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -305;
			return m_uart[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_TERMSERV
	if (0 == memcmp(name,"terminal",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_terminal();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_terminal.size();
				m_terminal.resize(x+1);
				idxe = (char*)(name + 10);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+9)))
					return -306;
				if (m_terminal.size() <= x)
					return -307;
				if ((idxe[1] == 0) && (value == 0)) {
					m_terminal.erase(m_terminal.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -308;
			return m_terminal[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_TERMSERV
	if (0 == strcmp(name,"udp_ctrl_port")) {
		if (value == 0) {
			clear_udp_ctrl_port();
			return 0;
		}
		int r = parse_ascii_u16(&m_udp_ctrl_port,value);
		if (r > 0)
			p_validbits |= ((uint16_t)1U << 8);
		return r;
	}
	if (0 == memcmp(name,"debugs",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_debugs();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_debugs.size();
				m_debugs.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -309;
				if (m_debugs.size() <= x)
					return -310;
				if ((idxe[1] == 0) && (value == 0)) {
					m_debugs.erase(m_debugs.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -311;
			m_debugs[x] = value;
			return m_debugs[x].size();
		}
	}
	#ifdef CONFIG_FTP
	if (0 == memcmp(name,"ftpd",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_ftpd();
			return 0;
		} else if (name[4] == '.') {
			p_validbits |= ((uint16_t)1U << 9);
			return m_ftpd.setByName(name+5,value);
		}
	}
	#endif // CONFIG_FTP
	#ifdef CONFIG_HTTP
	if (0 == memcmp(name,"httpd",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_httpd();
			return 0;
		} else if (name[5] == '.') {
			p_validbits |= ((uint16_t)1U << 10);
			return m_httpd.setByName(name+6,value);
		}
	}
	#endif // CONFIG_HTTP
	if (0 == strcmp(name,"otasrv")) {
		if (value == 0) {
			m_otasrv.clear();
			return 0;
		}
		m_otasrv = value;
		int r = m_otasrv.size();
		return r;
	}
	if (0 == memcmp(name,"timefuses",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_timefuses();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_timefuses.size();
				m_timefuses.resize(x+1);
				idxe = (char*)(name + 11);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+10)))
					return -312;
				if (m_timefuses.size() <= x)
					return -313;
				if ((idxe[1] == 0) && (value == 0)) {
					m_timefuses.erase(m_timefuses.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -314;
			return m_timefuses[x].setByName(idxe+2,value);
		}
	}
	if (0 == strcmp(name,"dim_step")) {
		if (value == 0) {
			clear_dim_step();
			return 0;
		}
		int r = parse_ascii_u32(&m_dim_step,value);
		return r;
	}
	if (0 == strcmp(name,"pwm_freq")) {
		if (value == 0) {
			clear_pwm_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_pwm_freq,value);
		return r;
	}
	#ifdef CONFIG_APP_PARAMS
	if (0 == memcmp(name,"app_params",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_app_params();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_app_params.size();
				m_app_params.resize(x+1);
				idxe = (char*)(name + 12);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+11)))
					return -315;
				if (m_app_params.size() <= x)
					return -316;
				if ((idxe[1] == 0) && (value == 0)) {
					m_app_params.erase(m_app_params.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -317;
			return m_app_params[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_APP_PARAMS
	#ifdef CONFIG_THRESHOLDS
	if (0 == memcmp(name,"thresholds",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_thresholds();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_thresholds.size();
				m_thresholds.resize(x+1);
				idxe = (char*)(name + 12);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+11)))
					return -318;
				if (m_thresholds.size() <= x)
					return -319;
				if ((idxe[1] == 0) && (value == 0)) {
					m_thresholds.erase(m_thresholds.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -320;
			return m_thresholds[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_THRESHOLDS
	#ifdef CONFIG_LUA
	if (0 == memcmp(name,"luafiles",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_luafiles();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_luafiles.size();
				m_luafiles.resize(x+1);
				idxe = (char*)(name + 10);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+9)))
					return -321;
				if (m_luafiles.size() <= x)
					return -322;
				if ((idxe[1] == 0) && (value == 0)) {
					m_luafiles.erase(m_luafiles.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -323;
			m_luafiles[x] = value;
			return m_luafiles[x].size();
		}
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_LUA
	if (0 == strcmp(name,"lua_disable")) {
		if (value == 0) {
			clear_lua_disable();
			return 0;
		}
		int r = parse_ascii_bool(&m_lua_disable,value);
		return r;
	}
	#endif // CONFIG_LUA
	#ifdef CONFIG_ONEWIRE
	if (0 == memcmp(name,"owdevices",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_owdevices();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_owdevices.size();
				m_owdevices.resize(x+1);
				idxe = (char*)(name + 11);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+10)))
					return -324;
				if (m_owdevices.size() <= x)
					return -325;
				if ((idxe[1] == 0) && (value == 0)) {
					m_owdevices.erase(m_owdevices.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -326;
			return m_owdevices[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_XPLANE
	if (0 == memcmp(name,"xplane",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_xplane();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 11);
			return m_xplane.setByName(name+7,value);
		}
	}
	#endif // CONFIG_XPLANE
	return -327;
}

