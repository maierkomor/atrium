/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: P2304.21 (hg:477/6f02a2b83060)
 * WFC is Copyright 2015-2025, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : hwcfg.wfc
 * Copyright: 2018-2025
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2025-05-13, 08:33:00 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from esp32:
 * endian          : "little"
 * Optimize        : "speed"
 * 
 * options from esp:
 * bytestype       : "estring"
 * enumnames       : "true"
 * intsize         : 32
 * SortMembers     : "size"
 * stringtype      : "estring"
 * toASCII         : "toASCII"
 * toSink          : ""
 * toString        : ""
 * toWire          : ""
 * varintbits      : 32
 * 
 * options from common:
 * BaseClass       : "Message"
 * getMember       : "getMember"
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bool      : "ascii_bool"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * calcSize        : "calcSize"
 * cfgdefs         : ""
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * ClearValue      : "compatible"
 * copyright       : ""
 * email           : ""
 * enummap         : "false"
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * pbt_indent      : "pbt_indent"
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * toPbt           : "toPbt"
 * UnknownField    : "skip"
 * wireput         : ""
 * wiresize        : ""
 * 
 * enabled flags from esp32:
 * 	withUnequal
 * enabled flags from esp:
 * 	withEqual
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux
 */

#include <map>
#include <stdlib.h>
#include <string.h>
#include "hwcfg_esp32.h"

#include "wfccore_esp32.h"

#if !defined(WFC_ENDIAN) || (WFC_ENDIAN != 0)
#error wfc: incompatible settings concerning endian
#endif


static const char *pull_mode_e_names[] = {
	"pull_none",
	"pull_en",
	"pull_down",
	"pull_dir",
	"pull_up",
};

static pull_mode_e pull_mode_e_values[] = {
	pull_none,
	pull_en,
	pull_down,
	pull_dir,
	pull_up,
};

size_t parse_ascii_pull_mode_e(pull_mode_e *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (pull_mode_e)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(pull_mode_e_names)/sizeof(pull_mode_e_names[0]); ++i) {
		if (0 == strcmp(pull_mode_e_names[i],s)) {
			*v = pull_mode_e_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *pull_mode_e_str(pull_mode_e e)
{
	for (size_t i = 0; i < sizeof(pull_mode_e_values)/sizeof(pull_mode_e_values[0]); ++i) {
		if (e == pull_mode_e_values[i])
			return pull_mode_e_names[i];
	}
	return 0;
}

static const char *dht_model_t_names[] = {
	"DHT_NONE",
	"RHT03",
	"DHT11",
	"DHT21",
	"DHT22",
	"AM2301",
	"AM2302",
};

static dht_model_t dht_model_t_values[] = {
	DHT_NONE,
	RHT03,
	DHT11,
	DHT21,
	DHT22,
	AM2301,
	AM2302,
};

size_t parse_ascii_dht_model_t(dht_model_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (dht_model_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(dht_model_t_names)/sizeof(dht_model_t_names[0]); ++i) {
		if (0 == strcmp(dht_model_t_names[i],s)) {
			*v = dht_model_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *dht_model_t_str(dht_model_t e)
{
	for (size_t i = 0; i < sizeof(dht_model_t_values)/sizeof(dht_model_t_values[0]); ++i) {
		if (e == dht_model_t_values[i])
			return dht_model_t_names[i];
	}
	return 0;
}

static const char *i2cdrv_t_names[] = {
	"i2cdrv_invalid",
	"i2cdrv_pcf8574",
	"i2cdrv_mcp2300x",
	"i2cdrv_mcp2301x",
	"i2cdrv_pca9685",
	"i2cdrv_pca9685_npn",
	"i2cdrv_pca9685_pnp",
	"i2cdrv_pca9685_xclk",
	"i2cdrv_pca9685_xclk_npn",
	"i2cdrv_pca9685_xclk_pnp",
	"i2cdrv_ht16k33",
	"i2cdrv_ina219",
	"i2cdrv_si7021",
	"i2cdrv_tca9555",
	"i2cdrv_ssd1306",
	"i2cdrv_sh1106",
	"i2cdrv_ads1013",
	"i2cdrv_ads1014",
	"i2cdrv_ads1015",
	"i2cdrv_ads1113",
	"i2cdrv_ads1114",
	"i2cdrv_ads1115",
	"i2cdrv_ina220",
	"i2cdrv_aht10",
	"i2cdrv_aht20",
	"i2cdrv_aht30",
};


size_t parse_ascii_i2cdrv_t(i2cdrv_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (i2cdrv_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(i2cdrv_t_names)/sizeof(i2cdrv_t_names[0]); ++i) {
		if (0 == strcmp(i2cdrv_t_names[i],s)) {
			*v = (i2cdrv_t)i;
			return strlen(s);
		}
	}
	return 0;
}

const char *i2cdrv_t_str(i2cdrv_t e)
{
	return i2cdrv_t_names[(size_t)e];
}

static const char *disp_t_names[] = {
	"dt_none",
	"dt_sd_7seg",
	"dt_sd_14seg",
	"dt_pcf8574_hd44780u",
	"dt_ssd1306",
	"dt_ssd1309",
	"dt_sh1106",
	"dt_ili9341",
};

static disp_t disp_t_values[] = {
	dt_none,
	dt_sd_7seg,
	dt_sd_14seg,
	dt_pcf8574_hd44780u,
	dt_ssd1306,
	dt_ssd1309,
	dt_sh1106,
	dt_ili9341,
};

size_t parse_ascii_disp_t(disp_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (disp_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(disp_t_names)/sizeof(disp_t_names[0]); ++i) {
		if (0 == strcmp(disp_t_names[i],s)) {
			*v = disp_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *disp_t_str(disp_t e)
{
	for (size_t i = 0; i < sizeof(disp_t_values)/sizeof(disp_t_values[0]); ++i) {
		if (e == disp_t_values[i])
			return disp_t_names[i];
	}
	return 0;
}

static const char *spidrv_t_names[] = {
	"spidrv_invalid",
	"spidrv_sx1276",
	"spidrv_ssd1309",
	"spidrv_ili9341",
	"spidrv_xpt2046",
	"spidrv_sdcard",
};


size_t parse_ascii_spidrv_t(spidrv_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (spidrv_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(spidrv_t_names)/sizeof(spidrv_t_names[0]); ++i) {
		if (0 == strcmp(spidrv_t_names[i],s)) {
			*v = (spidrv_t)i;
			return strlen(s);
		}
	}
	return 0;
}

const char *spidrv_t_str(spidrv_t e)
{
	return spidrv_t_names[(size_t)e];
}

void SystemConfig::clear()
{
	m_manufacturer.clear();
	m_board_name.clear();
	m_board_rev.clear();
	m_diag_uart = 0;
	m_console_rx = 0;
	m_console_tx = 0;
	m_model_name.clear();
	m_model_number.clear();
	#ifdef CONFIG_USB_DIAGLOG
	m_usb_diag = true;
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	m_usb_con = true;
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	m_cc1_gpio = -1;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	m_cc2_gpio = -1;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	p_validbits = 0;
}

void SystemConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // SystemConfig";
	++indent;
	if (full || has_manufacturer()) {
		ascii_string(o,indent,m_manufacturer.data(),m_manufacturer.size(),"manufacturer");
	}
	if (full || has_board_name()) {
		ascii_string(o,indent,m_board_name.data(),m_board_name.size(),"board_name");
	}
	if (full || has_board_rev()) {
		ascii_string(o,indent,m_board_rev.data(),m_board_rev.size(),"board_rev");
	}
	if (full || has_diag_uart()) {
		ascii_numeric(o, indent, "diag_uart", (signed) m_diag_uart);
	}
	if (full || has_console_rx()) {
		ascii_numeric(o, indent, "console_rx", (signed) m_console_rx);
	}
	if (full || has_console_tx()) {
		ascii_numeric(o, indent, "console_tx", (signed) m_console_tx);
	}
	if (full || has_model_name()) {
		ascii_string(o,indent,m_model_name.data(),m_model_name.size(),"model_name");
	}
	if (full || has_model_number()) {
		ascii_string(o,indent,m_model_number.data(),m_model_number.size(),"model_number");
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (full || has_usb_diag()) {
		ascii_bool(o, indent, "usb_diag", m_usb_diag);
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (full || has_usb_con()) {
		ascii_bool(o, indent, "usb_con", m_usb_con);
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (full || has_cc1_gpio()) {
		ascii_numeric(o, indent, "cc1_gpio", (signed) m_cc1_gpio);
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (full || has_cc2_gpio()) {
		ascii_numeric(o, indent, "cc2_gpio", (signed) m_cc2_gpio);
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void SystemConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_manufacturer()) {
		pbt_string(o,indent,m_manufacturer.data(),m_manufacturer.size(),"manufacturer");
	}
	if (full || has_board_name()) {
		pbt_string(o,indent,m_board_name.data(),m_board_name.size(),"board_name");
	}
	if (full || has_board_rev()) {
		pbt_string(o,indent,m_board_rev.data(),m_board_rev.size(),"board_rev");
	}
	if (full || has_diag_uart()) {
		pbt_numeric(o, indent, "diag_uart", (signed) m_diag_uart);
	}
	if (full || has_console_rx()) {
		pbt_numeric(o, indent, "console_rx", (signed) m_console_rx);
	}
	if (full || has_console_tx()) {
		pbt_numeric(o, indent, "console_tx", (signed) m_console_tx);
	}
	if (full || has_model_name()) {
		pbt_string(o,indent,m_model_name.data(),m_model_name.size(),"model_name");
	}
	if (full || has_model_number()) {
		pbt_string(o,indent,m_model_number.data(),m_model_number.size(),"model_number");
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (full || has_usb_diag()) {
		pbt_bool(o, indent, "usb_diag", m_usb_diag);
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (full || has_usb_con()) {
		pbt_bool(o, indent, "usb_con", m_usb_con);
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (full || has_cc1_gpio()) {
		pbt_numeric(o, indent, "cc1_gpio", (signed) m_cc1_gpio);
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (full || has_cc2_gpio()) {
		pbt_numeric(o, indent, "cc2_gpio", (signed) m_cc2_gpio);
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t SystemConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -1;
		a += fn;
		switch (fid) {
		case 0xa:	// manufacturer id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -2;
				m_manufacturer.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x12:	// board_name id 2, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -3;
				m_board_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x1a:	// board_rev id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -4;
				m_board_rev.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x20:	// diag_uart id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -5;
				a += n;
				set_diag_uart(varint_sint(v));
			}
			break;
		case 0x28:	// console_rx id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -6;
				a += n;
				set_console_rx(varint_sint(v));
			}
			break;
		case 0x30:	// console_tx id 6, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -7;
				a += n;
				set_console_tx(varint_sint(v));
			}
			break;
		case 0x3a:	// model_name id 7, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -8;
				m_model_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x42:	// model_number id 8, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -9;
				m_model_number.assign((const char*)a,v);
				a += v;
			}
			break;
			#ifdef CONFIG_USB_DIAGLOG
		case 0x4b:	// usb_diag id 9, type bool, coding 8bit
			if (a >= e)
				return -10;
			set_usb_diag(*a++);
			break;
			#endif // CONFIG_USB_DIAGLOG
			#ifdef CONFIG_USB_CONSOLE
		case 0x53:	// usb_con id 10, type bool, coding 8bit
			if (a >= e)
				return -11;
			set_usb_con(*a++);
			break;
			#endif // CONFIG_USB_CONSOLE
			#ifdef CONFIG_ESP_PHY_ENABLE_USB
		case 0x58:	// cc1_gpio id 11, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -12;
				a += n;
				set_cc1_gpio(varint_sint(v));
			}
			break;
			#endif // CONFIG_ESP_PHY_ENABLE_USB
			#ifdef CONFIG_ESP_PHY_ENABLE_USB
		case 0x60:	// cc2_gpio id 12, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -13;
				a += n;
				set_cc2_gpio(varint_sint(v));
			}
			break;
			#endif // CONFIG_ESP_PHY_ENABLE_USB
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -14;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -15;
	return a-(const uint8_t *)b;
}

ssize_t SystemConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has manufacturer?
	if (!m_manufacturer.empty()) {
		// 'manufacturer': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -16;
		*a++ = 0xa;
		ssize_t manufacturer_s = m_manufacturer.size();
		n = write_varint(a,e-a,manufacturer_s);
		a += n;
		if ((n <= 0) || ((e-a) < manufacturer_s))
			return -17;
		memcpy(a,m_manufacturer.data(),manufacturer_s);
		a += manufacturer_s;
	}
	// has board_name?
	if (!m_board_name.empty()) {
		// 'board_name': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -18;
		*a++ = 0x12;
		ssize_t board_name_s = m_board_name.size();
		n = write_varint(a,e-a,board_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < board_name_s))
			return -19;
		memcpy(a,m_board_name.data(),board_name_s);
		a += board_name_s;
	}
	// has board_rev?
	if (!m_board_rev.empty()) {
		// 'board_rev': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -20;
		*a++ = 0x1a;
		ssize_t board_rev_s = m_board_rev.size();
		n = write_varint(a,e-a,board_rev_s);
		a += n;
		if ((n <= 0) || ((e-a) < board_rev_s))
			return -21;
		memcpy(a,m_board_rev.data(),board_rev_s);
		a += board_rev_s;
	}
	// has diag_uart?
	if (m_diag_uart != 0) {
		// 'diag_uart': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -22;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_diag_uart));
		if (n <= 0)
			return -23;
		a += n;
	}
	// has console_rx?
	if (0 != (p_validbits & ((uint8_t)1U << vb_console_rx))) {
		// 'console_rx': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -24;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_console_rx));
		if (n <= 0)
			return -25;
		a += n;
	}
	// has console_tx?
	if (0 != (p_validbits & ((uint8_t)1U << vb_console_tx))) {
		// 'console_tx': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -26;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_console_tx));
		if (n <= 0)
			return -27;
		a += n;
	}
	// has model_name?
	if (!m_model_name.empty()) {
		// 'model_name': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -28;
		*a++ = 0x3a;
		ssize_t model_name_s = m_model_name.size();
		n = write_varint(a,e-a,model_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < model_name_s))
			return -29;
		memcpy(a,m_model_name.data(),model_name_s);
		a += model_name_s;
	}
	// has model_number?
	if (!m_model_number.empty()) {
		// 'model_number': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -30;
		*a++ = 0x42;
		ssize_t model_number_s = m_model_number.size();
		n = write_varint(a,e-a,model_number_s);
		a += n;
		if ((n <= 0) || ((e-a) < model_number_s))
			return -31;
		memcpy(a,m_model_number.data(),model_number_s);
		a += model_number_s;
	}
	#ifdef CONFIG_USB_DIAGLOG
	// has usb_diag?
	if (m_usb_diag != true) {
		// 'usb_diag': id=9, encoding=8bit, tag=0x4b
		if (2 > (e-a))
			return -32;
		*a++ = 0x4b;
		*a++ = m_usb_diag;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	// has usb_con?
	if (m_usb_con != true) {
		// 'usb_con': id=10, encoding=8bit, tag=0x53
		if (2 > (e-a))
			return -33;
		*a++ = 0x53;
		*a++ = m_usb_con;
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// has cc1_gpio?
	if (m_cc1_gpio != -1) {
		// 'cc1_gpio': id=11, encoding=varint, tag=0x58
		if (a >= e)
			return -34;
		*a++ = 0x58;
		n = write_varint(a,e-a,sint_varint(m_cc1_gpio));
		if (n <= 0)
			return -35;
		a += n;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// has cc2_gpio?
	if (m_cc2_gpio != -1) {
		// 'cc2_gpio': id=12, encoding=varint, tag=0x60
		if (a >= e)
			return -36;
		*a++ = 0x60;
		n = write_varint(a,e-a,sint_varint(m_cc2_gpio));
		if (n <= 0)
			return -37;
		a += n;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	assert(a <= e);
	return a-b;
}

void SystemConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_manufacturer()) {
		fsep = json_indent(json,indLvl,fsep,"manufacturer");
		json_cstr(json,m_manufacturer.c_str());
	}
	if (full || has_board_name()) {
		fsep = json_indent(json,indLvl,fsep,"board_name");
		json_cstr(json,m_board_name.c_str());
	}
	if (full || has_board_rev()) {
		fsep = json_indent(json,indLvl,fsep,"board_rev");
		json_cstr(json,m_board_rev.c_str());
	}
	if (full || has_diag_uart()) {
		fsep = json_indent(json,indLvl,fsep,"diag_uart");
		json << (int) m_diag_uart;
	}
	if (full || has_console_rx()) {
		fsep = json_indent(json,indLvl,fsep,"console_rx");
		json << (int) m_console_rx;
	}
	if (full || has_console_tx()) {
		fsep = json_indent(json,indLvl,fsep,"console_tx");
		json << (int) m_console_tx;
	}
	if (full || has_model_name()) {
		fsep = json_indent(json,indLvl,fsep,"model_name");
		json_cstr(json,m_model_name.c_str());
	}
	if (full || has_model_number()) {
		fsep = json_indent(json,indLvl,fsep,"model_number");
		json_cstr(json,m_model_number.c_str());
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (full || has_usb_diag()) {
		fsep = json_indent(json,indLvl,fsep,"usb_diag");
		json << (m_usb_diag ? "true" : "false");
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (full || has_usb_con()) {
		fsep = json_indent(json,indLvl,fsep,"usb_con");
		json << (m_usb_con ? "true" : "false");
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (full || has_cc1_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"cc1_gpio");
		json << (int) m_cc1_gpio;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (full || has_cc2_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"cc2_gpio");
		json << (int) m_cc2_gpio;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SystemConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string manufacturer, id 1
	if (!m_manufacturer.empty()) {
		size_t manufacturer_s = m_manufacturer.size();
		r += manufacturer_s + wiresize(manufacturer_s) + 1 /* tag(manufacturer) 0x8 */;
	}
	// optional string board_name, id 2
	if (!m_board_name.empty()) {
		size_t board_name_s = m_board_name.size();
		r += board_name_s + wiresize(board_name_s) + 1 /* tag(board_name) 0x10 */;
	}
	// optional string board_rev, id 3
	if (!m_board_rev.empty()) {
		size_t board_rev_s = m_board_rev.size();
		r += board_rev_s + wiresize(board_rev_s) + 1 /* tag(board_rev) 0x18 */;
	}
	// optional sint8 diag_uart, id 4
	if (m_diag_uart != 0) {
		r += wiresize_s((varint_t)m_diag_uart) + 1 /* tag(diag_uart) 0x20 */;
	}
	// optional sint8 console_rx, id 5
	if (0 != (p_validbits & ((uint8_t)1U << vb_console_rx))) {
		r += wiresize_s((varint_t)m_console_rx) + 1 /* tag(console_rx) 0x28 */;
	}
	// optional sint8 console_tx, id 6
	if (0 != (p_validbits & ((uint8_t)1U << vb_console_tx))) {
		r += wiresize_s((varint_t)m_console_tx) + 1 /* tag(console_tx) 0x30 */;
	}
	// optional string model_name, id 7
	if (!m_model_name.empty()) {
		size_t model_name_s = m_model_name.size();
		r += model_name_s + wiresize(model_name_s) + 1 /* tag(model_name) 0x38 */;
	}
	// optional string model_number, id 8
	if (!m_model_number.empty()) {
		size_t model_number_s = m_model_number.size();
		r += model_number_s + wiresize(model_number_s) + 1 /* tag(model_number) 0x40 */;
	}
	#ifdef CONFIG_USB_DIAGLOG
	// optional bool usb_diag, id 9
	if (m_usb_diag != true) {
		r += 2;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	// optional bool usb_con, id 10
	if (m_usb_con != true) {
		r += 2;
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// optional sint8 cc1_gpio, id 11
	if (m_cc1_gpio != -1) {
		r += wiresize_s((varint_t)m_cc1_gpio) + 1 /* tag(cc1_gpio) 0x58 */;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// optional sint8 cc2_gpio, id 12
	if (m_cc2_gpio != -1) {
		r += wiresize_s((varint_t)m_cc2_gpio) + 1 /* tag(cc2_gpio) 0x60 */;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	return r;
}

bool SystemConfig::operator != (const SystemConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_manufacturer() && (m_manufacturer != r.m_manufacturer))
		return true;
	if (has_board_name() && (m_board_name != r.m_board_name))
		return true;
	if (has_board_rev() && (m_board_rev != r.m_board_rev))
		return true;
	if (has_diag_uart() && (m_diag_uart != r.m_diag_uart))
		return true;
	if (has_console_rx() && (m_console_rx != r.m_console_rx))
		return true;
	if (has_console_tx() && (m_console_tx != r.m_console_tx))
		return true;
	if (has_model_name() && (m_model_name != r.m_model_name))
		return true;
	if (has_model_number() && (m_model_number != r.m_model_number))
		return true;
	#ifdef CONFIG_USB_DIAGLOG
	if (has_usb_diag() && (m_usb_diag != r.m_usb_diag))
		return true;
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (has_usb_con() && (m_usb_con != r.m_usb_con))
		return true;
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (has_cc1_gpio() && (m_cc1_gpio != r.m_cc1_gpio))
		return true;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (has_cc2_gpio() && (m_cc2_gpio != r.m_cc2_gpio))
		return true;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	return false;
}


bool SystemConfig::operator == (const SystemConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SystemConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"manufacturer")) {
		if (value == 0) {
			m_manufacturer.clear();
			return 0;
		}
		m_manufacturer = value;
		int r = m_manufacturer.size();
		return r;
	}
	if (0 == strcmp(name,"board_name")) {
		if (value == 0) {
			m_board_name.clear();
			return 0;
		}
		m_board_name = value;
		int r = m_board_name.size();
		return r;
	}
	if (0 == strcmp(name,"board_rev")) {
		if (value == 0) {
			m_board_rev.clear();
			return 0;
		}
		m_board_rev = value;
		int r = m_board_rev.size();
		return r;
	}
	if (0 == strcmp(name,"diag_uart")) {
		if (value == 0) {
			clear_diag_uart();
			return 0;
		}
		int r = parse_ascii_s8(&m_diag_uart,value);
		return r;
	}
	if (0 == strcmp(name,"console_rx")) {
		if (value == 0) {
			clear_console_rx();
			return 0;
		}
		int r = parse_ascii_s8(&m_console_rx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"console_tx")) {
		if (value == 0) {
			clear_console_tx();
			return 0;
		}
		int r = parse_ascii_s8(&m_console_tx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"model_name")) {
		if (value == 0) {
			m_model_name.clear();
			return 0;
		}
		m_model_name = value;
		int r = m_model_name.size();
		return r;
	}
	if (0 == strcmp(name,"model_number")) {
		if (value == 0) {
			m_model_number.clear();
			return 0;
		}
		m_model_number = value;
		int r = m_model_number.size();
		return r;
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (0 == strcmp(name,"usb_diag")) {
		if (value == 0) {
			clear_usb_diag();
			return 0;
		}
		int r = parse_ascii_bool(&m_usb_diag,value);
		return r;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (0 == strcmp(name,"usb_con")) {
		if (value == 0) {
			clear_usb_con();
			return 0;
		}
		int r = parse_ascii_bool(&m_usb_con,value);
		return r;
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (0 == strcmp(name,"cc1_gpio")) {
		if (value == 0) {
			clear_cc1_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_cc1_gpio,value);
		return r;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (0 == strcmp(name,"cc2_gpio")) {
		if (value == 0) {
			clear_cc2_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_cc2_gpio,value);
		return r;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	return -38;
}

Message *SystemConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *SystemConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void TouchpadConfig::clear()
{
	m_fsm_mode = false;
	m_lvolt = -1;
	m_hvolt = -1;
	m_atten = -1;
	m_interval = 0;
	p_validbits = 0;
}

void TouchpadConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // TouchpadConfig";
	++indent;
	if (full || has_fsm_mode()) {
		ascii_bool(o, indent, "fsm_mode", m_fsm_mode);
	}
	if (full || has_lvolt()) {
		ascii_numeric(o, indent, "lvolt", (signed) m_lvolt);
	}
	if (full || has_hvolt()) {
		ascii_numeric(o, indent, "hvolt", (signed) m_hvolt);
	}
	if (full || has_atten()) {
		ascii_numeric(o, indent, "atten", (signed) m_atten);
	}
	if (full || has_interval()) {
		ascii_numeric(o, indent, "interval", m_interval);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void TouchpadConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_fsm_mode()) {
		pbt_bool(o, indent, "fsm_mode", m_fsm_mode);
	}
	if (full || has_lvolt()) {
		pbt_numeric(o, indent, "lvolt", (signed) m_lvolt);
	}
	if (full || has_hvolt()) {
		pbt_numeric(o, indent, "hvolt", (signed) m_hvolt);
	}
	if (full || has_atten()) {
		pbt_numeric(o, indent, "atten", (signed) m_atten);
	}
	if (full || has_interval()) {
		pbt_numeric(o, indent, "interval", m_interval);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t TouchpadConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -39;
		a += fn;
		switch (fid) {
		case 0xb:	// fsm_mode id 1, type bool, coding 8bit
			if (a >= e)
				return -40;
			set_fsm_mode(*a++);
			break;
		case 0x10:	// lvolt id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -41;
				a += n;
				set_lvolt(varint_sint(v));
			}
			break;
		case 0x18:	// hvolt id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -42;
				a += n;
				set_hvolt(varint_sint(v));
			}
			break;
		case 0x20:	// atten id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -43;
				a += n;
				set_atten(varint_sint(v));
			}
			break;
		case 0x38:	// interval id 7, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -44;
				a += n;
				set_interval(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -45;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -46;
	return a-(const uint8_t *)b;
}

ssize_t TouchpadConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has fsm_mode?
	if (m_fsm_mode != false) {
		// 'fsm_mode': id=1, encoding=8bit, tag=0xb
		if (2 > (e-a))
			return -47;
		*a++ = 0xb;
		*a++ = m_fsm_mode;
	}
	// has lvolt?
	if (m_lvolt != -1) {
		// 'lvolt': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -48;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_lvolt));
		if (n <= 0)
			return -49;
		a += n;
	}
	// has hvolt?
	if (m_hvolt != -1) {
		// 'hvolt': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -50;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_hvolt));
		if (n <= 0)
			return -51;
		a += n;
	}
	// has atten?
	if (m_atten != -1) {
		// 'atten': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -52;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_atten));
		if (n <= 0)
			return -53;
		a += n;
	}
	// has interval?
	if (0 != (p_validbits & ((uint8_t)1U << vb_interval))) {
		// 'interval': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -54;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_interval);
		if (n <= 0)
			return -55;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void TouchpadConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_fsm_mode()) {
		fsep = json_indent(json,indLvl,fsep,"fsm_mode");
		json << (m_fsm_mode ? "true" : "false");
	}
	if (full || has_lvolt()) {
		fsep = json_indent(json,indLvl,fsep,"lvolt");
		json << (int) m_lvolt;
	}
	if (full || has_hvolt()) {
		fsep = json_indent(json,indLvl,fsep,"hvolt");
		json << (int) m_hvolt;
	}
	if (full || has_atten()) {
		fsep = json_indent(json,indLvl,fsep,"atten");
		json << (int) m_atten;
	}
	if (full || has_interval()) {
		fsep = json_indent(json,indLvl,fsep,"interval");
		json << m_interval;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TouchpadConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional bool fsm_mode, id 1
	if (m_fsm_mode != false) {
		r += 2;
	}
	// optional sint8 lvolt, id 2
	if (m_lvolt != -1) {
		r += wiresize_s((varint_t)m_lvolt) + 1 /* tag(lvolt) 0x10 */;
	}
	// optional sint8 hvolt, id 3
	if (m_hvolt != -1) {
		r += wiresize_s((varint_t)m_hvolt) + 1 /* tag(hvolt) 0x18 */;
	}
	// optional sint8 atten, id 4
	if (m_atten != -1) {
		r += wiresize_s((varint_t)m_atten) + 1 /* tag(atten) 0x20 */;
	}
	// optional unsigned interval, id 7
	if (0 != (p_validbits & ((uint8_t)1U << vb_interval))) {
		r += wiresize((varint_t)m_interval) + 1 /* tag(interval) 0x38 */;
	}
	return r;
}

bool TouchpadConfig::operator != (const TouchpadConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_fsm_mode() && (m_fsm_mode != r.m_fsm_mode))
		return true;
	if (has_lvolt() && (m_lvolt != r.m_lvolt))
		return true;
	if (has_hvolt() && (m_hvolt != r.m_hvolt))
		return true;
	if (has_atten() && (m_atten != r.m_atten))
		return true;
	if (has_interval() && (m_interval != r.m_interval))
		return true;
	return false;
}


bool TouchpadConfig::operator == (const TouchpadConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TouchpadConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"fsm_mode")) {
		if (value == 0) {
			clear_fsm_mode();
			return 0;
		}
		int r = parse_ascii_bool(&m_fsm_mode,value);
		return r;
	}
	if (0 == strcmp(name,"lvolt")) {
		if (value == 0) {
			clear_lvolt();
			return 0;
		}
		int r = parse_ascii_s8(&m_lvolt,value);
		return r;
	}
	if (0 == strcmp(name,"hvolt")) {
		if (value == 0) {
			clear_hvolt();
			return 0;
		}
		int r = parse_ascii_s8(&m_hvolt,value);
		return r;
	}
	if (0 == strcmp(name,"atten")) {
		if (value == 0) {
			clear_atten();
			return 0;
		}
		int r = parse_ascii_s8(&m_atten,value);
		return r;
	}
	if (0 == strcmp(name,"interval")) {
		if (value == 0) {
			clear_interval();
			return 0;
		}
		int r = parse_ascii_u32(&m_interval,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	return -56;
}

Message *TouchpadConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *TouchpadConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void TouchChannelConfig::clear()
{
	m_name.clear();
	m_channel = -1;
	m_threshold = 0;
	m_slope = 0;
	m_tieopt = 0;
	p_validbits = 0;
}

void TouchChannelConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // TouchChannelConfig";
	++indent;
	if (full || has_name()) {
		ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_channel()) {
		ascii_numeric(o, indent, "channel", (signed) m_channel);
	}
	if (full || has_threshold()) {
		ascii_numeric(o, indent, "threshold", m_threshold);
	}
	if (full || has_slope()) {
		ascii_numeric(o, indent, "slope", (unsigned) m_slope);
	}
	if (full || has_tieopt()) {
		ascii_numeric(o, indent, "tieopt", (unsigned) m_tieopt);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void TouchChannelConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_name()) {
		pbt_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_channel()) {
		pbt_numeric(o, indent, "channel", (signed) m_channel);
	}
	if (full || has_threshold()) {
		pbt_numeric(o, indent, "threshold", m_threshold);
	}
	if (full || has_slope()) {
		pbt_numeric(o, indent, "slope", (unsigned) m_slope);
	}
	if (full || has_tieopt()) {
		pbt_numeric(o, indent, "tieopt", (unsigned) m_tieopt);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t TouchChannelConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -57;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -58;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// channel id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -59;
				a += n;
				set_channel(varint_sint(v));
			}
			break;
		case 0x1c:	// threshold id 3, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -60;
			set_threshold((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x20:	// slope id 4, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -61;
				a += n;
				set_slope(v);
			}
			break;
		case 0x28:	// tieopt id 5, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -62;
				a += n;
				set_tieopt(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -63;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -64;
	return a-(const uint8_t *)b;
}

ssize_t TouchChannelConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -65;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -66;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has channel?
	if (m_channel != -1) {
		// 'channel': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -67;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_channel));
		if (n <= 0)
			return -68;
		a += n;
	}
	// has threshold?
	if (0 != (p_validbits & ((uint8_t)1U << vb_threshold))) {
		// 'threshold': id=3, encoding=16bit, tag=0x1c
		if (3 > (e-a))
			return -69;
		*a++ = 0x1c;
		write_u16(a,m_threshold);
		a += 2;
	}
	// has slope?
	if (0 != (p_validbits & ((uint8_t)1U << vb_slope))) {
		// 'slope': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -70;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_slope);
		if (n <= 0)
			return -71;
		a += n;
	}
	// has tieopt?
	if (0 != (p_validbits & ((uint8_t)1U << vb_tieopt))) {
		// 'tieopt': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -72;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_tieopt);
		if (n <= 0)
			return -73;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void TouchChannelConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (full || has_channel()) {
		fsep = json_indent(json,indLvl,fsep,"channel");
		json << (int) m_channel;
	}
	if (full || has_threshold()) {
		fsep = json_indent(json,indLvl,fsep,"threshold");
		json << m_threshold;
	}
	if (full || has_slope()) {
		fsep = json_indent(json,indLvl,fsep,"slope");
		json << (unsigned) m_slope;
	}
	if (full || has_tieopt()) {
		fsep = json_indent(json,indLvl,fsep,"tieopt");
		json << (unsigned) m_tieopt;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TouchChannelConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 channel, id 2
	if (m_channel != -1) {
		r += wiresize_s((varint_t)m_channel) + 1 /* tag(channel) 0x10 */;
	}
	// optional fixed16 threshold, id 3
	if (0 != (p_validbits & ((uint8_t)1U << vb_threshold))) {
		r += 3;
	}
	// optional uint8 slope, id 4
	if (0 != (p_validbits & ((uint8_t)1U << vb_slope))) {
		r += wiresize((varint_t)m_slope) + 1 /* tag(slope) 0x20 */;
	}
	// optional uint8 tieopt, id 5
	if (0 != (p_validbits & ((uint8_t)1U << vb_tieopt))) {
		r += wiresize((varint_t)m_tieopt) + 1 /* tag(tieopt) 0x28 */;
	}
	return r;
}

bool TouchChannelConfig::operator != (const TouchChannelConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_channel() && (m_channel != r.m_channel))
		return true;
	if (has_threshold() && (m_threshold != r.m_threshold))
		return true;
	if (has_slope() && (m_slope != r.m_slope))
		return true;
	if (has_tieopt() && (m_tieopt != r.m_tieopt))
		return true;
	return false;
}


bool TouchChannelConfig::operator == (const TouchChannelConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TouchChannelConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"channel")) {
		if (value == 0) {
			clear_channel();
			return 0;
		}
		int r = parse_ascii_s8(&m_channel,value);
		return r;
	}
	if (0 == strcmp(name,"threshold")) {
		if (value == 0) {
			clear_threshold();
			return 0;
		}
		int r = parse_ascii_u16(&m_threshold,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"slope")) {
		if (value == 0) {
			clear_slope();
			return 0;
		}
		int r = parse_ascii_u8(&m_slope,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"tieopt")) {
		if (value == 0) {
			clear_tieopt();
			return 0;
		}
		int r = parse_ascii_u8(&m_tieopt,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	return -74;
}

Message *TouchChannelConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *TouchChannelConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void ButtonConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_presslvl = 0;
	m_pull_mode = pull_none;
	#ifdef CONFIG_ROTARYENCODER
	m_clk = -1;
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	m_dt = -1;
	#endif // CONFIG_ROTARYENCODER
}

void ButtonConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // ButtonConfig";
	++indent;
	if (full || has_name()) {
		ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_gpio()) {
		ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || has_presslvl()) {
		ascii_bool(o, indent, "presslvl", m_presslvl);
	}
	if (full || has_pull_mode()) {
		ascii_indent(o,indent,"pull_mode");
		o << "{ // (pull_mode_t) " << (unsigned)m_pull_mode;
		++indent;
		gen_indent(o,indent);
		o << ".enable";
		o << (pull_mode_enable() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".up";
		o << (pull_mode_up() ? " = true;" : " = false;");
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#ifdef CONFIG_ROTARYENCODER
	if (full || has_clk()) {
		ascii_numeric(o, indent, "clk", (signed) m_clk);
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (full || has_dt()) {
		ascii_numeric(o, indent, "dt", (signed) m_dt);
	}
	#endif // CONFIG_ROTARYENCODER
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void ButtonConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_name()) {
		pbt_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_gpio()) {
		pbt_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || has_presslvl()) {
		pbt_bool(o, indent, "presslvl", m_presslvl);
	}
	if (full || has_pull_mode()) {
		pbt_numeric(o, indent, "pull_mode", (unsigned) m_pull_mode);
	}
	#ifdef CONFIG_ROTARYENCODER
	if (full || has_clk()) {
		pbt_numeric(o, indent, "clk", (signed) m_clk);
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (full || has_dt()) {
		pbt_numeric(o, indent, "dt", (signed) m_dt);
	}
	#endif // CONFIG_ROTARYENCODER
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t ButtonConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -75;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -76;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -77;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x1b:	// presslvl id 3, type bool, coding 8bit
			if (a >= e)
				return -78;
			set_presslvl(*a++);
			break;
		case 0x20:	// pull_mode id 4, type pull_mode_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -79;
				a += n;
				set_pull_mode((pull_mode_t) v);
			}
			break;
			#ifdef CONFIG_ROTARYENCODER
		case 0x28:	// clk id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -80;
				a += n;
				set_clk(varint_sint(v));
			}
			break;
			#endif // CONFIG_ROTARYENCODER
			#ifdef CONFIG_ROTARYENCODER
		case 0x30:	// dt id 6, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -81;
				a += n;
				set_dt(varint_sint(v));
			}
			break;
			#endif // CONFIG_ROTARYENCODER
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -82;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -83;
	return a-(const uint8_t *)b;
}

ssize_t ButtonConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -84;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -85;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -86;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -87;
		a += n;
	}
	// has presslvl?
	if (m_presslvl != 0) {
		// 'presslvl': id=3, encoding=8bit, tag=0x1b
		if (2 > (e-a))
			return -88;
		*a++ = 0x1b;
		*a++ = m_presslvl;
	}
	// has pull_mode?
	if (m_pull_mode != pull_none) {
		// 'pull_mode': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -89;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_pull_mode);
		if (n <= 0)
			return -90;
		a += n;
	}
	#ifdef CONFIG_ROTARYENCODER
	// has clk?
	if (m_clk != -1) {
		// 'clk': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -91;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_clk));
		if (n <= 0)
			return -92;
		a += n;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	// has dt?
	if (m_dt != -1) {
		// 'dt': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -93;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_dt));
		if (n <= 0)
			return -94;
		a += n;
	}
	#endif // CONFIG_ROTARYENCODER
	assert(a <= e);
	return a-b;
}

void ButtonConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (full || has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (full || has_presslvl()) {
		fsep = json_indent(json,indLvl,fsep,"presslvl");
		json << (m_presslvl ? "true" : "false");
	}
	if (full || has_pull_mode()) {
		fsep = json_indent(json,indLvl,fsep,"pull_mode");
		json << (unsigned) m_pull_mode;
	}
	#ifdef CONFIG_ROTARYENCODER
	if (full || has_clk()) {
		fsep = json_indent(json,indLvl,fsep,"clk");
		json << (int) m_clk;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (full || has_dt()) {
		fsep = json_indent(json,indLvl,fsep,"dt");
		json << (int) m_dt;
	}
	#endif // CONFIG_ROTARYENCODER
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t ButtonConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional bool presslvl, id 3
	if (m_presslvl != 0) {
		r += 2;
	}
	// optional pull_mode_t pull_mode, id 4
	if (m_pull_mode != pull_none) {
		r += wiresize((varint_t)m_pull_mode) + 1 /* tag(pull_mode) 0x20 */;
	}
	#ifdef CONFIG_ROTARYENCODER
	// optional sint8 clk, id 5
	if (m_clk != -1) {
		r += wiresize_s((varint_t)m_clk) + 1 /* tag(clk) 0x28 */;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	// optional sint8 dt, id 6
	if (m_dt != -1) {
		r += wiresize_s((varint_t)m_dt) + 1 /* tag(dt) 0x30 */;
	}
	#endif // CONFIG_ROTARYENCODER
	return r;
}

bool ButtonConfig::operator != (const ButtonConfig &r) const
{
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_presslvl() && (m_presslvl != r.m_presslvl))
		return true;
	if (has_pull_mode() && (m_pull_mode != r.m_pull_mode))
		return true;
	#ifdef CONFIG_ROTARYENCODER
	if (has_clk() && (m_clk != r.m_clk))
		return true;
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (has_dt() && (m_dt != r.m_dt))
		return true;
	#endif // CONFIG_ROTARYENCODER
	return false;
}


bool ButtonConfig::operator == (const ButtonConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int ButtonConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"presslvl")) {
		if (value == 0) {
			clear_presslvl();
			return 0;
		}
		int r = parse_ascii_bool(&m_presslvl,value);
		return r;
	}
	if ((0 == memcmp(name,"pull_mode",9)) && ((name[9] == 0) || name[9] == '.')) {
		name += 9;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_pull_mode((pull_mode_t)ull);
			else if (!strcmp(name,"enable"))
				set_pull_mode_enable((bool)ull);
			else if (!strcmp(name,"up"))
				set_pull_mode_up((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -95;
		} else if (!strcmp(name,"enable")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_pull_mode_enable(tmp);
			return r;
		} else if (!strcmp(name,"up")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_pull_mode_up(tmp);
			return r;
		}
	}
	#ifdef CONFIG_ROTARYENCODER
	if (0 == strcmp(name,"clk")) {
		if (value == 0) {
			clear_clk();
			return 0;
		}
		int r = parse_ascii_s8(&m_clk,value);
		return r;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (0 == strcmp(name,"dt")) {
		if (value == 0) {
			clear_dt();
			return 0;
		}
		int r = parse_ascii_s8(&m_dt,value);
		return r;
	}
	#endif // CONFIG_ROTARYENCODER
	return -96;
}

Message *ButtonConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *ButtonConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void RelayConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_config = 0;
	m_min_itv = 0;
	m_interlock = -1;
	p_validbits = 0;
}

void RelayConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // RelayConfig";
	++indent;
	if (full || has_name()) {
		ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_gpio()) {
		ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || has_config()) {
		ascii_indent(o,indent,"config");
		o << "{ // (relay_cfg_t) " << (unsigned)m_config;
		++indent;
		gen_indent(o,indent);
		o << ".active_high";
		o << (config_active_high() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".init_on";
		o << (config_init_on() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".persistent";
		o << (config_persistent() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".opendrain";
		o << (config_opendrain() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".mqtt";
		o << (config_mqtt() ? " = true;" : " = false;");
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	if (full || has_min_itv()) {
		ascii_numeric(o, indent, "min_itv", m_min_itv);
	}
	if (full || has_interlock()) {
		ascii_numeric(o, indent, "interlock", (signed) m_interlock);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void RelayConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_name()) {
		pbt_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_gpio()) {
		pbt_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || has_config()) {
		pbt_numeric(o, indent, "config", (unsigned) m_config);
	}
	if (full || has_min_itv()) {
		pbt_numeric(o, indent, "min_itv", m_min_itv);
	}
	if (full || has_interlock()) {
		pbt_numeric(o, indent, "interlock", (signed) m_interlock);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t RelayConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -97;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -98;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -99;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x18:	// config id 3, type relay_cfg_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -100;
				a += n;
				set_config((relay_cfg_t) v);
			}
			break;
		case 0x20:	// min_itv id 4, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -101;
				a += n;
				set_min_itv(v);
			}
			break;
		case 0x28:	// interlock id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -102;
				a += n;
				set_interlock(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -103;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -104;
	return a-(const uint8_t *)b;
}

ssize_t RelayConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -105;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -106;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -107;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -108;
		a += n;
	}
	// has config?
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -109;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -110;
		a += n;
	}
	// has min_itv?
	if (0 != (p_validbits & ((uint8_t)1U << vb_min_itv))) {
		// 'min_itv': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -111;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_min_itv);
		if (n <= 0)
			return -112;
		a += n;
	}
	// has interlock?
	if (m_interlock != -1) {
		// 'interlock': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -113;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_interlock));
		if (n <= 0)
			return -114;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void RelayConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (full || has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (full || has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (full || has_min_itv()) {
		fsep = json_indent(json,indLvl,fsep,"min_itv");
		json << m_min_itv;
	}
	if (full || has_interlock()) {
		fsep = json_indent(json,indLvl,fsep,"interlock");
		json << (int) m_interlock;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t RelayConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional relay_cfg_t config, id 3
	if (m_config != 0) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	// optional unsigned min_itv, id 4
	if (0 != (p_validbits & ((uint8_t)1U << vb_min_itv))) {
		r += wiresize((varint_t)m_min_itv) + 1 /* tag(min_itv) 0x20 */;
	}
	// optional sint8 interlock, id 5
	if (m_interlock != -1) {
		r += wiresize_s((varint_t)m_interlock) + 1 /* tag(interlock) 0x28 */;
	}
	return r;
}

bool RelayConfig::operator != (const RelayConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	if (has_min_itv() && (m_min_itv != r.m_min_itv))
		return true;
	if (has_interlock() && (m_interlock != r.m_interlock))
		return true;
	return false;
}


bool RelayConfig::operator == (const RelayConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int RelayConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((relay_cfg_t)ull);
			else if (!strcmp(name,"active_high"))
				set_config_active_high((bool)ull);
			else if (!strcmp(name,"init_on"))
				set_config_init_on((bool)ull);
			else if (!strcmp(name,"persistent"))
				set_config_persistent((bool)ull);
			else if (!strcmp(name,"opendrain"))
				set_config_opendrain((bool)ull);
			else if (!strcmp(name,"mqtt"))
				set_config_mqtt((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -115;
		} else if (!strcmp(name,"active_high")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_active_high(tmp);
			return r;
		} else if (!strcmp(name,"init_on")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_init_on(tmp);
			return r;
		} else if (!strcmp(name,"persistent")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_persistent(tmp);
			return r;
		} else if (!strcmp(name,"opendrain")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_opendrain(tmp);
			return r;
		} else if (!strcmp(name,"mqtt")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_mqtt(tmp);
			return r;
		}
	}
	if (0 == strcmp(name,"min_itv")) {
		if (value == 0) {
			clear_min_itv();
			return 0;
		}
		int r = parse_ascii_u32(&m_min_itv,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"interlock")) {
		if (value == 0) {
			clear_interlock();
			return 0;
		}
		int r = parse_ascii_s8(&m_interlock,value);
		return r;
	}
	return -116;
}

Message *RelayConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *RelayConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void Max7219Config::clear()
{
	m_clk = -1;
	m_dout = -1;
	m_cs = -1;
	m_odrain = false;
	m_digits = 0;
}

void Max7219Config::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // Max7219Config";
	++indent;
	if (full || has_clk()) {
		ascii_numeric(o, indent, "clk", (signed) m_clk);
	}
	if (full || has_dout()) {
		ascii_numeric(o, indent, "dout", (signed) m_dout);
	}
	if (full || has_cs()) {
		ascii_numeric(o, indent, "cs", (signed) m_cs);
	}
	if (full || has_odrain()) {
		ascii_bool(o, indent, "odrain", m_odrain);
	}
	if (full || has_digits()) {
		ascii_numeric(o, indent, "digits", (unsigned) m_digits);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void Max7219Config::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_clk()) {
		pbt_numeric(o, indent, "clk", (signed) m_clk);
	}
	if (full || has_dout()) {
		pbt_numeric(o, indent, "dout", (signed) m_dout);
	}
	if (full || has_cs()) {
		pbt_numeric(o, indent, "cs", (signed) m_cs);
	}
	if (full || has_odrain()) {
		pbt_bool(o, indent, "odrain", m_odrain);
	}
	if (full || has_digits()) {
		pbt_numeric(o, indent, "digits", (unsigned) m_digits);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t Max7219Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -117;
		a += fn;
		switch (fid) {
		case 0x8:	// clk id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -118;
				a += n;
				set_clk(varint_sint(v));
			}
			break;
		case 0x10:	// dout id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -119;
				a += n;
				set_dout(varint_sint(v));
			}
			break;
		case 0x18:	// cs id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -120;
				a += n;
				set_cs(varint_sint(v));
			}
			break;
		case 0x23:	// odrain id 4, type bool, coding 8bit
			if (a >= e)
				return -121;
			set_odrain(*a++);
			break;
		case 0x28:	// digits id 5, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -122;
				a += n;
				set_digits(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -123;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -124;
	return a-(const uint8_t *)b;
}

ssize_t Max7219Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has clk?
	if (m_clk != -1) {
		// 'clk': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -125;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_clk));
		if (n <= 0)
			return -126;
		a += n;
	}
	// has dout?
	if (m_dout != -1) {
		// 'dout': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -127;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_dout));
		if (n <= 0)
			return -128;
		a += n;
	}
	// has cs?
	if (m_cs != -1) {
		// 'cs': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -129;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_cs));
		if (n <= 0)
			return -130;
		a += n;
	}
	// has odrain?
	if (m_odrain != false) {
		// 'odrain': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -131;
		*a++ = 0x23;
		*a++ = m_odrain;
	}
	// has digits?
	if (m_digits != 0) {
		// 'digits': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -132;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_digits);
		if (n <= 0)
			return -133;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Max7219Config::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_clk()) {
		fsep = json_indent(json,indLvl,fsep,"clk");
		json << (int) m_clk;
	}
	if (full || has_dout()) {
		fsep = json_indent(json,indLvl,fsep,"dout");
		json << (int) m_dout;
	}
	if (full || has_cs()) {
		fsep = json_indent(json,indLvl,fsep,"cs");
		json << (int) m_cs;
	}
	if (full || has_odrain()) {
		fsep = json_indent(json,indLvl,fsep,"odrain");
		json << (m_odrain ? "true" : "false");
	}
	if (full || has_digits()) {
		fsep = json_indent(json,indLvl,fsep,"digits");
		json << (unsigned) m_digits;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Max7219Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 clk, id 1
	if (m_clk != -1) {
		r += wiresize_s((varint_t)m_clk) + 1 /* tag(clk) 0x8 */;
	}
	// optional sint8 dout, id 2
	if (m_dout != -1) {
		r += wiresize_s((varint_t)m_dout) + 1 /* tag(dout) 0x10 */;
	}
	// optional sint8 cs, id 3
	if (m_cs != -1) {
		r += wiresize_s((varint_t)m_cs) + 1 /* tag(cs) 0x18 */;
	}
	// optional bool odrain, id 4
	if (m_odrain != false) {
		r += 2;
	}
	// optional uint8 digits, id 5
	if (m_digits != 0) {
		r += wiresize((varint_t)m_digits) + 1 /* tag(digits) 0x28 */;
	}
	return r;
}

bool Max7219Config::operator != (const Max7219Config &r) const
{
	if (has_clk() && (m_clk != r.m_clk))
		return true;
	if (has_dout() && (m_dout != r.m_dout))
		return true;
	if (has_cs() && (m_cs != r.m_cs))
		return true;
	if (has_odrain() && (m_odrain != r.m_odrain))
		return true;
	if (has_digits() && (m_digits != r.m_digits))
		return true;
	return false;
}


bool Max7219Config::operator == (const Max7219Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Max7219Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"clk")) {
		if (value == 0) {
			clear_clk();
			return 0;
		}
		int r = parse_ascii_s8(&m_clk,value);
		return r;
	}
	if (0 == strcmp(name,"dout")) {
		if (value == 0) {
			clear_dout();
			return 0;
		}
		int r = parse_ascii_s8(&m_dout,value);
		return r;
	}
	if (0 == strcmp(name,"cs")) {
		if (value == 0) {
			clear_cs();
			return 0;
		}
		int r = parse_ascii_s8(&m_cs,value);
		return r;
	}
	if (0 == strcmp(name,"odrain")) {
		if (value == 0) {
			clear_odrain();
			return 0;
		}
		int r = parse_ascii_bool(&m_odrain,value);
		return r;
	}
	if (0 == strcmp(name,"digits")) {
		if (value == 0) {
			clear_digits();
			return 0;
		}
		int r = parse_ascii_u8(&m_digits,value);
		return r;
	}
	return -134;
}

Message *Max7219Config::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *Max7219Config::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void Tlc5947Config::clear()
{
	m_sin = -1;
	m_sclk = -1;
	m_xlat = -1;
	m_blank = -1;
	m_ntlc = 0;
}

void Tlc5947Config::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // Tlc5947Config";
	++indent;
	if (full || has_sin()) {
		ascii_numeric(o, indent, "sin", (signed) m_sin);
	}
	if (full || has_sclk()) {
		ascii_numeric(o, indent, "sclk", (signed) m_sclk);
	}
	if (full || has_xlat()) {
		ascii_numeric(o, indent, "xlat", (signed) m_xlat);
	}
	if (full || has_blank()) {
		ascii_numeric(o, indent, "blank", (signed) m_blank);
	}
	if (full || has_ntlc()) {
		ascii_numeric(o, indent, "ntlc", (unsigned) m_ntlc);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void Tlc5947Config::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_sin()) {
		pbt_numeric(o, indent, "sin", (signed) m_sin);
	}
	if (full || has_sclk()) {
		pbt_numeric(o, indent, "sclk", (signed) m_sclk);
	}
	if (full || has_xlat()) {
		pbt_numeric(o, indent, "xlat", (signed) m_xlat);
	}
	if (full || has_blank()) {
		pbt_numeric(o, indent, "blank", (signed) m_blank);
	}
	if (full || has_ntlc()) {
		pbt_numeric(o, indent, "ntlc", (unsigned) m_ntlc);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t Tlc5947Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -135;
		a += fn;
		switch (fid) {
		case 0x8:	// sin id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -136;
				a += n;
				set_sin(varint_sint(v));
			}
			break;
		case 0x10:	// sclk id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -137;
				a += n;
				set_sclk(varint_sint(v));
			}
			break;
		case 0x18:	// xlat id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -138;
				a += n;
				set_xlat(varint_sint(v));
			}
			break;
		case 0x20:	// blank id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -139;
				a += n;
				set_blank(varint_sint(v));
			}
			break;
		case 0x28:	// ntlc id 5, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -140;
				a += n;
				set_ntlc(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -141;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -142;
	return a-(const uint8_t *)b;
}

ssize_t Tlc5947Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has sin?
	if (m_sin != -1) {
		// 'sin': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -143;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_sin));
		if (n <= 0)
			return -144;
		a += n;
	}
	// has sclk?
	if (m_sclk != -1) {
		// 'sclk': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -145;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sclk));
		if (n <= 0)
			return -146;
		a += n;
	}
	// has xlat?
	if (m_xlat != -1) {
		// 'xlat': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -147;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_xlat));
		if (n <= 0)
			return -148;
		a += n;
	}
	// has blank?
	if (m_blank != -1) {
		// 'blank': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -149;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_blank));
		if (n <= 0)
			return -150;
		a += n;
	}
	// has ntlc?
	if (m_ntlc != 0) {
		// 'ntlc': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -151;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_ntlc);
		if (n <= 0)
			return -152;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Tlc5947Config::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_sin()) {
		fsep = json_indent(json,indLvl,fsep,"sin");
		json << (int) m_sin;
	}
	if (full || has_sclk()) {
		fsep = json_indent(json,indLvl,fsep,"sclk");
		json << (int) m_sclk;
	}
	if (full || has_xlat()) {
		fsep = json_indent(json,indLvl,fsep,"xlat");
		json << (int) m_xlat;
	}
	if (full || has_blank()) {
		fsep = json_indent(json,indLvl,fsep,"blank");
		json << (int) m_blank;
	}
	if (full || has_ntlc()) {
		fsep = json_indent(json,indLvl,fsep,"ntlc");
		json << (unsigned) m_ntlc;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Tlc5947Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 sin, id 1
	if (m_sin != -1) {
		r += wiresize_s((varint_t)m_sin) + 1 /* tag(sin) 0x8 */;
	}
	// optional sint8 sclk, id 2
	if (m_sclk != -1) {
		r += wiresize_s((varint_t)m_sclk) + 1 /* tag(sclk) 0x10 */;
	}
	// optional sint8 xlat, id 3
	if (m_xlat != -1) {
		r += wiresize_s((varint_t)m_xlat) + 1 /* tag(xlat) 0x18 */;
	}
	// optional sint8 blank, id 4
	if (m_blank != -1) {
		r += wiresize_s((varint_t)m_blank) + 1 /* tag(blank) 0x20 */;
	}
	// optional uint8 ntlc, id 5
	if (m_ntlc != 0) {
		r += wiresize((varint_t)m_ntlc) + 1 /* tag(ntlc) 0x28 */;
	}
	return r;
}

bool Tlc5947Config::operator != (const Tlc5947Config &r) const
{
	if (has_sin() && (m_sin != r.m_sin))
		return true;
	if (has_sclk() && (m_sclk != r.m_sclk))
		return true;
	if (has_xlat() && (m_xlat != r.m_xlat))
		return true;
	if (has_blank() && (m_blank != r.m_blank))
		return true;
	if (has_ntlc() && (m_ntlc != r.m_ntlc))
		return true;
	return false;
}


bool Tlc5947Config::operator == (const Tlc5947Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Tlc5947Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"sin")) {
		if (value == 0) {
			clear_sin();
			return 0;
		}
		int r = parse_ascii_s8(&m_sin,value);
		return r;
	}
	if (0 == strcmp(name,"sclk")) {
		if (value == 0) {
			clear_sclk();
			return 0;
		}
		int r = parse_ascii_s8(&m_sclk,value);
		return r;
	}
	if (0 == strcmp(name,"xlat")) {
		if (value == 0) {
			clear_xlat();
			return 0;
		}
		int r = parse_ascii_s8(&m_xlat,value);
		return r;
	}
	if (0 == strcmp(name,"blank")) {
		if (value == 0) {
			clear_blank();
			return 0;
		}
		int r = parse_ascii_s8(&m_blank,value);
		return r;
	}
	if (0 == strcmp(name,"ntlc")) {
		if (value == 0) {
			clear_ntlc();
			return 0;
		}
		int r = parse_ascii_u8(&m_ntlc,value);
		return r;
	}
	return -153;
}

Message *Tlc5947Config::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *Tlc5947Config::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void Ws2812bConfig::clear()
{
	m_gpio = -1;
	#ifdef CONFIG_SOC_RMT_SUPPORTED
	m_ch = -1;
	#endif // CONFIG_SOC_RMT_SUPPORTED
	m_nleds = 0;
	m_name.clear();
}

void Ws2812bConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // Ws2812bConfig";
	++indent;
	if (full || has_gpio()) {
		ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	#ifdef CONFIG_SOC_RMT_SUPPORTED
	if (full || has_ch()) {
		ascii_numeric(o, indent, "ch", (signed) m_ch);
	}
	#endif // CONFIG_SOC_RMT_SUPPORTED
	if (full || has_nleds()) {
		ascii_numeric(o, indent, "nleds", (unsigned) m_nleds);
	}
	if (full || has_name()) {
		ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void Ws2812bConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_gpio()) {
		pbt_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	#ifdef CONFIG_SOC_RMT_SUPPORTED
	if (full || has_ch()) {
		pbt_numeric(o, indent, "ch", (signed) m_ch);
	}
	#endif // CONFIG_SOC_RMT_SUPPORTED
	if (full || has_nleds()) {
		pbt_numeric(o, indent, "nleds", (unsigned) m_nleds);
	}
	if (full || has_name()) {
		pbt_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t Ws2812bConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -154;
		a += fn;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -155;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
			#ifdef CONFIG_SOC_RMT_SUPPORTED
		case 0x10:	// ch id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -156;
				a += n;
				set_ch(varint_sint(v));
			}
			break;
			#endif // CONFIG_SOC_RMT_SUPPORTED
		case 0x18:	// nleds id 3, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -157;
				a += n;
				set_nleds(v);
			}
			break;
		case 0x22:	// name id 4, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -158;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -159;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -160;
	return a-(const uint8_t *)b;
}

ssize_t Ws2812bConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -161;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -162;
		a += n;
	}
	#ifdef CONFIG_SOC_RMT_SUPPORTED
	// has ch?
	if (m_ch != -1) {
		// 'ch': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -163;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_ch));
		if (n <= 0)
			return -164;
		a += n;
	}
	#endif // CONFIG_SOC_RMT_SUPPORTED
	// has nleds?
	if (m_nleds != 0) {
		// 'nleds': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -165;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_nleds);
		if (n <= 0)
			return -166;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -167;
		*a++ = 0x22;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -168;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	assert(a <= e);
	return a-b;
}

void Ws2812bConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	#ifdef CONFIG_SOC_RMT_SUPPORTED
	if (full || has_ch()) {
		fsep = json_indent(json,indLvl,fsep,"ch");
		json << (int) m_ch;
	}
	#endif // CONFIG_SOC_RMT_SUPPORTED
	if (full || has_nleds()) {
		fsep = json_indent(json,indLvl,fsep,"nleds");
		json << (unsigned) m_nleds;
	}
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Ws2812bConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	#ifdef CONFIG_SOC_RMT_SUPPORTED
	// optional sint8 ch, id 2
	if (m_ch != -1) {
		r += wiresize_s((varint_t)m_ch) + 1 /* tag(ch) 0x10 */;
	}
	#endif // CONFIG_SOC_RMT_SUPPORTED
	// optional uint8 nleds, id 3
	if (m_nleds != 0) {
		r += wiresize((varint_t)m_nleds) + 1 /* tag(nleds) 0x18 */;
	}
	// optional string name, id 4
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x20 */;
	}
	return r;
}

bool Ws2812bConfig::operator != (const Ws2812bConfig &r) const
{
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	#ifdef CONFIG_SOC_RMT_SUPPORTED
	if (has_ch() && (m_ch != r.m_ch))
		return true;
	#endif // CONFIG_SOC_RMT_SUPPORTED
	if (has_nleds() && (m_nleds != r.m_nleds))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	return false;
}


bool Ws2812bConfig::operator == (const Ws2812bConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Ws2812bConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	#ifdef CONFIG_SOC_RMT_SUPPORTED
	if (0 == strcmp(name,"ch")) {
		if (value == 0) {
			clear_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_ch,value);
		return r;
	}
	#endif // CONFIG_SOC_RMT_SUPPORTED
	if (0 == strcmp(name,"nleds")) {
		if (value == 0) {
			clear_nleds();
			return 0;
		}
		int r = parse_ascii_u8(&m_nleds,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	return -169;
}

Message *Ws2812bConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *Ws2812bConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void DhtConfig::clear()
{
	m_model = DHT_NONE;
	m_gpio = -1;
}

void DhtConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // DhtConfig";
	++indent;
	if (full || has_model()) {
		ascii_indent(o,indent,"model");
		if (const char *v = dht_model_t_str(m_model))
			o << v;
		else
			o << m_model;
		o << ';';
	}
	if (full || has_gpio()) {
		ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void DhtConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_model()) {
		pbt_indent(o,indent,"model");
		if (const char *v = dht_model_t_str(m_model))
			o << v;
		else
			o << m_model;
	}
	if (full || has_gpio()) {
		pbt_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t DhtConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -170;
		a += fn;
		switch (fid) {
		case 0x8:	// model id 1, type dht_model_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -171;
				a += n;
				set_model((dht_model_t) v);
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -172;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -173;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -174;
	return a-(const uint8_t *)b;
}

ssize_t DhtConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has model?
	if (m_model != DHT_NONE) {
		// 'model': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -175;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_model);
		if (n <= 0)
			return -176;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -177;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -178;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void DhtConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_model()) {
		fsep = json_indent(json,indLvl,fsep,"model");
		if (const char *v = dht_model_t_str(m_model)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_model;
		}
	}
	if (full || has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t DhtConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional dht_model_t model, id 1
	if (m_model != DHT_NONE) {
		r += wiresize((varint_t)m_model) + 1 /* tag(model) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	return r;
}

bool DhtConfig::operator != (const DhtConfig &r) const
{
	if (has_model() && (m_model != r.m_model))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	return false;
}


bool DhtConfig::operator == (const DhtConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int DhtConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"model")) {
		if (value == 0) {
			clear_model();
			return 0;
		}
		dht_model_t v;
		size_t r = parse_ascii_dht_model_t(&v,value);
		if (r == 0)
			return -179;
		set_model(v);
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	return -180;
}

Message *DhtConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *DhtConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void I2CConfig::clear()
{
	m_port = 0;
	m_sda = -1;
	m_scl = -1;
	m_freq = 100000;
	m_xpullup = false;
	#ifdef CONFIG_I2C_XDEV
	m_devices.clear();
	#endif // CONFIG_I2C_XDEV
	p_validbits = 0;
}

void I2CConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // I2CConfig";
	++indent;
	if (full || has_port()) {
		ascii_numeric(o, indent, "port", (unsigned) m_port);
	}
	if (full || has_sda()) {
		ascii_numeric(o, indent, "sda", (signed) m_sda);
	}
	if (full || has_scl()) {
		ascii_numeric(o, indent, "scl", (signed) m_scl);
	}
	if (full || has_freq()) {
		ascii_numeric(o, indent, "freq", m_freq);
	}
	if (full || has_xpullup()) {
		ascii_bool(o, indent, "xpullup", m_xpullup);
	}
	#ifdef CONFIG_I2C_XDEV
	if (full || (0 != m_devices.size())) {
		gen_indent(o,indent);
		size_t s_devices = m_devices.size();
		o << "devices[" << s_devices << "] = {";
		++indent;
		for (size_t i = 0, e = s_devices; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			ascii_indent(o,indent,0);
			o << "{ // (i2cdev_t) " << (unsigned)m_devices[i];
			++indent;
			gen_indent(o,indent);
			o << ".addr = " ;
			o << (unsigned) devices_addr(i);
			o << ';';
			gen_indent(o,indent);
			o << ".drv = " ;
			o << i2cdrv_t_str(devices_drv(i));
			o << ';';
			gen_indent(o,indent);
			o << ".intr = " ;
			o << (unsigned) devices_intr(i);
			o << ';';
			--indent;
			gen_indent(o,indent);
			o << '}';
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#endif // CONFIG_I2C_XDEV
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void I2CConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_port()) {
		pbt_numeric(o, indent, "port", (unsigned) m_port);
	}
	if (full || has_sda()) {
		pbt_numeric(o, indent, "sda", (signed) m_sda);
	}
	if (full || has_scl()) {
		pbt_numeric(o, indent, "scl", (signed) m_scl);
	}
	if (full || has_freq()) {
		pbt_numeric(o, indent, "freq", m_freq);
	}
	if (full || has_xpullup()) {
		pbt_bool(o, indent, "xpullup", m_xpullup);
	}
	#ifdef CONFIG_I2C_XDEV
	if (full || (0 != m_devices.size())) {
		gen_indent(o,indent);
		size_t s_devices = m_devices.size();
		o << "devices: [";
		++indent;
		for (size_t i = 0, e = s_devices; i != e; ++i) {
			gen_indent(o,indent);
			o << m_devices[i] << ',';
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#endif // CONFIG_I2C_XDEV
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t I2CConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -181;
		a += fn;
		switch (fid) {
		case 0x8:	// port id 1, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -182;
				a += n;
				set_port(v);
			}
			break;
		case 0x10:	// sda id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -183;
				a += n;
				set_sda(varint_sint(v));
			}
			break;
		case 0x18:	// scl id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -184;
				a += n;
				set_scl(varint_sint(v));
			}
			break;
		case 0x20:	// freq id 4, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -185;
				a += n;
				set_freq(v);
			}
			break;
		case 0x2b:	// xpullup id 5, type bool, coding 8bit
			if (a >= e)
				return -186;
			set_xpullup(*a++);
			break;
			#ifdef CONFIG_I2C_XDEV
		case 0x32: {	// devices id 6, packed i2cdev_t[] coding 2
				varint_t v;
				int n = read_varint(a,e-a,&v);	// length of packed
				if (n <= 0)
					return -187;
				a += n;
				const uint8_t *ae = a + v;
				do {
					varint_t v;
					int n = read_varint(a,e-a,&v);
					if (n <= 0)
						return -188;
					a += n;
					m_devices.push_back((i2cdev_t)v);
				} while (a < ae);
			} break;
			#endif // CONFIG_I2C_XDEV
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -189;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -190;
	return a-(const uint8_t *)b;
}

ssize_t I2CConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (0 != (p_validbits & ((uint8_t)1U << vb_port))) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -191;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_port);
		if (n <= 0)
			return -192;
		a += n;
	}
	// has sda?
	if (m_sda != -1) {
		// 'sda': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -193;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sda));
		if (n <= 0)
			return -194;
		a += n;
	}
	// has scl?
	if (m_scl != -1) {
		// 'scl': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -195;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_scl));
		if (n <= 0)
			return -196;
		a += n;
	}
	// has freq?
	if (0 != (p_validbits & ((uint8_t)1U << vb_freq))) {
		// 'freq': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -197;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_freq);
		if (n <= 0)
			return -198;
		a += n;
	}
	// has xpullup?
	if (m_xpullup != false) {
		// 'xpullup': id=5, encoding=8bit, tag=0x2b
		if (2 > (e-a))
			return -199;
		*a++ = 0x2b;
		*a++ = m_xpullup;
	}
	#ifdef CONFIG_I2C_XDEV
	if (size_t devices_ne = m_devices.size()) {
		// 'devices': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -200;
		*a++ = 0x32;
		ssize_t devices_ws = 0;
		for (size_t x = 0; x != devices_ne; ++x)
			devices_ws += wiresize(m_devices[x]);
		n = write_varint(a,e-a,devices_ws);
		a += n;
		if ((n <= 0) || (devices_ws > (e-a)))
			return -201;
		for (size_t x = 0; x != devices_ne; ++x)
			a += write_varint(a,e-a,m_devices[x]);
	}
	#endif // CONFIG_I2C_XDEV
	assert(a <= e);
	return a-b;
}

void I2CConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << (unsigned) m_port;
	}
	if (full || has_sda()) {
		fsep = json_indent(json,indLvl,fsep,"sda");
		json << (int) m_sda;
	}
	if (full || has_scl()) {
		fsep = json_indent(json,indLvl,fsep,"scl");
		json << (int) m_scl;
	}
	if (full || has_freq()) {
		fsep = json_indent(json,indLvl,fsep,"freq");
		json << m_freq;
	}
	if (full || has_xpullup()) {
		fsep = json_indent(json,indLvl,fsep,"xpullup");
		json << (m_xpullup ? "true" : "false");
	}
	#ifdef CONFIG_I2C_XDEV
	if (size_t s = m_devices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"devices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json << m_devices[i];
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_I2C_XDEV
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t I2CConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional uint8 port, id 1
	if (0 != (p_validbits & ((uint8_t)1U << vb_port))) {
		r += wiresize((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional sint8 sda, id 2
	if (m_sda != -1) {
		r += wiresize_s((varint_t)m_sda) + 1 /* tag(sda) 0x10 */;
	}
	// optional sint8 scl, id 3
	if (m_scl != -1) {
		r += wiresize_s((varint_t)m_scl) + 1 /* tag(scl) 0x18 */;
	}
	// optional unsigned freq, id 4
	if (0 != (p_validbits & ((uint8_t)1U << vb_freq))) {
		r += wiresize((varint_t)m_freq) + 1 /* tag(freq) 0x20 */;
	}
	// optional bool xpullup, id 5
	if (m_xpullup != false) {
		r += 2;
	}
	#ifdef CONFIG_I2C_XDEV
	// repeated i2cdev_t devices, id 6
	if (!m_devices.empty()) {
		// devices: packed repeated i2cdev_t
		size_t devices_dl = 0;
		for (size_t x = 0, y = m_devices.size(); x < y; ++x)
			devices_dl += wiresize((varint_t)m_devices[x]);
		r += devices_dl + wiresize(devices_dl) /* data length */ + 1 /* tag(devices) 0x30 */;
	}
	#endif // CONFIG_I2C_XDEV
	return r;
}

bool I2CConfig::operator != (const I2CConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_sda() && (m_sda != r.m_sda))
		return true;
	if (has_scl() && (m_scl != r.m_scl))
		return true;
	if (has_freq() && (m_freq != r.m_freq))
		return true;
	if (has_xpullup() && (m_xpullup != r.m_xpullup))
		return true;
	#ifdef CONFIG_I2C_XDEV
	if (m_devices != r.m_devices)
		return true;
	#endif // CONFIG_I2C_XDEV
	return false;
}


bool I2CConfig::operator == (const I2CConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int I2CConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u8(&m_port,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"sda")) {
		if (value == 0) {
			clear_sda();
			return 0;
		}
		int r = parse_ascii_s8(&m_sda,value);
		return r;
	}
	if (0 == strcmp(name,"scl")) {
		if (value == 0) {
			clear_scl();
			return 0;
		}
		int r = parse_ascii_s8(&m_scl,value);
		return r;
	}
	if (0 == strcmp(name,"freq")) {
		if (value == 0) {
			clear_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_freq,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"xpullup")) {
		if (value == 0) {
			clear_xpullup();
			return 0;
		}
		int r = parse_ascii_bool(&m_xpullup,value);
		return r;
	}
	#ifdef CONFIG_I2C_XDEV
	if (0 == memcmp(name,"devices",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_devices();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_devices.size();
				m_devices.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -202;
				if (m_devices.size() <= x)
					return -203;
				if ((idxe[1] == 0) && (value == 0)) {
					m_devices.erase(m_devices.begin()+x);
					return 0;
				}
			}
			char *eptr = 0;
			unsigned long long ull = strtoull(value,&eptr,0);
			if (idxe[1] == 0) {
				m_devices[x] = (i2cdev_t) ull;
				return eptr - value;
			}
			if (idxe[1] != '.')
				return -204;
			idxe += 2;
			if (!strcmp("addr",idxe)) {
				if (eptr != value) {
					set_devices_addr(x,(uint8_t)ull);
					return 0;
				}
			}
			if (!strcmp("drv",idxe)) {
				if (eptr != value) {
					set_devices_drv(x,(i2cdrv_t)ull);
					return 0;
				}
			}
			if (!strcmp("intr",idxe)) {
				if (eptr != value) {
					set_devices_intr(x,(uint8_t)ull);
					return 0;
				}
			}
			return -205;
		}
	}
	#endif // CONFIG_I2C_XDEV
	return -206;
}

Message *I2CConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *I2CConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void HcSr04Config::clear()
{
	m_trigger = -1;
	m_echo = -1;
	m_name.clear();
}

void HcSr04Config::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // HcSr04Config";
	++indent;
	if (full || has_trigger()) {
		ascii_numeric(o, indent, "trigger", (signed) m_trigger);
	}
	if (full || has_echo()) {
		ascii_numeric(o, indent, "echo", (signed) m_echo);
	}
	if (full || has_name()) {
		ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void HcSr04Config::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_trigger()) {
		pbt_numeric(o, indent, "trigger", (signed) m_trigger);
	}
	if (full || has_echo()) {
		pbt_numeric(o, indent, "echo", (signed) m_echo);
	}
	if (full || has_name()) {
		pbt_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t HcSr04Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -207;
		a += fn;
		switch (fid) {
		case 0x8:	// trigger id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -208;
				a += n;
				set_trigger(varint_sint(v));
			}
			break;
		case 0x10:	// echo id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -209;
				a += n;
				set_echo(varint_sint(v));
			}
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -210;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -211;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -212;
	return a-(const uint8_t *)b;
}

ssize_t HcSr04Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has trigger?
	if (m_trigger != -1) {
		// 'trigger': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -213;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_trigger));
		if (n <= 0)
			return -214;
		a += n;
	}
	// has echo?
	if (m_echo != -1) {
		// 'echo': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -215;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_echo));
		if (n <= 0)
			return -216;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -217;
		*a++ = 0x1a;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -218;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	assert(a <= e);
	return a-b;
}

void HcSr04Config::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_trigger()) {
		fsep = json_indent(json,indLvl,fsep,"trigger");
		json << (int) m_trigger;
	}
	if (full || has_echo()) {
		fsep = json_indent(json,indLvl,fsep,"echo");
		json << (int) m_echo;
	}
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t HcSr04Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 trigger, id 1
	if (m_trigger != -1) {
		r += wiresize_s((varint_t)m_trigger) + 1 /* tag(trigger) 0x8 */;
	}
	// optional sint8 echo, id 2
	if (m_echo != -1) {
		r += wiresize_s((varint_t)m_echo) + 1 /* tag(echo) 0x10 */;
	}
	// optional string name, id 3
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	return r;
}

bool HcSr04Config::operator != (const HcSr04Config &r) const
{
	if (has_trigger() && (m_trigger != r.m_trigger))
		return true;
	if (has_echo() && (m_echo != r.m_echo))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	return false;
}


bool HcSr04Config::operator == (const HcSr04Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int HcSr04Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"trigger")) {
		if (value == 0) {
			clear_trigger();
			return 0;
		}
		int r = parse_ascii_s8(&m_trigger,value);
		return r;
	}
	if (0 == strcmp(name,"echo")) {
		if (value == 0) {
			clear_echo();
			return 0;
		}
		int r = parse_ascii_s8(&m_echo,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	return -219;
}

Message *HcSr04Config::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *HcSr04Config::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void LedConfig::clear()
{
	m_gpio = -1;
	m_config = 0;
	m_name.clear();
	m_pwm_ch = -1;
	p_validbits = 0;
}

void LedConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // LedConfig";
	++indent;
	if (full || has_gpio()) {
		ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || has_config()) {
		ascii_indent(o,indent,"config");
		o << "{ // (ledcfg_t) " << (unsigned)m_config;
		++indent;
		gen_indent(o,indent);
		o << ".active_high";
		o << (config_active_high() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".open_drain";
		o << (config_open_drain() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".init_high";
		o << (config_init_high() ? " = true;" : " = false;");
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	if (full || has_name()) {
		ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_pwm_ch()) {
		ascii_numeric(o, indent, "pwm_ch", (signed) m_pwm_ch);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void LedConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_gpio()) {
		pbt_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || has_config()) {
		pbt_numeric(o, indent, "config", (unsigned) m_config);
	}
	if (full || has_name()) {
		pbt_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_pwm_ch()) {
		pbt_numeric(o, indent, "pwm_ch", (signed) m_pwm_ch);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t LedConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -220;
		a += fn;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -221;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x10:	// config id 2, type ledcfg_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -222;
				a += n;
				set_config((ledcfg_t) v);
			}
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -223;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x20:	// pwm_ch id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -224;
				a += n;
				set_pwm_ch(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -225;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -226;
	return a-(const uint8_t *)b;
}

ssize_t LedConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -227;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -228;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << vb_config))) {
		// 'config': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -229;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -230;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -231;
		*a++ = 0x1a;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -232;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has pwm_ch?
	if (m_pwm_ch != -1) {
		// 'pwm_ch': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -233;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_pwm_ch));
		if (n <= 0)
			return -234;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void LedConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (full || has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (full || has_pwm_ch()) {
		fsep = json_indent(json,indLvl,fsep,"pwm_ch");
		json << (int) m_pwm_ch;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t LedConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional ledcfg_t config, id 2
	if (0 != (p_validbits & ((uint8_t)1U << vb_config))) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x10 */;
	}
	// optional string name, id 3
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	// optional sint8 pwm_ch, id 4
	if (m_pwm_ch != -1) {
		r += wiresize_s((varint_t)m_pwm_ch) + 1 /* tag(pwm_ch) 0x20 */;
	}
	return r;
}

bool LedConfig::operator != (const LedConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_pwm_ch() && (m_pwm_ch != r.m_pwm_ch))
		return true;
	return false;
}


bool LedConfig::operator == (const LedConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int LedConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((ledcfg_t)ull);
			else if (!strcmp(name,"active_high"))
				set_config_active_high((bool)ull);
			else if (!strcmp(name,"open_drain"))
				set_config_open_drain((bool)ull);
			else if (!strcmp(name,"init_high"))
				set_config_init_high((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -235;
		} else if (!strcmp(name,"active_high")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_active_high(tmp);
			return r;
		} else if (!strcmp(name,"open_drain")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_open_drain(tmp);
			return r;
		} else if (!strcmp(name,"init_high")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_init_high(tmp);
			return r;
		}
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"pwm_ch")) {
		if (value == 0) {
			clear_pwm_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_pwm_ch,value);
		return r;
	}
	return -236;
}

Message *LedConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *LedConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void OneWireConfig::clear()
{
	m_gpio = -1;
	m_pullup = false;
	m_power = -1;
}

void OneWireConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // OneWireConfig";
	++indent;
	if (full || has_gpio()) {
		ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || has_pullup()) {
		ascii_bool(o, indent, "pullup", m_pullup);
	}
	if (full || has_power()) {
		ascii_numeric(o, indent, "power", (signed) m_power);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void OneWireConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_gpio()) {
		pbt_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || has_pullup()) {
		pbt_bool(o, indent, "pullup", m_pullup);
	}
	if (full || has_power()) {
		pbt_numeric(o, indent, "power", (signed) m_power);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t OneWireConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -237;
		a += fn;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -238;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x13:	// pullup id 2, type bool, coding 8bit
			if (a >= e)
				return -239;
			set_pullup(*a++);
			break;
		case 0x18:	// power id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -240;
				a += n;
				set_power(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -241;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -242;
	return a-(const uint8_t *)b;
}

ssize_t OneWireConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -243;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -244;
		a += n;
	}
	// has pullup?
	if (m_pullup != false) {
		// 'pullup': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -245;
		*a++ = 0x13;
		*a++ = m_pullup;
	}
	// has power?
	if (m_power != -1) {
		// 'power': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -246;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_power));
		if (n <= 0)
			return -247;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void OneWireConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (full || has_pullup()) {
		fsep = json_indent(json,indLvl,fsep,"pullup");
		json << (m_pullup ? "true" : "false");
	}
	if (full || has_power()) {
		fsep = json_indent(json,indLvl,fsep,"power");
		json << (int) m_power;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t OneWireConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional bool pullup, id 2
	if (m_pullup != false) {
		r += 2;
	}
	// optional sint8 power, id 3
	if (m_power != -1) {
		r += wiresize_s((varint_t)m_power) + 1 /* tag(power) 0x18 */;
	}
	return r;
}

bool OneWireConfig::operator != (const OneWireConfig &r) const
{
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_pullup() && (m_pullup != r.m_pullup))
		return true;
	if (has_power() && (m_power != r.m_power))
		return true;
	return false;
}


bool OneWireConfig::operator == (const OneWireConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int OneWireConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"pullup")) {
		if (value == 0) {
			clear_pullup();
			return 0;
		}
		int r = parse_ascii_bool(&m_pullup,value);
		return r;
	}
	if (0 == strcmp(name,"power")) {
		if (value == 0) {
			clear_power();
			return 0;
		}
		int r = parse_ascii_s8(&m_power,value);
		return r;
	}
	return -248;
}

Message *OneWireConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *OneWireConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void UartConfig::clear()
{
	m_port = -1;
	m_tx_gpio = -1;
	m_rx_gpio = -1;
	m_cts_gpio = -1;
	m_rts_gpio = -1;
}

void UartConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // UartConfig";
	++indent;
	if (full || has_port()) {
		ascii_numeric(o, indent, "port", (signed) m_port);
	}
	if (full || has_tx_gpio()) {
		ascii_numeric(o, indent, "tx_gpio", (signed) m_tx_gpio);
	}
	if (full || has_rx_gpio()) {
		ascii_numeric(o, indent, "rx_gpio", (signed) m_rx_gpio);
	}
	if (full || has_cts_gpio()) {
		ascii_numeric(o, indent, "cts_gpio", (signed) m_cts_gpio);
	}
	if (full || has_rts_gpio()) {
		ascii_numeric(o, indent, "rts_gpio", (signed) m_rts_gpio);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void UartConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_port()) {
		pbt_numeric(o, indent, "port", (signed) m_port);
	}
	if (full || has_tx_gpio()) {
		pbt_numeric(o, indent, "tx_gpio", (signed) m_tx_gpio);
	}
	if (full || has_rx_gpio()) {
		pbt_numeric(o, indent, "rx_gpio", (signed) m_rx_gpio);
	}
	if (full || has_cts_gpio()) {
		pbt_numeric(o, indent, "cts_gpio", (signed) m_cts_gpio);
	}
	if (full || has_rts_gpio()) {
		pbt_numeric(o, indent, "rts_gpio", (signed) m_rts_gpio);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t UartConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -249;
		a += fn;
		switch (fid) {
		case 0x8:	// port id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -250;
				a += n;
				set_port(varint_sint(v));
			}
			break;
		case 0x10:	// tx_gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -251;
				a += n;
				set_tx_gpio(varint_sint(v));
			}
			break;
		case 0x18:	// rx_gpio id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -252;
				a += n;
				set_rx_gpio(varint_sint(v));
			}
			break;
		case 0x20:	// cts_gpio id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -253;
				a += n;
				set_cts_gpio(varint_sint(v));
			}
			break;
		case 0x28:	// rts_gpio id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -254;
				a += n;
				set_rts_gpio(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -255;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -256;
	return a-(const uint8_t *)b;
}

ssize_t UartConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (m_port != -1) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -257;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_port));
		if (n <= 0)
			return -258;
		a += n;
	}
	// has tx_gpio?
	if (m_tx_gpio != -1) {
		// 'tx_gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -259;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_tx_gpio));
		if (n <= 0)
			return -260;
		a += n;
	}
	// has rx_gpio?
	if (m_rx_gpio != -1) {
		// 'rx_gpio': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -261;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_rx_gpio));
		if (n <= 0)
			return -262;
		a += n;
	}
	// has cts_gpio?
	if (m_cts_gpio != -1) {
		// 'cts_gpio': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -263;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_cts_gpio));
		if (n <= 0)
			return -264;
		a += n;
	}
	// has rts_gpio?
	if (m_rts_gpio != -1) {
		// 'rts_gpio': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -265;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_rts_gpio));
		if (n <= 0)
			return -266;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void UartConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << (int) m_port;
	}
	if (full || has_tx_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"tx_gpio");
		json << (int) m_tx_gpio;
	}
	if (full || has_rx_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"rx_gpio");
		json << (int) m_rx_gpio;
	}
	if (full || has_cts_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"cts_gpio");
		json << (int) m_cts_gpio;
	}
	if (full || has_rts_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"rts_gpio");
		json << (int) m_rts_gpio;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t UartConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 port, id 1
	if (m_port != -1) {
		r += wiresize_s((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional sint8 tx_gpio, id 2
	if (m_tx_gpio != -1) {
		r += wiresize_s((varint_t)m_tx_gpio) + 1 /* tag(tx_gpio) 0x10 */;
	}
	// optional sint8 rx_gpio, id 3
	if (m_rx_gpio != -1) {
		r += wiresize_s((varint_t)m_rx_gpio) + 1 /* tag(rx_gpio) 0x18 */;
	}
	// optional sint8 cts_gpio, id 4
	if (m_cts_gpio != -1) {
		r += wiresize_s((varint_t)m_cts_gpio) + 1 /* tag(cts_gpio) 0x20 */;
	}
	// optional sint8 rts_gpio, id 5
	if (m_rts_gpio != -1) {
		r += wiresize_s((varint_t)m_rts_gpio) + 1 /* tag(rts_gpio) 0x28 */;
	}
	return r;
}

bool UartConfig::operator != (const UartConfig &r) const
{
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_tx_gpio() && (m_tx_gpio != r.m_tx_gpio))
		return true;
	if (has_rx_gpio() && (m_rx_gpio != r.m_rx_gpio))
		return true;
	if (has_cts_gpio() && (m_cts_gpio != r.m_cts_gpio))
		return true;
	if (has_rts_gpio() && (m_rts_gpio != r.m_rts_gpio))
		return true;
	return false;
}


bool UartConfig::operator == (const UartConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int UartConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_s8(&m_port,value);
		return r;
	}
	if (0 == strcmp(name,"tx_gpio")) {
		if (value == 0) {
			clear_tx_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_tx_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"rx_gpio")) {
		if (value == 0) {
			clear_rx_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_rx_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"cts_gpio")) {
		if (value == 0) {
			clear_cts_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_cts_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"rts_gpio")) {
		if (value == 0) {
			clear_rts_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_rts_gpio,value);
		return r;
	}
	return -267;
}

Message *UartConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *UartConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void AdcChannel::clear()
{
	m_name.clear();
	m_unit = 0;
	m_ch = -1;
	m_atten = 0;
	m_interval = 0;
	m_window = 0;
	m_scale = 1;
	m_offset = 0;
	m_dim.clear();
	p_validbits = 0;
}

void AdcChannel::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // AdcChannel";
	++indent;
	if (full || has_name()) {
		ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_unit()) {
		ascii_numeric(o, indent, "unit", (unsigned) m_unit);
	}
	if (full || has_ch()) {
		ascii_numeric(o, indent, "ch", (signed) m_ch);
	}
	if (full || has_atten()) {
		ascii_numeric(o, indent, "atten", (unsigned) m_atten);
	}
	if (full || has_interval()) {
		ascii_numeric(o, indent, "interval", m_interval);
	}
	if (full || has_window()) {
		ascii_numeric(o, indent, "window", (unsigned) m_window);
	}
	if (full || has_scale()) {
		ascii_numeric(o, indent, "scale", m_scale);
	}
	if (full || has_offset()) {
		ascii_numeric(o, indent, "offset", m_offset);
	}
	if (full || has_dim()) {
		ascii_string(o,indent,m_dim.data(),m_dim.size(),"dim");
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void AdcChannel::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_name()) {
		pbt_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_unit()) {
		pbt_numeric(o, indent, "unit", (unsigned) m_unit);
	}
	if (full || has_ch()) {
		pbt_numeric(o, indent, "ch", (signed) m_ch);
	}
	if (full || has_atten()) {
		pbt_numeric(o, indent, "atten", (unsigned) m_atten);
	}
	if (full || has_interval()) {
		pbt_numeric(o, indent, "interval", m_interval);
	}
	if (full || has_window()) {
		pbt_numeric(o, indent, "window", (unsigned) m_window);
	}
	if (full || has_scale()) {
		pbt_numeric(o, indent, "scale", m_scale);
	}
	if (full || has_offset()) {
		pbt_numeric(o, indent, "offset", m_offset);
	}
	if (full || has_dim()) {
		pbt_string(o,indent,m_dim.data(),m_dim.size(),"dim");
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t AdcChannel::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -268;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -269;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// unit id 2, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -270;
				a += n;
				set_unit(v);
			}
			break;
		case 0x18:	// ch id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -271;
				a += n;
				set_ch(varint_sint(v));
			}
			break;
		case 0x20:	// atten id 4, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -272;
				a += n;
				set_atten(v);
			}
			break;
		case 0x28:	// interval id 5, type uint16_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -273;
				a += n;
				set_interval(v);
			}
			break;
		case 0x30:	// window id 6, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -274;
				a += n;
				set_window(v);
			}
			break;
		case 0x45:	// scale id 8, type float, coding 32bit
			if ((a+3) >= e)
				return -275;
			set_scale(read_float(a));
			a += 4;
			break;
		case 0x4d:	// offset id 9, type float, coding 32bit
			if ((a+3) >= e)
				return -276;
			set_offset(read_float(a));
			a += 4;
			break;
		case 0x52:	// dim id 10, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -277;
				m_dim.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -278;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -279;
	return a-(const uint8_t *)b;
}

ssize_t AdcChannel::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -280;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -281;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has unit?
	if (m_unit != 0) {
		// 'unit': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -282;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_unit);
		if (n <= 0)
			return -283;
		a += n;
	}
	// has ch?
	if (m_ch != -1) {
		// 'ch': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -284;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_ch));
		if (n <= 0)
			return -285;
		a += n;
	}
	// has atten?
	if (0 != (p_validbits & ((uint8_t)1U << vb_atten))) {
		// 'atten': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -286;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_atten);
		if (n <= 0)
			return -287;
		a += n;
	}
	// has interval?
	if (m_interval != 0) {
		// 'interval': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -288;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_interval);
		if (n <= 0)
			return -289;
		a += n;
	}
	// has window?
	if (m_window != 0) {
		// 'window': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -290;
		*a++ = 0x30;
		n = write_varint(a,e-a,m_window);
		if (n <= 0)
			return -291;
		a += n;
	}
	// has scale?
	if (0 != (p_validbits & ((uint8_t)1U << vb_scale))) {
		// 'scale': id=8, encoding=32bit, tag=0x45
		if (5 > (e-a))
			return -292;
		*a++ = 0x45;
		if ((e-a) < 4)
			return -293;
		write_u32(a,mangle_float(m_scale));
		a += 4;
	}
	// has offset?
	if (0 != (p_validbits & ((uint8_t)1U << vb_offset))) {
		// 'offset': id=9, encoding=32bit, tag=0x4d
		if (5 > (e-a))
			return -294;
		*a++ = 0x4d;
		if ((e-a) < 4)
			return -295;
		write_u32(a,mangle_float(m_offset));
		a += 4;
	}
	// has dim?
	if (!m_dim.empty()) {
		// 'dim': id=10, encoding=lenpfx, tag=0x52
		if (a >= e)
			return -296;
		*a++ = 0x52;
		ssize_t dim_s = m_dim.size();
		n = write_varint(a,e-a,dim_s);
		a += n;
		if ((n <= 0) || ((e-a) < dim_s))
			return -297;
		memcpy(a,m_dim.data(),dim_s);
		a += dim_s;
	}
	assert(a <= e);
	return a-b;
}

void AdcChannel::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (full || has_unit()) {
		fsep = json_indent(json,indLvl,fsep,"unit");
		json << (unsigned) m_unit;
	}
	if (full || has_ch()) {
		fsep = json_indent(json,indLvl,fsep,"ch");
		json << (int) m_ch;
	}
	if (full || has_atten()) {
		fsep = json_indent(json,indLvl,fsep,"atten");
		json << (unsigned) m_atten;
	}
	if (full || has_interval()) {
		fsep = json_indent(json,indLvl,fsep,"interval");
		json << m_interval;
	}
	if (full || has_window()) {
		fsep = json_indent(json,indLvl,fsep,"window");
		json << (unsigned) m_window;
	}
	if (full || has_scale()) {
		fsep = json_indent(json,indLvl,fsep,"scale");
		to_dblstr(json,m_scale);
	}
	if (full || has_offset()) {
		fsep = json_indent(json,indLvl,fsep,"offset");
		to_dblstr(json,m_offset);
	}
	if (full || has_dim()) {
		fsep = json_indent(json,indLvl,fsep,"dim");
		json_cstr(json,m_dim.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AdcChannel::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional uint8 unit, id 2
	if (m_unit != 0) {
		r += wiresize((varint_t)m_unit) + 1 /* tag(unit) 0x10 */;
	}
	// optional sint8 ch, id 3
	if (m_ch != -1) {
		r += wiresize_s((varint_t)m_ch) + 1 /* tag(ch) 0x18 */;
	}
	// optional uint8 atten, id 4
	if (0 != (p_validbits & ((uint8_t)1U << vb_atten))) {
		r += wiresize((varint_t)m_atten) + 1 /* tag(atten) 0x20 */;
	}
	// optional uint16 interval, id 5
	if (m_interval != 0) {
		r += wiresize((varint_t)m_interval) + 1 /* tag(interval) 0x28 */;
	}
	// optional uint8 window, id 6
	if (m_window != 0) {
		r += wiresize((varint_t)m_window) + 1 /* tag(window) 0x30 */;
	}
	// optional float scale, id 8
	if (0 != (p_validbits & ((uint8_t)1U << vb_scale))) {
		r += 5;
	}
	// optional float offset, id 9
	if (0 != (p_validbits & ((uint8_t)1U << vb_offset))) {
		r += 5;
	}
	// optional string dim, id 10
	if (!m_dim.empty()) {
		size_t dim_s = m_dim.size();
		r += dim_s + wiresize(dim_s) + 1 /* tag(dim) 0x50 */;
	}
	return r;
}

bool AdcChannel::operator != (const AdcChannel &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_unit() && (m_unit != r.m_unit))
		return true;
	if (has_ch() && (m_ch != r.m_ch))
		return true;
	if (has_atten() && (m_atten != r.m_atten))
		return true;
	if (has_interval() && (m_interval != r.m_interval))
		return true;
	if (has_window() && (m_window != r.m_window))
		return true;
	if (has_scale() && (m_scale != r.m_scale))
		return true;
	if (has_offset() && (m_offset != r.m_offset))
		return true;
	if (has_dim() && (m_dim != r.m_dim))
		return true;
	return false;
}


bool AdcChannel::operator == (const AdcChannel &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AdcChannel::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"unit")) {
		if (value == 0) {
			clear_unit();
			return 0;
		}
		int r = parse_ascii_u8(&m_unit,value);
		return r;
	}
	if (0 == strcmp(name,"ch")) {
		if (value == 0) {
			clear_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_ch,value);
		return r;
	}
	if (0 == strcmp(name,"atten")) {
		if (value == 0) {
			clear_atten();
			return 0;
		}
		int r = parse_ascii_u8(&m_atten,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"interval")) {
		if (value == 0) {
			clear_interval();
			return 0;
		}
		int r = parse_ascii_u16(&m_interval,value);
		return r;
	}
	if (0 == strcmp(name,"window")) {
		if (value == 0) {
			clear_window();
			return 0;
		}
		int r = parse_ascii_u8(&m_window,value);
		return r;
	}
	if (0 == strcmp(name,"scale")) {
		if (value == 0) {
			clear_scale();
			return 0;
		}
		int r = parse_ascii_flt(&m_scale,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"offset")) {
		if (value == 0) {
			clear_offset();
			return 0;
		}
		int r = parse_ascii_flt(&m_offset,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"dim")) {
		if (value == 0) {
			m_dim.clear();
			return 0;
		}
		m_dim = value;
		int r = m_dim.size();
		return r;
	}
	return -298;
}

Message *AdcChannel::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *AdcChannel::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void AdcConfig::clear()
{
	m_adc1_bits = 0;
	m_adc2_bits = 0;
	#ifdef CONFIG_IDF_TARGET_ESP32
	m_hall_name.clear();
	#endif // CONFIG_IDF_TARGET_ESP32
	m_channels.clear();
	p_validbits = 0;
}

void AdcConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // AdcConfig";
	++indent;
	if (full || has_adc1_bits()) {
		ascii_numeric(o, indent, "adc1_bits", (unsigned) m_adc1_bits);
	}
	if (full || has_adc2_bits()) {
		ascii_numeric(o, indent, "adc2_bits", (unsigned) m_adc2_bits);
	}
	#ifdef CONFIG_IDF_TARGET_ESP32
	if (full || has_hall_name()) {
		ascii_string(o,indent,m_hall_name.data(),m_hall_name.size(),"hall_name");
	}
	#endif // CONFIG_IDF_TARGET_ESP32
	if (full || (0 != m_channels.size())) {
		gen_indent(o,indent);
		size_t s_channels = m_channels.size();
		o << "channels[" << s_channels << "] = {";
		++indent;
		for (size_t i = 0, e = s_channels; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_channels[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void AdcConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_adc1_bits()) {
		pbt_numeric(o, indent, "adc1_bits", (unsigned) m_adc1_bits);
	}
	if (full || has_adc2_bits()) {
		pbt_numeric(o, indent, "adc2_bits", (unsigned) m_adc2_bits);
	}
	#ifdef CONFIG_IDF_TARGET_ESP32
	if (full || has_hall_name()) {
		pbt_string(o,indent,m_hall_name.data(),m_hall_name.size(),"hall_name");
	}
	#endif // CONFIG_IDF_TARGET_ESP32
	if (full || (0 != m_channels.size())) {
		gen_indent(o,indent);
		size_t s_channels = m_channels.size();
		o << "channels: [";
		++indent;
		for (size_t i = 0, e = s_channels; i != e; ++i) {
			gen_indent(o,indent);
			m_channels[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t AdcConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -299;
		a += fn;
		switch (fid) {
		case 0x10:	// adc1_bits id 2, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -300;
				a += n;
				set_adc1_bits(v);
			}
			break;
		case 0x18:	// adc2_bits id 3, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -301;
				a += n;
				set_adc2_bits(v);
			}
			break;
			#ifdef CONFIG_IDF_TARGET_ESP32
		case 0x32:	// hall_name id 6, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -302;
				m_hall_name.assign((const char*)a,v);
				a += v;
			}
			break;
			#endif // CONFIG_IDF_TARGET_ESP32
		case 0x3a:	// channels id 7, type AdcChannel, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -303;
				m_channels.emplace_back();
				if (v != 0) {
					n = m_channels.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -304;
					a += v;
				}
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -305;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -306;
	return a-(const uint8_t *)b;
}

ssize_t AdcConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// 'adc_name' is unused. Therefore no data will be written.
	// has adc1_bits?
	if (0 != (p_validbits & ((uint8_t)1U << vb_adc1_bits))) {
		// 'adc1_bits': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -307;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_adc1_bits);
		if (n <= 0)
			return -308;
		a += n;
	}
	// has adc2_bits?
	if (0 != (p_validbits & ((uint8_t)1U << vb_adc2_bits))) {
		// 'adc2_bits': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -309;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_adc2_bits);
		if (n <= 0)
			return -310;
		a += n;
	}
	// 'mode' is unused. Therefore no data will be written.
	// 'clk_div' is unused. Therefore no data will be written.
	#ifdef CONFIG_IDF_TARGET_ESP32
	// has hall_name?
	if (!m_hall_name.empty()) {
		// 'hall_name': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -311;
		*a++ = 0x32;
		ssize_t hall_name_s = m_hall_name.size();
		n = write_varint(a,e-a,hall_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < hall_name_s))
			return -312;
		memcpy(a,m_hall_name.data(),hall_name_s);
		a += hall_name_s;
	}
	#endif // CONFIG_IDF_TARGET_ESP32
	for (const auto &x : m_channels) {
		// 'channels': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -313;
		*a++ = 0x3a;
		ssize_t channels_ws = x.calcSize();
		n = write_varint(a,e-a,channels_ws);
		a += n;
		if ((n <= 0) || (channels_ws > (e-a)))
			return -314;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == channels_ws);
	}
	assert(a <= e);
	return a-b;
}

void AdcConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_adc1_bits()) {
		fsep = json_indent(json,indLvl,fsep,"adc1_bits");
		json << (unsigned) m_adc1_bits;
	}
	if (full || has_adc2_bits()) {
		fsep = json_indent(json,indLvl,fsep,"adc2_bits");
		json << (unsigned) m_adc2_bits;
	}
	#ifdef CONFIG_IDF_TARGET_ESP32
	if (full || has_hall_name()) {
		fsep = json_indent(json,indLvl,fsep,"hall_name");
		json_cstr(json,m_hall_name.c_str());
	}
	#endif // CONFIG_IDF_TARGET_ESP32
	if (size_t s = m_channels.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"channels\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_channels[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AdcConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// unused optional string adc_name, id 1
	// optional uint8 adc1_bits, id 2
	if (0 != (p_validbits & ((uint8_t)1U << vb_adc1_bits))) {
		r += wiresize((varint_t)m_adc1_bits) + 1 /* tag(adc1_bits) 0x10 */;
	}
	// optional uint8 adc2_bits, id 3
	if (0 != (p_validbits & ((uint8_t)1U << vb_adc2_bits))) {
		r += wiresize((varint_t)m_adc2_bits) + 1 /* tag(adc2_bits) 0x18 */;
	}
	// unused optional uint8 mode, id 4
	// unused optional uint8 clk_div, id 5
	#ifdef CONFIG_IDF_TARGET_ESP32
	// optional string hall_name, id 6
	if (!m_hall_name.empty()) {
		size_t hall_name_s = m_hall_name.size();
		r += hall_name_s + wiresize(hall_name_s) + 1 /* tag(hall_name) 0x30 */;
	}
	#endif // CONFIG_IDF_TARGET_ESP32
	// repeated AdcChannel channels, id 7
	// repeated message channels
	for (size_t x = 0, y = m_channels.size(); x < y; ++x) {
		size_t s = m_channels[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(channels) 0x38 */;
	}
	return r;
}

bool AdcConfig::operator != (const AdcConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_adc1_bits() && (m_adc1_bits != r.m_adc1_bits))
		return true;
	if (has_adc2_bits() && (m_adc2_bits != r.m_adc2_bits))
		return true;
	#ifdef CONFIG_IDF_TARGET_ESP32
	if (has_hall_name() && (m_hall_name != r.m_hall_name))
		return true;
	#endif // CONFIG_IDF_TARGET_ESP32
	if (m_channels != r.m_channels)
		return true;
	return false;
}


bool AdcConfig::operator == (const AdcConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AdcConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"adc1_bits")) {
		if (value == 0) {
			clear_adc1_bits();
			return 0;
		}
		int r = parse_ascii_u8(&m_adc1_bits,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"adc2_bits")) {
		if (value == 0) {
			clear_adc2_bits();
			return 0;
		}
		int r = parse_ascii_u8(&m_adc2_bits,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	#ifdef CONFIG_IDF_TARGET_ESP32
	if (0 == strcmp(name,"hall_name")) {
		if (value == 0) {
			m_hall_name.clear();
			return 0;
		}
		m_hall_name = value;
		int r = m_hall_name.size();
		return r;
	}
	#endif // CONFIG_IDF_TARGET_ESP32
	if (0 == memcmp(name,"channels",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_channels();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_channels.size();
				m_channels.resize(x+1);
				idxe = (char*)(name + 10);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+9)))
					return -315;
				if (m_channels.size() <= x)
					return -316;
				if ((idxe[1] == 0) && (value == 0)) {
					m_channels.erase(m_channels.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -317;
			return m_channels[x].setByName(idxe+2,value);
		}
	}
	return -318;
}

Message *AdcConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *AdcConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	if ((n == 8) && (0 == memcmp("channels",s,8))) {
		if (x < m_channels.size())
			return &m_channels[x];
	}
	return 0;
}

void GpioConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_config = 0;
	p_validbits = 0;
}

void GpioConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // GpioConfig";
	++indent;
	if (full || has_name()) {
		ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_gpio()) {
		ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || has_config()) {
		ascii_indent(o,indent,"config");
		o << "{ // (gpiocfg_t) " << (unsigned)m_config;
		++indent;
		gen_indent(o,indent);
		o << ".mode = " ;
		o << (unsigned) config_mode();
		o << ';';
		gen_indent(o,indent);
		o << ".intrtype = " ;
		o << (unsigned) config_intrtype();
		o << ';';
		gen_indent(o,indent);
		o << ".setinit";
		o << (config_setinit() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".initlvl";
		o << (config_initlvl() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".pullup";
		o << (config_pullup() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".pulldown";
		o << (config_pulldown() ? " = true;" : " = false;");
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void GpioConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_name()) {
		pbt_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_gpio()) {
		pbt_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || has_config()) {
		pbt_numeric(o, indent, "config", m_config);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t GpioConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -319;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -320;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -321;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x18:	// config id 3, type gpiocfg_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -322;
				a += n;
				set_config((gpiocfg_t) v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -323;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -324;
	return a-(const uint8_t *)b;
}

ssize_t GpioConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -325;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -326;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -327;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -328;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << vb_config))) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -329;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -330;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void GpioConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (full || has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (full || has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t GpioConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional gpiocfg_t config, id 3
	if (0 != (p_validbits & ((uint8_t)1U << vb_config))) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	return r;
}

bool GpioConfig::operator != (const GpioConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	return false;
}


bool GpioConfig::operator == (const GpioConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int GpioConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((gpiocfg_t)ull);
			else if (!strcmp(name,"mode"))
				set_config_mode((uint8_t)ull);
			else if (!strcmp(name,"intrtype"))
				set_config_intrtype((uint8_t)ull);
			else if (!strcmp(name,"setinit"))
				set_config_setinit((bool)ull);
			else if (!strcmp(name,"initlvl"))
				set_config_initlvl((bool)ull);
			else if (!strcmp(name,"pullup"))
				set_config_pullup((bool)ull);
			else if (!strcmp(name,"pulldown"))
				set_config_pulldown((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -331;
		} else if (!strcmp(name,"mode")) {
			uint8_t tmp;
			int r = parse_ascii_u8(&tmp,value);
			if (r > 0)
				set_config_mode(tmp);
			return r;
		} else if (!strcmp(name,"intrtype")) {
			uint8_t tmp;
			int r = parse_ascii_u8(&tmp,value);
			if (r > 0)
				set_config_intrtype(tmp);
			return r;
		} else if (!strcmp(name,"setinit")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_setinit(tmp);
			return r;
		} else if (!strcmp(name,"initlvl")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_initlvl(tmp);
			return r;
		} else if (!strcmp(name,"pullup")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_pullup(tmp);
			return r;
		} else if (!strcmp(name,"pulldown")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_pulldown(tmp);
			return r;
		}
	}
	return -332;
}

Message *GpioConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *GpioConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void DisplayConfig::clear()
{
	m_type = dt_none;
	m_options = 0;
	m_maxx = 0;
	m_maxy = 1;
	p_validbits = 0;
}

void DisplayConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // DisplayConfig";
	++indent;
	if (full || has_type()) {
		ascii_indent(o,indent,"type");
		if (const char *v = disp_t_str(m_type))
			o << v;
		else
			o << m_type;
		o << ';';
	}
	if (full || has_options()) {
		ascii_numeric(o, indent, "options", m_options);
	}
	if (full || has_maxx()) {
		ascii_numeric(o, indent, "maxx", m_maxx);
	}
	if (full || has_maxy()) {
		ascii_numeric(o, indent, "maxy", m_maxy);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void DisplayConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_type()) {
		pbt_indent(o,indent,"type");
		if (const char *v = disp_t_str(m_type))
			o << v;
		else
			o << m_type;
	}
	if (full || has_options()) {
		pbt_numeric(o, indent, "options", m_options);
	}
	if (full || has_maxx()) {
		pbt_numeric(o, indent, "maxx", m_maxx);
	}
	if (full || has_maxy()) {
		pbt_numeric(o, indent, "maxy", m_maxy);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t DisplayConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -333;
		a += fn;
		switch (fid) {
		case 0x8:	// type id 1, type disp_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -334;
				a += n;
				set_type((disp_t) v);
			}
			break;
		case 0x10:	// options id 2, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -335;
				a += n;
				set_options(v);
			}
			break;
		case 0x18:	// maxx id 3, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -336;
				a += n;
				set_maxx(v);
			}
			break;
		case 0x20:	// maxy id 4, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -337;
				a += n;
				set_maxy(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -338;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -339;
	return a-(const uint8_t *)b;
}

ssize_t DisplayConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has type?
	if (m_type != dt_none) {
		// 'type': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -340;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_type);
		if (n <= 0)
			return -341;
		a += n;
	}
	// has options?
	if (0 != (p_validbits & ((uint8_t)1U << vb_options))) {
		// 'options': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -342;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_options);
		if (n <= 0)
			return -343;
		a += n;
	}
	// has maxx?
	if (0 != (p_validbits & ((uint8_t)1U << vb_maxx))) {
		// 'maxx': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -344;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_maxx);
		if (n <= 0)
			return -345;
		a += n;
	}
	// has maxy?
	if (0 != (p_validbits & ((uint8_t)1U << vb_maxy))) {
		// 'maxy': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -346;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_maxy);
		if (n <= 0)
			return -347;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void DisplayConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_type()) {
		fsep = json_indent(json,indLvl,fsep,"type");
		if (const char *v = disp_t_str(m_type)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_type;
		}
	}
	if (full || has_options()) {
		fsep = json_indent(json,indLvl,fsep,"options");
		json << m_options;
	}
	if (full || has_maxx()) {
		fsep = json_indent(json,indLvl,fsep,"maxx");
		json << m_maxx;
	}
	if (full || has_maxy()) {
		fsep = json_indent(json,indLvl,fsep,"maxy");
		json << m_maxy;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t DisplayConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional disp_t type, id 1
	if (m_type != dt_none) {
		r += wiresize((varint_t)m_type) + 1 /* tag(type) 0x8 */;
	}
	// optional unsigned options, id 2
	if (0 != (p_validbits & ((uint8_t)1U << vb_options))) {
		r += wiresize((varint_t)m_options) + 1 /* tag(options) 0x10 */;
	}
	// optional unsigned maxx, id 3
	if (0 != (p_validbits & ((uint8_t)1U << vb_maxx))) {
		r += wiresize((varint_t)m_maxx) + 1 /* tag(maxx) 0x18 */;
	}
	// optional unsigned maxy, id 4
	if (0 != (p_validbits & ((uint8_t)1U << vb_maxy))) {
		r += wiresize((varint_t)m_maxy) + 1 /* tag(maxy) 0x20 */;
	}
	return r;
}

bool DisplayConfig::operator != (const DisplayConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_type() && (m_type != r.m_type))
		return true;
	if (has_options() && (m_options != r.m_options))
		return true;
	if (has_maxx() && (m_maxx != r.m_maxx))
		return true;
	if (has_maxy() && (m_maxy != r.m_maxy))
		return true;
	return false;
}


bool DisplayConfig::operator == (const DisplayConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int DisplayConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"type")) {
		if (value == 0) {
			clear_type();
			return 0;
		}
		disp_t v;
		size_t r = parse_ascii_disp_t(&v,value);
		if (r == 0)
			return -348;
		set_type(v);
		return r;
	}
	if (0 == strcmp(name,"options")) {
		if (value == 0) {
			clear_options();
			return 0;
		}
		int r = parse_ascii_u32(&m_options,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"maxx")) {
		if (value == 0) {
			clear_maxx();
			return 0;
		}
		int r = parse_ascii_u32(&m_maxx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"maxy")) {
		if (value == 0) {
			clear_maxy();
			return 0;
		}
		int r = parse_ascii_u32(&m_maxy,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	return -349;
}

Message *DisplayConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *DisplayConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void SpiDeviceConfig::clear()
{
	m_drv = spidrv_invalid;
	m_cs = -1;
	m_intr = -1;
	m_reset = -1;
	m_cd = -1;
	m_freq = 0;
}

void SpiDeviceConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // SpiDeviceConfig";
	++indent;
	if (full || has_drv()) {
		ascii_indent(o,indent,"drv");
		if (const char *v = spidrv_t_str(m_drv))
			o << v;
		else
			o << m_drv;
		o << ';';
	}
	if (full || has_cs()) {
		ascii_numeric(o, indent, "cs", (signed) m_cs);
	}
	if (full || has_intr()) {
		ascii_numeric(o, indent, "intr", (signed) m_intr);
	}
	if (full || has_reset()) {
		ascii_numeric(o, indent, "reset", (signed) m_reset);
	}
	if (full || has_cd()) {
		ascii_numeric(o, indent, "cd", (signed) m_cd);
	}
	if (full || has_freq()) {
		ascii_numeric(o, indent, "freq", m_freq);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void SpiDeviceConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_drv()) {
		pbt_indent(o,indent,"drv");
		if (const char *v = spidrv_t_str(m_drv))
			o << v;
		else
			o << m_drv;
	}
	if (full || has_cs()) {
		pbt_numeric(o, indent, "cs", (signed) m_cs);
	}
	if (full || has_intr()) {
		pbt_numeric(o, indent, "intr", (signed) m_intr);
	}
	if (full || has_reset()) {
		pbt_numeric(o, indent, "reset", (signed) m_reset);
	}
	if (full || has_cd()) {
		pbt_numeric(o, indent, "cd", (signed) m_cd);
	}
	if (full || has_freq()) {
		pbt_numeric(o, indent, "freq", m_freq);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t SpiDeviceConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -350;
		a += fn;
		switch (fid) {
		case 0x8:	// drv id 1, type spidrv_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -351;
				a += n;
				set_drv((spidrv_t) v);
			}
			break;
		case 0x10:	// cs id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -352;
				a += n;
				set_cs(varint_sint(v));
			}
			break;
		case 0x18:	// intr id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -353;
				a += n;
				set_intr(varint_sint(v));
			}
			break;
		case 0x20:	// reset id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -354;
				a += n;
				set_reset(varint_sint(v));
			}
			break;
		case 0x28:	// cd id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -355;
				a += n;
				set_cd(varint_sint(v));
			}
			break;
		case 0x30:	// freq id 6, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -356;
				a += n;
				set_freq(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -357;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -358;
	return a-(const uint8_t *)b;
}

ssize_t SpiDeviceConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has drv?
	if (m_drv != spidrv_invalid) {
		// 'drv': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -359;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_drv);
		if (n <= 0)
			return -360;
		a += n;
	}
	// has cs?
	if (m_cs != -1) {
		// 'cs': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -361;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_cs));
		if (n <= 0)
			return -362;
		a += n;
	}
	// has intr?
	if (m_intr != -1) {
		// 'intr': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -363;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_intr));
		if (n <= 0)
			return -364;
		a += n;
	}
	// has reset?
	if (m_reset != -1) {
		// 'reset': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -365;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_reset));
		if (n <= 0)
			return -366;
		a += n;
	}
	// has cd?
	if (m_cd != -1) {
		// 'cd': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -367;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_cd));
		if (n <= 0)
			return -368;
		a += n;
	}
	// has freq?
	if (m_freq != 0) {
		// 'freq': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -369;
		*a++ = 0x30;
		n = write_varint(a,e-a,m_freq);
		if (n <= 0)
			return -370;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void SpiDeviceConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_drv()) {
		fsep = json_indent(json,indLvl,fsep,"drv");
		if (const char *v = spidrv_t_str(m_drv)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_drv;
		}
	}
	if (full || has_cs()) {
		fsep = json_indent(json,indLvl,fsep,"cs");
		json << (int) m_cs;
	}
	if (full || has_intr()) {
		fsep = json_indent(json,indLvl,fsep,"intr");
		json << (int) m_intr;
	}
	if (full || has_reset()) {
		fsep = json_indent(json,indLvl,fsep,"reset");
		json << (int) m_reset;
	}
	if (full || has_cd()) {
		fsep = json_indent(json,indLvl,fsep,"cd");
		json << (int) m_cd;
	}
	if (full || has_freq()) {
		fsep = json_indent(json,indLvl,fsep,"freq");
		json << m_freq;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SpiDeviceConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional spidrv_t drv, id 1
	if (m_drv != spidrv_invalid) {
		r += wiresize((varint_t)m_drv) + 1 /* tag(drv) 0x8 */;
	}
	// optional sint8 cs, id 2
	if (m_cs != -1) {
		r += wiresize_s((varint_t)m_cs) + 1 /* tag(cs) 0x10 */;
	}
	// optional sint8 intr, id 3
	if (m_intr != -1) {
		r += wiresize_s((varint_t)m_intr) + 1 /* tag(intr) 0x18 */;
	}
	// optional sint8 reset, id 4
	if (m_reset != -1) {
		r += wiresize_s((varint_t)m_reset) + 1 /* tag(reset) 0x20 */;
	}
	// optional sint8 cd, id 5
	if (m_cd != -1) {
		r += wiresize_s((varint_t)m_cd) + 1 /* tag(cd) 0x28 */;
	}
	// optional unsigned freq, id 6
	if (m_freq != 0) {
		r += wiresize((varint_t)m_freq) + 1 /* tag(freq) 0x30 */;
	}
	return r;
}

bool SpiDeviceConfig::operator != (const SpiDeviceConfig &r) const
{
	if (has_drv() && (m_drv != r.m_drv))
		return true;
	if (has_cs() && (m_cs != r.m_cs))
		return true;
	if (has_intr() && (m_intr != r.m_intr))
		return true;
	if (has_reset() && (m_reset != r.m_reset))
		return true;
	if (has_cd() && (m_cd != r.m_cd))
		return true;
	if (has_freq() && (m_freq != r.m_freq))
		return true;
	return false;
}


bool SpiDeviceConfig::operator == (const SpiDeviceConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SpiDeviceConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"drv")) {
		if (value == 0) {
			clear_drv();
			return 0;
		}
		spidrv_t v;
		size_t r = parse_ascii_spidrv_t(&v,value);
		if (r == 0)
			return -371;
		set_drv(v);
		return r;
	}
	if (0 == strcmp(name,"cs")) {
		if (value == 0) {
			clear_cs();
			return 0;
		}
		int r = parse_ascii_s8(&m_cs,value);
		return r;
	}
	if (0 == strcmp(name,"intr")) {
		if (value == 0) {
			clear_intr();
			return 0;
		}
		int r = parse_ascii_s8(&m_intr,value);
		return r;
	}
	if (0 == strcmp(name,"reset")) {
		if (value == 0) {
			clear_reset();
			return 0;
		}
		int r = parse_ascii_s8(&m_reset,value);
		return r;
	}
	if (0 == strcmp(name,"cd")) {
		if (value == 0) {
			clear_cd();
			return 0;
		}
		int r = parse_ascii_s8(&m_cd,value);
		return r;
	}
	if (0 == strcmp(name,"freq")) {
		if (value == 0) {
			clear_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_freq,value);
		return r;
	}
	return -372;
}

Message *SpiDeviceConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *SpiDeviceConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void SpiBusConfig::clear()
{
	m_host = -1;
	m_mosi = -1;
	m_miso = -1;
	m_sclk = -1;
	m_wp = -1;
	m_hold = -1;
	m_options = 0;
	m_dma = -1;
	m_devices.clear();
	p_validbits = 0;
}

void SpiBusConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // SpiBusConfig";
	++indent;
	if (full || has_host()) {
		ascii_numeric(o, indent, "host", (signed) m_host);
	}
	if (full || has_mosi()) {
		ascii_numeric(o, indent, "mosi", (signed) m_mosi);
	}
	if (full || has_miso()) {
		ascii_numeric(o, indent, "miso", (signed) m_miso);
	}
	if (full || has_sclk()) {
		ascii_numeric(o, indent, "sclk", (signed) m_sclk);
	}
	if (full || has_wp()) {
		ascii_numeric(o, indent, "wp", (signed) m_wp);
	}
	if (full || has_hold()) {
		ascii_numeric(o, indent, "hold", (signed) m_hold);
	}
	if (full || has_options()) {
		ascii_indent(o,indent,"options");
		o << "{ // (spiopt_t) " << (unsigned)m_options;
		++indent;
		gen_indent(o,indent);
		o << ".txlsbfirst";
		o << (options_txlsbfirst() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".rxlsbfirst";
		o << (options_rxlsbfirst() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".mosi_as_miso";
		o << (options_mosi_as_miso() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".positive_cs";
		o << (options_positive_cs() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".full_duplex";
		o << (options_full_duplex() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".pol_hi";
		o << (options_pol_hi() ? " = true;" : " = false;");
		gen_indent(o,indent);
		o << ".pha_hi";
		o << (options_pha_hi() ? " = true;" : " = false;");
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	if (full || has_dma()) {
		ascii_numeric(o, indent, "dma", (signed) m_dma);
	}
	if (full || (0 != m_devices.size())) {
		gen_indent(o,indent);
		size_t s_devices = m_devices.size();
		o << "devices[" << s_devices << "] = {";
		++indent;
		for (size_t i = 0, e = s_devices; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_devices[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void SpiBusConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_host()) {
		pbt_numeric(o, indent, "host", (signed) m_host);
	}
	if (full || has_mosi()) {
		pbt_numeric(o, indent, "mosi", (signed) m_mosi);
	}
	if (full || has_miso()) {
		pbt_numeric(o, indent, "miso", (signed) m_miso);
	}
	if (full || has_sclk()) {
		pbt_numeric(o, indent, "sclk", (signed) m_sclk);
	}
	if (full || has_wp()) {
		pbt_numeric(o, indent, "wp", (signed) m_wp);
	}
	if (full || has_hold()) {
		pbt_numeric(o, indent, "hold", (signed) m_hold);
	}
	if (full || has_options()) {
		pbt_numeric(o, indent, "options", (unsigned) m_options);
	}
	if (full || has_dma()) {
		pbt_numeric(o, indent, "dma", (signed) m_dma);
	}
	if (full || (0 != m_devices.size())) {
		gen_indent(o,indent);
		size_t s_devices = m_devices.size();
		o << "devices: [";
		++indent;
		for (size_t i = 0, e = s_devices; i != e; ++i) {
			gen_indent(o,indent);
			m_devices[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t SpiBusConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -373;
		a += fn;
		switch (fid) {
		case 0x8:	// host id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -374;
				a += n;
				set_host(varint_sint(v));
			}
			break;
		case 0x10:	// mosi id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -375;
				a += n;
				set_mosi(varint_sint(v));
			}
			break;
		case 0x18:	// miso id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -376;
				a += n;
				set_miso(varint_sint(v));
			}
			break;
		case 0x20:	// sclk id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -377;
				a += n;
				set_sclk(varint_sint(v));
			}
			break;
		case 0x28:	// wp id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -378;
				a += n;
				set_wp(varint_sint(v));
			}
			break;
		case 0x30:	// hold id 6, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -379;
				a += n;
				set_hold(varint_sint(v));
			}
			break;
		case 0x38:	// options id 7, type spiopt_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -380;
				a += n;
				set_options((spiopt_t) v);
			}
			break;
		case 0x40:	// dma id 8, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -381;
				a += n;
				set_dma(varint_sint(v));
			}
			break;
		case 0x4a:	// devices id 9, type SpiDeviceConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -382;
				m_devices.emplace_back();
				if (v != 0) {
					n = m_devices.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -383;
					a += v;
				}
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -384;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -385;
	return a-(const uint8_t *)b;
}

ssize_t SpiBusConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has host?
	if (m_host != -1) {
		// 'host': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -386;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_host));
		if (n <= 0)
			return -387;
		a += n;
	}
	// has mosi?
	if (m_mosi != -1) {
		// 'mosi': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -388;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_mosi));
		if (n <= 0)
			return -389;
		a += n;
	}
	// has miso?
	if (m_miso != -1) {
		// 'miso': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -390;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_miso));
		if (n <= 0)
			return -391;
		a += n;
	}
	// has sclk?
	if (m_sclk != -1) {
		// 'sclk': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -392;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_sclk));
		if (n <= 0)
			return -393;
		a += n;
	}
	// has wp?
	if (m_wp != -1) {
		// 'wp': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -394;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_wp));
		if (n <= 0)
			return -395;
		a += n;
	}
	// has hold?
	if (m_hold != -1) {
		// 'hold': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -396;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_hold));
		if (n <= 0)
			return -397;
		a += n;
	}
	// has options?
	if (0 != (p_validbits & ((uint8_t)1U << vb_options))) {
		// 'options': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -398;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_options);
		if (n <= 0)
			return -399;
		a += n;
	}
	// has dma?
	if (m_dma != -1) {
		// 'dma': id=8, encoding=varint, tag=0x40
		if (a >= e)
			return -400;
		*a++ = 0x40;
		n = write_varint(a,e-a,sint_varint(m_dma));
		if (n <= 0)
			return -401;
		a += n;
	}
	for (const auto &x : m_devices) {
		// 'devices': id=9, encoding=lenpfx, tag=0x4a
		if (a >= e)
			return -402;
		*a++ = 0x4a;
		ssize_t devices_ws = x.calcSize();
		n = write_varint(a,e-a,devices_ws);
		a += n;
		if ((n <= 0) || (devices_ws > (e-a)))
			return -403;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == devices_ws);
	}
	assert(a <= e);
	return a-b;
}

void SpiBusConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_host()) {
		fsep = json_indent(json,indLvl,fsep,"host");
		json << (int) m_host;
	}
	if (full || has_mosi()) {
		fsep = json_indent(json,indLvl,fsep,"mosi");
		json << (int) m_mosi;
	}
	if (full || has_miso()) {
		fsep = json_indent(json,indLvl,fsep,"miso");
		json << (int) m_miso;
	}
	if (full || has_sclk()) {
		fsep = json_indent(json,indLvl,fsep,"sclk");
		json << (int) m_sclk;
	}
	if (full || has_wp()) {
		fsep = json_indent(json,indLvl,fsep,"wp");
		json << (int) m_wp;
	}
	if (full || has_hold()) {
		fsep = json_indent(json,indLvl,fsep,"hold");
		json << (int) m_hold;
	}
	if (full || has_options()) {
		fsep = json_indent(json,indLvl,fsep,"options");
		json << (unsigned) m_options;
	}
	if (full || has_dma()) {
		fsep = json_indent(json,indLvl,fsep,"dma");
		json << (int) m_dma;
	}
	if (size_t s = m_devices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"devices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_devices[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SpiBusConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 host, id 1
	if (m_host != -1) {
		r += wiresize_s((varint_t)m_host) + 1 /* tag(host) 0x8 */;
	}
	// optional sint8 mosi, id 2
	if (m_mosi != -1) {
		r += wiresize_s((varint_t)m_mosi) + 1 /* tag(mosi) 0x10 */;
	}
	// optional sint8 miso, id 3
	if (m_miso != -1) {
		r += wiresize_s((varint_t)m_miso) + 1 /* tag(miso) 0x18 */;
	}
	// optional sint8 sclk, id 4
	if (m_sclk != -1) {
		r += wiresize_s((varint_t)m_sclk) + 1 /* tag(sclk) 0x20 */;
	}
	// optional sint8 wp, id 5
	if (m_wp != -1) {
		r += wiresize_s((varint_t)m_wp) + 1 /* tag(wp) 0x28 */;
	}
	// optional sint8 hold, id 6
	if (m_hold != -1) {
		r += wiresize_s((varint_t)m_hold) + 1 /* tag(hold) 0x30 */;
	}
	// optional spiopt_t options, id 7
	if (0 != (p_validbits & ((uint8_t)1U << vb_options))) {
		r += wiresize((varint_t)m_options) + 1 /* tag(options) 0x38 */;
	}
	// optional sint8 dma, id 8
	if (m_dma != -1) {
		r += wiresize_s((varint_t)m_dma) + 1 /* tag(dma) 0x40 */;
	}
	// repeated SpiDeviceConfig devices, id 9
	// repeated message devices
	for (size_t x = 0, y = m_devices.size(); x < y; ++x) {
		size_t s = m_devices[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(devices) 0x48 */;
	}
	return r;
}

bool SpiBusConfig::operator != (const SpiBusConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_host() && (m_host != r.m_host))
		return true;
	if (has_mosi() && (m_mosi != r.m_mosi))
		return true;
	if (has_miso() && (m_miso != r.m_miso))
		return true;
	if (has_sclk() && (m_sclk != r.m_sclk))
		return true;
	if (has_wp() && (m_wp != r.m_wp))
		return true;
	if (has_hold() && (m_hold != r.m_hold))
		return true;
	if (has_options() && (m_options != r.m_options))
		return true;
	if (has_dma() && (m_dma != r.m_dma))
		return true;
	if (m_devices != r.m_devices)
		return true;
	return false;
}


bool SpiBusConfig::operator == (const SpiBusConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SpiBusConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"host")) {
		if (value == 0) {
			clear_host();
			return 0;
		}
		int r = parse_ascii_s8(&m_host,value);
		return r;
	}
	if (0 == strcmp(name,"mosi")) {
		if (value == 0) {
			clear_mosi();
			return 0;
		}
		int r = parse_ascii_s8(&m_mosi,value);
		return r;
	}
	if (0 == strcmp(name,"miso")) {
		if (value == 0) {
			clear_miso();
			return 0;
		}
		int r = parse_ascii_s8(&m_miso,value);
		return r;
	}
	if (0 == strcmp(name,"sclk")) {
		if (value == 0) {
			clear_sclk();
			return 0;
		}
		int r = parse_ascii_s8(&m_sclk,value);
		return r;
	}
	if (0 == strcmp(name,"wp")) {
		if (value == 0) {
			clear_wp();
			return 0;
		}
		int r = parse_ascii_s8(&m_wp,value);
		return r;
	}
	if (0 == strcmp(name,"hold")) {
		if (value == 0) {
			clear_hold();
			return 0;
		}
		int r = parse_ascii_s8(&m_hold,value);
		return r;
	}
	if ((0 == memcmp(name,"options",7)) && ((name[7] == 0) || name[7] == '.')) {
		name += 7;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_options((spiopt_t)ull);
			else if (!strcmp(name,"txlsbfirst"))
				set_options_txlsbfirst((bool)ull);
			else if (!strcmp(name,"rxlsbfirst"))
				set_options_rxlsbfirst((bool)ull);
			else if (!strcmp(name,"mosi_as_miso"))
				set_options_mosi_as_miso((bool)ull);
			else if (!strcmp(name,"positive_cs"))
				set_options_positive_cs((bool)ull);
			else if (!strcmp(name,"full_duplex"))
				set_options_full_duplex((bool)ull);
			else if (!strcmp(name,"pol_hi"))
				set_options_pol_hi((bool)ull);
			else if (!strcmp(name,"pha_hi"))
				set_options_pha_hi((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -404;
		} else if (!strcmp(name,"txlsbfirst")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_txlsbfirst(tmp);
			return r;
		} else if (!strcmp(name,"rxlsbfirst")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_rxlsbfirst(tmp);
			return r;
		} else if (!strcmp(name,"mosi_as_miso")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_mosi_as_miso(tmp);
			return r;
		} else if (!strcmp(name,"positive_cs")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_positive_cs(tmp);
			return r;
		} else if (!strcmp(name,"full_duplex")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_full_duplex(tmp);
			return r;
		} else if (!strcmp(name,"pol_hi")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_pol_hi(tmp);
			return r;
		} else if (!strcmp(name,"pha_hi")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_pha_hi(tmp);
			return r;
		}
	}
	if (0 == strcmp(name,"dma")) {
		if (value == 0) {
			clear_dma();
			return 0;
		}
		int r = parse_ascii_s8(&m_dma,value);
		return r;
	}
	if (0 == memcmp(name,"devices",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_devices();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_devices.size();
				m_devices.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -405;
				if (m_devices.size() <= x)
					return -406;
				if ((idxe[1] == 0) && (value == 0)) {
					m_devices.erase(m_devices.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -407;
			return m_devices[x].setByName(idxe+2,value);
		}
	}
	return -408;
}

Message *SpiBusConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *SpiBusConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	if ((n == 7) && (0 == memcmp("devices",s,7))) {
		if (x < m_devices.size())
			return &m_devices[x];
	}
	return 0;
}

void GpioCluster::clear()
{
	m_name.clear();
	m_base = 0;
	m_numio = 0;
	m_int_a = -1;
	m_int_b = -1;
}

void GpioCluster::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // GpioCluster";
	++indent;
	if (full || has_name()) {
		ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_base()) {
		ascii_numeric(o, indent, "base", (unsigned) m_base);
	}
	if (full || has_numio()) {
		ascii_numeric(o, indent, "numio", (unsigned) m_numio);
	}
	if (full || has_int_a()) {
		ascii_numeric(o, indent, "int_a", (signed) m_int_a);
	}
	if (full || has_int_b()) {
		ascii_numeric(o, indent, "int_b", (signed) m_int_b);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void GpioCluster::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_name()) {
		pbt_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || has_base()) {
		pbt_numeric(o, indent, "base", (unsigned) m_base);
	}
	if (full || has_numio()) {
		pbt_numeric(o, indent, "numio", (unsigned) m_numio);
	}
	if (full || has_int_a()) {
		pbt_numeric(o, indent, "int_a", (signed) m_int_a);
	}
	if (full || has_int_b()) {
		pbt_numeric(o, indent, "int_b", (signed) m_int_b);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t GpioCluster::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -409;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -410;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// base id 2, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -411;
				a += n;
				set_base(v);
			}
			break;
		case 0x18:	// numio id 3, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -412;
				a += n;
				set_numio(v);
			}
			break;
		case 0x20:	// int_a id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -413;
				a += n;
				set_int_a(varint_sint(v));
			}
			break;
		case 0x28:	// int_b id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -414;
				a += n;
				set_int_b(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -415;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -416;
	return a-(const uint8_t *)b;
}

ssize_t GpioCluster::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -417;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -418;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has base?
	if (m_base != 0) {
		// 'base': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -419;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_base);
		if (n <= 0)
			return -420;
		a += n;
	}
	// has numio?
	if (m_numio != 0) {
		// 'numio': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -421;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_numio);
		if (n <= 0)
			return -422;
		a += n;
	}
	// has int_a?
	if (m_int_a != -1) {
		// 'int_a': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -423;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_int_a));
		if (n <= 0)
			return -424;
		a += n;
	}
	// has int_b?
	if (m_int_b != -1) {
		// 'int_b': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -425;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_int_b));
		if (n <= 0)
			return -426;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void GpioCluster::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (full || has_base()) {
		fsep = json_indent(json,indLvl,fsep,"base");
		json << (unsigned) m_base;
	}
	if (full || has_numio()) {
		fsep = json_indent(json,indLvl,fsep,"numio");
		json << (unsigned) m_numio;
	}
	if (full || has_int_a()) {
		fsep = json_indent(json,indLvl,fsep,"int_a");
		json << (int) m_int_a;
	}
	if (full || has_int_b()) {
		fsep = json_indent(json,indLvl,fsep,"int_b");
		json << (int) m_int_b;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t GpioCluster::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional uint8 base, id 2
	if (m_base != 0) {
		r += wiresize((varint_t)m_base) + 1 /* tag(base) 0x10 */;
	}
	// optional uint8 numio, id 3
	if (m_numio != 0) {
		r += wiresize((varint_t)m_numio) + 1 /* tag(numio) 0x18 */;
	}
	// optional sint8 int_a, id 4
	if (m_int_a != -1) {
		r += wiresize_s((varint_t)m_int_a) + 1 /* tag(int_a) 0x20 */;
	}
	// optional sint8 int_b, id 5
	if (m_int_b != -1) {
		r += wiresize_s((varint_t)m_int_b) + 1 /* tag(int_b) 0x28 */;
	}
	return r;
}

bool GpioCluster::operator != (const GpioCluster &r) const
{
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_base() && (m_base != r.m_base))
		return true;
	if (has_numio() && (m_numio != r.m_numio))
		return true;
	if (has_int_a() && (m_int_a != r.m_int_a))
		return true;
	if (has_int_b() && (m_int_b != r.m_int_b))
		return true;
	return false;
}


bool GpioCluster::operator == (const GpioCluster &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int GpioCluster::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"base")) {
		if (value == 0) {
			clear_base();
			return 0;
		}
		int r = parse_ascii_u8(&m_base,value);
		return r;
	}
	if (0 == strcmp(name,"numio")) {
		if (value == 0) {
			clear_numio();
			return 0;
		}
		int r = parse_ascii_u8(&m_numio,value);
		return r;
	}
	if (0 == strcmp(name,"int_a")) {
		if (value == 0) {
			clear_int_a();
			return 0;
		}
		int r = parse_ascii_s8(&m_int_a,value);
		return r;
	}
	if (0 == strcmp(name,"int_b")) {
		if (value == 0) {
			clear_int_b();
			return 0;
		}
		int r = parse_ascii_s8(&m_int_b,value);
		return r;
	}
	return -427;
}

Message *GpioCluster::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *GpioCluster::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void Hlw8012Config::clear()
{
	m_sel = -1;
	m_cf = -1;
	m_cf1 = -1;
}

void Hlw8012Config::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // Hlw8012Config";
	++indent;
	if (full || has_sel()) {
		ascii_numeric(o, indent, "sel", (signed) m_sel);
	}
	if (full || has_cf()) {
		ascii_numeric(o, indent, "cf", (signed) m_cf);
	}
	if (full || has_cf1()) {
		ascii_numeric(o, indent, "cf1", (signed) m_cf1);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void Hlw8012Config::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_sel()) {
		pbt_numeric(o, indent, "sel", (signed) m_sel);
	}
	if (full || has_cf()) {
		pbt_numeric(o, indent, "cf", (signed) m_cf);
	}
	if (full || has_cf1()) {
		pbt_numeric(o, indent, "cf1", (signed) m_cf1);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t Hlw8012Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -428;
		a += fn;
		switch (fid) {
		case 0x10:	// sel id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -429;
				a += n;
				set_sel(varint_sint(v));
			}
			break;
		case 0x18:	// cf id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -430;
				a += n;
				set_cf(varint_sint(v));
			}
			break;
		case 0x20:	// cf1 id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -431;
				a += n;
				set_cf1(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -432;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -433;
	return a-(const uint8_t *)b;
}

ssize_t Hlw8012Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has sel?
	if (m_sel != -1) {
		// 'sel': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -434;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sel));
		if (n <= 0)
			return -435;
		a += n;
	}
	// has cf?
	if (m_cf != -1) {
		// 'cf': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -436;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_cf));
		if (n <= 0)
			return -437;
		a += n;
	}
	// has cf1?
	if (m_cf1 != -1) {
		// 'cf1': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -438;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_cf1));
		if (n <= 0)
			return -439;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Hlw8012Config::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_sel()) {
		fsep = json_indent(json,indLvl,fsep,"sel");
		json << (int) m_sel;
	}
	if (full || has_cf()) {
		fsep = json_indent(json,indLvl,fsep,"cf");
		json << (int) m_cf;
	}
	if (full || has_cf1()) {
		fsep = json_indent(json,indLvl,fsep,"cf1");
		json << (int) m_cf1;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Hlw8012Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 sel, id 2
	if (m_sel != -1) {
		r += wiresize_s((varint_t)m_sel) + 1 /* tag(sel) 0x10 */;
	}
	// optional sint8 cf, id 3
	if (m_cf != -1) {
		r += wiresize_s((varint_t)m_cf) + 1 /* tag(cf) 0x18 */;
	}
	// optional sint8 cf1, id 4
	if (m_cf1 != -1) {
		r += wiresize_s((varint_t)m_cf1) + 1 /* tag(cf1) 0x20 */;
	}
	return r;
}

bool Hlw8012Config::operator != (const Hlw8012Config &r) const
{
	if (has_sel() && (m_sel != r.m_sel))
		return true;
	if (has_cf() && (m_cf != r.m_cf))
		return true;
	if (has_cf1() && (m_cf1 != r.m_cf1))
		return true;
	return false;
}


bool Hlw8012Config::operator == (const Hlw8012Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Hlw8012Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"sel")) {
		if (value == 0) {
			clear_sel();
			return 0;
		}
		int r = parse_ascii_s8(&m_sel,value);
		return r;
	}
	if (0 == strcmp(name,"cf")) {
		if (value == 0) {
			clear_cf();
			return 0;
		}
		int r = parse_ascii_s8(&m_cf,value);
		return r;
	}
	if (0 == strcmp(name,"cf1")) {
		if (value == 0) {
			clear_cf1();
			return 0;
		}
		int r = parse_ascii_s8(&m_cf1,value);
		return r;
	}
	return -440;
}

Message *Hlw8012Config::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *Hlw8012Config::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void SX1276Config::clear()
{
	m_dio0 = -1;
	m_dio1 = -1;
	m_dio2 = -1;
	m_dio3 = -1;
	m_dio4 = -1;
	m_dio5 = -1;
}

void SX1276Config::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // SX1276Config";
	++indent;
	if (full || has_dio0()) {
		ascii_numeric(o, indent, "dio0", (signed) m_dio0);
	}
	if (full || has_dio1()) {
		ascii_numeric(o, indent, "dio1", (signed) m_dio1);
	}
	if (full || has_dio2()) {
		ascii_numeric(o, indent, "dio2", (signed) m_dio2);
	}
	if (full || has_dio3()) {
		ascii_numeric(o, indent, "dio3", (signed) m_dio3);
	}
	if (full || has_dio4()) {
		ascii_numeric(o, indent, "dio4", (signed) m_dio4);
	}
	if (full || has_dio5()) {
		ascii_numeric(o, indent, "dio5", (signed) m_dio5);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void SX1276Config::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_dio0()) {
		pbt_numeric(o, indent, "dio0", (signed) m_dio0);
	}
	if (full || has_dio1()) {
		pbt_numeric(o, indent, "dio1", (signed) m_dio1);
	}
	if (full || has_dio2()) {
		pbt_numeric(o, indent, "dio2", (signed) m_dio2);
	}
	if (full || has_dio3()) {
		pbt_numeric(o, indent, "dio3", (signed) m_dio3);
	}
	if (full || has_dio4()) {
		pbt_numeric(o, indent, "dio4", (signed) m_dio4);
	}
	if (full || has_dio5()) {
		pbt_numeric(o, indent, "dio5", (signed) m_dio5);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t SX1276Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -441;
		a += fn;
		switch (fid) {
		case 0x8:	// dio0 id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -442;
				a += n;
				set_dio0(varint_sint(v));
			}
			break;
		case 0x10:	// dio1 id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -443;
				a += n;
				set_dio1(varint_sint(v));
			}
			break;
		case 0x18:	// dio2 id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -444;
				a += n;
				set_dio2(varint_sint(v));
			}
			break;
		case 0x20:	// dio3 id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -445;
				a += n;
				set_dio3(varint_sint(v));
			}
			break;
		case 0x28:	// dio4 id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -446;
				a += n;
				set_dio4(varint_sint(v));
			}
			break;
		case 0x30:	// dio5 id 6, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -447;
				a += n;
				set_dio5(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -448;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -449;
	return a-(const uint8_t *)b;
}

ssize_t SX1276Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has dio0?
	if (m_dio0 != -1) {
		// 'dio0': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -450;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_dio0));
		if (n <= 0)
			return -451;
		a += n;
	}
	// has dio1?
	if (m_dio1 != -1) {
		// 'dio1': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -452;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_dio1));
		if (n <= 0)
			return -453;
		a += n;
	}
	// has dio2?
	if (m_dio2 != -1) {
		// 'dio2': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -454;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_dio2));
		if (n <= 0)
			return -455;
		a += n;
	}
	// has dio3?
	if (m_dio3 != -1) {
		// 'dio3': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -456;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_dio3));
		if (n <= 0)
			return -457;
		a += n;
	}
	// has dio4?
	if (m_dio4 != -1) {
		// 'dio4': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -458;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_dio4));
		if (n <= 0)
			return -459;
		a += n;
	}
	// has dio5?
	if (m_dio5 != -1) {
		// 'dio5': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -460;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_dio5));
		if (n <= 0)
			return -461;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void SX1276Config::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_dio0()) {
		fsep = json_indent(json,indLvl,fsep,"dio0");
		json << (int) m_dio0;
	}
	if (full || has_dio1()) {
		fsep = json_indent(json,indLvl,fsep,"dio1");
		json << (int) m_dio1;
	}
	if (full || has_dio2()) {
		fsep = json_indent(json,indLvl,fsep,"dio2");
		json << (int) m_dio2;
	}
	if (full || has_dio3()) {
		fsep = json_indent(json,indLvl,fsep,"dio3");
		json << (int) m_dio3;
	}
	if (full || has_dio4()) {
		fsep = json_indent(json,indLvl,fsep,"dio4");
		json << (int) m_dio4;
	}
	if (full || has_dio5()) {
		fsep = json_indent(json,indLvl,fsep,"dio5");
		json << (int) m_dio5;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SX1276Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 dio0, id 1
	if (m_dio0 != -1) {
		r += wiresize_s((varint_t)m_dio0) + 1 /* tag(dio0) 0x8 */;
	}
	// optional sint8 dio1, id 2
	if (m_dio1 != -1) {
		r += wiresize_s((varint_t)m_dio1) + 1 /* tag(dio1) 0x10 */;
	}
	// optional sint8 dio2, id 3
	if (m_dio2 != -1) {
		r += wiresize_s((varint_t)m_dio2) + 1 /* tag(dio2) 0x18 */;
	}
	// optional sint8 dio3, id 4
	if (m_dio3 != -1) {
		r += wiresize_s((varint_t)m_dio3) + 1 /* tag(dio3) 0x20 */;
	}
	// optional sint8 dio4, id 5
	if (m_dio4 != -1) {
		r += wiresize_s((varint_t)m_dio4) + 1 /* tag(dio4) 0x28 */;
	}
	// optional sint8 dio5, id 6
	if (m_dio5 != -1) {
		r += wiresize_s((varint_t)m_dio5) + 1 /* tag(dio5) 0x30 */;
	}
	return r;
}

bool SX1276Config::operator != (const SX1276Config &r) const
{
	if (has_dio0() && (m_dio0 != r.m_dio0))
		return true;
	if (has_dio1() && (m_dio1 != r.m_dio1))
		return true;
	if (has_dio2() && (m_dio2 != r.m_dio2))
		return true;
	if (has_dio3() && (m_dio3 != r.m_dio3))
		return true;
	if (has_dio4() && (m_dio4 != r.m_dio4))
		return true;
	if (has_dio5() && (m_dio5 != r.m_dio5))
		return true;
	return false;
}


bool SX1276Config::operator == (const SX1276Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SX1276Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"dio0")) {
		if (value == 0) {
			clear_dio0();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio0,value);
		return r;
	}
	if (0 == strcmp(name,"dio1")) {
		if (value == 0) {
			clear_dio1();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio1,value);
		return r;
	}
	if (0 == strcmp(name,"dio2")) {
		if (value == 0) {
			clear_dio2();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio2,value);
		return r;
	}
	if (0 == strcmp(name,"dio3")) {
		if (value == 0) {
			clear_dio3();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio3,value);
		return r;
	}
	if (0 == strcmp(name,"dio4")) {
		if (value == 0) {
			clear_dio4();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio4,value);
		return r;
	}
	if (0 == strcmp(name,"dio5")) {
		if (value == 0) {
			clear_dio5();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio5,value);
		return r;
	}
	return -462;
}

Message *SX1276Config::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *SX1276Config::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void Melody::clear()
{
	m_name.clear();
	m_tones.clear();
}

void Melody::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // Melody";
	++indent;
	if (full || has_name()) {
		ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || (0 != m_tones.size())) {
		gen_indent(o,indent);
		size_t s_tones = m_tones.size();
		o << "tones[" << s_tones << "] = {";
		++indent;
		for (size_t i = 0, e = s_tones; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			ascii_numeric(o, indent, 0, m_tones[i]);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void Melody::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_name()) {
		pbt_string(o,indent,m_name.data(),m_name.size(),"name");
	}
	if (full || (0 != m_tones.size())) {
		gen_indent(o,indent);
		size_t s_tones = m_tones.size();
		o << "tones: [";
		++indent;
		for (size_t i = 0, e = s_tones; i != e; ++i) {
			gen_indent(o,indent);
			o << m_tones[i] << ',';
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t Melody::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -463;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -464;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x14:	// tones id 2, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -465;
			m_tones.push_back((uint16_t) read_u16(a));
			a += 2;
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -466;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -467;
	return a-(const uint8_t *)b;
}

ssize_t Melody::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -468;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -469;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	for (auto x : m_tones) {
		// 'tones': id=2, encoding=16bit, tag=0x14
		if (3 > (e-a))
			return -470;
		*a++ = 0x14;
		if ((e-a) < 2)
			return -471;
		write_u16(a,x);
		a += 2;
	}
	assert(a <= e);
	return a-b;
}

void Melody::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (size_t s = m_tones.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"tones\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json << m_tones[i];
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Melody::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// repeated fixed16 tones, id 2
	if (!m_tones.empty()) {
		// tones: non-packed, fixed size elements
		r += m_tones.size() * 3;	// including tag
	}
	return r;
}

bool Melody::operator != (const Melody &r) const
{
	if (has_name() && (m_name != r.m_name))
		return true;
	if (m_tones != r.m_tones)
		return true;
	return false;
}


bool Melody::operator == (const Melody &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Melody::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			m_name.clear();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == memcmp(name,"tones",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_tones();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_tones.size();
				m_tones.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -472;
				if (m_tones.size() <= x)
					return -473;
				if ((idxe[1] == 0) && (value == 0)) {
					m_tones.erase(m_tones.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -474;
			return parse_ascii_u16(&m_tones[x],value);
		}
	}
	return -475;
}

Message *Melody::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *Melody::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void BuzzerConfig::clear()
{
	m_gpio = -1;
	m_melodies.clear();
}

void BuzzerConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // BuzzerConfig";
	++indent;
	if (full || has_gpio()) {
		ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || (0 != m_melodies.size())) {
		gen_indent(o,indent);
		size_t s_melodies = m_melodies.size();
		o << "melodies[" << s_melodies << "] = {";
		++indent;
		for (size_t i = 0, e = s_melodies; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_melodies[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void BuzzerConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_gpio()) {
		pbt_numeric(o, indent, "gpio", (signed) m_gpio);
	}
	if (full || (0 != m_melodies.size())) {
		gen_indent(o,indent);
		size_t s_melodies = m_melodies.size();
		o << "melodies: [";
		++indent;
		for (size_t i = 0, e = s_melodies; i != e; ++i) {
			gen_indent(o,indent);
			m_melodies[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t BuzzerConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -476;
		a += fn;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -477;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x12:	// melodies id 2, type Melody, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -478;
				m_melodies.emplace_back();
				if (v != 0) {
					n = m_melodies.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -479;
					a += v;
				}
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -480;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -481;
	return a-(const uint8_t *)b;
}

ssize_t BuzzerConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -482;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -483;
		a += n;
	}
	for (const auto &x : m_melodies) {
		// 'melodies': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -484;
		*a++ = 0x12;
		ssize_t melodies_ws = x.calcSize();
		n = write_varint(a,e-a,melodies_ws);
		a += n;
		if ((n <= 0) || (melodies_ws > (e-a)))
			return -485;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == melodies_ws);
	}
	assert(a <= e);
	return a-b;
}

void BuzzerConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (size_t s = m_melodies.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"melodies\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_melodies[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t BuzzerConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// repeated Melody melodies, id 2
	// repeated message melodies
	for (size_t x = 0, y = m_melodies.size(); x < y; ++x) {
		size_t s = m_melodies[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(melodies) 0x10 */;
	}
	return r;
}

bool BuzzerConfig::operator != (const BuzzerConfig &r) const
{
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (m_melodies != r.m_melodies)
		return true;
	return false;
}


bool BuzzerConfig::operator == (const BuzzerConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int BuzzerConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == memcmp(name,"melodies",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_melodies();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_melodies.size();
				m_melodies.resize(x+1);
				idxe = (char*)(name + 10);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+9)))
					return -486;
				if (m_melodies.size() <= x)
					return -487;
				if ((idxe[1] == 0) && (value == 0)) {
					m_melodies.erase(m_melodies.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -488;
			return m_melodies[x].setByName(idxe+2,value);
		}
	}
	return -489;
}

Message *BuzzerConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *BuzzerConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	if ((n == 8) && (0 == memcmp("melodies",s,8))) {
		if (x < m_melodies.size())
			return &m_melodies[x];
	}
	return 0;
}

void INA2xxConfig::clear()
{
	m_config = 0;
	m_limit = 0;
	m_mask = 0;
	m_res = 0;
	m_Ilsb = 0;
	m_interval = 10;
	p_validbits = 0;
}

void INA2xxConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // INA2xxConfig";
	++indent;
	if (full || has_config()) {
		ascii_numeric(o, indent, "config", m_config);
	}
	if (full || has_limit()) {
		ascii_numeric(o, indent, "limit", m_limit);
	}
	if (full || has_mask()) {
		ascii_numeric(o, indent, "mask", m_mask);
	}
	if (full || has_res()) {
		ascii_numeric(o, indent, "res", m_res);
	}
	if (full || has_Ilsb()) {
		ascii_numeric(o, indent, "Ilsb", m_Ilsb);
	}
	if (full || has_interval()) {
		ascii_numeric(o, indent, "interval", m_interval);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void INA2xxConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_config()) {
		pbt_numeric(o, indent, "config", m_config);
	}
	if (full || has_limit()) {
		pbt_numeric(o, indent, "limit", m_limit);
	}
	if (full || has_mask()) {
		pbt_numeric(o, indent, "mask", m_mask);
	}
	if (full || has_res()) {
		pbt_numeric(o, indent, "res", m_res);
	}
	if (full || has_Ilsb()) {
		pbt_numeric(o, indent, "Ilsb", m_Ilsb);
	}
	if (full || has_interval()) {
		pbt_numeric(o, indent, "interval", m_interval);
	}
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t INA2xxConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -490;
		a += fn;
		switch (fid) {
		case 0xc:	// config id 1, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -491;
			set_config((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x14:	// limit id 2, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -492;
			set_limit((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x1c:	// mask id 3, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -493;
			set_mask((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x25:	// res id 4, type float, coding 32bit
			if ((a+3) >= e)
				return -494;
			set_res(read_float(a));
			a += 4;
			break;
		case 0x2d:	// Ilsb id 5, type float, coding 32bit
			if ((a+3) >= e)
				return -495;
			set_Ilsb(read_float(a));
			a += 4;
			break;
		case 0x34:	// interval id 6, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -496;
			set_interval((uint16_t) read_u16(a));
			a += 2;
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -497;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -498;
	return a-(const uint8_t *)b;
}

ssize_t INA2xxConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << vb_config))) {
		// 'config': id=1, encoding=16bit, tag=0xc
		if (3 > (e-a))
			return -499;
		*a++ = 0xc;
		write_u16(a,m_config);
		a += 2;
	}
	// has limit?
	if (0 != (p_validbits & ((uint8_t)1U << vb_limit))) {
		// 'limit': id=2, encoding=16bit, tag=0x14
		if (3 > (e-a))
			return -500;
		*a++ = 0x14;
		write_u16(a,m_limit);
		a += 2;
	}
	// has mask?
	if (0 != (p_validbits & ((uint8_t)1U << vb_mask))) {
		// 'mask': id=3, encoding=16bit, tag=0x1c
		if (3 > (e-a))
			return -501;
		*a++ = 0x1c;
		write_u16(a,m_mask);
		a += 2;
	}
	// has res?
	if (0 != (p_validbits & ((uint8_t)1U << vb_res))) {
		// 'res': id=4, encoding=32bit, tag=0x25
		if (5 > (e-a))
			return -502;
		*a++ = 0x25;
		if ((e-a) < 4)
			return -503;
		write_u32(a,mangle_float(m_res));
		a += 4;
	}
	// has Ilsb?
	if (0 != (p_validbits & ((uint8_t)1U << vb_Ilsb))) {
		// 'Ilsb': id=5, encoding=32bit, tag=0x2d
		if (5 > (e-a))
			return -504;
		*a++ = 0x2d;
		if ((e-a) < 4)
			return -505;
		write_u32(a,mangle_float(m_Ilsb));
		a += 4;
	}
	// has interval?
	if (0 != (p_validbits & ((uint8_t)1U << vb_interval))) {
		// 'interval': id=6, encoding=16bit, tag=0x34
		if (3 > (e-a))
			return -506;
		*a++ = 0x34;
		write_u16(a,m_interval);
		a += 2;
	}
	assert(a <= e);
	return a-b;
}

void INA2xxConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (full || has_limit()) {
		fsep = json_indent(json,indLvl,fsep,"limit");
		json << m_limit;
	}
	if (full || has_mask()) {
		fsep = json_indent(json,indLvl,fsep,"mask");
		json << m_mask;
	}
	if (full || has_res()) {
		fsep = json_indent(json,indLvl,fsep,"res");
		to_dblstr(json,m_res);
	}
	if (full || has_Ilsb()) {
		fsep = json_indent(json,indLvl,fsep,"Ilsb");
		to_dblstr(json,m_Ilsb);
	}
	if (full || has_interval()) {
		fsep = json_indent(json,indLvl,fsep,"interval");
		json << m_interval;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t INA2xxConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed16 config, id 1
	if (0 != (p_validbits & ((uint8_t)1U << vb_config))) {
		r += 3;
	}
	// optional fixed16 limit, id 2
	if (0 != (p_validbits & ((uint8_t)1U << vb_limit))) {
		r += 3;
	}
	// optional fixed16 mask, id 3
	if (0 != (p_validbits & ((uint8_t)1U << vb_mask))) {
		r += 3;
	}
	// optional float res, id 4
	if (0 != (p_validbits & ((uint8_t)1U << vb_res))) {
		r += 5;
	}
	// optional float Ilsb, id 5
	if (0 != (p_validbits & ((uint8_t)1U << vb_Ilsb))) {
		r += 5;
	}
	// optional fixed16 interval, id 6
	if (0 != (p_validbits & ((uint8_t)1U << vb_interval))) {
		r += 3;
	}
	return r;
}

bool INA2xxConfig::operator != (const INA2xxConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	if (has_limit() && (m_limit != r.m_limit))
		return true;
	if (has_mask() && (m_mask != r.m_mask))
		return true;
	if (has_res() && (m_res != r.m_res))
		return true;
	if (has_Ilsb() && (m_Ilsb != r.m_Ilsb))
		return true;
	if (has_interval() && (m_interval != r.m_interval))
		return true;
	return false;
}


bool INA2xxConfig::operator == (const INA2xxConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int INA2xxConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"config")) {
		if (value == 0) {
			clear_config();
			return 0;
		}
		int r = parse_ascii_u16(&m_config,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"limit")) {
		if (value == 0) {
			clear_limit();
			return 0;
		}
		int r = parse_ascii_u16(&m_limit,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"mask")) {
		if (value == 0) {
			clear_mask();
			return 0;
		}
		int r = parse_ascii_u16(&m_mask,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"res")) {
		if (value == 0) {
			clear_res();
			return 0;
		}
		int r = parse_ascii_flt(&m_res,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	if (0 == strcmp(name,"Ilsb")) {
		if (value == 0) {
			clear_Ilsb();
			return 0;
		}
		int r = parse_ascii_flt(&m_Ilsb,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 4);
		return r;
	}
	if (0 == strcmp(name,"interval")) {
		if (value == 0) {
			clear_interval();
			return 0;
		}
		int r = parse_ascii_u16(&m_interval,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 5);
		return r;
	}
	return -507;
}

Message *INA2xxConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	return 0;
}

Message *INA2xxConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	return 0;
}

void HardwareConfig::clear()
{
	m_magic = 0xAE54EDCB;
	m_system.clear();
	m_uart.clear();
	m_adc.clear();
	#ifdef CONFIG_TOUCHPAD
	m_touchpad.clear();
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	m_tp_channel.clear();
	#endif // CONFIG_TOUCHPAD
	m_gpios.clear();
	#ifdef CONFIG_SPI
	m_spibus.clear();
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	m_button.clear();
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	m_relay.clear();
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	m_led.clear();
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	m_buzzer.clear();
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	m_hlw8012.clear();
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	m_max7219.clear();
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	m_tlc5947.clear();
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	m_ws2812b.clear();
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	m_dht.clear();
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	m_i2c.clear();
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	m_hcsr04.clear();
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	m_onewire.clear();
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	m_sx1276.clear();
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	m_iocluster.clear();
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	m_display.clear();
	#endif // CONFIG_DISPLAY
	p_validbits = 0;
}

void HardwareConfig::toASCII(stream &o, bool full, size_t indent) const
{
	o << "{ // HardwareConfig";
	++indent;
	if (full || has_magic()) {
		ascii_numeric(o, indent, "magic", m_magic);
	}
	if (full || has_system()) {
		ascii_indent(o,indent,"system");
		m_system.toASCII(o,full,indent);
	}
	if (full || (0 != m_uart.size())) {
		gen_indent(o,indent);
		size_t s_uart = m_uart.size();
		o << "uart[" << s_uart << "] = {";
		++indent;
		for (size_t i = 0, e = s_uart; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_uart[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	if (full || has_adc()) {
		ascii_indent(o,indent,"adc");
		m_adc.toASCII(o,full,indent);
	}
	#ifdef CONFIG_TOUCHPAD
	if (full || has_touchpad()) {
		ascii_indent(o,indent,"touchpad");
		m_touchpad.toASCII(o,full,indent);
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	if (full || (0 != m_tp_channel.size())) {
		gen_indent(o,indent);
		size_t s_tp_channel = m_tp_channel.size();
		o << "tp_channel[" << s_tp_channel << "] = {";
		++indent;
		for (size_t i = 0, e = s_tp_channel; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_tp_channel[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#endif // CONFIG_TOUCHPAD
	if (full || (0 != m_gpios.size())) {
		gen_indent(o,indent);
		size_t s_gpios = m_gpios.size();
		o << "gpios[" << s_gpios << "] = {";
		++indent;
		for (size_t i = 0, e = s_gpios; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_gpios[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#ifdef CONFIG_SPI
	if (full || (0 != m_spibus.size())) {
		gen_indent(o,indent);
		size_t s_spibus = m_spibus.size();
		o << "spibus[" << s_spibus << "] = {";
		++indent;
		for (size_t i = 0, e = s_spibus; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_spibus[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (full || (0 != m_button.size())) {
		gen_indent(o,indent);
		size_t s_button = m_button.size();
		o << "button[" << s_button << "] = {";
		++indent;
		for (size_t i = 0, e = s_button; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_button[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (full || (0 != m_relay.size())) {
		gen_indent(o,indent);
		size_t s_relay = m_relay.size();
		o << "relay[" << s_relay << "] = {";
		++indent;
		for (size_t i = 0, e = s_relay; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_relay[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (full || (0 != m_led.size())) {
		gen_indent(o,indent);
		size_t s_led = m_led.size();
		o << "led[" << s_led << "] = {";
		++indent;
		for (size_t i = 0, e = s_led; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_led[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (full || has_buzzer()) {
		ascii_indent(o,indent,"buzzer");
		m_buzzer.toASCII(o,full,indent);
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (full || has_hlw8012()) {
		ascii_indent(o,indent,"hlw8012");
		m_hlw8012.toASCII(o,full,indent);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (full || has_max7219()) {
		ascii_indent(o,indent,"max7219");
		m_max7219.toASCII(o,full,indent);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (full || has_tlc5947()) {
		ascii_indent(o,indent,"tlc5947");
		m_tlc5947.toASCII(o,full,indent);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (full || (0 != m_ws2812b.size())) {
		gen_indent(o,indent);
		size_t s_ws2812b = m_ws2812b.size();
		o << "ws2812b[" << s_ws2812b << "] = {";
		++indent;
		for (size_t i = 0, e = s_ws2812b; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_ws2812b[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (full || has_dht()) {
		ascii_indent(o,indent,"dht");
		m_dht.toASCII(o,full,indent);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (full || (0 != m_i2c.size())) {
		gen_indent(o,indent);
		size_t s_i2c = m_i2c.size();
		o << "i2c[" << s_i2c << "] = {";
		++indent;
		for (size_t i = 0, e = s_i2c; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_i2c[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (full || (0 != m_hcsr04.size())) {
		gen_indent(o,indent);
		size_t s_hcsr04 = m_hcsr04.size();
		o << "hcsr04[" << s_hcsr04 << "] = {";
		++indent;
		for (size_t i = 0, e = s_hcsr04; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_hcsr04[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (full || has_onewire()) {
		ascii_indent(o,indent,"onewire");
		m_onewire.toASCII(o,full,indent);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (full || has_sx1276()) {
		ascii_indent(o,indent,"sx1276");
		m_sx1276.toASCII(o,full,indent);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (full || (0 != m_iocluster.size())) {
		gen_indent(o,indent);
		size_t s_iocluster = m_iocluster.size();
		o << "iocluster[" << s_iocluster << "] = {";
		++indent;
		for (size_t i = 0, e = s_iocluster; i != e; ++i) {
			gen_indent(o,indent);
			o << '[' << i << "]: ";
			m_iocluster[i].toASCII(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << '}';
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (full || has_display()) {
		ascii_indent(o,indent,"display");
		m_display.toASCII(o,full,indent);
	}
	#endif // CONFIG_DISPLAY
	--indent;
	gen_indent(o,indent);
	o << '}';
}

void HardwareConfig::toPbt(stream &o, bool full, size_t indent) const
{
	o << '{';
	++indent;
	if (full || has_magic()) {
		pbt_numeric(o, indent, "magic", m_magic);
	}
	if (full || has_system()) {
		pbt_indent(o,indent,"system");
		m_system.toPbt(o,full,indent);
	}
	if (full || (0 != m_uart.size())) {
		gen_indent(o,indent);
		size_t s_uart = m_uart.size();
		o << "uart: [";
		++indent;
		for (size_t i = 0, e = s_uart; i != e; ++i) {
			gen_indent(o,indent);
			m_uart[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	if (full || has_adc()) {
		pbt_indent(o,indent,"adc");
		m_adc.toPbt(o,full,indent);
	}
	#ifdef CONFIG_TOUCHPAD
	if (full || has_touchpad()) {
		pbt_indent(o,indent,"touchpad");
		m_touchpad.toPbt(o,full,indent);
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	if (full || (0 != m_tp_channel.size())) {
		gen_indent(o,indent);
		size_t s_tp_channel = m_tp_channel.size();
		o << "tp_channel: [";
		++indent;
		for (size_t i = 0, e = s_tp_channel; i != e; ++i) {
			gen_indent(o,indent);
			m_tp_channel[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#endif // CONFIG_TOUCHPAD
	if (full || (0 != m_gpios.size())) {
		gen_indent(o,indent);
		size_t s_gpios = m_gpios.size();
		o << "gpios: [";
		++indent;
		for (size_t i = 0, e = s_gpios; i != e; ++i) {
			gen_indent(o,indent);
			m_gpios[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#ifdef CONFIG_SPI
	if (full || (0 != m_spibus.size())) {
		gen_indent(o,indent);
		size_t s_spibus = m_spibus.size();
		o << "spibus: [";
		++indent;
		for (size_t i = 0, e = s_spibus; i != e; ++i) {
			gen_indent(o,indent);
			m_spibus[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (full || (0 != m_button.size())) {
		gen_indent(o,indent);
		size_t s_button = m_button.size();
		o << "button: [";
		++indent;
		for (size_t i = 0, e = s_button; i != e; ++i) {
			gen_indent(o,indent);
			m_button[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (full || (0 != m_relay.size())) {
		gen_indent(o,indent);
		size_t s_relay = m_relay.size();
		o << "relay: [";
		++indent;
		for (size_t i = 0, e = s_relay; i != e; ++i) {
			gen_indent(o,indent);
			m_relay[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (full || (0 != m_led.size())) {
		gen_indent(o,indent);
		size_t s_led = m_led.size();
		o << "led: [";
		++indent;
		for (size_t i = 0, e = s_led; i != e; ++i) {
			gen_indent(o,indent);
			m_led[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (full || has_buzzer()) {
		pbt_indent(o,indent,"buzzer");
		m_buzzer.toPbt(o,full,indent);
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (full || has_hlw8012()) {
		pbt_indent(o,indent,"hlw8012");
		m_hlw8012.toPbt(o,full,indent);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (full || has_max7219()) {
		pbt_indent(o,indent,"max7219");
		m_max7219.toPbt(o,full,indent);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (full || has_tlc5947()) {
		pbt_indent(o,indent,"tlc5947");
		m_tlc5947.toPbt(o,full,indent);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (full || (0 != m_ws2812b.size())) {
		gen_indent(o,indent);
		size_t s_ws2812b = m_ws2812b.size();
		o << "ws2812b: [";
		++indent;
		for (size_t i = 0, e = s_ws2812b; i != e; ++i) {
			gen_indent(o,indent);
			m_ws2812b[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (full || has_dht()) {
		pbt_indent(o,indent,"dht");
		m_dht.toPbt(o,full,indent);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (full || (0 != m_i2c.size())) {
		gen_indent(o,indent);
		size_t s_i2c = m_i2c.size();
		o << "i2c: [";
		++indent;
		for (size_t i = 0, e = s_i2c; i != e; ++i) {
			gen_indent(o,indent);
			m_i2c[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (full || (0 != m_hcsr04.size())) {
		gen_indent(o,indent);
		size_t s_hcsr04 = m_hcsr04.size();
		o << "hcsr04: [";
		++indent;
		for (size_t i = 0, e = s_hcsr04; i != e; ++i) {
			gen_indent(o,indent);
			m_hcsr04[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (full || has_onewire()) {
		pbt_indent(o,indent,"onewire");
		m_onewire.toPbt(o,full,indent);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (full || has_sx1276()) {
		pbt_indent(o,indent,"sx1276");
		m_sx1276.toPbt(o,full,indent);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (full || (0 != m_iocluster.size())) {
		gen_indent(o,indent);
		size_t s_iocluster = m_iocluster.size();
		o << "iocluster: [";
		++indent;
		for (size_t i = 0, e = s_iocluster; i != e; ++i) {
			gen_indent(o,indent);
			m_iocluster[i].toPbt(o,full,indent);
		}
		--indent;
		gen_indent(o,indent);
		o << ']';
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (full || has_display()) {
		pbt_indent(o,indent,"display");
		m_display.toPbt(o,full,indent);
	}
	#endif // CONFIG_DISPLAY
	--indent;
	gen_indent(o,indent);
	o << '}';
}

ssize_t HardwareConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -508;
		a += fn;
		switch (fid) {
		case 0x5:	// magic id 0, type uint32_t, coding 32bit
			if ((a+3) >= e)
				return -509;
			set_magic((uint32_t) read_u32(a));
			a += 4;
			break;
		case 0xa:	// system id 1, type SystemConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -510;
				if (v != 0) {
					n = m_system.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -511;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 1);
			break;
		case 0x1a:	// uart id 3, type UartConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -512;
				m_uart.emplace_back();
				if (v != 0) {
					n = m_uart.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -513;
					a += v;
				}
			}
			break;
		case 0x22:	// adc id 4, type AdcConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -514;
				if (v != 0) {
					n = m_adc.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -515;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 2);
			break;
			#ifdef CONFIG_TOUCHPAD
		case 0x2a:	// touchpad id 5, type TouchpadConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -516;
				if (v != 0) {
					n = m_touchpad.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -517;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 3);
			break;
			#endif // CONFIG_TOUCHPAD
			#ifdef CONFIG_TOUCHPAD
		case 0x32:	// tp_channel id 6, type TouchChannelConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -518;
				m_tp_channel.emplace_back();
				if (v != 0) {
					n = m_tp_channel.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -519;
					a += v;
				}
			}
			break;
			#endif // CONFIG_TOUCHPAD
		case 0x3a:	// gpios id 7, type GpioConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -520;
				m_gpios.emplace_back();
				if (v != 0) {
					n = m_gpios.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -521;
					a += v;
				}
			}
			break;
			#ifdef CONFIG_SPI
		case 0x42:	// spibus id 8, type SpiBusConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -522;
				m_spibus.emplace_back();
				if (v != 0) {
					n = m_spibus.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -523;
					a += v;
				}
			}
			break;
			#endif // CONFIG_SPI
			#ifdef CONFIG_BUTTON
		case 0x82:	// button id 16, type ButtonConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -524;
				m_button.emplace_back();
				if (v != 0) {
					n = m_button.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -525;
					a += v;
				}
			}
			break;
			#endif // CONFIG_BUTTON
			#ifdef CONFIG_RELAY
		case 0x8a:	// relay id 17, type RelayConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -526;
				m_relay.emplace_back();
				if (v != 0) {
					n = m_relay.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -527;
					a += v;
				}
			}
			break;
			#endif // CONFIG_RELAY
			#ifdef CONFIG_LEDS
		case 0x92:	// led id 18, type LedConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -528;
				m_led.emplace_back();
				if (v != 0) {
					n = m_led.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -529;
					a += v;
				}
			}
			break;
			#endif // CONFIG_LEDS
			#ifdef CONFIG_BUZZER
		case 0x9a:	// buzzer id 19, type BuzzerConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -530;
				if (v != 0) {
					n = m_buzzer.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -531;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 4);
			break;
			#endif // CONFIG_BUZZER
			#ifdef CONFIG_HLW8012
		case 0xa2:	// hlw8012 id 20, type Hlw8012Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -532;
				if (v != 0) {
					n = m_hlw8012.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -533;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 5);
			break;
			#endif // CONFIG_HLW8012
			#ifdef CONFIG_MAX7219
		case 0x102:	// max7219 id 32, type Max7219Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -534;
				if (v != 0) {
					n = m_max7219.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -535;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 6);
			break;
			#endif // CONFIG_MAX7219
			#ifdef CONFIG_TLC5947
		case 0x10a:	// tlc5947 id 33, type Tlc5947Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -536;
				if (v != 0) {
					n = m_tlc5947.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -537;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 7);
			break;
			#endif // CONFIG_TLC5947
			#ifdef CONFIG_RGBLEDS
		case 0x112:	// ws2812b id 34, type Ws2812bConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -538;
				m_ws2812b.emplace_back();
				if (v != 0) {
					n = m_ws2812b.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -539;
					a += v;
				}
			}
			break;
			#endif // CONFIG_RGBLEDS
			#ifdef CONFIG_DHT
		case 0x11a:	// dht id 35, type DhtConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -540;
				if (v != 0) {
					n = m_dht.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -541;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 8);
			break;
			#endif // CONFIG_DHT
			#ifdef CONFIG_I2C
		case 0x122:	// i2c id 36, type I2CConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -542;
				m_i2c.emplace_back();
				if (v != 0) {
					n = m_i2c.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -543;
					a += v;
				}
			}
			break;
			#endif // CONFIG_I2C
			#ifdef CONFIG_HCSR04
		case 0x12a:	// hcsr04 id 37, type HcSr04Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -544;
				m_hcsr04.emplace_back();
				if (v != 0) {
					n = m_hcsr04.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -545;
					a += v;
				}
			}
			break;
			#endif // CONFIG_HCSR04
			#ifdef CONFIG_ONEWIRE
		case 0x132:	// onewire id 38, type OneWireConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -546;
				if (v != 0) {
					n = m_onewire.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -547;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 9);
			break;
			#endif // CONFIG_ONEWIRE
			#ifdef CONFIG_SX1276
		case 0x13a:	// sx1276 id 39, type SX1276Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -548;
				if (v != 0) {
					n = m_sx1276.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -549;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 10);
			break;
			#endif // CONFIG_SX1276
			#ifdef CONFIG_IOEXTENDERS
		case 0x142:	// iocluster id 40, type GpioCluster, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -550;
				m_iocluster.emplace_back();
				if (v != 0) {
					n = m_iocluster.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -551;
					a += v;
				}
			}
			break;
			#endif // CONFIG_IOEXTENDERS
			#ifdef CONFIG_DISPLAY
		case 0x192:	// display id 50, type DisplayConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -552;
				if (v != 0) {
					n = m_display.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -553;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 11);
			break;
			#endif // CONFIG_DISPLAY
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -554;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -555;
	return a-(const uint8_t *)b;
}

ssize_t HardwareConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has magic?
	if (0 != (p_validbits & ((uint16_t)1U << vb_magic))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		if (5 > (e-a))
			return -556;
		*a++ = 0x5;
		if ((e-a) < 4)
			return -557;
		write_u32(a,(uint32_t)m_magic);
		a += 4;
	}
	// has system?
	if (0 != (p_validbits & ((uint16_t)1U << vb_system))) {
		// 'system': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -558;
		*a++ = 0xa;
		ssize_t system_ws = m_system.calcSize();
		n = write_varint(a,e-a,system_ws);
		a += n;
		if ((n <= 0) || (system_ws > (e-a)))
			return -559;
		n = m_system.toMemory(a,e-a);
		a += n;
		assert(n == system_ws);
	}
	for (const auto &x : m_uart) {
		// 'uart': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -560;
		*a++ = 0x1a;
		ssize_t uart_ws = x.calcSize();
		n = write_varint(a,e-a,uart_ws);
		a += n;
		if ((n <= 0) || (uart_ws > (e-a)))
			return -561;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == uart_ws);
	}
	// has adc?
	if (0 != (p_validbits & ((uint16_t)1U << vb_adc))) {
		// 'adc': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -562;
		*a++ = 0x22;
		ssize_t adc_ws = m_adc.calcSize();
		n = write_varint(a,e-a,adc_ws);
		a += n;
		if ((n <= 0) || (adc_ws > (e-a)))
			return -563;
		n = m_adc.toMemory(a,e-a);
		a += n;
		assert(n == adc_ws);
	}
	#ifdef CONFIG_TOUCHPAD
	// has touchpad?
	if (0 != (p_validbits & ((uint16_t)1U << vb_touchpad))) {
		// 'touchpad': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -564;
		*a++ = 0x2a;
		ssize_t touchpad_ws = m_touchpad.calcSize();
		n = write_varint(a,e-a,touchpad_ws);
		a += n;
		if ((n <= 0) || (touchpad_ws > (e-a)))
			return -565;
		n = m_touchpad.toMemory(a,e-a);
		a += n;
		assert(n == touchpad_ws);
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	for (const auto &x : m_tp_channel) {
		// 'tp_channel': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -566;
		*a++ = 0x32;
		ssize_t tp_channel_ws = x.calcSize();
		n = write_varint(a,e-a,tp_channel_ws);
		a += n;
		if ((n <= 0) || (tp_channel_ws > (e-a)))
			return -567;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == tp_channel_ws);
	}
	#endif // CONFIG_TOUCHPAD
	for (const auto &x : m_gpios) {
		// 'gpios': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -568;
		*a++ = 0x3a;
		ssize_t gpios_ws = x.calcSize();
		n = write_varint(a,e-a,gpios_ws);
		a += n;
		if ((n <= 0) || (gpios_ws > (e-a)))
			return -569;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == gpios_ws);
	}
	#ifdef CONFIG_SPI
	for (const auto &x : m_spibus) {
		// 'spibus': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -570;
		*a++ = 0x42;
		ssize_t spibus_ws = x.calcSize();
		n = write_varint(a,e-a,spibus_ws);
		a += n;
		if ((n <= 0) || (spibus_ws > (e-a)))
			return -571;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == spibus_ws);
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	for (const auto &x : m_button) {
		// 'button': id=16, encoding=lenpfx, tag=0x82
		if (2 > (e-a))
			return -572;
		*a++ = 0x82;
		*a++ = 0x1;
		ssize_t button_ws = x.calcSize();
		n = write_varint(a,e-a,button_ws);
		a += n;
		if ((n <= 0) || (button_ws > (e-a)))
			return -573;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == button_ws);
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	for (const auto &x : m_relay) {
		// 'relay': id=17, encoding=lenpfx, tag=0x8a
		if (2 > (e-a))
			return -574;
		*a++ = 0x8a;
		*a++ = 0x1;
		ssize_t relay_ws = x.calcSize();
		n = write_varint(a,e-a,relay_ws);
		a += n;
		if ((n <= 0) || (relay_ws > (e-a)))
			return -575;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == relay_ws);
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	for (const auto &x : m_led) {
		// 'led': id=18, encoding=lenpfx, tag=0x92
		if (2 > (e-a))
			return -576;
		*a++ = 0x92;
		*a++ = 0x1;
		ssize_t led_ws = x.calcSize();
		n = write_varint(a,e-a,led_ws);
		a += n;
		if ((n <= 0) || (led_ws > (e-a)))
			return -577;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == led_ws);
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	// has buzzer?
	if (0 != (p_validbits & ((uint16_t)1U << vb_buzzer))) {
		// 'buzzer': id=19, encoding=lenpfx, tag=0x9a
		if (2 > (e-a))
			return -578;
		*a++ = 0x9a;
		*a++ = 0x1;
		ssize_t buzzer_ws = m_buzzer.calcSize();
		n = write_varint(a,e-a,buzzer_ws);
		a += n;
		if ((n <= 0) || (buzzer_ws > (e-a)))
			return -579;
		n = m_buzzer.toMemory(a,e-a);
		a += n;
		assert(n == buzzer_ws);
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	// has hlw8012?
	if (0 != (p_validbits & ((uint16_t)1U << vb_hlw8012))) {
		// 'hlw8012': id=20, encoding=lenpfx, tag=0xa2
		if (2 > (e-a))
			return -580;
		*a++ = 0xa2;
		*a++ = 0x1;
		ssize_t hlw8012_ws = m_hlw8012.calcSize();
		n = write_varint(a,e-a,hlw8012_ws);
		a += n;
		if ((n <= 0) || (hlw8012_ws > (e-a)))
			return -581;
		n = m_hlw8012.toMemory(a,e-a);
		a += n;
		assert(n == hlw8012_ws);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	// has max7219?
	if (0 != (p_validbits & ((uint16_t)1U << vb_max7219))) {
		// 'max7219': id=32, encoding=lenpfx, tag=0x102
		if (2 > (e-a))
			return -582;
		*a++ = 0x82;
		*a++ = 0x2;
		ssize_t max7219_ws = m_max7219.calcSize();
		n = write_varint(a,e-a,max7219_ws);
		a += n;
		if ((n <= 0) || (max7219_ws > (e-a)))
			return -583;
		n = m_max7219.toMemory(a,e-a);
		a += n;
		assert(n == max7219_ws);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	// has tlc5947?
	if (0 != (p_validbits & ((uint16_t)1U << vb_tlc5947))) {
		// 'tlc5947': id=33, encoding=lenpfx, tag=0x10a
		if (2 > (e-a))
			return -584;
		*a++ = 0x8a;
		*a++ = 0x2;
		ssize_t tlc5947_ws = m_tlc5947.calcSize();
		n = write_varint(a,e-a,tlc5947_ws);
		a += n;
		if ((n <= 0) || (tlc5947_ws > (e-a)))
			return -585;
		n = m_tlc5947.toMemory(a,e-a);
		a += n;
		assert(n == tlc5947_ws);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	for (const auto &x : m_ws2812b) {
		// 'ws2812b': id=34, encoding=lenpfx, tag=0x112
		if (2 > (e-a))
			return -586;
		*a++ = 0x92;
		*a++ = 0x2;
		ssize_t ws2812b_ws = x.calcSize();
		n = write_varint(a,e-a,ws2812b_ws);
		a += n;
		if ((n <= 0) || (ws2812b_ws > (e-a)))
			return -587;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == ws2812b_ws);
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	// has dht?
	if (0 != (p_validbits & ((uint16_t)1U << vb_dht))) {
		// 'dht': id=35, encoding=lenpfx, tag=0x11a
		if (2 > (e-a))
			return -588;
		*a++ = 0x9a;
		*a++ = 0x2;
		ssize_t dht_ws = m_dht.calcSize();
		n = write_varint(a,e-a,dht_ws);
		a += n;
		if ((n <= 0) || (dht_ws > (e-a)))
			return -589;
		n = m_dht.toMemory(a,e-a);
		a += n;
		assert(n == dht_ws);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	for (const auto &x : m_i2c) {
		// 'i2c': id=36, encoding=lenpfx, tag=0x122
		if (2 > (e-a))
			return -590;
		*a++ = 0xa2;
		*a++ = 0x2;
		ssize_t i2c_ws = x.calcSize();
		n = write_varint(a,e-a,i2c_ws);
		a += n;
		if ((n <= 0) || (i2c_ws > (e-a)))
			return -591;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == i2c_ws);
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	for (const auto &x : m_hcsr04) {
		// 'hcsr04': id=37, encoding=lenpfx, tag=0x12a
		if (2 > (e-a))
			return -592;
		*a++ = 0xaa;
		*a++ = 0x2;
		ssize_t hcsr04_ws = x.calcSize();
		n = write_varint(a,e-a,hcsr04_ws);
		a += n;
		if ((n <= 0) || (hcsr04_ws > (e-a)))
			return -593;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == hcsr04_ws);
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	// has onewire?
	if (0 != (p_validbits & ((uint16_t)1U << vb_onewire))) {
		// 'onewire': id=38, encoding=lenpfx, tag=0x132
		if (2 > (e-a))
			return -594;
		*a++ = 0xb2;
		*a++ = 0x2;
		ssize_t onewire_ws = m_onewire.calcSize();
		n = write_varint(a,e-a,onewire_ws);
		a += n;
		if ((n <= 0) || (onewire_ws > (e-a)))
			return -595;
		n = m_onewire.toMemory(a,e-a);
		a += n;
		assert(n == onewire_ws);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	// has sx1276?
	if (0 != (p_validbits & ((uint16_t)1U << vb_sx1276))) {
		// 'sx1276': id=39, encoding=lenpfx, tag=0x13a
		if (2 > (e-a))
			return -596;
		*a++ = 0xba;
		*a++ = 0x2;
		ssize_t sx1276_ws = m_sx1276.calcSize();
		n = write_varint(a,e-a,sx1276_ws);
		a += n;
		if ((n <= 0) || (sx1276_ws > (e-a)))
			return -597;
		n = m_sx1276.toMemory(a,e-a);
		a += n;
		assert(n == sx1276_ws);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	for (const auto &x : m_iocluster) {
		// 'iocluster': id=40, encoding=lenpfx, tag=0x142
		if (2 > (e-a))
			return -598;
		*a++ = 0xc2;
		*a++ = 0x2;
		ssize_t iocluster_ws = x.calcSize();
		n = write_varint(a,e-a,iocluster_ws);
		a += n;
		if ((n <= 0) || (iocluster_ws > (e-a)))
			return -599;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == iocluster_ws);
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	// has display?
	if (0 != (p_validbits & ((uint16_t)1U << vb_display))) {
		// 'display': id=50, encoding=lenpfx, tag=0x192
		if (2 > (e-a))
			return -600;
		*a++ = 0x92;
		*a++ = 0x3;
		ssize_t display_ws = m_display.calcSize();
		n = write_varint(a,e-a,display_ws);
		a += n;
		if ((n <= 0) || (display_ws > (e-a)))
			return -601;
		n = m_display.toMemory(a,e-a);
		a += n;
		assert(n == display_ws);
	}
	#endif // CONFIG_DISPLAY
	assert(a <= e);
	return a-b;
}

void HardwareConfig::toJSON(stream &json, bool full, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (full || has_magic()) {
		fsep = json_indent(json,indLvl,fsep,"magic");
		json << m_magic;
	}
	if (full || has_system()) {
		fsep = json_indent(json,indLvl,fsep,"system");
		m_system.toJSON(json,full,indLvl);
	}
	if (size_t s = m_uart.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"uart\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_uart[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (full || has_adc()) {
		fsep = json_indent(json,indLvl,fsep,"adc");
		m_adc.toJSON(json,full,indLvl);
	}
	#ifdef CONFIG_TOUCHPAD
	if (full || has_touchpad()) {
		fsep = json_indent(json,indLvl,fsep,"touchpad");
		m_touchpad.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	if (size_t s = m_tp_channel.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"tp_channel\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_tp_channel[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_TOUCHPAD
	if (size_t s = m_gpios.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"gpios\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_gpios[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_SPI
	if (size_t s = m_spibus.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"spibus\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_spibus[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (size_t s = m_button.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"button\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_button[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (size_t s = m_relay.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"relay\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_relay[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (size_t s = m_led.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"led\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_led[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (full || has_buzzer()) {
		fsep = json_indent(json,indLvl,fsep,"buzzer");
		m_buzzer.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (full || has_hlw8012()) {
		fsep = json_indent(json,indLvl,fsep,"hlw8012");
		m_hlw8012.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (full || has_max7219()) {
		fsep = json_indent(json,indLvl,fsep,"max7219");
		m_max7219.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (full || has_tlc5947()) {
		fsep = json_indent(json,indLvl,fsep,"tlc5947");
		m_tlc5947.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (size_t s = m_ws2812b.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"ws2812b\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_ws2812b[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (full || has_dht()) {
		fsep = json_indent(json,indLvl,fsep,"dht");
		m_dht.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (size_t s = m_i2c.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"i2c\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_i2c[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (size_t s = m_hcsr04.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"hcsr04\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_hcsr04[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (full || has_onewire()) {
		fsep = json_indent(json,indLvl,fsep,"onewire");
		m_onewire.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (full || has_sx1276()) {
		fsep = json_indent(json,indLvl,fsep,"sx1276");
		m_sx1276.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (size_t s = m_iocluster.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"iocluster\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_iocluster[i].toJSON(json,full,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (full || has_display()) {
		fsep = json_indent(json,indLvl,fsep,"display");
		m_display.toJSON(json,full,indLvl);
	}
	#endif // CONFIG_DISPLAY
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t HardwareConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed32 magic, id 0
	if (0 != (p_validbits & ((uint16_t)1U << vb_magic))) {
		r += 5;
	}
	// optional SystemConfig system, id 1
	if (0 != (p_validbits & ((uint16_t)1U << vb_system))) {
		size_t system_s = m_system.calcSize();
		r += system_s + wiresize(system_s) + 1 /* tag(system) 0x8 */;
	}
	// repeated UartConfig uart, id 3
	// repeated message uart
	for (size_t x = 0, y = m_uart.size(); x < y; ++x) {
		size_t s = m_uart[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(uart) 0x18 */;
	}
	// optional AdcConfig adc, id 4
	if (0 != (p_validbits & ((uint16_t)1U << vb_adc))) {
		size_t adc_s = m_adc.calcSize();
		r += adc_s + wiresize(adc_s) + 1 /* tag(adc) 0x20 */;
	}
	#ifdef CONFIG_TOUCHPAD
	// optional TouchpadConfig touchpad, id 5
	if (0 != (p_validbits & ((uint16_t)1U << vb_touchpad))) {
		size_t touchpad_s = m_touchpad.calcSize();
		r += touchpad_s + wiresize(touchpad_s) + 1 /* tag(touchpad) 0x28 */;
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	// repeated TouchChannelConfig tp_channel, id 6
	// repeated message tp_channel
	for (size_t x = 0, y = m_tp_channel.size(); x < y; ++x) {
		size_t s = m_tp_channel[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(tp_channel) 0x30 */;
	}
	#endif // CONFIG_TOUCHPAD
	// repeated GpioConfig gpios, id 7
	// repeated message gpios
	for (size_t x = 0, y = m_gpios.size(); x < y; ++x) {
		size_t s = m_gpios[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(gpios) 0x38 */;
	}
	#ifdef CONFIG_SPI
	// repeated SpiBusConfig spibus, id 8
	// repeated message spibus
	for (size_t x = 0, y = m_spibus.size(); x < y; ++x) {
		size_t s = m_spibus[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(spibus) 0x40 */;
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	// repeated ButtonConfig button, id 16
	// repeated message button
	for (size_t x = 0, y = m_button.size(); x < y; ++x) {
		size_t s = m_button[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(button) 0x80 */;
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	// repeated RelayConfig relay, id 17
	// repeated message relay
	for (size_t x = 0, y = m_relay.size(); x < y; ++x) {
		size_t s = m_relay[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(relay) 0x88 */;
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	// repeated LedConfig led, id 18
	// repeated message led
	for (size_t x = 0, y = m_led.size(); x < y; ++x) {
		size_t s = m_led[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(led) 0x90 */;
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	// optional BuzzerConfig buzzer, id 19
	if (0 != (p_validbits & ((uint16_t)1U << vb_buzzer))) {
		size_t buzzer_s = m_buzzer.calcSize();
		r += buzzer_s + wiresize(buzzer_s) + 2 /* tag(buzzer) 0x98 */;
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	// optional Hlw8012Config hlw8012, id 20
	if (0 != (p_validbits & ((uint16_t)1U << vb_hlw8012))) {
		size_t hlw8012_s = m_hlw8012.calcSize();
		r += hlw8012_s + wiresize(hlw8012_s) + 2 /* tag(hlw8012) 0xa0 */;
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	// optional Max7219Config max7219, id 32
	if (0 != (p_validbits & ((uint16_t)1U << vb_max7219))) {
		size_t max7219_s = m_max7219.calcSize();
		r += max7219_s + wiresize(max7219_s) + 2 /* tag(max7219) 0x100 */;
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	// optional Tlc5947Config tlc5947, id 33
	if (0 != (p_validbits & ((uint16_t)1U << vb_tlc5947))) {
		size_t tlc5947_s = m_tlc5947.calcSize();
		r += tlc5947_s + wiresize(tlc5947_s) + 2 /* tag(tlc5947) 0x108 */;
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	// repeated Ws2812bConfig ws2812b, id 34
	// repeated message ws2812b
	for (size_t x = 0, y = m_ws2812b.size(); x < y; ++x) {
		size_t s = m_ws2812b[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(ws2812b) 0x110 */;
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	// optional DhtConfig dht, id 35
	if (0 != (p_validbits & ((uint16_t)1U << vb_dht))) {
		size_t dht_s = m_dht.calcSize();
		r += dht_s + wiresize(dht_s) + 2 /* tag(dht) 0x118 */;
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	// repeated I2CConfig i2c, id 36
	// repeated message i2c
	for (size_t x = 0, y = m_i2c.size(); x < y; ++x) {
		size_t s = m_i2c[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(i2c) 0x120 */;
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	// repeated HcSr04Config hcsr04, id 37
	// repeated message hcsr04
	for (size_t x = 0, y = m_hcsr04.size(); x < y; ++x) {
		size_t s = m_hcsr04[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(hcsr04) 0x128 */;
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	// optional OneWireConfig onewire, id 38
	if (0 != (p_validbits & ((uint16_t)1U << vb_onewire))) {
		size_t onewire_s = m_onewire.calcSize();
		r += onewire_s + wiresize(onewire_s) + 2 /* tag(onewire) 0x130 */;
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	// optional SX1276Config sx1276, id 39
	if (0 != (p_validbits & ((uint16_t)1U << vb_sx1276))) {
		size_t sx1276_s = m_sx1276.calcSize();
		r += sx1276_s + wiresize(sx1276_s) + 2 /* tag(sx1276) 0x138 */;
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	// repeated GpioCluster iocluster, id 40
	// repeated message iocluster
	for (size_t x = 0, y = m_iocluster.size(); x < y; ++x) {
		size_t s = m_iocluster[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(iocluster) 0x140 */;
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	// optional DisplayConfig display, id 50
	if (0 != (p_validbits & ((uint16_t)1U << vb_display))) {
		size_t display_s = m_display.calcSize();
		r += display_s + wiresize(display_s) + 2 /* tag(display) 0x190 */;
	}
	#endif // CONFIG_DISPLAY
	return r;
}

bool HardwareConfig::operator != (const HardwareConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_magic() && (m_magic != r.m_magic))
		return true;
	if (has_system() && (m_system != r.m_system))
		return true;
	if (m_uart != r.m_uart)
		return true;
	if (has_adc() && (m_adc != r.m_adc))
		return true;
	#ifdef CONFIG_TOUCHPAD
	if (has_touchpad() && (m_touchpad != r.m_touchpad))
		return true;
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	if (m_tp_channel != r.m_tp_channel)
		return true;
	#endif // CONFIG_TOUCHPAD
	if (m_gpios != r.m_gpios)
		return true;
	#ifdef CONFIG_SPI
	if (m_spibus != r.m_spibus)
		return true;
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (m_button != r.m_button)
		return true;
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (m_relay != r.m_relay)
		return true;
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (m_led != r.m_led)
		return true;
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (has_buzzer() && (m_buzzer != r.m_buzzer))
		return true;
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (has_hlw8012() && (m_hlw8012 != r.m_hlw8012))
		return true;
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (has_max7219() && (m_max7219 != r.m_max7219))
		return true;
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (has_tlc5947() && (m_tlc5947 != r.m_tlc5947))
		return true;
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (m_ws2812b != r.m_ws2812b)
		return true;
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (has_dht() && (m_dht != r.m_dht))
		return true;
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (m_i2c != r.m_i2c)
		return true;
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (m_hcsr04 != r.m_hcsr04)
		return true;
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (has_onewire() && (m_onewire != r.m_onewire))
		return true;
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (has_sx1276() && (m_sx1276 != r.m_sx1276))
		return true;
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (m_iocluster != r.m_iocluster)
		return true;
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (has_display() && (m_display != r.m_display))
		return true;
	#endif // CONFIG_DISPLAY
	return false;
}


bool HardwareConfig::operator == (const HardwareConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int HardwareConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"magic")) {
		if (value == 0) {
			clear_magic();
			return 0;
		}
		int r = parse_ascii_u32(&m_magic,value);
		if (r > 0)
			p_validbits |= ((uint16_t)1U << 0);
		return r;
	}
	if (0 == memcmp(name,"system",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_system();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 1);
			return m_system.setByName(name+7,value);
		}
	}
	if (0 == memcmp(name,"uart",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_uart();
			return 0;
		} else if (name[4] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[5] == '+') && (name[6] == ']')) {
				x = m_uart.size();
				m_uart.resize(x+1);
				idxe = (char*)(name + 6);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+5,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+5)))
					return -602;
				if (m_uart.size() <= x)
					return -603;
				if ((idxe[1] == 0) && (value == 0)) {
					m_uart.erase(m_uart.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -604;
			return m_uart[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"adc",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_adc();
			return 0;
		} else if (name[3] == '.') {
			p_validbits |= ((uint16_t)1U << 2);
			return m_adc.setByName(name+4,value);
		}
	}
	#ifdef CONFIG_TOUCHPAD
	if (0 == memcmp(name,"touchpad",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_touchpad();
			return 0;
		} else if (name[8] == '.') {
			p_validbits |= ((uint16_t)1U << 3);
			return m_touchpad.setByName(name+9,value);
		}
	}
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	if (0 == memcmp(name,"tp_channel",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_tp_channel();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_tp_channel.size();
				m_tp_channel.resize(x+1);
				idxe = (char*)(name + 12);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+11)))
					return -605;
				if (m_tp_channel.size() <= x)
					return -606;
				if ((idxe[1] == 0) && (value == 0)) {
					m_tp_channel.erase(m_tp_channel.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -607;
			return m_tp_channel[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_TOUCHPAD
	if (0 == memcmp(name,"gpios",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_gpios();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_gpios.size();
				m_gpios.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -608;
				if (m_gpios.size() <= x)
					return -609;
				if ((idxe[1] == 0) && (value == 0)) {
					m_gpios.erase(m_gpios.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -610;
			return m_gpios[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_SPI
	if (0 == memcmp(name,"spibus",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_spibus();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_spibus.size();
				m_spibus.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -611;
				if (m_spibus.size() <= x)
					return -612;
				if ((idxe[1] == 0) && (value == 0)) {
					m_spibus.erase(m_spibus.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -613;
			return m_spibus[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (0 == memcmp(name,"button",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_button();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_button.size();
				m_button.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -614;
				if (m_button.size() <= x)
					return -615;
				if ((idxe[1] == 0) && (value == 0)) {
					m_button.erase(m_button.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -616;
			return m_button[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (0 == memcmp(name,"relay",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_relay();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_relay.size();
				m_relay.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -617;
				if (m_relay.size() <= x)
					return -618;
				if ((idxe[1] == 0) && (value == 0)) {
					m_relay.erase(m_relay.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -619;
			return m_relay[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (0 == memcmp(name,"led",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_led();
			return 0;
		} else if (name[3] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[4] == '+') && (name[5] == ']')) {
				x = m_led.size();
				m_led.resize(x+1);
				idxe = (char*)(name + 5);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+4,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+4)))
					return -620;
				if (m_led.size() <= x)
					return -621;
				if ((idxe[1] == 0) && (value == 0)) {
					m_led.erase(m_led.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -622;
			return m_led[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (0 == memcmp(name,"buzzer",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_buzzer();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 4);
			return m_buzzer.setByName(name+7,value);
		}
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (0 == memcmp(name,"hlw8012",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_hlw8012();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 5);
			return m_hlw8012.setByName(name+8,value);
		}
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (0 == memcmp(name,"max7219",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_max7219();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 6);
			return m_max7219.setByName(name+8,value);
		}
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (0 == memcmp(name,"tlc5947",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_tlc5947();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 7);
			return m_tlc5947.setByName(name+8,value);
		}
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (0 == memcmp(name,"ws2812b",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_ws2812b();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_ws2812b.size();
				m_ws2812b.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -623;
				if (m_ws2812b.size() <= x)
					return -624;
				if ((idxe[1] == 0) && (value == 0)) {
					m_ws2812b.erase(m_ws2812b.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -625;
			return m_ws2812b[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (0 == memcmp(name,"dht",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_dht();
			return 0;
		} else if (name[3] == '.') {
			p_validbits |= ((uint16_t)1U << 8);
			return m_dht.setByName(name+4,value);
		}
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (0 == memcmp(name,"i2c",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_i2c();
			return 0;
		} else if (name[3] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[4] == '+') && (name[5] == ']')) {
				x = m_i2c.size();
				m_i2c.resize(x+1);
				idxe = (char*)(name + 5);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+4,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+4)))
					return -626;
				if (m_i2c.size() <= x)
					return -627;
				if ((idxe[1] == 0) && (value == 0)) {
					m_i2c.erase(m_i2c.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -628;
			return m_i2c[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (0 == memcmp(name,"hcsr04",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_hcsr04();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_hcsr04.size();
				m_hcsr04.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -629;
				if (m_hcsr04.size() <= x)
					return -630;
				if ((idxe[1] == 0) && (value == 0)) {
					m_hcsr04.erase(m_hcsr04.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -631;
			return m_hcsr04[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (0 == memcmp(name,"onewire",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_onewire();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 9);
			return m_onewire.setByName(name+8,value);
		}
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (0 == memcmp(name,"sx1276",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_sx1276();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 10);
			return m_sx1276.setByName(name+7,value);
		}
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (0 == memcmp(name,"iocluster",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_iocluster();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_iocluster.size();
				m_iocluster.resize(x+1);
				idxe = (char*)(name + 11);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+10)))
					return -632;
				if (m_iocluster.size() <= x)
					return -633;
				if ((idxe[1] == 0) && (value == 0)) {
					m_iocluster.erase(m_iocluster.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -634;
			return m_iocluster[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (0 == memcmp(name,"display",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_display();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 11);
			return m_display.setByName(name+8,value);
		}
	}
	#endif // CONFIG_DISPLAY
	return -635;
}

Message *HardwareConfig::p_getMember(const char *s, unsigned n)
{
	// caller guarantee: s[n] == '.'
	if ((n == 6) && (0 == memcmp("system",s,6)))
		return &m_system;
	if ((n == 3) && (0 == memcmp("adc",s,3)))
		return &m_adc;
	#ifdef CONFIG_TOUCHPAD
	if ((n == 8) && (0 == memcmp("touchpad",s,8)))
		return &m_touchpad;
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_BUZZER
	if ((n == 6) && (0 == memcmp("buzzer",s,6)))
		return &m_buzzer;
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if ((n == 7) && (0 == memcmp("hlw8012",s,7)))
		return &m_hlw8012;
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if ((n == 7) && (0 == memcmp("max7219",s,7)))
		return &m_max7219;
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if ((n == 7) && (0 == memcmp("tlc5947",s,7)))
		return &m_tlc5947;
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_DHT
	if ((n == 3) && (0 == memcmp("dht",s,3)))
		return &m_dht;
	#endif // CONFIG_DHT
	#ifdef CONFIG_ONEWIRE
	if ((n == 7) && (0 == memcmp("onewire",s,7)))
		return &m_onewire;
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if ((n == 6) && (0 == memcmp("sx1276",s,6)))
		return &m_sx1276;
	#endif // CONFIG_SX1276
	#ifdef CONFIG_DISPLAY
	if ((n == 7) && (0 == memcmp("display",s,7)))
		return &m_display;
	#endif // CONFIG_DISPLAY
	return 0;
}

Message *HardwareConfig::p_getMember(const char *s, unsigned n, unsigned x)
{
	// caller guarantee: s[n] == '['
	if ((n == 4) && (0 == memcmp("uart",s,4))) {
		if (x < m_uart.size())
			return &m_uart[x];
		#ifdef CONFIG_TOUCHPAD
	} else if ((n == 10) && (0 == memcmp("tp_channel",s,10))) {
		if (x < m_tp_channel.size())
			return &m_tp_channel[x];
		#endif // CONFIG_TOUCHPAD
	} else if ((n == 5) && (0 == memcmp("gpios",s,5))) {
		if (x < m_gpios.size())
			return &m_gpios[x];
		#ifdef CONFIG_SPI
	} else if ((n == 6) && (0 == memcmp("spibus",s,6))) {
		if (x < m_spibus.size())
			return &m_spibus[x];
		#endif // CONFIG_SPI
		#ifdef CONFIG_BUTTON
	} else if ((n == 6) && (0 == memcmp("button",s,6))) {
		if (x < m_button.size())
			return &m_button[x];
		#endif // CONFIG_BUTTON
		#ifdef CONFIG_RELAY
	} else if ((n == 5) && (0 == memcmp("relay",s,5))) {
		if (x < m_relay.size())
			return &m_relay[x];
		#endif // CONFIG_RELAY
		#ifdef CONFIG_LEDS
	} else if ((n == 3) && (0 == memcmp("led",s,3))) {
		if (x < m_led.size())
			return &m_led[x];
		#endif // CONFIG_LEDS
		#ifdef CONFIG_RGBLEDS
	} else if ((n == 7) && (0 == memcmp("ws2812b",s,7))) {
		if (x < m_ws2812b.size())
			return &m_ws2812b[x];
		#endif // CONFIG_RGBLEDS
		#ifdef CONFIG_I2C
	} else if ((n == 3) && (0 == memcmp("i2c",s,3))) {
		if (x < m_i2c.size())
			return &m_i2c[x];
		#endif // CONFIG_I2C
		#ifdef CONFIG_HCSR04
	} else if ((n == 6) && (0 == memcmp("hcsr04",s,6))) {
		if (x < m_hcsr04.size())
			return &m_hcsr04[x];
		#endif // CONFIG_HCSR04
		#ifdef CONFIG_IOEXTENDERS
	} else if ((n == 9) && (0 == memcmp("iocluster",s,9))) {
		if (x < m_iocluster.size())
			return &m_iocluster[x];
		#endif // CONFIG_IOEXTENDERS
	}
	return 0;
}

