/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: R2104.27 (hg:415/471fe430034d)
 * WFC is Copyright 2015-2021, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : hwcfg.wfc
 * Copyright: 2018-2021
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2021-08-31, 19:17:19 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from esp32:
 * endian          : "little"
 * Optimize        : "speed"
 * 
 * options from esp:
 * bytestype       : "estring"
 * intsize         : 32
 * SortMembers     : "size"
 * stringtype      : "estring"
 * toASCII         : "toASCII"
 * toSink          : ""
 * toString        : ""
 * toWire          : ""
 * varintbits      : 32
 * 
 * options from common:
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * BaseClass       : ""
 * calcSize        : "calcSize"
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * copyright       : ""
 * email           : ""
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * UnknownField    : "skip"
 * wireput         : ""
 * wiresize        : ""
 * 
 * enabled flags from esp32:
 * 	withUnequal
 * enabled flags from esp:
 * 	enumnames, withEqual
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux
 */

#include <map>
#include <stdlib.h>
#include <string.h>
#include "hwcfg.h"

#include "wfccore.h"

#if !defined(WFC_ENDIAN) || (WFC_ENDIAN != 0)
#error wfc: incompatible settings concerning endian
#endif


const char *pull_mode_e_str(pull_mode_e e)
{
	switch (e) {
	default:
		return 0;
	case pull_none:
		return "pull_none";
	case pull_en:
		// alias pull_down
		return "pull_en";
	case pull_dir:
		return "pull_dir";
	case pull_up:
		return "pull_up";
	}
}

size_t parse_ascii_pull_mode_e(pull_mode_e *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (pull_mode_e)ull;
		return e-s;
	} else if (0 == strcmp(s,"pull_none")) {
		*v = pull_none;
		return 9;
	} else if (0 == strcmp(s,"pull_en")) {
		*v = pull_en;
		return 7;
	} else if (0 == strcmp(s,"pull_down")) {
		*v = pull_down;
		return 9;
	} else if (0 == strcmp(s,"pull_dir")) {
		*v = pull_dir;
		return 8;
	} else if (0 == strcmp(s,"pull_up")) {
		*v = pull_up;
		return 7;
	} else {
		return 0;
	}
	return 0;
}

const char *dht_model_t_str(dht_model_t e)
{
	switch (e) {
	default:
		return 0;
	case DHT_NONE:
		return "DHT_NONE";
	case RHT03:
		return "RHT03";
	case DHT11:
		return "DHT11";
	case DHT21:
		return "DHT21";
	case DHT22:
		return "DHT22";
	case AM2301:
		return "AM2301";
	case AM2302:
		return "AM2302";
	}
}

size_t parse_ascii_dht_model_t(dht_model_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (dht_model_t)ull;
		return e-s;
	} else if (0 == strcmp(s,"DHT_NONE")) {
		*v = DHT_NONE;
		return 8;
	} else if (0 == strcmp(s,"RHT03")) {
		*v = RHT03;
		return 5;
	} else if (0 == strcmp(s,"DHT11")) {
		*v = DHT11;
		return 5;
	} else if (0 == strcmp(s,"DHT21")) {
		*v = DHT21;
		return 5;
	} else if (0 == strcmp(s,"DHT22")) {
		*v = DHT22;
		return 5;
	} else if (0 == strcmp(s,"AM2301")) {
		*v = AM2301;
		return 6;
	} else if (0 == strcmp(s,"AM2302")) {
		*v = AM2302;
		return 6;
	} else {
		return 0;
	}
	return 0;
}

const char *i2cdrv_t_str(i2cdrv_t e)
{
	switch (e) {
	default:
		return 0;
	case i2cdrv_invalid:
		return "i2cdrv_invalid";
	case i2cdrv_pcf8574:
		return "i2cdrv_pcf8574";
	}
}

size_t parse_ascii_i2cdrv_t(i2cdrv_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (i2cdrv_t)ull;
		return e-s;
	} else if (0 == strcmp(s,"i2cdrv_invalid")) {
		*v = i2cdrv_invalid;
		return 14;
	} else if (0 == strcmp(s,"i2cdrv_pcf8574")) {
		*v = i2cdrv_pcf8574;
		return 14;
	} else {
		return 0;
	}
	return 0;
}

const char *disp_t_str(disp_t e)
{
	switch (e) {
	default:
		return 0;
	case dt_none:
		return "dt_none";
	case dt_sd_7seg:
		return "dt_sd_7seg";
	case dt_sd_14seg:
		return "dt_sd_14seg";
	case dt_pcf8574_hd44780u:
		return "dt_pcf8574_hd44780u";
	case dt_ssd1306:
		return "dt_ssd1306";
	}
}

size_t parse_ascii_disp_t(disp_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (disp_t)ull;
		return e-s;
	} else if (0 == strcmp(s,"dt_none")) {
		*v = dt_none;
		return 7;
	} else if (0 == strcmp(s,"dt_sd_7seg")) {
		*v = dt_sd_7seg;
		return 10;
	} else if (0 == strcmp(s,"dt_sd_14seg")) {
		*v = dt_sd_14seg;
		return 11;
	} else if (0 == strcmp(s,"dt_pcf8574_hd44780u")) {
		*v = dt_pcf8574_hd44780u;
		return 19;
	} else if (0 == strcmp(s,"dt_ssd1306")) {
		*v = dt_ssd1306;
		return 10;
	} else {
		return 0;
	}
	return 0;
}

SystemConfig::SystemConfig()
: m_manufacturer("")
, m_board_name("")
, m_board_rev("")
, m_model_name("")
, m_model_number("")
, m_diag_uart(0)
, m_console_rx(0)
, m_console_tx(0)
, p_validbits(0)
{
}

void SystemConfig::clear()
{
	m_manufacturer = "";
	m_board_name = "";
	m_board_rev = "";
	m_diag_uart = 0;
	m_console_rx = 0;
	m_console_tx = 0;
	m_model_name = "";
	m_model_number = "";
	p_validbits = 0;
}

void SystemConfig::toASCII(stream &o, size_t indent) const
{
	o << "SystemConfig {";
	++indent;
	ascii_indent(o,indent,"manufacturer");
	ascii_string(o,m_manufacturer.data(),m_manufacturer.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"board_name");
	ascii_string(o,m_board_name.data(),m_board_name.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"board_rev");
	ascii_string(o,m_board_rev.data(),m_board_rev.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "diag_uart", (signed) m_diag_uart);
	ascii_numeric(o, indent, "console_rx", (signed) m_console_rx);
	ascii_numeric(o, indent, "console_tx", (signed) m_console_tx);
	ascii_indent(o,indent,"model_name");
	ascii_string(o,m_model_name.data(),m_model_name.size(),indent+2);
	o << ';';
	ascii_indent(o,indent,"model_number");
	ascii_string(o,m_model_number.data(),m_model_number.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SystemConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -1;
		a += fn;
		switch (fid) {
		case 0xa:	// manufacturer id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -2;
				m_manufacturer.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x12:	// board_name id 2, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -3;
				m_board_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x1a:	// board_rev id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -4;
				m_board_rev.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x20:	// diag_uart id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -5;
				a += n;
				set_diag_uart(varint_sint(v));
			}
			break;
		case 0x28:	// console_rx id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -6;
				a += n;
				set_console_rx(varint_sint(v));
			}
			break;
		case 0x30:	// console_tx id 6, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -7;
				a += n;
				set_console_tx(varint_sint(v));
			}
			break;
		case 0x3a:	// model_name id 7, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -8;
				m_model_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x42:	// model_number id 8, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -9;
				m_model_number.assign((const char*)a,v);
				a += v;
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -10;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -11;
	return a-(const uint8_t *)b;
}

ssize_t SystemConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has manufacturer?
	if (!m_manufacturer.empty()) {
		// 'manufacturer': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -12;
		*a++ = 0xa;
		ssize_t manufacturer_s = m_manufacturer.size();
		n = write_varint(a,e-a,manufacturer_s);
		a += n;
		if ((n <= 0) || ((e-a) < manufacturer_s))
			return -13;
		memcpy(a,m_manufacturer.data(),manufacturer_s);
		a += manufacturer_s;
	}
	// has board_name?
	if (!m_board_name.empty()) {
		// 'board_name': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -14;
		*a++ = 0x12;
		ssize_t board_name_s = m_board_name.size();
		n = write_varint(a,e-a,board_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < board_name_s))
			return -15;
		memcpy(a,m_board_name.data(),board_name_s);
		a += board_name_s;
	}
	// has board_rev?
	if (!m_board_rev.empty()) {
		// 'board_rev': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -16;
		*a++ = 0x1a;
		ssize_t board_rev_s = m_board_rev.size();
		n = write_varint(a,e-a,board_rev_s);
		a += n;
		if ((n <= 0) || ((e-a) < board_rev_s))
			return -17;
		memcpy(a,m_board_rev.data(),board_rev_s);
		a += board_rev_s;
	}
	// has diag_uart?
	if (m_diag_uart != 0) {
		// 'diag_uart': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -18;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_diag_uart));
		if (n <= 0)
			return -19;
		a += n;
	}
	// has console_rx?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'console_rx': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -20;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_console_rx));
		if (n <= 0)
			return -21;
		a += n;
	}
	// has console_tx?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'console_tx': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -22;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_console_tx));
		if (n <= 0)
			return -23;
		a += n;
	}
	// has model_name?
	if (!m_model_name.empty()) {
		// 'model_name': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -24;
		*a++ = 0x3a;
		ssize_t model_name_s = m_model_name.size();
		n = write_varint(a,e-a,model_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < model_name_s))
			return -25;
		memcpy(a,m_model_name.data(),model_name_s);
		a += model_name_s;
	}
	// has model_number?
	if (!m_model_number.empty()) {
		// 'model_number': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -26;
		*a++ = 0x42;
		ssize_t model_number_s = m_model_number.size();
		n = write_varint(a,e-a,model_number_s);
		a += n;
		if ((n <= 0) || ((e-a) < model_number_s))
			return -27;
		memcpy(a,m_model_number.data(),model_number_s);
		a += model_number_s;
	}
	assert(a <= e);
	return a-b;
}

void SystemConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_manufacturer()) {
		fsep = json_indent(json,indLvl,fsep,"manufacturer");
		json_cstr(json,m_manufacturer.c_str());
	}
	if (has_board_name()) {
		fsep = json_indent(json,indLvl,fsep,"board_name");
		json_cstr(json,m_board_name.c_str());
	}
	if (has_board_rev()) {
		fsep = json_indent(json,indLvl,fsep,"board_rev");
		json_cstr(json,m_board_rev.c_str());
	}
	if (has_diag_uart()) {
		fsep = json_indent(json,indLvl,fsep,"diag_uart");
		json << (int) m_diag_uart;
	}
	if (has_console_rx()) {
		fsep = json_indent(json,indLvl,fsep,"console_rx");
		json << (int) m_console_rx;
	}
	if (has_console_tx()) {
		fsep = json_indent(json,indLvl,fsep,"console_tx");
		json << (int) m_console_tx;
	}
	if (has_model_name()) {
		fsep = json_indent(json,indLvl,fsep,"model_name");
		json_cstr(json,m_model_name.c_str());
	}
	if (has_model_number()) {
		fsep = json_indent(json,indLvl,fsep,"model_number");
		json_cstr(json,m_model_number.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SystemConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string manufacturer, id 1
	if (!m_manufacturer.empty()) {
		size_t manufacturer_s = m_manufacturer.size();
		r += manufacturer_s + wiresize(manufacturer_s) + 1 /* tag(manufacturer) 0x8 */;
	}
	// optional string board_name, id 2
	if (!m_board_name.empty()) {
		size_t board_name_s = m_board_name.size();
		r += board_name_s + wiresize(board_name_s) + 1 /* tag(board_name) 0x10 */;
	}
	// optional string board_rev, id 3
	if (!m_board_rev.empty()) {
		size_t board_rev_s = m_board_rev.size();
		r += board_rev_s + wiresize(board_rev_s) + 1 /* tag(board_rev) 0x18 */;
	}
	// optional sint8 diag_uart, id 4
	if (m_diag_uart != 0) {
		r += wiresize_s((varint_t)m_diag_uart) + 1 /* tag(diag_uart) 0x20 */;
	}
	// optional sint8 console_rx, id 5
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize_s((varint_t)m_console_rx) + 1 /* tag(console_rx) 0x28 */;
	}
	// optional sint8 console_tx, id 6
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize_s((varint_t)m_console_tx) + 1 /* tag(console_tx) 0x30 */;
	}
	// optional string model_name, id 7
	if (!m_model_name.empty()) {
		size_t model_name_s = m_model_name.size();
		r += model_name_s + wiresize(model_name_s) + 1 /* tag(model_name) 0x38 */;
	}
	// optional string model_number, id 8
	if (!m_model_number.empty()) {
		size_t model_number_s = m_model_number.size();
		r += model_number_s + wiresize(model_number_s) + 1 /* tag(model_number) 0x40 */;
	}
	return r;
}

bool SystemConfig::operator != (const SystemConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_manufacturer() && (m_manufacturer != r.m_manufacturer))
		return true;
	if (has_board_name() && (m_board_name != r.m_board_name))
		return true;
	if (has_board_rev() && (m_board_rev != r.m_board_rev))
		return true;
	if (has_diag_uart() && (m_diag_uart != r.m_diag_uart))
		return true;
	if (has_console_rx() && (m_console_rx != r.m_console_rx))
		return true;
	if (has_console_tx() && (m_console_tx != r.m_console_tx))
		return true;
	if (has_model_name() && (m_model_name != r.m_model_name))
		return true;
	if (has_model_number() && (m_model_number != r.m_model_number))
		return true;
	return false;
}


bool SystemConfig::operator == (const SystemConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SystemConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"manufacturer")) {
		if (value == 0) {
			clear_manufacturer();
			return 0;
		}
		m_manufacturer = value;
		int r = m_manufacturer.size();
		return r;
	}
	if (0 == strcmp(name,"board_name")) {
		if (value == 0) {
			clear_board_name();
			return 0;
		}
		m_board_name = value;
		int r = m_board_name.size();
		return r;
	}
	if (0 == strcmp(name,"board_rev")) {
		if (value == 0) {
			clear_board_rev();
			return 0;
		}
		m_board_rev = value;
		int r = m_board_rev.size();
		return r;
	}
	if (0 == strcmp(name,"diag_uart")) {
		if (value == 0) {
			clear_diag_uart();
			return 0;
		}
		int r = parse_ascii_s8(&m_diag_uart,value);
		return r;
	}
	if (0 == strcmp(name,"console_rx")) {
		if (value == 0) {
			clear_console_rx();
			return 0;
		}
		int r = parse_ascii_s8(&m_console_rx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"console_tx")) {
		if (value == 0) {
			clear_console_tx();
			return 0;
		}
		int r = parse_ascii_s8(&m_console_tx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"model_name")) {
		if (value == 0) {
			clear_model_name();
			return 0;
		}
		m_model_name = value;
		int r = m_model_name.size();
		return r;
	}
	if (0 == strcmp(name,"model_number")) {
		if (value == 0) {
			clear_model_number();
			return 0;
		}
		m_model_number = value;
		int r = m_model_number.size();
		return r;
	}
	return -28;
}

TouchpadConfig::TouchpadConfig()
: m_interval(0)
, m_fsm_mode(false)
, m_lvolt(-1)
, m_hvolt(-1)
, m_atten(-1)
, p_validbits(0)
{
}

void TouchpadConfig::clear()
{
	m_fsm_mode = false;
	m_lvolt = -1;
	m_hvolt = -1;
	m_atten = -1;
	m_interval = 0;
	p_validbits = 0;
}

void TouchpadConfig::toASCII(stream &o, size_t indent) const
{
	o << "TouchpadConfig {";
	++indent;
	ascii_indent(o,indent,"fsm_mode");
	o << (m_fsm_mode ? "true" : "false") << ';';
	ascii_numeric(o, indent, "lvolt", (signed) m_lvolt);
	ascii_numeric(o, indent, "hvolt", (signed) m_hvolt);
	ascii_numeric(o, indent, "atten", (signed) m_atten);
	ascii_numeric(o, indent, "interval", m_interval);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t TouchpadConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -29;
		a += fn;
		switch (fid) {
		case 0xb:	// fsm_mode id 1, type bool, coding 8bit
			if (a >= e)
				return -30;
			set_fsm_mode(*a++);
			break;
		case 0x10:	// lvolt id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -31;
				a += n;
				set_lvolt(varint_sint(v));
			}
			break;
		case 0x18:	// hvolt id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -32;
				a += n;
				set_hvolt(varint_sint(v));
			}
			break;
		case 0x20:	// atten id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -33;
				a += n;
				set_atten(varint_sint(v));
			}
			break;
		case 0x38:	// interval id 7, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -34;
				a += n;
				set_interval(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -35;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -36;
	return a-(const uint8_t *)b;
}

ssize_t TouchpadConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has fsm_mode?
	if (m_fsm_mode != false) {
		// 'fsm_mode': id=1, encoding=8bit, tag=0xb
		if (2 > (e-a))
			return -37;
		*a++ = 0xb;
		*a++ = m_fsm_mode;
	}
	// has lvolt?
	if (m_lvolt != -1) {
		// 'lvolt': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -38;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_lvolt));
		if (n <= 0)
			return -39;
		a += n;
	}
	// has hvolt?
	if (m_hvolt != -1) {
		// 'hvolt': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -40;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_hvolt));
		if (n <= 0)
			return -41;
		a += n;
	}
	// has atten?
	if (m_atten != -1) {
		// 'atten': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -42;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_atten));
		if (n <= 0)
			return -43;
		a += n;
	}
	// has interval?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'interval': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -44;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_interval);
		if (n <= 0)
			return -45;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void TouchpadConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_fsm_mode()) {
		fsep = json_indent(json,indLvl,fsep,"fsm_mode");
		json << (m_fsm_mode ? "true" : "false");
	}
	if (has_lvolt()) {
		fsep = json_indent(json,indLvl,fsep,"lvolt");
		json << (int) m_lvolt;
	}
	if (has_hvolt()) {
		fsep = json_indent(json,indLvl,fsep,"hvolt");
		json << (int) m_hvolt;
	}
	if (has_atten()) {
		fsep = json_indent(json,indLvl,fsep,"atten");
		json << (int) m_atten;
	}
	if (has_interval()) {
		fsep = json_indent(json,indLvl,fsep,"interval");
		json << m_interval;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TouchpadConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional bool fsm_mode, id 1
	if (m_fsm_mode != false) {
		r += 2;
	}
	// optional sint8 lvolt, id 2
	if (m_lvolt != -1) {
		r += wiresize_s((varint_t)m_lvolt) + 1 /* tag(lvolt) 0x10 */;
	}
	// optional sint8 hvolt, id 3
	if (m_hvolt != -1) {
		r += wiresize_s((varint_t)m_hvolt) + 1 /* tag(hvolt) 0x18 */;
	}
	// optional sint8 atten, id 4
	if (m_atten != -1) {
		r += wiresize_s((varint_t)m_atten) + 1 /* tag(atten) 0x20 */;
	}
	// optional unsigned interval, id 7
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_interval) + 1 /* tag(interval) 0x38 */;
	}
	return r;
}

bool TouchpadConfig::operator != (const TouchpadConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_fsm_mode() && (m_fsm_mode != r.m_fsm_mode))
		return true;
	if (has_lvolt() && (m_lvolt != r.m_lvolt))
		return true;
	if (has_hvolt() && (m_hvolt != r.m_hvolt))
		return true;
	if (has_atten() && (m_atten != r.m_atten))
		return true;
	if (has_interval() && (m_interval != r.m_interval))
		return true;
	return false;
}


bool TouchpadConfig::operator == (const TouchpadConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TouchpadConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"fsm_mode")) {
		if (value == 0) {
			clear_fsm_mode();
			return 0;
		}
		int r = parse_ascii_bool(&m_fsm_mode,value);
		return r;
	}
	if (0 == strcmp(name,"lvolt")) {
		if (value == 0) {
			clear_lvolt();
			return 0;
		}
		int r = parse_ascii_s8(&m_lvolt,value);
		return r;
	}
	if (0 == strcmp(name,"hvolt")) {
		if (value == 0) {
			clear_hvolt();
			return 0;
		}
		int r = parse_ascii_s8(&m_hvolt,value);
		return r;
	}
	if (0 == strcmp(name,"atten")) {
		if (value == 0) {
			clear_atten();
			return 0;
		}
		int r = parse_ascii_s8(&m_atten,value);
		return r;
	}
	if (0 == strcmp(name,"interval")) {
		if (value == 0) {
			clear_interval();
			return 0;
		}
		int r = parse_ascii_u32(&m_interval,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	return -46;
}

TouchChannelConfig::TouchChannelConfig()
: m_name()
, m_threshold(0)
, m_channel(-1)
, m_slope(0)
, m_tieopt(0)
, p_validbits(0)
{
}

void TouchChannelConfig::clear()
{
	m_name.clear();
	m_channel = -1;
	m_threshold = 0;
	m_slope = 0;
	m_tieopt = 0;
	p_validbits = 0;
}

void TouchChannelConfig::toASCII(stream &o, size_t indent) const
{
	o << "TouchChannelConfig {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "channel", (signed) m_channel);
	ascii_numeric(o, indent, "threshold", m_threshold);
	ascii_numeric(o, indent, "slope", (unsigned) m_slope);
	ascii_numeric(o, indent, "tieopt", (unsigned) m_tieopt);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t TouchChannelConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -47;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -48;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x10:	// channel id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -49;
				a += n;
				set_channel(varint_sint(v));
			}
			break;
		case 0x1c:	// threshold id 3, type uint16_t, coding 16bit
			if ((a+1) >= e)
				return -50;
			set_threshold((uint16_t) read_u16(a));
			a += 2;
			break;
		case 0x20:	// slope id 4, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -51;
				a += n;
				set_slope(v);
			}
			break;
		case 0x28:	// tieopt id 5, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -52;
				a += n;
				set_tieopt(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -53;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -54;
	return a-(const uint8_t *)b;
}

ssize_t TouchChannelConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -55;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -56;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has channel?
	if (m_channel != -1) {
		// 'channel': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -57;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_channel));
		if (n <= 0)
			return -58;
		a += n;
	}
	// has threshold?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'threshold': id=3, encoding=16bit, tag=0x1c
		if (3 > (e-a))
			return -59;
		*a++ = 0x1c;
		write_u16(a,m_threshold);
		a += 2;
	}
	// has slope?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'slope': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -60;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_slope);
		if (n <= 0)
			return -61;
		a += n;
	}
	// has tieopt?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'tieopt': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -62;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_tieopt);
		if (n <= 0)
			return -63;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void TouchChannelConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_channel()) {
		fsep = json_indent(json,indLvl,fsep,"channel");
		json << (int) m_channel;
	}
	if (has_threshold()) {
		fsep = json_indent(json,indLvl,fsep,"threshold");
		json << m_threshold;
	}
	if (has_slope()) {
		fsep = json_indent(json,indLvl,fsep,"slope");
		json << (unsigned) m_slope;
	}
	if (has_tieopt()) {
		fsep = json_indent(json,indLvl,fsep,"tieopt");
		json << (unsigned) m_tieopt;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TouchChannelConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 channel, id 2
	if (m_channel != -1) {
		r += wiresize_s((varint_t)m_channel) + 1 /* tag(channel) 0x10 */;
	}
	// optional fixed16 threshold, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += 3;
	}
	// optional uint8 slope, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += wiresize((varint_t)m_slope) + 1 /* tag(slope) 0x20 */;
	}
	// optional uint8 tieopt, id 5
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		r += wiresize((varint_t)m_tieopt) + 1 /* tag(tieopt) 0x28 */;
	}
	return r;
}

bool TouchChannelConfig::operator != (const TouchChannelConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_channel() && (m_channel != r.m_channel))
		return true;
	if (has_threshold() && (m_threshold != r.m_threshold))
		return true;
	if (has_slope() && (m_slope != r.m_slope))
		return true;
	if (has_tieopt() && (m_tieopt != r.m_tieopt))
		return true;
	return false;
}


bool TouchChannelConfig::operator == (const TouchChannelConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TouchChannelConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"channel")) {
		if (value == 0) {
			clear_channel();
			return 0;
		}
		int r = parse_ascii_s8(&m_channel,value);
		return r;
	}
	if (0 == strcmp(name,"threshold")) {
		if (value == 0) {
			clear_threshold();
			return 0;
		}
		int r = parse_ascii_u16(&m_threshold,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"slope")) {
		if (value == 0) {
			clear_slope();
			return 0;
		}
		int r = parse_ascii_u8(&m_slope,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"tieopt")) {
		if (value == 0) {
			clear_tieopt();
			return 0;
		}
		int r = parse_ascii_u8(&m_tieopt,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	return -64;
}

ButtonConfig::ButtonConfig()
: m_name("")
, m_gpio(-1)
, m_presslvl(0)
, m_pull_mode(pull_none)
{
}

void ButtonConfig::clear()
{
	m_name = "";
	m_gpio = -1;
	m_presslvl = 0;
	m_pull_mode = pull_none;
}

void ButtonConfig::toASCII(stream &o, size_t indent) const
{
	o << "ButtonConfig {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_indent(o,indent,"presslvl");
	o << (m_presslvl ? "true" : "false") << ';';
	ascii_numeric(o, indent, "pull_mode", (unsigned) m_pull_mode);
	++indent;
	ascii_indent(o,indent);
	o << ".enable = " ;
	o << (pull_mode_enable() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".up = " ;
	o << (pull_mode_up() ? "true;" : "false;");
	--indent;
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t ButtonConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -65;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -66;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -67;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x1b:	// presslvl id 3, type bool, coding 8bit
			if (a >= e)
				return -68;
			set_presslvl(*a++);
			break;
		case 0x20:	// pull_mode id 4, type pull_mode_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -69;
				a += n;
				set_pull_mode((pull_mode_t) v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -70;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -71;
	return a-(const uint8_t *)b;
}

ssize_t ButtonConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -72;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -73;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -74;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -75;
		a += n;
	}
	// has presslvl?
	if (m_presslvl != 0) {
		// 'presslvl': id=3, encoding=8bit, tag=0x1b
		if (2 > (e-a))
			return -76;
		*a++ = 0x1b;
		*a++ = m_presslvl;
	}
	// has pull_mode?
	if (m_pull_mode != pull_none) {
		// 'pull_mode': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -77;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_pull_mode);
		if (n <= 0)
			return -78;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void ButtonConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_presslvl()) {
		fsep = json_indent(json,indLvl,fsep,"presslvl");
		json << (m_presslvl ? "true" : "false");
	}
	if (has_pull_mode()) {
		fsep = json_indent(json,indLvl,fsep,"pull_mode");
		json << (unsigned) m_pull_mode;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t ButtonConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional bool presslvl, id 3
	if (m_presslvl != 0) {
		r += 2;
	}
	// optional pull_mode_t pull_mode, id 4
	if (m_pull_mode != pull_none) {
		r += wiresize((varint_t)m_pull_mode) + 1 /* tag(pull_mode) 0x20 */;
	}
	return r;
}

bool ButtonConfig::operator != (const ButtonConfig &r) const
{
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_presslvl() && (m_presslvl != r.m_presslvl))
		return true;
	if (has_pull_mode() && (m_pull_mode != r.m_pull_mode))
		return true;
	return false;
}


bool ButtonConfig::operator == (const ButtonConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int ButtonConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"presslvl")) {
		if (value == 0) {
			clear_presslvl();
			return 0;
		}
		int r = parse_ascii_bool(&m_presslvl,value);
		return r;
	}
	if ((0 == memcmp(name,"pull_mode",9)) && ((name[9] == 0) || name[9] == '.')) {
		name += 9;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_pull_mode((pull_mode_t)ull);
			else if (!strcmp(name,"enable"))
				set_pull_mode_enable((bool)ull);
			else if (!strcmp(name,"up"))
				set_pull_mode_up((bool)ull);
			return eptr - value;
		} else {
			return -79;
		}
	}
	return -80;
}

RelayConfig::RelayConfig()
: m_name("")
, m_min_itv(0)
, m_gpio(-1)
, m_config(0)
, m_interlock(-1)
, p_validbits(0)
{
}

void RelayConfig::clear()
{
	m_name = "";
	m_gpio = -1;
	m_config = 0;
	m_min_itv = 0;
	m_interlock = -1;
	p_validbits = 0;
}

void RelayConfig::toASCII(stream &o, size_t indent) const
{
	o << "RelayConfig {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", (unsigned) m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".active_high = " ;
	o << (config_active_high() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".init_on = " ;
	o << (config_init_on() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".persistent = " ;
	o << (config_persistent() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".opendrain = " ;
	o << (config_opendrain() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".mqtt = " ;
	o << (config_mqtt() ? "true;" : "false;");
	--indent;
	ascii_numeric(o, indent, "min_itv", m_min_itv);
	ascii_numeric(o, indent, "interlock", (signed) m_interlock);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t RelayConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -81;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -82;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -83;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x18:	// config id 3, type relay_cfg_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -84;
				a += n;
				set_config((relay_cfg_t) v);
			}
			break;
		case 0x20:	// min_itv id 4, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -85;
				a += n;
				set_min_itv(v);
			}
			break;
		case 0x28:	// interlock id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -86;
				a += n;
				set_interlock(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -87;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -88;
	return a-(const uint8_t *)b;
}

ssize_t RelayConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -89;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -90;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -91;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -92;
		a += n;
	}
	// has config?
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -93;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -94;
		a += n;
	}
	// has min_itv?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'min_itv': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -95;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_min_itv);
		if (n <= 0)
			return -96;
		a += n;
	}
	// has interlock?
	if (m_interlock != -1) {
		// 'interlock': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -97;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_interlock));
		if (n <= 0)
			return -98;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void RelayConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (has_min_itv()) {
		fsep = json_indent(json,indLvl,fsep,"min_itv");
		json << m_min_itv;
	}
	if (has_interlock()) {
		fsep = json_indent(json,indLvl,fsep,"interlock");
		json << (int) m_interlock;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t RelayConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional relay_cfg_t config, id 3
	if (m_config != 0) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	// optional unsigned min_itv, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_min_itv) + 1 /* tag(min_itv) 0x20 */;
	}
	// optional sint8 interlock, id 5
	if (m_interlock != -1) {
		r += wiresize_s((varint_t)m_interlock) + 1 /* tag(interlock) 0x28 */;
	}
	return r;
}

bool RelayConfig::operator != (const RelayConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	if (has_min_itv() && (m_min_itv != r.m_min_itv))
		return true;
	if (has_interlock() && (m_interlock != r.m_interlock))
		return true;
	return false;
}


bool RelayConfig::operator == (const RelayConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int RelayConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((relay_cfg_t)ull);
			else if (!strcmp(name,"active_high"))
				set_config_active_high((bool)ull);
			else if (!strcmp(name,"init_on"))
				set_config_init_on((bool)ull);
			else if (!strcmp(name,"persistent"))
				set_config_persistent((bool)ull);
			else if (!strcmp(name,"opendrain"))
				set_config_opendrain((bool)ull);
			else if (!strcmp(name,"mqtt"))
				set_config_mqtt((bool)ull);
			return eptr - value;
		} else {
			return -99;
		}
	}
	if (0 == strcmp(name,"min_itv")) {
		if (value == 0) {
			clear_min_itv();
			return 0;
		}
		int r = parse_ascii_u32(&m_min_itv,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"interlock")) {
		if (value == 0) {
			clear_interlock();
			return 0;
		}
		int r = parse_ascii_s8(&m_interlock,value);
		return r;
	}
	return -100;
}

Max7219Config::Max7219Config()
: m_clk(-1)
, m_dout(-1)
, m_cs(-1)
, m_odrain(false)
, m_digits(0)
{
}

void Max7219Config::clear()
{
	m_clk = -1;
	m_dout = -1;
	m_cs = -1;
	m_odrain = false;
	m_digits = 0;
}

void Max7219Config::toASCII(stream &o, size_t indent) const
{
	o << "Max7219Config {";
	++indent;
	ascii_numeric(o, indent, "clk", (signed) m_clk);
	ascii_numeric(o, indent, "dout", (signed) m_dout);
	ascii_numeric(o, indent, "cs", (signed) m_cs);
	ascii_indent(o,indent,"odrain");
	o << (m_odrain ? "true" : "false") << ';';
	ascii_numeric(o, indent, "digits", (unsigned) m_digits);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Max7219Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -101;
		a += fn;
		switch (fid) {
		case 0x8:	// clk id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -102;
				a += n;
				set_clk(varint_sint(v));
			}
			break;
		case 0x10:	// dout id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -103;
				a += n;
				set_dout(varint_sint(v));
			}
			break;
		case 0x18:	// cs id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -104;
				a += n;
				set_cs(varint_sint(v));
			}
			break;
		case 0x23:	// odrain id 4, type bool, coding 8bit
			if (a >= e)
				return -105;
			set_odrain(*a++);
			break;
		case 0x28:	// digits id 5, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -106;
				a += n;
				set_digits(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -107;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -108;
	return a-(const uint8_t *)b;
}

ssize_t Max7219Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has clk?
	if (m_clk != -1) {
		// 'clk': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -109;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_clk));
		if (n <= 0)
			return -110;
		a += n;
	}
	// has dout?
	if (m_dout != -1) {
		// 'dout': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -111;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_dout));
		if (n <= 0)
			return -112;
		a += n;
	}
	// has cs?
	if (m_cs != -1) {
		// 'cs': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -113;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_cs));
		if (n <= 0)
			return -114;
		a += n;
	}
	// has odrain?
	if (m_odrain != false) {
		// 'odrain': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -115;
		*a++ = 0x23;
		*a++ = m_odrain;
	}
	// has digits?
	if (m_digits != 0) {
		// 'digits': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -116;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_digits);
		if (n <= 0)
			return -117;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Max7219Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_clk()) {
		fsep = json_indent(json,indLvl,fsep,"clk");
		json << (int) m_clk;
	}
	if (has_dout()) {
		fsep = json_indent(json,indLvl,fsep,"dout");
		json << (int) m_dout;
	}
	if (has_cs()) {
		fsep = json_indent(json,indLvl,fsep,"cs");
		json << (int) m_cs;
	}
	if (has_odrain()) {
		fsep = json_indent(json,indLvl,fsep,"odrain");
		json << (m_odrain ? "true" : "false");
	}
	if (has_digits()) {
		fsep = json_indent(json,indLvl,fsep,"digits");
		json << (unsigned) m_digits;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Max7219Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 clk, id 1
	if (m_clk != -1) {
		r += wiresize_s((varint_t)m_clk) + 1 /* tag(clk) 0x8 */;
	}
	// optional sint8 dout, id 2
	if (m_dout != -1) {
		r += wiresize_s((varint_t)m_dout) + 1 /* tag(dout) 0x10 */;
	}
	// optional sint8 cs, id 3
	if (m_cs != -1) {
		r += wiresize_s((varint_t)m_cs) + 1 /* tag(cs) 0x18 */;
	}
	// optional bool odrain, id 4
	if (m_odrain != false) {
		r += 2;
	}
	// optional uint8 digits, id 5
	if (m_digits != 0) {
		r += wiresize((varint_t)m_digits) + 1 /* tag(digits) 0x28 */;
	}
	return r;
}

bool Max7219Config::operator != (const Max7219Config &r) const
{
	if (has_clk() && (m_clk != r.m_clk))
		return true;
	if (has_dout() && (m_dout != r.m_dout))
		return true;
	if (has_cs() && (m_cs != r.m_cs))
		return true;
	if (has_odrain() && (m_odrain != r.m_odrain))
		return true;
	if (has_digits() && (m_digits != r.m_digits))
		return true;
	return false;
}


bool Max7219Config::operator == (const Max7219Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Max7219Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"clk")) {
		if (value == 0) {
			clear_clk();
			return 0;
		}
		int r = parse_ascii_s8(&m_clk,value);
		return r;
	}
	if (0 == strcmp(name,"dout")) {
		if (value == 0) {
			clear_dout();
			return 0;
		}
		int r = parse_ascii_s8(&m_dout,value);
		return r;
	}
	if (0 == strcmp(name,"cs")) {
		if (value == 0) {
			clear_cs();
			return 0;
		}
		int r = parse_ascii_s8(&m_cs,value);
		return r;
	}
	if (0 == strcmp(name,"odrain")) {
		if (value == 0) {
			clear_odrain();
			return 0;
		}
		int r = parse_ascii_bool(&m_odrain,value);
		return r;
	}
	if (0 == strcmp(name,"digits")) {
		if (value == 0) {
			clear_digits();
			return 0;
		}
		int r = parse_ascii_u8(&m_digits,value);
		return r;
	}
	return -118;
}

Tlc5947Config::Tlc5947Config()
: m_sin(-1)
, m_sclk(-1)
, m_xlat(-1)
, m_blank(-1)
, m_ntlc(0)
{
}

void Tlc5947Config::clear()
{
	m_sin = -1;
	m_sclk = -1;
	m_xlat = -1;
	m_blank = -1;
	m_ntlc = 0;
}

void Tlc5947Config::toASCII(stream &o, size_t indent) const
{
	o << "Tlc5947Config {";
	++indent;
	ascii_numeric(o, indent, "sin", (signed) m_sin);
	ascii_numeric(o, indent, "sclk", (signed) m_sclk);
	ascii_numeric(o, indent, "xlat", (signed) m_xlat);
	ascii_numeric(o, indent, "blank", (signed) m_blank);
	ascii_numeric(o, indent, "ntlc", (unsigned) m_ntlc);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Tlc5947Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -119;
		a += fn;
		switch (fid) {
		case 0x8:	// sin id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -120;
				a += n;
				set_sin(varint_sint(v));
			}
			break;
		case 0x10:	// sclk id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -121;
				a += n;
				set_sclk(varint_sint(v));
			}
			break;
		case 0x18:	// xlat id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -122;
				a += n;
				set_xlat(varint_sint(v));
			}
			break;
		case 0x20:	// blank id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -123;
				a += n;
				set_blank(varint_sint(v));
			}
			break;
		case 0x28:	// ntlc id 5, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -124;
				a += n;
				set_ntlc(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -125;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -126;
	return a-(const uint8_t *)b;
}

ssize_t Tlc5947Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has sin?
	if (m_sin != -1) {
		// 'sin': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -127;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_sin));
		if (n <= 0)
			return -128;
		a += n;
	}
	// has sclk?
	if (m_sclk != -1) {
		// 'sclk': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -129;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sclk));
		if (n <= 0)
			return -130;
		a += n;
	}
	// has xlat?
	if (m_xlat != -1) {
		// 'xlat': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -131;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_xlat));
		if (n <= 0)
			return -132;
		a += n;
	}
	// has blank?
	if (m_blank != -1) {
		// 'blank': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -133;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_blank));
		if (n <= 0)
			return -134;
		a += n;
	}
	// has ntlc?
	if (m_ntlc != 0) {
		// 'ntlc': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -135;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_ntlc);
		if (n <= 0)
			return -136;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Tlc5947Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_sin()) {
		fsep = json_indent(json,indLvl,fsep,"sin");
		json << (int) m_sin;
	}
	if (has_sclk()) {
		fsep = json_indent(json,indLvl,fsep,"sclk");
		json << (int) m_sclk;
	}
	if (has_xlat()) {
		fsep = json_indent(json,indLvl,fsep,"xlat");
		json << (int) m_xlat;
	}
	if (has_blank()) {
		fsep = json_indent(json,indLvl,fsep,"blank");
		json << (int) m_blank;
	}
	if (has_ntlc()) {
		fsep = json_indent(json,indLvl,fsep,"ntlc");
		json << (unsigned) m_ntlc;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Tlc5947Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 sin, id 1
	if (m_sin != -1) {
		r += wiresize_s((varint_t)m_sin) + 1 /* tag(sin) 0x8 */;
	}
	// optional sint8 sclk, id 2
	if (m_sclk != -1) {
		r += wiresize_s((varint_t)m_sclk) + 1 /* tag(sclk) 0x10 */;
	}
	// optional sint8 xlat, id 3
	if (m_xlat != -1) {
		r += wiresize_s((varint_t)m_xlat) + 1 /* tag(xlat) 0x18 */;
	}
	// optional sint8 blank, id 4
	if (m_blank != -1) {
		r += wiresize_s((varint_t)m_blank) + 1 /* tag(blank) 0x20 */;
	}
	// optional uint8 ntlc, id 5
	if (m_ntlc != 0) {
		r += wiresize((varint_t)m_ntlc) + 1 /* tag(ntlc) 0x28 */;
	}
	return r;
}

bool Tlc5947Config::operator != (const Tlc5947Config &r) const
{
	if (has_sin() && (m_sin != r.m_sin))
		return true;
	if (has_sclk() && (m_sclk != r.m_sclk))
		return true;
	if (has_xlat() && (m_xlat != r.m_xlat))
		return true;
	if (has_blank() && (m_blank != r.m_blank))
		return true;
	if (has_ntlc() && (m_ntlc != r.m_ntlc))
		return true;
	return false;
}


bool Tlc5947Config::operator == (const Tlc5947Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Tlc5947Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"sin")) {
		if (value == 0) {
			clear_sin();
			return 0;
		}
		int r = parse_ascii_s8(&m_sin,value);
		return r;
	}
	if (0 == strcmp(name,"sclk")) {
		if (value == 0) {
			clear_sclk();
			return 0;
		}
		int r = parse_ascii_s8(&m_sclk,value);
		return r;
	}
	if (0 == strcmp(name,"xlat")) {
		if (value == 0) {
			clear_xlat();
			return 0;
		}
		int r = parse_ascii_s8(&m_xlat,value);
		return r;
	}
	if (0 == strcmp(name,"blank")) {
		if (value == 0) {
			clear_blank();
			return 0;
		}
		int r = parse_ascii_s8(&m_blank,value);
		return r;
	}
	if (0 == strcmp(name,"ntlc")) {
		if (value == 0) {
			clear_ntlc();
			return 0;
		}
		int r = parse_ascii_u8(&m_ntlc,value);
		return r;
	}
	return -137;
}

Ws2812bConfig::Ws2812bConfig()
: m_gpio(-1)
, m_ch(-1)
, m_nleds(0)
{
}

void Ws2812bConfig::clear()
{
	m_gpio = -1;
	m_ch = -1;
	m_nleds = 0;
}

void Ws2812bConfig::toASCII(stream &o, size_t indent) const
{
	o << "Ws2812bConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "ch", (signed) m_ch);
	ascii_numeric(o, indent, "nleds", (unsigned) m_nleds);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Ws2812bConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -138;
		a += fn;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -139;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x10:	// ch id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -140;
				a += n;
				set_ch(varint_sint(v));
			}
			break;
		case 0x18:	// nleds id 3, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -141;
				a += n;
				set_nleds(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -142;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -143;
	return a-(const uint8_t *)b;
}

ssize_t Ws2812bConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -144;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -145;
		a += n;
	}
	// has ch?
	if (m_ch != -1) {
		// 'ch': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -146;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_ch));
		if (n <= 0)
			return -147;
		a += n;
	}
	// has nleds?
	if (m_nleds != 0) {
		// 'nleds': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -148;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_nleds);
		if (n <= 0)
			return -149;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Ws2812bConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_ch()) {
		fsep = json_indent(json,indLvl,fsep,"ch");
		json << (int) m_ch;
	}
	if (has_nleds()) {
		fsep = json_indent(json,indLvl,fsep,"nleds");
		json << (unsigned) m_nleds;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Ws2812bConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional sint8 ch, id 2
	if (m_ch != -1) {
		r += wiresize_s((varint_t)m_ch) + 1 /* tag(ch) 0x10 */;
	}
	// optional uint8 nleds, id 3
	if (m_nleds != 0) {
		r += wiresize((varint_t)m_nleds) + 1 /* tag(nleds) 0x18 */;
	}
	return r;
}

bool Ws2812bConfig::operator != (const Ws2812bConfig &r) const
{
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_ch() && (m_ch != r.m_ch))
		return true;
	if (has_nleds() && (m_nleds != r.m_nleds))
		return true;
	return false;
}


bool Ws2812bConfig::operator == (const Ws2812bConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Ws2812bConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"ch")) {
		if (value == 0) {
			clear_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_ch,value);
		return r;
	}
	if (0 == strcmp(name,"nleds")) {
		if (value == 0) {
			clear_nleds();
			return 0;
		}
		int r = parse_ascii_u8(&m_nleds,value);
		return r;
	}
	return -150;
}

DhtConfig::DhtConfig()
: m_model(DHT_NONE)
, m_gpio(-1)
{
}

void DhtConfig::clear()
{
	m_model = DHT_NONE;
	m_gpio = -1;
}

void DhtConfig::toASCII(stream &o, size_t indent) const
{
	o << "DhtConfig {";
	++indent;
	ascii_indent(o,indent,"model");
	if (const char *v = dht_model_t_str(m_model))
		o << v;
	else
		o << m_model;
	o << ';';
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t DhtConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -151;
		a += fn;
		switch (fid) {
		case 0x8:	// model id 1, type dht_model_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -152;
				a += n;
				set_model((dht_model_t) v);
			}
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -153;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -154;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -155;
	return a-(const uint8_t *)b;
}

ssize_t DhtConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has model?
	if (m_model != DHT_NONE) {
		// 'model': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -156;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_model);
		if (n <= 0)
			return -157;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -158;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -159;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void DhtConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_model()) {
		fsep = json_indent(json,indLvl,fsep,"model");
		if (const char *v = dht_model_t_str(m_model)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_model;
		}
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t DhtConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional dht_model_t model, id 1
	if (m_model != DHT_NONE) {
		r += wiresize((varint_t)m_model) + 1 /* tag(model) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	return r;
}

bool DhtConfig::operator != (const DhtConfig &r) const
{
	if (has_model() && (m_model != r.m_model))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	return false;
}


bool DhtConfig::operator == (const DhtConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int DhtConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"model")) {
		if (value == 0) {
			clear_model();
			return 0;
		}
		dht_model_t v;
		size_t r = parse_ascii_dht_model_t(&v,value);
		if (r == 0)
			return -160;
		set_model(v);
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	return -161;
}

I2CConfig::I2CConfig()
: m_freq(100000)
, m_devices()
, m_port(0)
, m_sda(-1)
, m_scl(-1)
, m_xpullup(0)
, p_validbits(0)
{
}

void I2CConfig::clear()
{
	m_port = 0;
	m_sda = -1;
	m_scl = -1;
	m_freq = 100000;
	m_xpullup = 0;
	m_devices.clear();
	p_validbits = 0;
}

void I2CConfig::toASCII(stream &o, size_t indent) const
{
	o << "I2CConfig {";
	++indent;
	ascii_numeric(o, indent, "port", (unsigned) m_port);
	ascii_numeric(o, indent, "sda", (signed) m_sda);
	ascii_numeric(o, indent, "scl", (signed) m_scl);
	ascii_numeric(o, indent, "freq", m_freq);
	ascii_indent(o,indent,"xpullup");
	o << (m_xpullup ? "true" : "false") << ';';
	ascii_indent(o,indent);
	size_t s_devices = m_devices.size();
	o << "devices[" << s_devices << "] = {";
	++indent;
	for (size_t i = 0, e = s_devices; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_numeric(o, indent, "devices", m_devices[i]);
		++indent;
		ascii_indent(o,indent);
		o << ".addr = " ;
		o << (unsigned) devices_addr(i);
		o << ';';
		ascii_indent(o,indent);
		o << ".scanaddr = " ;
		o << (devices_scanaddr(i) ? "true;" : "false;");
		ascii_indent(o,indent);
		o << ".drv = " ;
		o << i2cdrv_t_str(devices_drv(i));
		o << ';';
		--indent;
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t I2CConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -162;
		a += fn;
		switch (fid) {
		case 0x8:	// port id 1, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -163;
				a += n;
				set_port(v);
			}
			break;
		case 0x10:	// sda id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -164;
				a += n;
				set_sda(varint_sint(v));
			}
			break;
		case 0x18:	// scl id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -165;
				a += n;
				set_scl(varint_sint(v));
			}
			break;
		case 0x20:	// freq id 4, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -166;
				a += n;
				set_freq(v);
			}
			break;
		case 0x2b:	// xpullup id 5, type bool, coding 8bit
			if (a >= e)
				return -167;
			set_xpullup(*a++);
			break;
		case 0x32: {	// devices id 6, packed i2cdev_t[] coding 2
				varint_t v;
				int n = read_varint(a,e-a,&v);	// length of packed
				if (n <= 0)
					return -168;
				a += n;
				const uint8_t *ae = a + v;
				do {
					varint_t v;
					int n = read_varint(a,e-a,&v);
					if (n <= 0)
						return -169;
					a += n;
					m_devices.push_back((i2cdev_t)v);
				} while (a < ae);
			} break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -170;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -171;
	return a-(const uint8_t *)b;
}

ssize_t I2CConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -172;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_port);
		if (n <= 0)
			return -173;
		a += n;
	}
	// has sda?
	if (m_sda != -1) {
		// 'sda': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -174;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sda));
		if (n <= 0)
			return -175;
		a += n;
	}
	// has scl?
	if (m_scl != -1) {
		// 'scl': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -176;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_scl));
		if (n <= 0)
			return -177;
		a += n;
	}
	// has freq?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'freq': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -178;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_freq);
		if (n <= 0)
			return -179;
		a += n;
	}
	// has xpullup?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'xpullup': id=5, encoding=8bit, tag=0x2b
		if (2 > (e-a))
			return -180;
		*a++ = 0x2b;
		*a++ = m_xpullup;
	}
	if (size_t devices_ne = m_devices.size()) {
		// 'devices': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -181;
		*a++ = 0x32;
		ssize_t devices_ws = 0;
		for (size_t x = 0; x != devices_ne; ++x)
			devices_ws += wiresize(m_devices[x]);
		n = write_varint(a,e-a,devices_ws);
		a += n;
		if ((n <= 0) || (devices_ws > (e-a)))
			return -182;
		for (size_t x = 0; x != devices_ne; ++x)
			a += write_varint(a,e-a,m_devices[x]);
	}
	assert(a <= e);
	return a-b;
}

void I2CConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << (unsigned) m_port;
	}
	if (has_sda()) {
		fsep = json_indent(json,indLvl,fsep,"sda");
		json << (int) m_sda;
	}
	if (has_scl()) {
		fsep = json_indent(json,indLvl,fsep,"scl");
		json << (int) m_scl;
	}
	if (has_freq()) {
		fsep = json_indent(json,indLvl,fsep,"freq");
		json << m_freq;
	}
	if (has_xpullup()) {
		fsep = json_indent(json,indLvl,fsep,"xpullup");
		json << (m_xpullup ? "true" : "false");
	}
	if (size_t s = m_devices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"devices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json << m_devices[i];
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t I2CConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional uint8 port, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional sint8 sda, id 2
	if (m_sda != -1) {
		r += wiresize_s((varint_t)m_sda) + 1 /* tag(sda) 0x10 */;
	}
	// optional sint8 scl, id 3
	if (m_scl != -1) {
		r += wiresize_s((varint_t)m_scl) + 1 /* tag(scl) 0x18 */;
	}
	// optional unsigned freq, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_freq) + 1 /* tag(freq) 0x20 */;
	}
	// optional bool xpullup, id 5
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += 2;
	}
	// repeated i2cdev_t devices, id 6
	if (!m_devices.empty()) {
		// devices: packed repeated i2cdev_t
		size_t devices_dl = 0;
		for (size_t x = 0, y = m_devices.size(); x < y; ++x)
			devices_dl += wiresize((varint_t)m_devices[x]);
		r += devices_dl + wiresize(devices_dl) /* data length */ + 1 /* tag(devices) 0x30 */;
	}
	return r;
}

bool I2CConfig::operator != (const I2CConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_sda() && (m_sda != r.m_sda))
		return true;
	if (has_scl() && (m_scl != r.m_scl))
		return true;
	if (has_freq() && (m_freq != r.m_freq))
		return true;
	if (has_xpullup() && (m_xpullup != r.m_xpullup))
		return true;
	if (m_devices != r.m_devices)
		return true;
	return false;
}


bool I2CConfig::operator == (const I2CConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int I2CConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u8(&m_port,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"sda")) {
		if (value == 0) {
			clear_sda();
			return 0;
		}
		int r = parse_ascii_s8(&m_sda,value);
		return r;
	}
	if (0 == strcmp(name,"scl")) {
		if (value == 0) {
			clear_scl();
			return 0;
		}
		int r = parse_ascii_s8(&m_scl,value);
		return r;
	}
	if (0 == strcmp(name,"freq")) {
		if (value == 0) {
			clear_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_freq,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"xpullup")) {
		if (value == 0) {
			clear_xpullup();
			return 0;
		}
		int r = parse_ascii_bool(&m_xpullup,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == memcmp(name,"devices",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_devices();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_devices.size();
				m_devices.resize(x+1);
				idxe = (char*)(name + 9);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if (idxe[0] != ']')
					return -183;
				if (m_devices.size() <= x)
					return -184;
				if ((idxe[1] == 0) && (value == 0)) {
					m_devices.erase(m_devices.begin()+x);
					return 0;
				}
			}
			char *eptr = 0;
			unsigned long long ull = strtoull(value,&eptr,0);
			if (eptr == value)
				return -185;
			if (idxe[1] == 0) {
				m_devices[x] = (i2cdev_t) ull;
				return eptr - value;
			}
			if (idxe[1] != '.')
				return -186;
			idxe += 2;
			if (!strcmp("addr",idxe)) {
				set_devices_addr(x,(uint8_t)ull);
				return 0;
			}
			if (!strcmp("scanaddr",idxe)) {
				set_devices_scanaddr(x,(bool)ull);
				return 0;
			}
			if (!strcmp("drv",idxe)) {
				set_devices_drv(x,(i2cdrv_t)ull);
				return 0;
			}
			return -187;
		}
	}
	return -188;
}

HcSr04Config::HcSr04Config()
: m_name()
, m_trigger(-1)
, m_echo(-1)
, p_validbits(0)
{
}

void HcSr04Config::clear()
{
	m_trigger = -1;
	m_echo = -1;
	m_name.clear();
	p_validbits = 0;
}

void HcSr04Config::toASCII(stream &o, size_t indent) const
{
	o << "HcSr04Config {";
	++indent;
	ascii_numeric(o, indent, "trigger", (signed) m_trigger);
	ascii_numeric(o, indent, "echo", (signed) m_echo);
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t HcSr04Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -189;
		a += fn;
		switch (fid) {
		case 0x8:	// trigger id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -190;
				a += n;
				set_trigger(varint_sint(v));
			}
			break;
		case 0x10:	// echo id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -191;
				a += n;
				set_echo(varint_sint(v));
			}
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -192;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -193;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -194;
	return a-(const uint8_t *)b;
}

ssize_t HcSr04Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has trigger?
	if (m_trigger != -1) {
		// 'trigger': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -195;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_trigger));
		if (n <= 0)
			return -196;
		a += n;
	}
	// has echo?
	if (m_echo != -1) {
		// 'echo': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -197;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_echo));
		if (n <= 0)
			return -198;
		a += n;
	}
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -199;
		*a++ = 0x1a;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -200;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	assert(a <= e);
	return a-b;
}

void HcSr04Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_trigger()) {
		fsep = json_indent(json,indLvl,fsep,"trigger");
		json << (int) m_trigger;
	}
	if (has_echo()) {
		fsep = json_indent(json,indLvl,fsep,"echo");
		json << (int) m_echo;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t HcSr04Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 trigger, id 1
	if (m_trigger != -1) {
		r += wiresize_s((varint_t)m_trigger) + 1 /* tag(trigger) 0x8 */;
	}
	// optional sint8 echo, id 2
	if (m_echo != -1) {
		r += wiresize_s((varint_t)m_echo) + 1 /* tag(echo) 0x10 */;
	}
	// optional string name, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	return r;
}

bool HcSr04Config::operator != (const HcSr04Config &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_trigger() && (m_trigger != r.m_trigger))
		return true;
	if (has_echo() && (m_echo != r.m_echo))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	return false;
}


bool HcSr04Config::operator == (const HcSr04Config &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int HcSr04Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"trigger")) {
		if (value == 0) {
			clear_trigger();
			return 0;
		}
		int r = parse_ascii_s8(&m_trigger,value);
		return r;
	}
	if (0 == strcmp(name,"echo")) {
		if (value == 0) {
			clear_echo();
			return 0;
		}
		int r = parse_ascii_s8(&m_echo,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	return -201;
}

LedConfig::LedConfig()
: m_name("")
, m_gpio(-1)
, m_config(0)
, m_pwm_ch(-1)
, p_validbits(0)
{
}

void LedConfig::clear()
{
	m_gpio = -1;
	m_config = 0;
	m_name = "";
	m_pwm_ch = -1;
	p_validbits = 0;
}

void LedConfig::toASCII(stream &o, size_t indent) const
{
	o << "LedConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", (unsigned) m_config);
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "pwm_ch", (signed) m_pwm_ch);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t LedConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -202;
		a += fn;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -203;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x10:	// config id 2, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -204;
				a += n;
				set_config(v);
			}
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -205;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x20:	// pwm_ch id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -206;
				a += n;
				set_pwm_ch(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -207;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -208;
	return a-(const uint8_t *)b;
}

ssize_t LedConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -209;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -210;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -211;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -212;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -213;
		*a++ = 0x1a;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -214;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has pwm_ch?
	if (m_pwm_ch != -1) {
		// 'pwm_ch': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -215;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_pwm_ch));
		if (n <= 0)
			return -216;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void LedConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_pwm_ch()) {
		fsep = json_indent(json,indLvl,fsep,"pwm_ch");
		json << (int) m_pwm_ch;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t LedConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional uint8 config, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x10 */;
	}
	// optional string name, id 3
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	// optional sint8 pwm_ch, id 4
	if (m_pwm_ch != -1) {
		r += wiresize_s((varint_t)m_pwm_ch) + 1 /* tag(pwm_ch) 0x20 */;
	}
	return r;
}

bool LedConfig::operator != (const LedConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_pwm_ch() && (m_pwm_ch != r.m_pwm_ch))
		return true;
	return false;
}


bool LedConfig::operator == (const LedConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int LedConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"config")) {
		if (value == 0) {
			clear_config();
			return 0;
		}
		int r = parse_ascii_u8(&m_config,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"pwm_ch")) {
		if (value == 0) {
			clear_pwm_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_pwm_ch,value);
		return r;
	}
	return -217;
}

OneWireConfig::OneWireConfig()
: m_gpio(-1)
, m_pullup(false)
, m_power(-1)
{
}

void OneWireConfig::clear()
{
	m_gpio = -1;
	m_pullup = false;
	m_power = -1;
}

void OneWireConfig::toASCII(stream &o, size_t indent) const
{
	o << "OneWireConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_indent(o,indent,"pullup");
	o << (m_pullup ? "true" : "false") << ';';
	ascii_numeric(o, indent, "power", (signed) m_power);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t OneWireConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -218;
		a += fn;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -219;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x13:	// pullup id 2, type bool, coding 8bit
			if (a >= e)
				return -220;
			set_pullup(*a++);
			break;
		case 0x18:	// power id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -221;
				a += n;
				set_power(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -222;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -223;
	return a-(const uint8_t *)b;
}

ssize_t OneWireConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -224;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -225;
		a += n;
	}
	// has pullup?
	if (m_pullup != false) {
		// 'pullup': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -226;
		*a++ = 0x13;
		*a++ = m_pullup;
	}
	// has power?
	if (m_power != -1) {
		// 'power': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -227;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_power));
		if (n <= 0)
			return -228;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void OneWireConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_pullup()) {
		fsep = json_indent(json,indLvl,fsep,"pullup");
		json << (m_pullup ? "true" : "false");
	}
	if (has_power()) {
		fsep = json_indent(json,indLvl,fsep,"power");
		json << (int) m_power;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t OneWireConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional bool pullup, id 2
	if (m_pullup != false) {
		r += 2;
	}
	// optional sint8 power, id 3
	if (m_power != -1) {
		r += wiresize_s((varint_t)m_power) + 1 /* tag(power) 0x18 */;
	}
	return r;
}

bool OneWireConfig::operator != (const OneWireConfig &r) const
{
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_pullup() && (m_pullup != r.m_pullup))
		return true;
	if (has_power() && (m_power != r.m_power))
		return true;
	return false;
}


bool OneWireConfig::operator == (const OneWireConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int OneWireConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"pullup")) {
		if (value == 0) {
			clear_pullup();
			return 0;
		}
		int r = parse_ascii_bool(&m_pullup,value);
		return r;
	}
	if (0 == strcmp(name,"power")) {
		if (value == 0) {
			clear_power();
			return 0;
		}
		int r = parse_ascii_s8(&m_power,value);
		return r;
	}
	return -229;
}

UartConfig::UartConfig()
: m_port(0)
, m_tx_gpio(0)
, m_rx_gpio(0)
, m_cts_gpio(0)
, m_rts_gpio(0)
, p_validbits(0)
{
}

void UartConfig::clear()
{
	m_port = 0;
	m_tx_gpio = 0;
	m_rx_gpio = 0;
	m_cts_gpio = 0;
	m_rts_gpio = 0;
	p_validbits = 0;
}

void UartConfig::toASCII(stream &o, size_t indent) const
{
	o << "UartConfig {";
	++indent;
	ascii_numeric(o, indent, "port", (signed) m_port);
	ascii_numeric(o, indent, "tx_gpio", (signed) m_tx_gpio);
	ascii_numeric(o, indent, "rx_gpio", (signed) m_rx_gpio);
	ascii_numeric(o, indent, "cts_gpio", (signed) m_cts_gpio);
	ascii_numeric(o, indent, "rts_gpio", (signed) m_rts_gpio);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t UartConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -230;
		a += fn;
		switch (fid) {
		case 0x8:	// port id 1, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -231;
				a += n;
				set_port(varint_sint(v));
			}
			break;
		case 0x10:	// tx_gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -232;
				a += n;
				set_tx_gpio(varint_sint(v));
			}
			break;
		case 0x18:	// rx_gpio id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -233;
				a += n;
				set_rx_gpio(varint_sint(v));
			}
			break;
		case 0x20:	// cts_gpio id 4, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -234;
				a += n;
				set_cts_gpio(varint_sint(v));
			}
			break;
		case 0x28:	// rts_gpio id 5, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -235;
				a += n;
				set_rts_gpio(varint_sint(v));
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -236;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -237;
	return a-(const uint8_t *)b;
}

ssize_t UartConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -238;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_port));
		if (n <= 0)
			return -239;
		a += n;
	}
	// has tx_gpio?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'tx_gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -240;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_tx_gpio));
		if (n <= 0)
			return -241;
		a += n;
	}
	// has rx_gpio?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'rx_gpio': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -242;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_rx_gpio));
		if (n <= 0)
			return -243;
		a += n;
	}
	// has cts_gpio?
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		// 'cts_gpio': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -244;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_cts_gpio));
		if (n <= 0)
			return -245;
		a += n;
	}
	// has rts_gpio?
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		// 'rts_gpio': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -246;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_rts_gpio));
		if (n <= 0)
			return -247;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void UartConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		json << (int) m_port;
	}
	if (has_tx_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"tx_gpio");
		json << (int) m_tx_gpio;
	}
	if (has_rx_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"rx_gpio");
		json << (int) m_rx_gpio;
	}
	if (has_cts_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"cts_gpio");
		json << (int) m_cts_gpio;
	}
	if (has_rts_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"rts_gpio");
		json << (int) m_rts_gpio;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t UartConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 port, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize_s((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional sint8 tx_gpio, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize_s((varint_t)m_tx_gpio) + 1 /* tag(tx_gpio) 0x10 */;
	}
	// optional sint8 rx_gpio, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += wiresize_s((varint_t)m_rx_gpio) + 1 /* tag(rx_gpio) 0x18 */;
	}
	// optional sint8 cts_gpio, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 3))) {
		r += wiresize_s((varint_t)m_cts_gpio) + 1 /* tag(cts_gpio) 0x20 */;
	}
	// optional sint8 rts_gpio, id 5
	if (0 != (p_validbits & ((uint8_t)1U << 4))) {
		r += wiresize_s((varint_t)m_rts_gpio) + 1 /* tag(rts_gpio) 0x28 */;
	}
	return r;
}

bool UartConfig::operator != (const UartConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_port() && (m_port != r.m_port))
		return true;
	if (has_tx_gpio() && (m_tx_gpio != r.m_tx_gpio))
		return true;
	if (has_rx_gpio() && (m_rx_gpio != r.m_rx_gpio))
		return true;
	if (has_cts_gpio() && (m_cts_gpio != r.m_cts_gpio))
		return true;
	if (has_rts_gpio() && (m_rts_gpio != r.m_rts_gpio))
		return true;
	return false;
}


bool UartConfig::operator == (const UartConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int UartConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_s8(&m_port,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"tx_gpio")) {
		if (value == 0) {
			clear_tx_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_tx_gpio,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"rx_gpio")) {
		if (value == 0) {
			clear_rx_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_rx_gpio,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"cts_gpio")) {
		if (value == 0) {
			clear_cts_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_cts_gpio,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 3);
		return r;
	}
	if (0 == strcmp(name,"rts_gpio")) {
		if (value == 0) {
			clear_rts_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_rts_gpio,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 4);
		return r;
	}
	return -248;
}

AdcChannel::AdcChannel()
: m_name("")
, m_unit(0)
, m_ch(-1)
, m_atten(0)
, p_validbits(0)
{
}

void AdcChannel::clear()
{
	m_name = "";
	m_unit = 0;
	m_ch = -1;
	m_atten = 0;
	p_validbits = 0;
}

void AdcChannel::toASCII(stream &o, size_t indent) const
{
	o << "AdcChannel {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "unit", (unsigned) m_unit);
	ascii_numeric(o, indent, "ch", (signed) m_ch);
	ascii_numeric(o, indent, "atten", (unsigned) m_atten);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AdcChannel::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -249;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -250;
				m_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// unit id 2, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -251;
				a += n;
				set_unit(v);
			}
			break;
		case 0x18:	// ch id 3, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -252;
				a += n;
				set_ch(varint_sint(v));
			}
			break;
		case 0x20:	// atten id 4, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -253;
				a += n;
				set_atten(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -254;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -255;
	return a-(const uint8_t *)b;
}

ssize_t AdcChannel::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -256;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -257;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has unit?
	if (m_unit != 0) {
		// 'unit': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -258;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_unit);
		if (n <= 0)
			return -259;
		a += n;
	}
	// has ch?
	if (m_ch != -1) {
		// 'ch': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -260;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_ch));
		if (n <= 0)
			return -261;
		a += n;
	}
	// has atten?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'atten': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -262;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_atten);
		if (n <= 0)
			return -263;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void AdcChannel::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_unit()) {
		fsep = json_indent(json,indLvl,fsep,"unit");
		json << (unsigned) m_unit;
	}
	if (has_ch()) {
		fsep = json_indent(json,indLvl,fsep,"ch");
		json << (int) m_ch;
	}
	if (has_atten()) {
		fsep = json_indent(json,indLvl,fsep,"atten");
		json << (unsigned) m_atten;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AdcChannel::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (!m_name.empty()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional uint8 unit, id 2
	if (m_unit != 0) {
		r += wiresize((varint_t)m_unit) + 1 /* tag(unit) 0x10 */;
	}
	// optional sint8 ch, id 3
	if (m_ch != -1) {
		r += wiresize_s((varint_t)m_ch) + 1 /* tag(ch) 0x18 */;
	}
	// optional uint8 atten, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_atten) + 1 /* tag(atten) 0x20 */;
	}
	return r;
}

bool AdcChannel::operator != (const AdcChannel &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_unit() && (m_unit != r.m_unit))
		return true;
	if (has_ch() && (m_ch != r.m_ch))
		return true;
	if (has_atten() && (m_atten != r.m_atten))
		return true;
	return false;
}


bool AdcChannel::operator == (const AdcChannel &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AdcChannel::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"unit")) {
		if (value == 0) {
			clear_unit();
			return 0;
		}
		int r = parse_ascii_u8(&m_unit,value);
		return r;
	}
	if (0 == strcmp(name,"ch")) {
		if (value == 0) {
			clear_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_ch,value);
		return r;
	}
	if (0 == strcmp(name,"atten")) {
		if (value == 0) {
			clear_atten();
			return 0;
		}
		int r = parse_ascii_u8(&m_atten,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	return -264;
}

AdcConfig::AdcConfig()
: m_adc_name("")
, m_hall_name("")
, m_adc1_bits(0)
, m_adc2_bits(0)
// omitted unused member mode
// omitted unused member clk_div
, m_channels()
, p_validbits(0)
{
}

void AdcConfig::clear()
{
	m_adc_name = "";
	m_adc1_bits = 0;
	m_adc2_bits = 0;
	m_hall_name = "";
	m_channels.clear();
	p_validbits = 0;
}

void AdcConfig::toASCII(stream &o, size_t indent) const
{
	o << "AdcConfig {";
	++indent;
	ascii_indent(o,indent,"adc_name");
	ascii_string(o,m_adc_name.data(),m_adc_name.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "adc1_bits", (unsigned) m_adc1_bits);
	ascii_numeric(o, indent, "adc2_bits", (unsigned) m_adc2_bits);
	ascii_indent(o,indent,"hall_name");
	ascii_string(o,m_hall_name.data(),m_hall_name.size(),indent+2);
	o << ';';
	ascii_indent(o,indent);
	size_t s_channels = m_channels.size();
	o << "channels[" << s_channels << "] = {";
	++indent;
	for (size_t i = 0, e = s_channels; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_channels[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AdcConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -265;
		a += fn;
		switch (fid) {
		case 0xa:	// adc_name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -266;
				m_adc_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x10:	// adc1_bits id 2, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -267;
				a += n;
				set_adc1_bits(v);
			}
			break;
		case 0x18:	// adc2_bits id 3, type uint8_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -268;
				a += n;
				set_adc2_bits(v);
			}
			break;
		case 0x32:	// hall_name id 6, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -269;
				m_hall_name.assign((const char*)a,v);
				a += v;
			}
			break;
		case 0x3a:	// channels id 7, type AdcChannel, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -270;
				m_channels.emplace_back();
				if (v != 0) {
					n = m_channels.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -271;
					a += v;
				}
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -272;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -273;
	return a-(const uint8_t *)b;
}

ssize_t AdcConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has adc_name?
	if (!m_adc_name.empty()) {
		// 'adc_name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -274;
		*a++ = 0xa;
		ssize_t adc_name_s = m_adc_name.size();
		n = write_varint(a,e-a,adc_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < adc_name_s))
			return -275;
		memcpy(a,m_adc_name.data(),adc_name_s);
		a += adc_name_s;
	}
	// has adc1_bits?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'adc1_bits': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -276;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_adc1_bits);
		if (n <= 0)
			return -277;
		a += n;
	}
	// has adc2_bits?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'adc2_bits': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -278;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_adc2_bits);
		if (n <= 0)
			return -279;
		a += n;
	}
	// 'mode' is unused. Therefore no data will be written.
	// 'clk_div' is unused. Therefore no data will be written.
	// has hall_name?
	if (!m_hall_name.empty()) {
		// 'hall_name': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -280;
		*a++ = 0x32;
		ssize_t hall_name_s = m_hall_name.size();
		n = write_varint(a,e-a,hall_name_s);
		a += n;
		if ((n <= 0) || ((e-a) < hall_name_s))
			return -281;
		memcpy(a,m_hall_name.data(),hall_name_s);
		a += hall_name_s;
	}
	for (const auto &x : m_channels) {
		// 'channels': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -282;
		*a++ = 0x3a;
		ssize_t channels_ws = x.calcSize();
		n = write_varint(a,e-a,channels_ws);
		a += n;
		if ((n <= 0) || (channels_ws > (e-a)))
			return -283;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == channels_ws);
	}
	assert(a <= e);
	return a-b;
}

void AdcConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_adc_name()) {
		fsep = json_indent(json,indLvl,fsep,"adc_name");
		json_cstr(json,m_adc_name.c_str());
	}
	if (has_adc1_bits()) {
		fsep = json_indent(json,indLvl,fsep,"adc1_bits");
		json << (unsigned) m_adc1_bits;
	}
	if (has_adc2_bits()) {
		fsep = json_indent(json,indLvl,fsep,"adc2_bits");
		json << (unsigned) m_adc2_bits;
	}
	if (has_hall_name()) {
		fsep = json_indent(json,indLvl,fsep,"hall_name");
		json_cstr(json,m_hall_name.c_str());
	}
	if (size_t s = m_channels.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"channels\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_channels[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AdcConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string adc_name, id 1
	if (!m_adc_name.empty()) {
		size_t adc_name_s = m_adc_name.size();
		r += adc_name_s + wiresize(adc_name_s) + 1 /* tag(adc_name) 0x8 */;
	}
	// optional uint8 adc1_bits, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_adc1_bits) + 1 /* tag(adc1_bits) 0x10 */;
	}
	// optional uint8 adc2_bits, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_adc2_bits) + 1 /* tag(adc2_bits) 0x18 */;
	}
	// unused optional uint8 mode, id 4
	// unused optional uint8 clk_div, id 5
	// optional string hall_name, id 6
	if (!m_hall_name.empty()) {
		size_t hall_name_s = m_hall_name.size();
		r += hall_name_s + wiresize(hall_name_s) + 1 /* tag(hall_name) 0x30 */;
	}
	// repeated AdcChannel channels, id 7
	// repeated message channels
	for (size_t x = 0, y = m_channels.size(); x < y; ++x) {
		size_t s = m_channels[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(channels) 0x38 */;
	}
	return r;
}

bool AdcConfig::operator != (const AdcConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_adc_name() && (m_adc_name != r.m_adc_name))
		return true;
	if (has_adc1_bits() && (m_adc1_bits != r.m_adc1_bits))
		return true;
	if (has_adc2_bits() && (m_adc2_bits != r.m_adc2_bits))
		return true;
	if (has_hall_name() && (m_hall_name != r.m_hall_name))
		return true;
	if (m_channels != r.m_channels)
		return true;
	return false;
}


bool AdcConfig::operator == (const AdcConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AdcConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"adc_name")) {
		if (value == 0) {
			clear_adc_name();
			return 0;
		}
		m_adc_name = value;
		int r = m_adc_name.size();
		return r;
	}
	if (0 == strcmp(name,"adc1_bits")) {
		if (value == 0) {
			clear_adc1_bits();
			return 0;
		}
		int r = parse_ascii_u8(&m_adc1_bits,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"adc2_bits")) {
		if (value == 0) {
			clear_adc2_bits();
			return 0;
		}
		int r = parse_ascii_u8(&m_adc2_bits,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"hall_name")) {
		if (value == 0) {
			clear_hall_name();
			return 0;
		}
		m_hall_name = value;
		int r = m_hall_name.size();
		return r;
	}
	if (0 == memcmp(name,"channels",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_channels();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_channels.size();
				m_channels.resize(x+1);
				idxe = (char*)(name + 10);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if (idxe[0] != ']')
					return -284;
				if (m_channels.size() <= x)
					return -285;
				if ((idxe[1] == 0) && (value == 0)) {
					m_channels.erase(m_channels.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -286;
			return m_channels[x].setByName(idxe+2,value);
		}
	}
	return -287;
}

GpioConfig::GpioConfig()
: m_name()
, m_config(0)
, m_gpio(-1)
, p_validbits(0)
{
}

void GpioConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_config = 0;
	p_validbits = 0;
}

void GpioConfig::toASCII(stream &o, size_t indent) const
{
	o << "GpioConfig {";
	++indent;
	ascii_indent(o,indent,"name");
	ascii_string(o,m_name.data(),m_name.size(),indent+2);
	o << ';';
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".mode = " ;
	o << (unsigned) config_mode();
	o << ';';
	ascii_indent(o,indent);
	o << ".intrtype = " ;
	o << (unsigned) config_intrtype();
	o << ';';
	ascii_indent(o,indent);
	o << ".setinit = " ;
	o << (config_setinit() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".initlvl = " ;
	o << (config_initlvl() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".pullup = " ;
	o << (config_pullup() ? "true;" : "false;");
	ascii_indent(o,indent);
	o << ".pulldown = " ;
	o << (config_pulldown() ? "true;" : "false;");
	--indent;
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t GpioConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -288;
		a += fn;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -289;
				m_name.assign((const char*)a,v);
				a += v;
			}
			p_validbits |= ((uint8_t)1U << 0);
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -290;
				a += n;
				set_gpio(varint_sint(v));
			}
			break;
		case 0x18:	// config id 3, type gpiocfg_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -291;
				a += n;
				set_config((gpiocfg_t) v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -292;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -293;
	return a-(const uint8_t *)b;
}

ssize_t GpioConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -294;
		*a++ = 0xa;
		ssize_t name_s = m_name.size();
		n = write_varint(a,e-a,name_s);
		a += n;
		if ((n <= 0) || ((e-a) < name_s))
			return -295;
		memcpy(a,m_name.data(),name_s);
		a += name_s;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -296;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -297;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -298;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -299;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void GpioConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		json << (int) m_gpio;
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t GpioConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (m_gpio != -1) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional gpiocfg_t config, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	return r;
}

bool GpioConfig::operator != (const GpioConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_name() && (m_name != r.m_name))
		return true;
	if (has_gpio() && (m_gpio != r.m_gpio))
		return true;
	if (has_config() && (m_config != r.m_config))
		return true;
	return false;
}


bool GpioConfig::operator == (const GpioConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int GpioConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((gpiocfg_t)ull);
			else if (!strcmp(name,"mode"))
				set_config_mode((uint8_t)ull);
			else if (!strcmp(name,"intrtype"))
				set_config_intrtype((uint8_t)ull);
			else if (!strcmp(name,"setinit"))
				set_config_setinit((bool)ull);
			else if (!strcmp(name,"initlvl"))
				set_config_initlvl((bool)ull);
			else if (!strcmp(name,"pullup"))
				set_config_pullup((bool)ull);
			else if (!strcmp(name,"pulldown"))
				set_config_pulldown((bool)ull);
			return eptr - value;
		} else {
			return -300;
		}
	}
	return -301;
}

DisplayConfig::DisplayConfig()
: m_type(dt_none)
, m_options(0)
, m_maxx(0)
, m_maxy(1)
, p_validbits(0)
{
}

void DisplayConfig::clear()
{
	m_type = dt_none;
	m_options = 0;
	m_maxx = 0;
	m_maxy = 1;
	p_validbits = 0;
}

void DisplayConfig::toASCII(stream &o, size_t indent) const
{
	o << "DisplayConfig {";
	++indent;
	ascii_indent(o,indent,"type");
	if (const char *v = disp_t_str(m_type))
		o << v;
	else
		o << m_type;
	o << ';';
	ascii_numeric(o, indent, "options", m_options);
	ascii_numeric(o, indent, "maxx", m_maxx);
	ascii_numeric(o, indent, "maxy", m_maxy);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t DisplayConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -302;
		a += fn;
		switch (fid) {
		case 0x8:	// type id 1, type disp_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -303;
				a += n;
				set_type((disp_t) v);
			}
			break;
		case 0x10:	// options id 2, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -304;
				a += n;
				set_options(v);
			}
			break;
		case 0x18:	// maxx id 3, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -305;
				a += n;
				set_maxx(v);
			}
			break;
		case 0x20:	// maxy id 4, type uint32_t, coding varint
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				if (n <= 0)
					return -306;
				a += n;
				set_maxy(v);
			}
			break;
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -307;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -308;
	return a-(const uint8_t *)b;
}

ssize_t DisplayConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has type?
	if (m_type != dt_none) {
		// 'type': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -309;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_type);
		if (n <= 0)
			return -310;
		a += n;
	}
	// has options?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'options': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -311;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_options);
		if (n <= 0)
			return -312;
		a += n;
	}
	// has maxx?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'maxx': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -313;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_maxx);
		if (n <= 0)
			return -314;
		a += n;
	}
	// has maxy?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'maxy': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -315;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_maxy);
		if (n <= 0)
			return -316;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void DisplayConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_type()) {
		fsep = json_indent(json,indLvl,fsep,"type");
		if (const char *v = disp_t_str(m_type)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_type;
		}
	}
	if (has_options()) {
		fsep = json_indent(json,indLvl,fsep,"options");
		json << m_options;
	}
	if (has_maxx()) {
		fsep = json_indent(json,indLvl,fsep,"maxx");
		json << m_maxx;
	}
	if (has_maxy()) {
		fsep = json_indent(json,indLvl,fsep,"maxy");
		json << m_maxy;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t DisplayConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional disp_t type, id 1
	if (m_type != dt_none) {
		r += wiresize((varint_t)m_type) + 1 /* tag(type) 0x8 */;
	}
	// optional unsigned options, id 2
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		r += wiresize((varint_t)m_options) + 1 /* tag(options) 0x10 */;
	}
	// optional unsigned maxx, id 3
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		r += wiresize((varint_t)m_maxx) + 1 /* tag(maxx) 0x18 */;
	}
	// optional unsigned maxy, id 4
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		r += wiresize((varint_t)m_maxy) + 1 /* tag(maxy) 0x20 */;
	}
	return r;
}

bool DisplayConfig::operator != (const DisplayConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_type() && (m_type != r.m_type))
		return true;
	if (has_options() && (m_options != r.m_options))
		return true;
	if (has_maxx() && (m_maxx != r.m_maxx))
		return true;
	if (has_maxy() && (m_maxy != r.m_maxy))
		return true;
	return false;
}


bool DisplayConfig::operator == (const DisplayConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int DisplayConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"type")) {
		if (value == 0) {
			clear_type();
			return 0;
		}
		disp_t v;
		size_t r = parse_ascii_disp_t(&v,value);
		if (r == 0)
			return -317;
		set_type(v);
		return r;
	}
	if (0 == strcmp(name,"options")) {
		if (value == 0) {
			clear_options();
			return 0;
		}
		int r = parse_ascii_u32(&m_options,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"maxx")) {
		if (value == 0) {
			clear_maxx();
			return 0;
		}
		int r = parse_ascii_u32(&m_maxx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"maxy")) {
		if (value == 0) {
			clear_maxy();
			return 0;
		}
		int r = parse_ascii_u32(&m_maxy,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	return -318;
}

HardwareConfig::HardwareConfig()
: m_magic(0)
, m_led()
#ifdef CONFIG_DISPLAY
, m_display()
#endif // CONFIG_DISPLAY
#ifdef CONFIG_ONEWIRE
, m_onewire()
#endif // CONFIG_ONEWIRE
#ifdef CONFIG_HCSR04
, m_hcsr04()
#endif // CONFIG_HCSR04
#ifdef CONFIG_I2C
, m_i2c()
#endif // CONFIG_I2C
#ifdef CONFIG_DHT
, m_dht()
#endif // CONFIG_DHT
#ifdef CONFIG_LEDSTRIP
, m_ws2812b()
#endif // CONFIG_LEDSTRIP
#ifdef CONFIG_NIGHTSKY
, m_tlc5947()
#endif // CONFIG_NIGHTSKY
#ifdef CONFIG_MAX7219
, m_max7219()
#endif // CONFIG_MAX7219
#ifdef CONFIG_RELAY
, m_relay()
#endif // CONFIG_RELAY
#ifdef CONFIG_BUTTON
, m_button()
#endif // CONFIG_BUTTON
, m_gpio()
, m_tp_channel()
, m_touchpad()
, m_adc()
, m_uart()
, m_system()
, p_validbits(0)
{
}

void HardwareConfig::clear()
{
	m_magic = 0;
	m_system.clear();
	m_uart.clear();
	m_adc.clear();
	m_touchpad.clear();
	m_tp_channel.clear();
	m_gpio.clear();
	#ifdef CONFIG_BUTTON
	m_button.clear();
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	m_relay.clear();
	#endif // CONFIG_RELAY
	m_led.clear();
	#ifdef CONFIG_MAX7219
	m_max7219.clear();
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_NIGHTSKY
	m_tlc5947.clear();
	#endif // CONFIG_NIGHTSKY
	#ifdef CONFIG_LEDSTRIP
	m_ws2812b.clear();
	#endif // CONFIG_LEDSTRIP
	#ifdef CONFIG_DHT
	m_dht.clear();
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	m_i2c.clear();
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	m_hcsr04.clear();
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	m_onewire.clear();
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_DISPLAY
	m_display.clear();
	#endif // CONFIG_DISPLAY
	p_validbits = 0;
}

void HardwareConfig::toASCII(stream &o, size_t indent) const
{
	o << "HardwareConfig {";
	++indent;
	ascii_numeric(o, indent, "magic", m_magic);
	ascii_indent(o,indent,"system");
	m_system.toASCII(o,indent);
	ascii_indent(o,indent);
	size_t s_uart = m_uart.size();
	o << "uart[" << s_uart << "] = {";
	++indent;
	for (size_t i = 0, e = s_uart; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_uart[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent,"adc");
	m_adc.toASCII(o,indent);
	ascii_indent(o,indent,"touchpad");
	m_touchpad.toASCII(o,indent);
	ascii_indent(o,indent);
	size_t s_tp_channel = m_tp_channel.size();
	o << "tp_channel[" << s_tp_channel << "] = {";
	++indent;
	for (size_t i = 0, e = s_tp_channel; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_tp_channel[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	ascii_indent(o,indent);
	size_t s_gpio = m_gpio.size();
	o << "gpio[" << s_gpio << "] = {";
	++indent;
	for (size_t i = 0, e = s_gpio; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_gpio[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_BUTTON
	ascii_indent(o,indent);
	size_t s_button = m_button.size();
	o << "button[" << s_button << "] = {";
	++indent;
	for (size_t i = 0, e = s_button; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_button[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	ascii_indent(o,indent);
	size_t s_relay = m_relay.size();
	o << "relay[" << s_relay << "] = {";
	++indent;
	for (size_t i = 0, e = s_relay; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_relay[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_RELAY
	ascii_indent(o,indent);
	size_t s_led = m_led.size();
	o << "led[" << s_led << "] = {";
	++indent;
	for (size_t i = 0, e = s_led; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_led[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_MAX7219
	ascii_indent(o,indent,"max7219");
	m_max7219.toASCII(o,indent);
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_NIGHTSKY
	ascii_indent(o,indent,"tlc5947");
	m_tlc5947.toASCII(o,indent);
	#endif // CONFIG_NIGHTSKY
	#ifdef CONFIG_LEDSTRIP
	ascii_indent(o,indent,"ws2812b");
	m_ws2812b.toASCII(o,indent);
	#endif // CONFIG_LEDSTRIP
	#ifdef CONFIG_DHT
	ascii_indent(o,indent,"dht");
	m_dht.toASCII(o,indent);
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	ascii_indent(o,indent);
	size_t s_i2c = m_i2c.size();
	o << "i2c[" << s_i2c << "] = {";
	++indent;
	for (size_t i = 0, e = s_i2c; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_i2c[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	ascii_indent(o,indent);
	size_t s_hcsr04 = m_hcsr04.size();
	o << "hcsr04[" << s_hcsr04 << "] = {";
	++indent;
	for (size_t i = 0, e = s_hcsr04; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_hcsr04[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	ascii_indent(o,indent,"onewire");
	m_onewire.toASCII(o,indent);
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_DISPLAY
	ascii_indent(o,indent,"display");
	m_display.toASCII(o,indent);
	#endif // CONFIG_DISPLAY
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t HardwareConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		int fn = read_varint(a,e-a,&fid);
		if (fn <= 0)
			return -319;
		a += fn;
		switch (fid) {
		case 0x5:	// magic id 0, type uint32_t, coding 32bit
			if ((a+3) >= e)
				return -320;
			set_magic((uint32_t) read_u32(a));
			a += 4;
			break;
		case 0xa:	// system id 1, type SystemConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -321;
				if (v != 0) {
					n = m_system.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -322;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 1);
			break;
		case 0x1a:	// uart id 3, type UartConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -323;
				m_uart.emplace_back();
				if (v != 0) {
					n = m_uart.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -324;
					a += v;
				}
			}
			break;
		case 0x22:	// adc id 4, type AdcConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -325;
				if (v != 0) {
					n = m_adc.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -326;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 2);
			break;
		case 0x2a:	// touchpad id 5, type TouchpadConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -327;
				if (v != 0) {
					n = m_touchpad.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -328;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 3);
			break;
		case 0x32:	// tp_channel id 6, type TouchChannelConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -329;
				m_tp_channel.emplace_back();
				if (v != 0) {
					n = m_tp_channel.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -330;
					a += v;
				}
			}
			break;
		case 0x3a:	// gpio id 7, type GpioConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -331;
				m_gpio.emplace_back();
				if (v != 0) {
					n = m_gpio.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -332;
					a += v;
				}
			}
			break;
			#ifdef CONFIG_BUTTON
		case 0x82:	// button id 16, type ButtonConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -333;
				m_button.emplace_back();
				if (v != 0) {
					n = m_button.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -334;
					a += v;
				}
			}
			break;
			#endif // CONFIG_BUTTON
			#ifdef CONFIG_RELAY
		case 0x8a:	// relay id 17, type RelayConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -335;
				m_relay.emplace_back();
				if (v != 0) {
					n = m_relay.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -336;
					a += v;
				}
			}
			break;
			#endif // CONFIG_RELAY
		case 0x92:	// led id 18, type LedConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -337;
				m_led.emplace_back();
				if (v != 0) {
					n = m_led.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -338;
					a += v;
				}
			}
			break;
			#ifdef CONFIG_MAX7219
		case 0x102:	// max7219 id 32, type Max7219Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -339;
				if (v != 0) {
					n = m_max7219.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -340;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 4);
			break;
			#endif // CONFIG_MAX7219
			#ifdef CONFIG_NIGHTSKY
		case 0x10a:	// tlc5947 id 33, type Tlc5947Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -341;
				if (v != 0) {
					n = m_tlc5947.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -342;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 5);
			break;
			#endif // CONFIG_NIGHTSKY
			#ifdef CONFIG_LEDSTRIP
		case 0x112:	// ws2812b id 34, type Ws2812bConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -343;
				if (v != 0) {
					n = m_ws2812b.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -344;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 6);
			break;
			#endif // CONFIG_LEDSTRIP
			#ifdef CONFIG_DHT
		case 0x11a:	// dht id 35, type DhtConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -345;
				if (v != 0) {
					n = m_dht.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -346;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 7);
			break;
			#endif // CONFIG_DHT
			#ifdef CONFIG_I2C
		case 0x122:	// i2c id 36, type I2CConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -347;
				m_i2c.emplace_back();
				if (v != 0) {
					n = m_i2c.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -348;
					a += v;
				}
			}
			break;
			#endif // CONFIG_I2C
			#ifdef CONFIG_HCSR04
		case 0x12a:	// hcsr04 id 37, type HcSr04Config, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -349;
				m_hcsr04.emplace_back();
				if (v != 0) {
					n = m_hcsr04.back().fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -350;
					a += v;
				}
			}
			break;
			#endif // CONFIG_HCSR04
			#ifdef CONFIG_ONEWIRE
		case 0x132:	// onewire id 38, type OneWireConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -351;
				if (v != 0) {
					n = m_onewire.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -352;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 8);
			break;
			#endif // CONFIG_ONEWIRE
			#ifdef CONFIG_DISPLAY
		case 0x192:	// display id 50, type DisplayConfig, coding byte[]
			{
				varint_t v;
				int n = read_varint(a,e-a,&v);
				a += n;
				if ((n <= 0) || ((a+v) > e))
					return -353;
				if (v != 0) {
					n = m_display.fromMemory((const uint8_t*)a,v);
					if (n < 0)
						return n;
					if (n != (ssize_t)v)
						return -354;
					a += v;
				}
			}
			p_validbits |= ((uint16_t)1U << 9);
			break;
			#endif // CONFIG_DISPLAY
		default:
			// unknown field (option unknown=skip)
			{
				ssize_t s = skip_content(a,e-a,fid&7);
				if (s <= 0)
					return -355;
				a += s;
				break;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -356;
	return a-(const uint8_t *)b;
}

ssize_t HardwareConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has magic?
	if (0 != (p_validbits & ((uint16_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		if (5 > (e-a))
			return -357;
		*a++ = 0x5;
		if ((e-a) < 4)
			return -358;
		write_u32(a,(uint32_t)m_magic);
		a += 4;
	}
	// has system?
	if (0 != (p_validbits & ((uint16_t)1U << 1))) {
		// 'system': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -359;
		*a++ = 0xa;
		ssize_t system_ws = m_system.calcSize();
		n = write_varint(a,e-a,system_ws);
		a += n;
		if ((n <= 0) || (system_ws > (e-a)))
			return -360;
		n = m_system.toMemory(a,e-a);
		a += n;
		assert(n == system_ws);
	}
	for (const auto &x : m_uart) {
		// 'uart': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -361;
		*a++ = 0x1a;
		ssize_t uart_ws = x.calcSize();
		n = write_varint(a,e-a,uart_ws);
		a += n;
		if ((n <= 0) || (uart_ws > (e-a)))
			return -362;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == uart_ws);
	}
	// has adc?
	if (0 != (p_validbits & ((uint16_t)1U << 2))) {
		// 'adc': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -363;
		*a++ = 0x22;
		ssize_t adc_ws = m_adc.calcSize();
		n = write_varint(a,e-a,adc_ws);
		a += n;
		if ((n <= 0) || (adc_ws > (e-a)))
			return -364;
		n = m_adc.toMemory(a,e-a);
		a += n;
		assert(n == adc_ws);
	}
	// has touchpad?
	if (0 != (p_validbits & ((uint16_t)1U << 3))) {
		// 'touchpad': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -365;
		*a++ = 0x2a;
		ssize_t touchpad_ws = m_touchpad.calcSize();
		n = write_varint(a,e-a,touchpad_ws);
		a += n;
		if ((n <= 0) || (touchpad_ws > (e-a)))
			return -366;
		n = m_touchpad.toMemory(a,e-a);
		a += n;
		assert(n == touchpad_ws);
	}
	for (const auto &x : m_tp_channel) {
		// 'tp_channel': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -367;
		*a++ = 0x32;
		ssize_t tp_channel_ws = x.calcSize();
		n = write_varint(a,e-a,tp_channel_ws);
		a += n;
		if ((n <= 0) || (tp_channel_ws > (e-a)))
			return -368;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == tp_channel_ws);
	}
	for (const auto &x : m_gpio) {
		// 'gpio': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -369;
		*a++ = 0x3a;
		ssize_t gpio_ws = x.calcSize();
		n = write_varint(a,e-a,gpio_ws);
		a += n;
		if ((n <= 0) || (gpio_ws > (e-a)))
			return -370;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == gpio_ws);
	}
	#ifdef CONFIG_BUTTON
	for (const auto &x : m_button) {
		// 'button': id=16, encoding=lenpfx, tag=0x82
		if (2 > (e-a))
			return -371;
		*a++ = 0x82;
		*a++ = 0x1;
		ssize_t button_ws = x.calcSize();
		n = write_varint(a,e-a,button_ws);
		a += n;
		if ((n <= 0) || (button_ws > (e-a)))
			return -372;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == button_ws);
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	for (const auto &x : m_relay) {
		// 'relay': id=17, encoding=lenpfx, tag=0x8a
		if (2 > (e-a))
			return -373;
		*a++ = 0x8a;
		*a++ = 0x1;
		ssize_t relay_ws = x.calcSize();
		n = write_varint(a,e-a,relay_ws);
		a += n;
		if ((n <= 0) || (relay_ws > (e-a)))
			return -374;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == relay_ws);
	}
	#endif // CONFIG_RELAY
	for (const auto &x : m_led) {
		// 'led': id=18, encoding=lenpfx, tag=0x92
		if (2 > (e-a))
			return -375;
		*a++ = 0x92;
		*a++ = 0x1;
		ssize_t led_ws = x.calcSize();
		n = write_varint(a,e-a,led_ws);
		a += n;
		if ((n <= 0) || (led_ws > (e-a)))
			return -376;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == led_ws);
	}
	#ifdef CONFIG_MAX7219
	// has max7219?
	if (0 != (p_validbits & ((uint16_t)1U << 4))) {
		// 'max7219': id=32, encoding=lenpfx, tag=0x102
		if (2 > (e-a))
			return -377;
		*a++ = 0x82;
		*a++ = 0x2;
		ssize_t max7219_ws = m_max7219.calcSize();
		n = write_varint(a,e-a,max7219_ws);
		a += n;
		if ((n <= 0) || (max7219_ws > (e-a)))
			return -378;
		n = m_max7219.toMemory(a,e-a);
		a += n;
		assert(n == max7219_ws);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_NIGHTSKY
	// has tlc5947?
	if (0 != (p_validbits & ((uint16_t)1U << 5))) {
		// 'tlc5947': id=33, encoding=lenpfx, tag=0x10a
		if (2 > (e-a))
			return -379;
		*a++ = 0x8a;
		*a++ = 0x2;
		ssize_t tlc5947_ws = m_tlc5947.calcSize();
		n = write_varint(a,e-a,tlc5947_ws);
		a += n;
		if ((n <= 0) || (tlc5947_ws > (e-a)))
			return -380;
		n = m_tlc5947.toMemory(a,e-a);
		a += n;
		assert(n == tlc5947_ws);
	}
	#endif // CONFIG_NIGHTSKY
	#ifdef CONFIG_LEDSTRIP
	// has ws2812b?
	if (0 != (p_validbits & ((uint16_t)1U << 6))) {
		// 'ws2812b': id=34, encoding=lenpfx, tag=0x112
		if (2 > (e-a))
			return -381;
		*a++ = 0x92;
		*a++ = 0x2;
		ssize_t ws2812b_ws = m_ws2812b.calcSize();
		n = write_varint(a,e-a,ws2812b_ws);
		a += n;
		if ((n <= 0) || (ws2812b_ws > (e-a)))
			return -382;
		n = m_ws2812b.toMemory(a,e-a);
		a += n;
		assert(n == ws2812b_ws);
	}
	#endif // CONFIG_LEDSTRIP
	#ifdef CONFIG_DHT
	// has dht?
	if (0 != (p_validbits & ((uint16_t)1U << 7))) {
		// 'dht': id=35, encoding=lenpfx, tag=0x11a
		if (2 > (e-a))
			return -383;
		*a++ = 0x9a;
		*a++ = 0x2;
		ssize_t dht_ws = m_dht.calcSize();
		n = write_varint(a,e-a,dht_ws);
		a += n;
		if ((n <= 0) || (dht_ws > (e-a)))
			return -384;
		n = m_dht.toMemory(a,e-a);
		a += n;
		assert(n == dht_ws);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	for (const auto &x : m_i2c) {
		// 'i2c': id=36, encoding=lenpfx, tag=0x122
		if (2 > (e-a))
			return -385;
		*a++ = 0xa2;
		*a++ = 0x2;
		ssize_t i2c_ws = x.calcSize();
		n = write_varint(a,e-a,i2c_ws);
		a += n;
		if ((n <= 0) || (i2c_ws > (e-a)))
			return -386;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == i2c_ws);
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	for (const auto &x : m_hcsr04) {
		// 'hcsr04': id=37, encoding=lenpfx, tag=0x12a
		if (2 > (e-a))
			return -387;
		*a++ = 0xaa;
		*a++ = 0x2;
		ssize_t hcsr04_ws = x.calcSize();
		n = write_varint(a,e-a,hcsr04_ws);
		a += n;
		if ((n <= 0) || (hcsr04_ws > (e-a)))
			return -388;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == hcsr04_ws);
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	// has onewire?
	if (0 != (p_validbits & ((uint16_t)1U << 8))) {
		// 'onewire': id=38, encoding=lenpfx, tag=0x132
		if (2 > (e-a))
			return -389;
		*a++ = 0xb2;
		*a++ = 0x2;
		ssize_t onewire_ws = m_onewire.calcSize();
		n = write_varint(a,e-a,onewire_ws);
		a += n;
		if ((n <= 0) || (onewire_ws > (e-a)))
			return -390;
		n = m_onewire.toMemory(a,e-a);
		a += n;
		assert(n == onewire_ws);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_DISPLAY
	// has display?
	if (0 != (p_validbits & ((uint16_t)1U << 9))) {
		// 'display': id=50, encoding=lenpfx, tag=0x192
		if (2 > (e-a))
			return -391;
		*a++ = 0x92;
		*a++ = 0x3;
		ssize_t display_ws = m_display.calcSize();
		n = write_varint(a,e-a,display_ws);
		a += n;
		if ((n <= 0) || (display_ws > (e-a)))
			return -392;
		n = m_display.toMemory(a,e-a);
		a += n;
		assert(n == display_ws);
	}
	#endif // CONFIG_DISPLAY
	assert(a <= e);
	return a-b;
}

void HardwareConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_magic()) {
		fsep = json_indent(json,indLvl,fsep,"magic");
		json << m_magic;
	}
	if (has_system()) {
		fsep = json_indent(json,indLvl,fsep,"system");
		m_system.toJSON(json,indLvl);
	}
	if (size_t s = m_uart.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"uart\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_uart[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (has_adc()) {
		fsep = json_indent(json,indLvl,fsep,"adc");
		m_adc.toJSON(json,indLvl);
	}
	if (has_touchpad()) {
		fsep = json_indent(json,indLvl,fsep,"touchpad");
		m_touchpad.toJSON(json,indLvl);
	}
	if (size_t s = m_tp_channel.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"tp_channel\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_tp_channel[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (size_t s = m_gpio.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"gpio\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_gpio[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_BUTTON
	if (size_t s = m_button.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"button\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_button[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (size_t s = m_relay.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"relay\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_relay[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_RELAY
	if (size_t s = m_led.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"led\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_led[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_MAX7219
	if (has_max7219()) {
		fsep = json_indent(json,indLvl,fsep,"max7219");
		m_max7219.toJSON(json,indLvl);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_NIGHTSKY
	if (has_tlc5947()) {
		fsep = json_indent(json,indLvl,fsep,"tlc5947");
		m_tlc5947.toJSON(json,indLvl);
	}
	#endif // CONFIG_NIGHTSKY
	#ifdef CONFIG_LEDSTRIP
	if (has_ws2812b()) {
		fsep = json_indent(json,indLvl,fsep,"ws2812b");
		m_ws2812b.toJSON(json,indLvl);
	}
	#endif // CONFIG_LEDSTRIP
	#ifdef CONFIG_DHT
	if (has_dht()) {
		fsep = json_indent(json,indLvl,fsep,"dht");
		m_dht.toJSON(json,indLvl);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (size_t s = m_i2c.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"i2c\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_i2c[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (size_t s = m_hcsr04.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"hcsr04\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_hcsr04[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (has_onewire()) {
		fsep = json_indent(json,indLvl,fsep,"onewire");
		m_onewire.toJSON(json,indLvl);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_DISPLAY
	if (has_display()) {
		fsep = json_indent(json,indLvl,fsep,"display");
		m_display.toJSON(json,indLvl);
	}
	#endif // CONFIG_DISPLAY
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t HardwareConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed32 magic, id 0
	if (0 != (p_validbits & ((uint16_t)1U << 0))) {
		r += 5;
	}
	// optional SystemConfig system, id 1
	if (0 != (p_validbits & ((uint16_t)1U << 1))) {
		size_t system_s = m_system.calcSize();
		r += system_s + wiresize(system_s) + 1 /* tag(system) 0x8 */;
	}
	// repeated UartConfig uart, id 3
	// repeated message uart
	for (size_t x = 0, y = m_uart.size(); x < y; ++x) {
		size_t s = m_uart[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(uart) 0x18 */;
	}
	// optional AdcConfig adc, id 4
	if (0 != (p_validbits & ((uint16_t)1U << 2))) {
		size_t adc_s = m_adc.calcSize();
		r += adc_s + wiresize(adc_s) + 1 /* tag(adc) 0x20 */;
	}
	// optional TouchpadConfig touchpad, id 5
	if (0 != (p_validbits & ((uint16_t)1U << 3))) {
		size_t touchpad_s = m_touchpad.calcSize();
		r += touchpad_s + wiresize(touchpad_s) + 1 /* tag(touchpad) 0x28 */;
	}
	// repeated TouchChannelConfig tp_channel, id 6
	// repeated message tp_channel
	for (size_t x = 0, y = m_tp_channel.size(); x < y; ++x) {
		size_t s = m_tp_channel[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(tp_channel) 0x30 */;
	}
	// repeated GpioConfig gpio, id 7
	// repeated message gpio
	for (size_t x = 0, y = m_gpio.size(); x < y; ++x) {
		size_t s = m_gpio[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(gpio) 0x38 */;
	}
	#ifdef CONFIG_BUTTON
	// repeated ButtonConfig button, id 16
	// repeated message button
	for (size_t x = 0, y = m_button.size(); x < y; ++x) {
		size_t s = m_button[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(button) 0x80 */;
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	// repeated RelayConfig relay, id 17
	// repeated message relay
	for (size_t x = 0, y = m_relay.size(); x < y; ++x) {
		size_t s = m_relay[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(relay) 0x88 */;
	}
	#endif // CONFIG_RELAY
	// repeated LedConfig led, id 18
	// repeated message led
	for (size_t x = 0, y = m_led.size(); x < y; ++x) {
		size_t s = m_led[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(led) 0x90 */;
	}
	#ifdef CONFIG_MAX7219
	// optional Max7219Config max7219, id 32
	if (0 != (p_validbits & ((uint16_t)1U << 4))) {
		size_t max7219_s = m_max7219.calcSize();
		r += max7219_s + wiresize(max7219_s) + 2 /* tag(max7219) 0x100 */;
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_NIGHTSKY
	// optional Tlc5947Config tlc5947, id 33
	if (0 != (p_validbits & ((uint16_t)1U << 5))) {
		size_t tlc5947_s = m_tlc5947.calcSize();
		r += tlc5947_s + wiresize(tlc5947_s) + 2 /* tag(tlc5947) 0x108 */;
	}
	#endif // CONFIG_NIGHTSKY
	#ifdef CONFIG_LEDSTRIP
	// optional Ws2812bConfig ws2812b, id 34
	if (0 != (p_validbits & ((uint16_t)1U << 6))) {
		size_t ws2812b_s = m_ws2812b.calcSize();
		r += ws2812b_s + wiresize(ws2812b_s) + 2 /* tag(ws2812b) 0x110 */;
	}
	#endif // CONFIG_LEDSTRIP
	#ifdef CONFIG_DHT
	// optional DhtConfig dht, id 35
	if (0 != (p_validbits & ((uint16_t)1U << 7))) {
		size_t dht_s = m_dht.calcSize();
		r += dht_s + wiresize(dht_s) + 2 /* tag(dht) 0x118 */;
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	// repeated I2CConfig i2c, id 36
	// repeated message i2c
	for (size_t x = 0, y = m_i2c.size(); x < y; ++x) {
		size_t s = m_i2c[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(i2c) 0x120 */;
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	// repeated HcSr04Config hcsr04, id 37
	// repeated message hcsr04
	for (size_t x = 0, y = m_hcsr04.size(); x < y; ++x) {
		size_t s = m_hcsr04[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(hcsr04) 0x128 */;
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	// optional OneWireConfig onewire, id 38
	if (0 != (p_validbits & ((uint16_t)1U << 8))) {
		size_t onewire_s = m_onewire.calcSize();
		r += onewire_s + wiresize(onewire_s) + 2 /* tag(onewire) 0x130 */;
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_DISPLAY
	// optional DisplayConfig display, id 50
	if (0 != (p_validbits & ((uint16_t)1U << 9))) {
		size_t display_s = m_display.calcSize();
		r += display_s + wiresize(display_s) + 2 /* tag(display) 0x190 */;
	}
	#endif // CONFIG_DISPLAY
	return r;
}

bool HardwareConfig::operator != (const HardwareConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return true;
	if (has_magic() && (m_magic != r.m_magic))
		return true;
	if (has_system() && (m_system != r.m_system))
		return true;
	if (m_uart != r.m_uart)
		return true;
	if (has_adc() && (m_adc != r.m_adc))
		return true;
	if (has_touchpad() && (m_touchpad != r.m_touchpad))
		return true;
	if (m_tp_channel != r.m_tp_channel)
		return true;
	if (m_gpio != r.m_gpio)
		return true;
	#ifdef CONFIG_BUTTON
	if (m_button != r.m_button)
		return true;
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (m_relay != r.m_relay)
		return true;
	#endif // CONFIG_RELAY
	if (m_led != r.m_led)
		return true;
	#ifdef CONFIG_MAX7219
	if (has_max7219() && (m_max7219 != r.m_max7219))
		return true;
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_NIGHTSKY
	if (has_tlc5947() && (m_tlc5947 != r.m_tlc5947))
		return true;
	#endif // CONFIG_NIGHTSKY
	#ifdef CONFIG_LEDSTRIP
	if (has_ws2812b() && (m_ws2812b != r.m_ws2812b))
		return true;
	#endif // CONFIG_LEDSTRIP
	#ifdef CONFIG_DHT
	if (has_dht() && (m_dht != r.m_dht))
		return true;
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (m_i2c != r.m_i2c)
		return true;
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (m_hcsr04 != r.m_hcsr04)
		return true;
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (has_onewire() && (m_onewire != r.m_onewire))
		return true;
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_DISPLAY
	if (has_display() && (m_display != r.m_display))
		return true;
	#endif // CONFIG_DISPLAY
	return false;
}


bool HardwareConfig::operator == (const HardwareConfig &r) const
{
	return !((*this) != r);
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int HardwareConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"magic")) {
		if (value == 0) {
			clear_magic();
			return 0;
		}
		int r = parse_ascii_u32(&m_magic,value);
		if (r > 0)
			p_validbits |= ((uint16_t)1U << 0);
		return r;
	}
	if (0 == memcmp(name,"system",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_system();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 1);
			return m_system.setByName(name+7,value);
		}
	}
	if (0 == memcmp(name,"uart",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_uart();
			return 0;
		} else if (name[4] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[5] == '+') && (name[6] == ']')) {
				x = m_uart.size();
				m_uart.resize(x+1);
				idxe = (char*)(name + 6);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+5,&idxe,0);
				if (idxe[0] != ']')
					return -393;
				if (m_uart.size() <= x)
					return -394;
				if ((idxe[1] == 0) && (value == 0)) {
					m_uart.erase(m_uart.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -395;
			return m_uart[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"adc",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_adc();
			return 0;
		} else if (name[3] == '.') {
			p_validbits |= ((uint16_t)1U << 2);
			return m_adc.setByName(name+4,value);
		}
	}
	if (0 == memcmp(name,"touchpad",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_touchpad();
			return 0;
		} else if (name[8] == '.') {
			p_validbits |= ((uint16_t)1U << 3);
			return m_touchpad.setByName(name+9,value);
		}
	}
	if (0 == memcmp(name,"tp_channel",10)) {
		if ((name[10] == 0) && (value == 0)) {
			clear_tp_channel();
			return 0;
		} else if (name[10] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[11] == '+') && (name[12] == ']')) {
				x = m_tp_channel.size();
				m_tp_channel.resize(x+1);
				idxe = (char*)(name + 12);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+11,&idxe,0);
				if (idxe[0] != ']')
					return -396;
				if (m_tp_channel.size() <= x)
					return -397;
				if ((idxe[1] == 0) && (value == 0)) {
					m_tp_channel.erase(m_tp_channel.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -398;
			return m_tp_channel[x].setByName(idxe+2,value);
		}
	}
	if (0 == memcmp(name,"gpio",4)) {
		if ((name[4] == 0) && (value == 0)) {
			clear_gpio();
			return 0;
		} else if (name[4] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[5] == '+') && (name[6] == ']')) {
				x = m_gpio.size();
				m_gpio.resize(x+1);
				idxe = (char*)(name + 6);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+5,&idxe,0);
				if (idxe[0] != ']')
					return -399;
				if (m_gpio.size() <= x)
					return -400;
				if ((idxe[1] == 0) && (value == 0)) {
					m_gpio.erase(m_gpio.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -401;
			return m_gpio[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_BUTTON
	if (0 == memcmp(name,"button",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_button();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_button.size();
				m_button.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -402;
				if (m_button.size() <= x)
					return -403;
				if ((idxe[1] == 0) && (value == 0)) {
					m_button.erase(m_button.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -404;
			return m_button[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (0 == memcmp(name,"relay",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_relay();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_relay.size();
				m_relay.resize(x+1);
				idxe = (char*)(name + 7);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if (idxe[0] != ']')
					return -405;
				if (m_relay.size() <= x)
					return -406;
				if ((idxe[1] == 0) && (value == 0)) {
					m_relay.erase(m_relay.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -407;
			return m_relay[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_RELAY
	if (0 == memcmp(name,"led",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_led();
			return 0;
		} else if (name[3] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[4] == '+') && (name[5] == ']')) {
				x = m_led.size();
				m_led.resize(x+1);
				idxe = (char*)(name + 5);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+4,&idxe,0);
				if (idxe[0] != ']')
					return -408;
				if (m_led.size() <= x)
					return -409;
				if ((idxe[1] == 0) && (value == 0)) {
					m_led.erase(m_led.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -410;
			return m_led[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_MAX7219
	if (0 == memcmp(name,"max7219",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_max7219();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 4);
			return m_max7219.setByName(name+8,value);
		}
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_NIGHTSKY
	if (0 == memcmp(name,"tlc5947",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_tlc5947();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 5);
			return m_tlc5947.setByName(name+8,value);
		}
	}
	#endif // CONFIG_NIGHTSKY
	#ifdef CONFIG_LEDSTRIP
	if (0 == memcmp(name,"ws2812b",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_ws2812b();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 6);
			return m_ws2812b.setByName(name+8,value);
		}
	}
	#endif // CONFIG_LEDSTRIP
	#ifdef CONFIG_DHT
	if (0 == memcmp(name,"dht",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_dht();
			return 0;
		} else if (name[3] == '.') {
			p_validbits |= ((uint16_t)1U << 7);
			return m_dht.setByName(name+4,value);
		}
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (0 == memcmp(name,"i2c",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_i2c();
			return 0;
		} else if (name[3] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[4] == '+') && (name[5] == ']')) {
				x = m_i2c.size();
				m_i2c.resize(x+1);
				idxe = (char*)(name + 5);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+4,&idxe,0);
				if (idxe[0] != ']')
					return -411;
				if (m_i2c.size() <= x)
					return -412;
				if ((idxe[1] == 0) && (value == 0)) {
					m_i2c.erase(m_i2c.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -413;
			return m_i2c[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (0 == memcmp(name,"hcsr04",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_hcsr04();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_hcsr04.size();
				m_hcsr04.resize(x+1);
				idxe = (char*)(name + 8);
				if (idxe[1] == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if (idxe[0] != ']')
					return -414;
				if (m_hcsr04.size() <= x)
					return -415;
				if ((idxe[1] == 0) && (value == 0)) {
					m_hcsr04.erase(m_hcsr04.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -416;
			return m_hcsr04[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (0 == memcmp(name,"onewire",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_onewire();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 8);
			return m_onewire.setByName(name+8,value);
		}
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_DISPLAY
	if (0 == memcmp(name,"display",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_display();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 9);
			return m_display.setByName(name+8,value);
		}
	}
	#endif // CONFIG_DISPLAY
	return -417;
}

