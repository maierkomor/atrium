/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: P2304.13 (hg:469/ae43a66811cb)
 * WFC is Copyright 2015-2025, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : hwcfg.wfc
 * Copyright: 2018-2024
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2025-02-09, 21:27:14 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from esp8285:
 * BaseClass       : ""
 * enummap         : ""
 * getMember       : ""
 * 
 * options from esp8266:
 * Optimize        : "size"
 * 
 * options from esp:
 * bytestype       : "estring"
 * enumnames       : "true"
 * intsize         : 32
 * SortMembers     : "size"
 * stringtype      : "estring"
 * toASCII         : "toASCII"
 * toSink          : ""
 * toString        : ""
 * toWire          : ""
 * varintbits      : 32
 * 
 * options from common:
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bool      : "ascii_bool"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * calcSize        : "calcSize"
 * cfgdefs         : ""
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * ClearValue      : "compatible"
 * copyright       : ""
 * email           : ""
 * endian          : "unknown"
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * UnknownField    : "skip"
 * wireput         : ""
 * wiresize        : ""
 * 
 * disabled flags from esp8266:
 * 	withUnequal
 * enabled flags from esp:
 * 	withEqual
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux
 */

#include <map>
#include <stdlib.h>
#include <string.h>
#include "hwcfg_esp8285.h"

#include "wfccore_esp8285.h"

#if !defined(WFC_ENDIAN) || (WFC_ENDIAN != 0)
#error wfc: incompatible settings concerning endian
#endif


static const char *pull_mode_e_names[] = {
	"pull_none",
	"pull_en",
	"pull_down",
	"pull_dir",
	"pull_up",
};

static pull_mode_e pull_mode_e_values[] = {
	pull_none,
	pull_en,
	pull_down,
	pull_dir,
	pull_up,
};

size_t parse_ascii_pull_mode_e(pull_mode_e *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (pull_mode_e)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(pull_mode_e_names)/sizeof(pull_mode_e_names[0]); ++i) {
		if (0 == strcmp(pull_mode_e_names[i],s)) {
			*v = pull_mode_e_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *pull_mode_e_str(pull_mode_e e)
{
	for (size_t i = 0; i < sizeof(pull_mode_e_values)/sizeof(pull_mode_e_values[0]); ++i) {
		if (e == pull_mode_e_values[i])
			return pull_mode_e_names[i];
	}
	return 0;
}

static const char *dht_model_t_names[] = {
	"DHT_NONE",
	"RHT03",
	"DHT11",
	"DHT21",
	"DHT22",
	"AM2301",
	"AM2302",
};

static dht_model_t dht_model_t_values[] = {
	DHT_NONE,
	RHT03,
	DHT11,
	DHT21,
	DHT22,
	AM2301,
	AM2302,
};

size_t parse_ascii_dht_model_t(dht_model_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (dht_model_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(dht_model_t_names)/sizeof(dht_model_t_names[0]); ++i) {
		if (0 == strcmp(dht_model_t_names[i],s)) {
			*v = dht_model_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *dht_model_t_str(dht_model_t e)
{
	for (size_t i = 0; i < sizeof(dht_model_t_values)/sizeof(dht_model_t_values[0]); ++i) {
		if (e == dht_model_t_values[i])
			return dht_model_t_names[i];
	}
	return 0;
}

static const char *i2cdrv_t_names[] = {
	"i2cdrv_invalid",
	"i2cdrv_pcf8574",
	"i2cdrv_mcp2300x",
	"i2cdrv_mcp2301x",
	"i2cdrv_pca9685",
	"i2cdrv_pca9685_npn",
	"i2cdrv_pca9685_pnp",
	"i2cdrv_pca9685_xclk",
	"i2cdrv_pca9685_xclk_npn",
	"i2cdrv_pca9685_xclk_pnp",
	"i2cdrv_ht16k33",
	"i2cdrv_ina219",
	"i2cdrv_si7021",
	"i2cdrv_tca9555",
	"i2cdrv_ssd1306",
	"i2cdrv_sh1106",
	"i2cdrv_ads1013",
	"i2cdrv_ads1014",
	"i2cdrv_ads1015",
	"i2cdrv_ads1113",
	"i2cdrv_ads1114",
	"i2cdrv_ads1115",
	"i2cdrv_ina220",
	"i2cdrv_aht10",
	"i2cdrv_aht20",
	"i2cdrv_aht30",
};


size_t parse_ascii_i2cdrv_t(i2cdrv_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (i2cdrv_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(i2cdrv_t_names)/sizeof(i2cdrv_t_names[0]); ++i) {
		if (0 == strcmp(i2cdrv_t_names[i],s)) {
			*v = (i2cdrv_t)i;
			return strlen(s);
		}
	}
	return 0;
}

const char *i2cdrv_t_str(i2cdrv_t e)
{
	return i2cdrv_t_names[(size_t)e];
}

static const char *disp_t_names[] = {
	"dt_none",
	"dt_sd_7seg",
	"dt_sd_14seg",
	"dt_pcf8574_hd44780u",
	"dt_ssd1306",
	"dt_ssd1309",
	"dt_sh1106",
	"dt_ili9341",
};

static disp_t disp_t_values[] = {
	dt_none,
	dt_sd_7seg,
	dt_sd_14seg,
	dt_pcf8574_hd44780u,
	dt_ssd1306,
	dt_ssd1309,
	dt_sh1106,
	dt_ili9341,
};

size_t parse_ascii_disp_t(disp_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (disp_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(disp_t_names)/sizeof(disp_t_names[0]); ++i) {
		if (0 == strcmp(disp_t_names[i],s)) {
			*v = disp_t_values[i];
			return strlen(s);
		}
	}
	return 0;
}

const char *disp_t_str(disp_t e)
{
	for (size_t i = 0; i < sizeof(disp_t_values)/sizeof(disp_t_values[0]); ++i) {
		if (e == disp_t_values[i])
			return disp_t_names[i];
	}
	return 0;
}

static const char *spidrv_t_names[] = {
	"spidrv_invalid",
	"spidrv_sx1276",
	"spidrv_ssd1309",
	"spidrv_ili9341",
	"spidrv_xpt2046",
	"spidrv_sdcard",
};


size_t parse_ascii_spidrv_t(spidrv_t *v, const char *s)
{
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (spidrv_t)ull;
		return e-s;
	}
	for (size_t i = 0; i < sizeof(spidrv_t_names)/sizeof(spidrv_t_names[0]); ++i) {
		if (0 == strcmp(spidrv_t_names[i],s)) {
			*v = (spidrv_t)i;
			return strlen(s);
		}
	}
	return 0;
}

const char *spidrv_t_str(spidrv_t e)
{
	return spidrv_t_names[(size_t)e];
}

SystemConfig::SystemConfig()
{
}

void SystemConfig::clear()
{
	m_manufacturer.clear();
	m_board_name.clear();
	m_board_rev.clear();
	m_diag_uart = 0;
	m_console_rx = 0;
	m_console_tx = 0;
	m_model_name.clear();
	m_model_number.clear();
	#ifdef CONFIG_USB_DIAGLOG
	m_usb_diag = true;
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	m_usb_con = true;
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	m_cc1_gpio = -1;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	m_cc2_gpio = -1;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	p_validbits = 0;
}

void SystemConfig::toASCII(stream &o, size_t indent) const
{
	o << "SystemConfig {";
	++indent;
	ascii_string(o,indent,m_manufacturer.data(),m_manufacturer.size(),"manufacturer");
	ascii_string(o,indent,m_board_name.data(),m_board_name.size(),"board_name");
	ascii_string(o,indent,m_board_rev.data(),m_board_rev.size(),"board_rev");
	ascii_numeric(o, indent, "diag_uart", (signed) m_diag_uart);
	ascii_numeric(o, indent, "console_rx", (signed) m_console_rx);
	ascii_numeric(o, indent, "console_tx", (signed) m_console_tx);
	ascii_string(o,indent,m_model_name.data(),m_model_name.size(),"model_name");
	ascii_string(o,indent,m_model_number.data(),m_model_number.size(),"model_number");
	#ifdef CONFIG_USB_DIAGLOG
	ascii_bool(o, indent, "usb_diag", m_usb_diag);
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	ascii_bool(o, indent, "usb_con", m_usb_con);
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	ascii_numeric(o, indent, "cc1_gpio", (signed) m_cc1_gpio);
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	ascii_numeric(o, indent, "cc2_gpio", (signed) m_cc2_gpio);
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SystemConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -1;
		a += x;
		switch (fid) {
		case 0xa:	// manufacturer id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -2;
			}
			m_manufacturer.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x12:	// board_name id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -3;
			}
			m_board_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x1a:	// board_rev id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -4;
			}
			m_board_rev.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x20:	// diag_uart id 4, type int8_t, coding signed varint
			set_diag_uart(varint_sint(ud.u8));
			break;
		case 0x28:	// console_rx id 5, type int8_t, coding signed varint
			set_console_rx(varint_sint(ud.u8));
			break;
		case 0x30:	// console_tx id 6, type int8_t, coding signed varint
			set_console_tx(varint_sint(ud.u8));
			break;
		case 0x3a:	// model_name id 7, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -5;
			}
			m_model_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x42:	// model_number id 8, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -6;
			}
			m_model_number.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
			#ifdef CONFIG_USB_DIAGLOG
		case 0x4b:	// usb_diag id 9, type bool, coding 8bit
			set_usb_diag(ud.u8);
			break;
			#endif // CONFIG_USB_DIAGLOG
			#ifdef CONFIG_USB_CONSOLE
		case 0x53:	// usb_con id 10, type bool, coding 8bit
			set_usb_con(ud.u8);
			break;
			#endif // CONFIG_USB_CONSOLE
			#ifdef CONFIG_ESP_PHY_ENABLE_USB
		case 0x58:	// cc1_gpio id 11, type int8_t, coding signed varint
			set_cc1_gpio(varint_sint(ud.u8));
			break;
			#endif // CONFIG_ESP_PHY_ENABLE_USB
			#ifdef CONFIG_ESP_PHY_ENABLE_USB
		case 0x60:	// cc2_gpio id 12, type int8_t, coding signed varint
			set_cc2_gpio(varint_sint(ud.u8));
			break;
			#endif // CONFIG_ESP_PHY_ENABLE_USB
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -7;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -8;
	return a-(const uint8_t *)b;
}

ssize_t SystemConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has manufacturer?
	if (!m_manufacturer.empty()) {
		// 'manufacturer': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -9;
		*a++ = 0xa;
		n = encode_bytes(m_manufacturer,a,e);
		if (n < 0)
			return -10;
		a += n;
	}
	// has board_name?
	if (!m_board_name.empty()) {
		// 'board_name': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -11;
		*a++ = 0x12;
		n = encode_bytes(m_board_name,a,e);
		if (n < 0)
			return -12;
		a += n;
	}
	// has board_rev?
	if (!m_board_rev.empty()) {
		// 'board_rev': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -13;
		*a++ = 0x1a;
		n = encode_bytes(m_board_rev,a,e);
		if (n < 0)
			return -14;
		a += n;
	}
	// has diag_uart?
	if (m_diag_uart != 0) {
		// 'diag_uart': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -15;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_diag_uart));
		if (n <= 0)
			return -16;
		a += n;
	}
	// has console_rx?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'console_rx': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -17;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_console_rx));
		if (n <= 0)
			return -18;
		a += n;
	}
	// has console_tx?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'console_tx': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -19;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_console_tx));
		if (n <= 0)
			return -20;
		a += n;
	}
	// has model_name?
	if (!m_model_name.empty()) {
		// 'model_name': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -21;
		*a++ = 0x3a;
		n = encode_bytes(m_model_name,a,e);
		if (n < 0)
			return -22;
		a += n;
	}
	// has model_number?
	if (!m_model_number.empty()) {
		// 'model_number': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -23;
		*a++ = 0x42;
		n = encode_bytes(m_model_number,a,e);
		if (n < 0)
			return -24;
		a += n;
	}
	#ifdef CONFIG_USB_DIAGLOG
	// has usb_diag?
	if (m_usb_diag != true) {
		// 'usb_diag': id=9, encoding=8bit, tag=0x4b
		if (2 > (e-a))
			return -25;
		*a++ = 0x4b;
		*a++ = m_usb_diag;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	// has usb_con?
	if (m_usb_con != true) {
		// 'usb_con': id=10, encoding=8bit, tag=0x53
		if (2 > (e-a))
			return -26;
		*a++ = 0x53;
		*a++ = m_usb_con;
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// has cc1_gpio?
	if (m_cc1_gpio != -1) {
		// 'cc1_gpio': id=11, encoding=varint, tag=0x58
		if (a >= e)
			return -27;
		*a++ = 0x58;
		n = write_varint(a,e-a,sint_varint(m_cc1_gpio));
		if (n <= 0)
			return -28;
		a += n;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// has cc2_gpio?
	if (m_cc2_gpio != -1) {
		// 'cc2_gpio': id=12, encoding=varint, tag=0x60
		if (a >= e)
			return -29;
		*a++ = 0x60;
		n = write_varint(a,e-a,sint_varint(m_cc2_gpio));
		if (n <= 0)
			return -30;
		a += n;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	assert(a <= e);
	return a-b;
}

void SystemConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_manufacturer()) {
		fsep = json_indent(json,indLvl,fsep,"manufacturer");
		json_cstr(json,m_manufacturer.c_str());
	}
	if (has_board_name()) {
		fsep = json_indent(json,indLvl,fsep,"board_name");
		json_cstr(json,m_board_name.c_str());
	}
	if (has_board_rev()) {
		fsep = json_indent(json,indLvl,fsep,"board_rev");
		json_cstr(json,m_board_rev.c_str());
	}
	if (has_diag_uart()) {
		fsep = json_indent(json,indLvl,fsep,"diag_uart");
		to_decstr(json,(int) m_diag_uart);
	}
	if (has_console_rx()) {
		fsep = json_indent(json,indLvl,fsep,"console_rx");
		to_decstr(json,(int) m_console_rx);
	}
	if (has_console_tx()) {
		fsep = json_indent(json,indLvl,fsep,"console_tx");
		to_decstr(json,(int) m_console_tx);
	}
	if (has_model_name()) {
		fsep = json_indent(json,indLvl,fsep,"model_name");
		json_cstr(json,m_model_name.c_str());
	}
	if (has_model_number()) {
		fsep = json_indent(json,indLvl,fsep,"model_number");
		json_cstr(json,m_model_number.c_str());
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (has_usb_diag()) {
		fsep = json_indent(json,indLvl,fsep,"usb_diag");
		json << (m_usb_diag ? "true" : "false");
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (has_usb_con()) {
		fsep = json_indent(json,indLvl,fsep,"usb_con");
		json << (m_usb_con ? "true" : "false");
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (has_cc1_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"cc1_gpio");
		to_decstr(json,(int) m_cc1_gpio);
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (has_cc2_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"cc2_gpio");
		to_decstr(json,(int) m_cc2_gpio);
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SystemConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string manufacturer, id 1
	if (has_manufacturer()) {
		size_t manufacturer_s = m_manufacturer.size();
		r += manufacturer_s + wiresize(manufacturer_s) + 1 /* tag(manufacturer) 0x8 */;
	}
	// optional string board_name, id 2
	if (has_board_name()) {
		size_t board_name_s = m_board_name.size();
		r += board_name_s + wiresize(board_name_s) + 1 /* tag(board_name) 0x10 */;
	}
	// optional string board_rev, id 3
	if (has_board_rev()) {
		size_t board_rev_s = m_board_rev.size();
		r += board_rev_s + wiresize(board_rev_s) + 1 /* tag(board_rev) 0x18 */;
	}
	// optional sint8 diag_uart, id 4
	if (has_diag_uart()) {
		r += wiresize_s((varint_t)m_diag_uart) + 1 /* tag(diag_uart) 0x20 */;
	}
	// optional sint8 console_rx, id 5
	if (has_console_rx()) {
		r += wiresize_s((varint_t)m_console_rx) + 1 /* tag(console_rx) 0x28 */;
	}
	// optional sint8 console_tx, id 6
	if (has_console_tx()) {
		r += wiresize_s((varint_t)m_console_tx) + 1 /* tag(console_tx) 0x30 */;
	}
	// optional string model_name, id 7
	if (has_model_name()) {
		size_t model_name_s = m_model_name.size();
		r += model_name_s + wiresize(model_name_s) + 1 /* tag(model_name) 0x38 */;
	}
	// optional string model_number, id 8
	if (has_model_number()) {
		size_t model_number_s = m_model_number.size();
		r += model_number_s + wiresize(model_number_s) + 1 /* tag(model_number) 0x40 */;
	}
	#ifdef CONFIG_USB_DIAGLOG
	// optional bool usb_diag, id 9
	if (has_usb_diag()) {
		r += 2;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	// optional bool usb_con, id 10
	if (has_usb_con()) {
		r += 2;
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// optional sint8 cc1_gpio, id 11
	if (has_cc1_gpio()) {
		r += wiresize_s((varint_t)m_cc1_gpio) + 1 /* tag(cc1_gpio) 0x58 */;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// optional sint8 cc2_gpio, id 12
	if (has_cc2_gpio()) {
		r += wiresize_s((varint_t)m_cc2_gpio) + 1 /* tag(cc2_gpio) 0x60 */;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	return r;
}

bool SystemConfig::operator == (const SystemConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_manufacturer() && (!(m_manufacturer == r.m_manufacturer)))
		return false;
	if (has_board_name() && (!(m_board_name == r.m_board_name)))
		return false;
	if (has_board_rev() && (!(m_board_rev == r.m_board_rev)))
		return false;
	if (has_diag_uart() && (!(m_diag_uart == r.m_diag_uart)))
		return false;
	if (has_console_rx() && (!(m_console_rx == r.m_console_rx)))
		return false;
	if (has_console_tx() && (!(m_console_tx == r.m_console_tx)))
		return false;
	if (has_model_name() && (!(m_model_name == r.m_model_name)))
		return false;
	if (has_model_number() && (!(m_model_number == r.m_model_number)))
		return false;
	#ifdef CONFIG_USB_DIAGLOG
	if (has_usb_diag() && (!(m_usb_diag == r.m_usb_diag)))
		return false;
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (has_usb_con() && (!(m_usb_con == r.m_usb_con)))
		return false;
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (has_cc1_gpio() && (!(m_cc1_gpio == r.m_cc1_gpio)))
		return false;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (has_cc2_gpio() && (!(m_cc2_gpio == r.m_cc2_gpio)))
		return false;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SystemConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"manufacturer")) {
		if (value == 0) {
			clear_manufacturer();
			return 0;
		}
		m_manufacturer = value;
		int r = m_manufacturer.size();
		return r;
	}
	if (0 == strcmp(name,"board_name")) {
		if (value == 0) {
			clear_board_name();
			return 0;
		}
		m_board_name = value;
		int r = m_board_name.size();
		return r;
	}
	if (0 == strcmp(name,"board_rev")) {
		if (value == 0) {
			clear_board_rev();
			return 0;
		}
		m_board_rev = value;
		int r = m_board_rev.size();
		return r;
	}
	if (0 == strcmp(name,"diag_uart")) {
		if (value == 0) {
			clear_diag_uart();
			return 0;
		}
		int r = parse_ascii_s8(&m_diag_uart,value);
		return r;
	}
	if (0 == strcmp(name,"console_rx")) {
		if (value == 0) {
			clear_console_rx();
			return 0;
		}
		int r = parse_ascii_s8(&m_console_rx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"console_tx")) {
		if (value == 0) {
			clear_console_tx();
			return 0;
		}
		int r = parse_ascii_s8(&m_console_tx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"model_name")) {
		if (value == 0) {
			clear_model_name();
			return 0;
		}
		m_model_name = value;
		int r = m_model_name.size();
		return r;
	}
	if (0 == strcmp(name,"model_number")) {
		if (value == 0) {
			clear_model_number();
			return 0;
		}
		m_model_number = value;
		int r = m_model_number.size();
		return r;
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (0 == strcmp(name,"usb_diag")) {
		if (value == 0) {
			clear_usb_diag();
			return 0;
		}
		int r = parse_ascii_bool(&m_usb_diag,value);
		return r;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (0 == strcmp(name,"usb_con")) {
		if (value == 0) {
			clear_usb_con();
			return 0;
		}
		int r = parse_ascii_bool(&m_usb_con,value);
		return r;
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (0 == strcmp(name,"cc1_gpio")) {
		if (value == 0) {
			clear_cc1_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_cc1_gpio,value);
		return r;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (0 == strcmp(name,"cc2_gpio")) {
		if (value == 0) {
			clear_cc2_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_cc2_gpio,value);
		return r;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	return -31;
}

ButtonConfig::ButtonConfig()
{
}

void ButtonConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_presslvl = 0;
	m_pull_mode = pull_none;
	#ifdef CONFIG_ROTARYENCODER
	m_clk = -1;
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	m_dt = -1;
	#endif // CONFIG_ROTARYENCODER
}

void ButtonConfig::toASCII(stream &o, size_t indent) const
{
	o << "ButtonConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_bool(o, indent, "presslvl", m_presslvl);
	ascii_numeric(o, indent, "pull_mode", (unsigned) m_pull_mode);
	++indent;
	ascii_indent(o,indent);
	o << ".enable";
	o << (pull_mode_enable() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".up";
	o << (pull_mode_up() ? " = true;" : " = false;");
	--indent;
	#ifdef CONFIG_ROTARYENCODER
	ascii_numeric(o, indent, "clk", (signed) m_clk);
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	ascii_numeric(o, indent, "dt", (signed) m_dt);
	#endif // CONFIG_ROTARYENCODER
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t ButtonConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -32;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -33;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x1b:	// presslvl id 3, type bool, coding 8bit
			set_presslvl(ud.u8);
			break;
		case 0x20:	// pull_mode id 4, type pull_mode_t, coding varint
			set_pull_mode((pull_mode_t) (pull_mode_t)ud.u32);
			break;
			#ifdef CONFIG_ROTARYENCODER
		case 0x28:	// clk id 5, type int8_t, coding signed varint
			set_clk(varint_sint(ud.u8));
			break;
			#endif // CONFIG_ROTARYENCODER
			#ifdef CONFIG_ROTARYENCODER
		case 0x30:	// dt id 6, type int8_t, coding signed varint
			set_dt(varint_sint(ud.u8));
			break;
			#endif // CONFIG_ROTARYENCODER
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -34;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -35;
	return a-(const uint8_t *)b;
}

ssize_t ButtonConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -36;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -37;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -38;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -39;
		a += n;
	}
	// has presslvl?
	if (m_presslvl != 0) {
		// 'presslvl': id=3, encoding=8bit, tag=0x1b
		if (2 > (e-a))
			return -40;
		*a++ = 0x1b;
		*a++ = m_presslvl;
	}
	// has pull_mode?
	if (m_pull_mode != pull_none) {
		// 'pull_mode': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -41;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_pull_mode);
		if (n <= 0)
			return -42;
		a += n;
	}
	#ifdef CONFIG_ROTARYENCODER
	// has clk?
	if (m_clk != -1) {
		// 'clk': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -43;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_clk));
		if (n <= 0)
			return -44;
		a += n;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	// has dt?
	if (m_dt != -1) {
		// 'dt': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -45;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_dt));
		if (n <= 0)
			return -46;
		a += n;
	}
	#endif // CONFIG_ROTARYENCODER
	assert(a <= e);
	return a-b;
}

void ButtonConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_presslvl()) {
		fsep = json_indent(json,indLvl,fsep,"presslvl");
		json << (m_presslvl ? "true" : "false");
	}
	if (has_pull_mode()) {
		fsep = json_indent(json,indLvl,fsep,"pull_mode");
		json << (unsigned) m_pull_mode;
	}
	#ifdef CONFIG_ROTARYENCODER
	if (has_clk()) {
		fsep = json_indent(json,indLvl,fsep,"clk");
		to_decstr(json,(int) m_clk);
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (has_dt()) {
		fsep = json_indent(json,indLvl,fsep,"dt");
		to_decstr(json,(int) m_dt);
	}
	#endif // CONFIG_ROTARYENCODER
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t ButtonConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional bool presslvl, id 3
	if (has_presslvl()) {
		r += 2;
	}
	// optional pull_mode_t pull_mode, id 4
	if (has_pull_mode()) {
		r += wiresize((varint_t)m_pull_mode) + 1 /* tag(pull_mode) 0x20 */;
	}
	#ifdef CONFIG_ROTARYENCODER
	// optional sint8 clk, id 5
	if (has_clk()) {
		r += wiresize_s((varint_t)m_clk) + 1 /* tag(clk) 0x28 */;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	// optional sint8 dt, id 6
	if (has_dt()) {
		r += wiresize_s((varint_t)m_dt) + 1 /* tag(dt) 0x30 */;
	}
	#endif // CONFIG_ROTARYENCODER
	return r;
}

bool ButtonConfig::operator == (const ButtonConfig &r) const
{
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_presslvl() && (!(m_presslvl == r.m_presslvl)))
		return false;
	if (has_pull_mode() && (!(m_pull_mode == r.m_pull_mode)))
		return false;
	#ifdef CONFIG_ROTARYENCODER
	if (has_clk() && (!(m_clk == r.m_clk)))
		return false;
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (has_dt() && (!(m_dt == r.m_dt)))
		return false;
	#endif // CONFIG_ROTARYENCODER
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int ButtonConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"presslvl")) {
		if (value == 0) {
			clear_presslvl();
			return 0;
		}
		int r = parse_ascii_bool(&m_presslvl,value);
		return r;
	}
	if ((0 == memcmp(name,"pull_mode",9)) && ((name[9] == 0) || name[9] == '.')) {
		name += 9;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_pull_mode((pull_mode_t)ull);
			else if (!strcmp(name,"enable"))
				set_pull_mode_enable((bool)ull);
			else if (!strcmp(name,"up"))
				set_pull_mode_up((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -47;
		} else if (!strcmp(name,"enable")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_pull_mode_enable(tmp);
			return r;
		} else if (!strcmp(name,"up")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_pull_mode_up(tmp);
			return r;
		}
	}
	#ifdef CONFIG_ROTARYENCODER
	if (0 == strcmp(name,"clk")) {
		if (value == 0) {
			clear_clk();
			return 0;
		}
		int r = parse_ascii_s8(&m_clk,value);
		return r;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (0 == strcmp(name,"dt")) {
		if (value == 0) {
			clear_dt();
			return 0;
		}
		int r = parse_ascii_s8(&m_dt,value);
		return r;
	}
	#endif // CONFIG_ROTARYENCODER
	return -48;
}

RelayConfig::RelayConfig()
{
}

void RelayConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_config = 0;
	m_min_itv = 0;
	m_interlock = -1;
	p_validbits = 0;
}

void RelayConfig::toASCII(stream &o, size_t indent) const
{
	o << "RelayConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", (unsigned) m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".active_high";
	o << (config_active_high() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".init_on";
	o << (config_init_on() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".persistent";
	o << (config_persistent() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".opendrain";
	o << (config_opendrain() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".mqtt";
	o << (config_mqtt() ? " = true;" : " = false;");
	--indent;
	ascii_numeric(o, indent, "min_itv", m_min_itv);
	ascii_numeric(o, indent, "interlock", (signed) m_interlock);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t RelayConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -49;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -50;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x18:	// config id 3, type relay_cfg_t, coding varint
			set_config((relay_cfg_t) (relay_cfg_t)ud.u32);
			break;
		case 0x20:	// min_itv id 4, type uint32_t, coding varint
			set_min_itv((uint32_t)ud.u32);
			break;
		case 0x28:	// interlock id 5, type int8_t, coding signed varint
			set_interlock(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -51;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -52;
	return a-(const uint8_t *)b;
}

ssize_t RelayConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -53;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -54;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -55;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -56;
		a += n;
	}
	// has config?
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -57;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -58;
		a += n;
	}
	// has min_itv?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'min_itv': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -59;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_min_itv);
		if (n <= 0)
			return -60;
		a += n;
	}
	// has interlock?
	if (m_interlock != -1) {
		// 'interlock': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -61;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_interlock));
		if (n <= 0)
			return -62;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void RelayConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (has_min_itv()) {
		fsep = json_indent(json,indLvl,fsep,"min_itv");
		to_decstr(json,m_min_itv);
	}
	if (has_interlock()) {
		fsep = json_indent(json,indLvl,fsep,"interlock");
		to_decstr(json,(int) m_interlock);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t RelayConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional relay_cfg_t config, id 3
	if (has_config()) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	// optional unsigned min_itv, id 4
	if (has_min_itv()) {
		r += wiresize((varint_t)m_min_itv) + 1 /* tag(min_itv) 0x20 */;
	}
	// optional sint8 interlock, id 5
	if (has_interlock()) {
		r += wiresize_s((varint_t)m_interlock) + 1 /* tag(interlock) 0x28 */;
	}
	return r;
}

bool RelayConfig::operator == (const RelayConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_config() && (!(m_config == r.m_config)))
		return false;
	if (has_min_itv() && (!(m_min_itv == r.m_min_itv)))
		return false;
	if (has_interlock() && (!(m_interlock == r.m_interlock)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int RelayConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((relay_cfg_t)ull);
			else if (!strcmp(name,"active_high"))
				set_config_active_high((bool)ull);
			else if (!strcmp(name,"init_on"))
				set_config_init_on((bool)ull);
			else if (!strcmp(name,"persistent"))
				set_config_persistent((bool)ull);
			else if (!strcmp(name,"opendrain"))
				set_config_opendrain((bool)ull);
			else if (!strcmp(name,"mqtt"))
				set_config_mqtt((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -63;
		} else if (!strcmp(name,"active_high")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_active_high(tmp);
			return r;
		} else if (!strcmp(name,"init_on")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_init_on(tmp);
			return r;
		} else if (!strcmp(name,"persistent")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_persistent(tmp);
			return r;
		} else if (!strcmp(name,"opendrain")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_opendrain(tmp);
			return r;
		} else if (!strcmp(name,"mqtt")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_mqtt(tmp);
			return r;
		}
	}
	if (0 == strcmp(name,"min_itv")) {
		if (value == 0) {
			clear_min_itv();
			return 0;
		}
		int r = parse_ascii_u32(&m_min_itv,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"interlock")) {
		if (value == 0) {
			clear_interlock();
			return 0;
		}
		int r = parse_ascii_s8(&m_interlock,value);
		return r;
	}
	return -64;
}

Tlc5947Config::Tlc5947Config()
{
}

void Tlc5947Config::clear()
{
	m_sin = -1;
	m_sclk = -1;
	m_xlat = -1;
	m_blank = -1;
	m_ntlc = 0;
}

void Tlc5947Config::toASCII(stream &o, size_t indent) const
{
	o << "Tlc5947Config {";
	++indent;
	ascii_numeric(o, indent, "sin", (signed) m_sin);
	ascii_numeric(o, indent, "sclk", (signed) m_sclk);
	ascii_numeric(o, indent, "xlat", (signed) m_xlat);
	ascii_numeric(o, indent, "blank", (signed) m_blank);
	ascii_numeric(o, indent, "ntlc", (unsigned) m_ntlc);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Tlc5947Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -65;
		a += x;
		switch (fid) {
		case 0x8:	// sin id 1, type int8_t, coding signed varint
			set_sin(varint_sint(ud.u8));
			break;
		case 0x10:	// sclk id 2, type int8_t, coding signed varint
			set_sclk(varint_sint(ud.u8));
			break;
		case 0x18:	// xlat id 3, type int8_t, coding signed varint
			set_xlat(varint_sint(ud.u8));
			break;
		case 0x20:	// blank id 4, type int8_t, coding signed varint
			set_blank(varint_sint(ud.u8));
			break;
		case 0x28:	// ntlc id 5, type uint8_t, coding varint
			set_ntlc((uint8_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -66;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -67;
	return a-(const uint8_t *)b;
}

ssize_t Tlc5947Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has sin?
	if (m_sin != -1) {
		// 'sin': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -68;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_sin));
		if (n <= 0)
			return -69;
		a += n;
	}
	// has sclk?
	if (m_sclk != -1) {
		// 'sclk': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -70;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sclk));
		if (n <= 0)
			return -71;
		a += n;
	}
	// has xlat?
	if (m_xlat != -1) {
		// 'xlat': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -72;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_xlat));
		if (n <= 0)
			return -73;
		a += n;
	}
	// has blank?
	if (m_blank != -1) {
		// 'blank': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -74;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_blank));
		if (n <= 0)
			return -75;
		a += n;
	}
	// has ntlc?
	if (m_ntlc != 0) {
		// 'ntlc': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -76;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_ntlc);
		if (n <= 0)
			return -77;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Tlc5947Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_sin()) {
		fsep = json_indent(json,indLvl,fsep,"sin");
		to_decstr(json,(int) m_sin);
	}
	if (has_sclk()) {
		fsep = json_indent(json,indLvl,fsep,"sclk");
		to_decstr(json,(int) m_sclk);
	}
	if (has_xlat()) {
		fsep = json_indent(json,indLvl,fsep,"xlat");
		to_decstr(json,(int) m_xlat);
	}
	if (has_blank()) {
		fsep = json_indent(json,indLvl,fsep,"blank");
		to_decstr(json,(int) m_blank);
	}
	if (has_ntlc()) {
		fsep = json_indent(json,indLvl,fsep,"ntlc");
		to_decstr(json,(unsigned) m_ntlc);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Tlc5947Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 sin, id 1
	if (has_sin()) {
		r += wiresize_s((varint_t)m_sin) + 1 /* tag(sin) 0x8 */;
	}
	// optional sint8 sclk, id 2
	if (has_sclk()) {
		r += wiresize_s((varint_t)m_sclk) + 1 /* tag(sclk) 0x10 */;
	}
	// optional sint8 xlat, id 3
	if (has_xlat()) {
		r += wiresize_s((varint_t)m_xlat) + 1 /* tag(xlat) 0x18 */;
	}
	// optional sint8 blank, id 4
	if (has_blank()) {
		r += wiresize_s((varint_t)m_blank) + 1 /* tag(blank) 0x20 */;
	}
	// optional uint8 ntlc, id 5
	if (has_ntlc()) {
		r += wiresize((varint_t)m_ntlc) + 1 /* tag(ntlc) 0x28 */;
	}
	return r;
}

bool Tlc5947Config::operator == (const Tlc5947Config &r) const
{
	if (has_sin() && (!(m_sin == r.m_sin)))
		return false;
	if (has_sclk() && (!(m_sclk == r.m_sclk)))
		return false;
	if (has_xlat() && (!(m_xlat == r.m_xlat)))
		return false;
	if (has_blank() && (!(m_blank == r.m_blank)))
		return false;
	if (has_ntlc() && (!(m_ntlc == r.m_ntlc)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Tlc5947Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"sin")) {
		if (value == 0) {
			clear_sin();
			return 0;
		}
		int r = parse_ascii_s8(&m_sin,value);
		return r;
	}
	if (0 == strcmp(name,"sclk")) {
		if (value == 0) {
			clear_sclk();
			return 0;
		}
		int r = parse_ascii_s8(&m_sclk,value);
		return r;
	}
	if (0 == strcmp(name,"xlat")) {
		if (value == 0) {
			clear_xlat();
			return 0;
		}
		int r = parse_ascii_s8(&m_xlat,value);
		return r;
	}
	if (0 == strcmp(name,"blank")) {
		if (value == 0) {
			clear_blank();
			return 0;
		}
		int r = parse_ascii_s8(&m_blank,value);
		return r;
	}
	if (0 == strcmp(name,"ntlc")) {
		if (value == 0) {
			clear_ntlc();
			return 0;
		}
		int r = parse_ascii_u8(&m_ntlc,value);
		return r;
	}
	return -78;
}

Ws2812bConfig::Ws2812bConfig()
{
}

void Ws2812bConfig::clear()
{
	m_gpio = -1;
	m_nleds = 0;
	m_name.clear();
}

void Ws2812bConfig::toASCII(stream &o, size_t indent) const
{
	o << "Ws2812bConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "nleds", (unsigned) m_nleds);
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Ws2812bConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -79;
		a += x;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x18:	// nleds id 3, type uint8_t, coding varint
			set_nleds((uint8_t)ud.u32);
			break;
		case 0x22:	// name id 4, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -80;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -81;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -82;
	return a-(const uint8_t *)b;
}

ssize_t Ws2812bConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -83;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -84;
		a += n;
	}
	#ifdef CONFIG_SOC_RMT_SUPPORTED
	// 'ch' is unused. Therefore no data will be written.
	#endif // CONFIG_SOC_RMT_SUPPORTED
	// has nleds?
	if (m_nleds != 0) {
		// 'nleds': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -85;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_nleds);
		if (n <= 0)
			return -86;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -87;
		*a++ = 0x22;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -88;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Ws2812bConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_nleds()) {
		fsep = json_indent(json,indLvl,fsep,"nleds");
		to_decstr(json,(unsigned) m_nleds);
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Ws2812bConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	#ifdef CONFIG_SOC_RMT_SUPPORTED
	// unused optional sint8 ch, id 2
	#endif // CONFIG_SOC_RMT_SUPPORTED
	// optional uint8 nleds, id 3
	if (has_nleds()) {
		r += wiresize((varint_t)m_nleds) + 1 /* tag(nleds) 0x18 */;
	}
	// optional string name, id 4
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x20 */;
	}
	return r;
}

bool Ws2812bConfig::operator == (const Ws2812bConfig &r) const
{
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_nleds() && (!(m_nleds == r.m_nleds)))
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Ws2812bConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"nleds")) {
		if (value == 0) {
			clear_nleds();
			return 0;
		}
		int r = parse_ascii_u8(&m_nleds,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	return -89;
}

DhtConfig::DhtConfig()
{
}

void DhtConfig::clear()
{
	m_model = DHT_NONE;
	m_gpio = -1;
}

void DhtConfig::toASCII(stream &o, size_t indent) const
{
	o << "DhtConfig {";
	++indent;
	ascii_indent(o,indent,"model");
	if (const char *v = dht_model_t_str(m_model))
		o << v;
	else
		o << m_model;
	o << ';';
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t DhtConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -90;
		a += x;
		switch (fid) {
		case 0x8:	// model id 1, type dht_model_t, coding varint
			set_model((dht_model_t) (dht_model_t)ud.u32);
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -91;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -92;
	return a-(const uint8_t *)b;
}

ssize_t DhtConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has model?
	if (m_model != DHT_NONE) {
		// 'model': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -93;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_model);
		if (n <= 0)
			return -94;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -95;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -96;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void DhtConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_model()) {
		fsep = json_indent(json,indLvl,fsep,"model");
		if (const char *v = dht_model_t_str(m_model)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_model;
		}
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t DhtConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional dht_model_t model, id 1
	if (has_model()) {
		r += wiresize((varint_t)m_model) + 1 /* tag(model) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	return r;
}

bool DhtConfig::operator == (const DhtConfig &r) const
{
	if (has_model() && (!(m_model == r.m_model)))
		return false;
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int DhtConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"model")) {
		if (value == 0) {
			clear_model();
			return 0;
		}
		dht_model_t v;
		size_t r = parse_ascii_dht_model_t(&v,value);
		if (r == 0)
			return -97;
		set_model(v);
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	return -98;
}

I2CConfig::I2CConfig()
{
}

void I2CConfig::clear()
{
	m_port = 0;
	m_sda = -1;
	m_scl = -1;
	m_xpullup = false;
	#ifdef CONFIG_I2C_XDEV
	m_devices.clear();
	#endif // CONFIG_I2C_XDEV
	p_validbits = 0;
}

void I2CConfig::toASCII(stream &o, size_t indent) const
{
	o << "I2CConfig {";
	++indent;
	ascii_numeric(o, indent, "port", (unsigned) m_port);
	ascii_numeric(o, indent, "sda", (signed) m_sda);
	ascii_numeric(o, indent, "scl", (signed) m_scl);
	ascii_bool(o, indent, "xpullup", m_xpullup);
	#ifdef CONFIG_I2C_XDEV
	ascii_indent(o,indent);
	size_t s_devices = m_devices.size();
	o << "devices[" << s_devices << "] = {";
	++indent;
	for (size_t i = 0, e = s_devices; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_numeric(o, indent, 0, m_devices[i]);
		++indent;
		ascii_indent(o,indent);
		o << ".addr = " ;
		o << (unsigned) devices_addr(i);
		o << ';';
		ascii_indent(o,indent);
		o << ".drv = " ;
		o << i2cdrv_t_str(devices_drv(i));
		o << ';';
		ascii_indent(o,indent);
		o << ".intr = " ;
		o << (unsigned) devices_intr(i);
		o << ';';
		--indent;
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_I2C_XDEV
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t I2CConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -99;
		a += x;
		switch (fid) {
		case 0x8:	// port id 1, type uint8_t, coding varint
			set_port((uint8_t)ud.u32);
			break;
		case 0x10:	// sda id 2, type int8_t, coding signed varint
			set_sda(varint_sint(ud.u8));
			break;
		case 0x18:	// scl id 3, type int8_t, coding signed varint
			set_scl(varint_sint(ud.u8));
			break;
		case 0x2b:	// xpullup id 5, type bool, coding 8bit
			set_xpullup(ud.u8);
			break;
			#ifdef CONFIG_I2C_XDEV
		case 0x32: {	// devices id 6, packed i2cdev_t[] coding 2
				varint_t v = ud.u64;
				const uint8_t *ae = a + v;
				do {
					varint_t v;
					int n = read_varint(a,e-a,&v);
					if (n <= 0)
						return -100;
					a += n;
					m_devices.push_back((i2cdev_t)v);
				} while (a < ae);
				break;
			}
			#endif // CONFIG_I2C_XDEV
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -101;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -102;
	return a-(const uint8_t *)b;
}

ssize_t I2CConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -103;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_port);
		if (n <= 0)
			return -104;
		a += n;
	}
	// has sda?
	if (m_sda != -1) {
		// 'sda': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -105;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sda));
		if (n <= 0)
			return -106;
		a += n;
	}
	// has scl?
	if (m_scl != -1) {
		// 'scl': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -107;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_scl));
		if (n <= 0)
			return -108;
		a += n;
	}
	// 'freq' is unused. Therefore no data will be written.
	// has xpullup?
	if (m_xpullup != false) {
		// 'xpullup': id=5, encoding=8bit, tag=0x2b
		if (2 > (e-a))
			return -109;
		*a++ = 0x2b;
		*a++ = m_xpullup;
	}
	#ifdef CONFIG_I2C_XDEV
	if (size_t devices_ne = m_devices.size()) {
		// 'devices': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -110;
		*a++ = 0x32;
		ssize_t devices_ws = 0;
		for (size_t x = 0; x != devices_ne; ++x)
			devices_ws += wiresize(m_devices[x]);
		n = write_varint(a,e-a,devices_ws);
		a += n;
		if ((n <= 0) || (devices_ws > (e-a)))
			return -111;
		for (size_t x = 0; x != devices_ne; ++x)
			a += write_varint(a,e-a,m_devices[x]);
	}
	#endif // CONFIG_I2C_XDEV
	assert(a <= e);
	return a-b;
}

void I2CConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		to_decstr(json,(unsigned) m_port);
	}
	if (has_sda()) {
		fsep = json_indent(json,indLvl,fsep,"sda");
		to_decstr(json,(int) m_sda);
	}
	if (has_scl()) {
		fsep = json_indent(json,indLvl,fsep,"scl");
		to_decstr(json,(int) m_scl);
	}
	if (has_xpullup()) {
		fsep = json_indent(json,indLvl,fsep,"xpullup");
		json << (m_xpullup ? "true" : "false");
	}
	#ifdef CONFIG_I2C_XDEV
	if (size_t s = m_devices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"devices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json << m_devices[i];
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_I2C_XDEV
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t I2CConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional uint8 port, id 1
	if (has_port()) {
		r += wiresize((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional sint8 sda, id 2
	if (has_sda()) {
		r += wiresize_s((varint_t)m_sda) + 1 /* tag(sda) 0x10 */;
	}
	// optional sint8 scl, id 3
	if (has_scl()) {
		r += wiresize_s((varint_t)m_scl) + 1 /* tag(scl) 0x18 */;
	}
	// unused optional unsigned freq, id 4
	// optional bool xpullup, id 5
	if (has_xpullup()) {
		r += 2;
	}
	#ifdef CONFIG_I2C_XDEV
	// repeated i2cdev_t devices, id 6
	if (!m_devices.empty()) {
		// devices: packed repeated i2cdev_t
		size_t devices_dl = 0;
		for (size_t x = 0, y = m_devices.size(); x < y; ++x)
			devices_dl += wiresize((varint_t)m_devices[x]);
		r += devices_dl + wiresize(devices_dl) /* data length */ + 1 /* tag(devices) 0x30 */;
	}
	#endif // CONFIG_I2C_XDEV
	return r;
}

bool I2CConfig::operator == (const I2CConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_port() && (!(m_port == r.m_port)))
		return false;
	if (has_sda() && (!(m_sda == r.m_sda)))
		return false;
	if (has_scl() && (!(m_scl == r.m_scl)))
		return false;
	if (has_xpullup() && (!(m_xpullup == r.m_xpullup)))
		return false;
	#ifdef CONFIG_I2C_XDEV
	if (!(m_devices == r.m_devices))
		return false;
	#endif // CONFIG_I2C_XDEV
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int I2CConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u8(&m_port,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"sda")) {
		if (value == 0) {
			clear_sda();
			return 0;
		}
		int r = parse_ascii_s8(&m_sda,value);
		return r;
	}
	if (0 == strcmp(name,"scl")) {
		if (value == 0) {
			clear_scl();
			return 0;
		}
		int r = parse_ascii_s8(&m_scl,value);
		return r;
	}
	if (0 == strcmp(name,"xpullup")) {
		if (value == 0) {
			clear_xpullup();
			return 0;
		}
		int r = parse_ascii_bool(&m_xpullup,value);
		return r;
	}
	#ifdef CONFIG_I2C_XDEV
	if (0 == memcmp(name,"devices",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_devices();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_devices.size();
				m_devices.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -112;
				if (m_devices.size() <= x)
					return -113;
				if ((idxe[1] == 0) && (value == 0)) {
					m_devices.erase(m_devices.begin()+x);
					return 0;
				}
			}
			char *eptr = 0;
			unsigned long long ull = strtoull(value,&eptr,0);
			if (idxe[1] == 0) {
				m_devices[x] = (i2cdev_t) ull;
				return eptr - value;
			}
			if (idxe[1] != '.')
				return -114;
			idxe += 2;
			if (!strcmp("addr",idxe)) {
				if (eptr != value) {
					set_devices_addr(x,(uint8_t)ull);
					return 0;
				}
			}
			if (!strcmp("drv",idxe)) {
				if (eptr != value) {
					set_devices_drv(x,(i2cdrv_t)ull);
					return 0;
				} else {
					i2cdrv_t ev;
					size_t r = parse_ascii_i2cdrv_t(&ev,value);
					if (r != 0) {
						set_devices_drv(x,ev);
						return r;
					}
				}
			}
			if (!strcmp("intr",idxe)) {
				if (eptr != value) {
					set_devices_intr(x,(uint8_t)ull);
					return 0;
				}
			}
			return -115;
		}
	}
	#endif // CONFIG_I2C_XDEV
	return -116;
}

HcSr04Config::HcSr04Config()
{
}

void HcSr04Config::clear()
{
	m_trigger = -1;
	m_echo = -1;
	m_name.clear();
}

void HcSr04Config::toASCII(stream &o, size_t indent) const
{
	o << "HcSr04Config {";
	++indent;
	ascii_numeric(o, indent, "trigger", (signed) m_trigger);
	ascii_numeric(o, indent, "echo", (signed) m_echo);
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t HcSr04Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -117;
		a += x;
		switch (fid) {
		case 0x8:	// trigger id 1, type int8_t, coding signed varint
			set_trigger(varint_sint(ud.u8));
			break;
		case 0x10:	// echo id 2, type int8_t, coding signed varint
			set_echo(varint_sint(ud.u8));
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -118;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -119;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -120;
	return a-(const uint8_t *)b;
}

ssize_t HcSr04Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has trigger?
	if (m_trigger != -1) {
		// 'trigger': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -121;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_trigger));
		if (n <= 0)
			return -122;
		a += n;
	}
	// has echo?
	if (m_echo != -1) {
		// 'echo': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -123;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_echo));
		if (n <= 0)
			return -124;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -125;
		*a++ = 0x1a;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -126;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void HcSr04Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_trigger()) {
		fsep = json_indent(json,indLvl,fsep,"trigger");
		to_decstr(json,(int) m_trigger);
	}
	if (has_echo()) {
		fsep = json_indent(json,indLvl,fsep,"echo");
		to_decstr(json,(int) m_echo);
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t HcSr04Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 trigger, id 1
	if (has_trigger()) {
		r += wiresize_s((varint_t)m_trigger) + 1 /* tag(trigger) 0x8 */;
	}
	// optional sint8 echo, id 2
	if (has_echo()) {
		r += wiresize_s((varint_t)m_echo) + 1 /* tag(echo) 0x10 */;
	}
	// optional string name, id 3
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	return r;
}

bool HcSr04Config::operator == (const HcSr04Config &r) const
{
	if (has_trigger() && (!(m_trigger == r.m_trigger)))
		return false;
	if (has_echo() && (!(m_echo == r.m_echo)))
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int HcSr04Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"trigger")) {
		if (value == 0) {
			clear_trigger();
			return 0;
		}
		int r = parse_ascii_s8(&m_trigger,value);
		return r;
	}
	if (0 == strcmp(name,"echo")) {
		if (value == 0) {
			clear_echo();
			return 0;
		}
		int r = parse_ascii_s8(&m_echo,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	return -127;
}

LedConfig::LedConfig()
{
}

void LedConfig::clear()
{
	m_gpio = -1;
	m_config = 0;
	m_name.clear();
	m_pwm_ch = -1;
	p_validbits = 0;
}

void LedConfig::toASCII(stream &o, size_t indent) const
{
	o << "LedConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", (unsigned) m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".active_high";
	o << (config_active_high() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".open_drain";
	o << (config_open_drain() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".init_high";
	o << (config_init_high() ? " = true;" : " = false;");
	--indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "pwm_ch", (signed) m_pwm_ch);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t LedConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -128;
		a += x;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x10:	// config id 2, type ledcfg_t, coding varint
			set_config((ledcfg_t) (ledcfg_t)ud.u32);
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -129;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x20:	// pwm_ch id 4, type int8_t, coding signed varint
			set_pwm_ch(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -130;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -131;
	return a-(const uint8_t *)b;
}

ssize_t LedConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -132;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -133;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -134;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -135;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -136;
		*a++ = 0x1a;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -137;
		a += n;
	}
	// has pwm_ch?
	if (m_pwm_ch != -1) {
		// 'pwm_ch': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -138;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_pwm_ch));
		if (n <= 0)
			return -139;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void LedConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_pwm_ch()) {
		fsep = json_indent(json,indLvl,fsep,"pwm_ch");
		to_decstr(json,(int) m_pwm_ch);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t LedConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional ledcfg_t config, id 2
	if (has_config()) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x10 */;
	}
	// optional string name, id 3
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	// optional sint8 pwm_ch, id 4
	if (has_pwm_ch()) {
		r += wiresize_s((varint_t)m_pwm_ch) + 1 /* tag(pwm_ch) 0x20 */;
	}
	return r;
}

bool LedConfig::operator == (const LedConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_config() && (!(m_config == r.m_config)))
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_pwm_ch() && (!(m_pwm_ch == r.m_pwm_ch)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int LedConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((ledcfg_t)ull);
			else if (!strcmp(name,"active_high"))
				set_config_active_high((bool)ull);
			else if (!strcmp(name,"open_drain"))
				set_config_open_drain((bool)ull);
			else if (!strcmp(name,"init_high"))
				set_config_init_high((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -140;
		} else if (!strcmp(name,"active_high")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_active_high(tmp);
			return r;
		} else if (!strcmp(name,"open_drain")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_open_drain(tmp);
			return r;
		} else if (!strcmp(name,"init_high")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_init_high(tmp);
			return r;
		}
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"pwm_ch")) {
		if (value == 0) {
			clear_pwm_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_pwm_ch,value);
		return r;
	}
	return -141;
}

OneWireConfig::OneWireConfig()
{
}

void OneWireConfig::clear()
{
	m_gpio = -1;
	m_pullup = false;
	m_power = -1;
}

void OneWireConfig::toASCII(stream &o, size_t indent) const
{
	o << "OneWireConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_bool(o, indent, "pullup", m_pullup);
	ascii_numeric(o, indent, "power", (signed) m_power);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t OneWireConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -142;
		a += x;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x13:	// pullup id 2, type bool, coding 8bit
			set_pullup(ud.u8);
			break;
		case 0x18:	// power id 3, type int8_t, coding signed varint
			set_power(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -143;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -144;
	return a-(const uint8_t *)b;
}

ssize_t OneWireConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -145;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -146;
		a += n;
	}
	// has pullup?
	if (m_pullup != false) {
		// 'pullup': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -147;
		*a++ = 0x13;
		*a++ = m_pullup;
	}
	// has power?
	if (m_power != -1) {
		// 'power': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -148;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_power));
		if (n <= 0)
			return -149;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void OneWireConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_pullup()) {
		fsep = json_indent(json,indLvl,fsep,"pullup");
		json << (m_pullup ? "true" : "false");
	}
	if (has_power()) {
		fsep = json_indent(json,indLvl,fsep,"power");
		to_decstr(json,(int) m_power);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t OneWireConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional bool pullup, id 2
	if (has_pullup()) {
		r += 2;
	}
	// optional sint8 power, id 3
	if (has_power()) {
		r += wiresize_s((varint_t)m_power) + 1 /* tag(power) 0x18 */;
	}
	return r;
}

bool OneWireConfig::operator == (const OneWireConfig &r) const
{
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_pullup() && (!(m_pullup == r.m_pullup)))
		return false;
	if (has_power() && (!(m_power == r.m_power)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int OneWireConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"pullup")) {
		if (value == 0) {
			clear_pullup();
			return 0;
		}
		int r = parse_ascii_bool(&m_pullup,value);
		return r;
	}
	if (0 == strcmp(name,"power")) {
		if (value == 0) {
			clear_power();
			return 0;
		}
		int r = parse_ascii_s8(&m_power,value);
		return r;
	}
	return -150;
}

UartConfig::UartConfig()
{
}

void UartConfig::clear()
{
	m_port = -1;
}

void UartConfig::toASCII(stream &o, size_t indent) const
{
	o << "UartConfig {";
	++indent;
	ascii_numeric(o, indent, "port", (signed) m_port);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t UartConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -151;
		a += x;
		switch (fid) {
		case 0x8:	// port id 1, type int8_t, coding signed varint
			set_port(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -152;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -153;
	return a-(const uint8_t *)b;
}

ssize_t UartConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (m_port != -1) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -154;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_port));
		if (n <= 0)
			return -155;
		a += n;
	}
	// 'tx_gpio' is unused. Therefore no data will be written.
	// 'rx_gpio' is unused. Therefore no data will be written.
	// 'cts_gpio' is unused. Therefore no data will be written.
	// 'rts_gpio' is unused. Therefore no data will be written.
	assert(a <= e);
	return a-b;
}

void UartConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		to_decstr(json,(int) m_port);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t UartConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 port, id 1
	if (has_port()) {
		r += wiresize_s((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// unused optional sint8 tx_gpio, id 2
	// unused optional sint8 rx_gpio, id 3
	// unused optional sint8 cts_gpio, id 4
	// unused optional sint8 rts_gpio, id 5
	return r;
}

bool UartConfig::operator == (const UartConfig &r) const
{
	if (has_port() && (!(m_port == r.m_port)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int UartConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_s8(&m_port,value);
		return r;
	}
	return -156;
}

AdcConfig::AdcConfig()
{
}

void AdcConfig::clear()
{
	m_adc_name.clear();
	m_mode = 0;
	m_clk_div = 0;
	p_validbits = 0;
}

void AdcConfig::toASCII(stream &o, size_t indent) const
{
	o << "AdcConfig {";
	++indent;
	ascii_string(o,indent,m_adc_name.data(),m_adc_name.size(),"adc_name");
	ascii_numeric(o, indent, "mode", (unsigned) m_mode);
	ascii_numeric(o, indent, "clk_div", (unsigned) m_clk_div);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AdcConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -157;
		a += x;
		switch (fid) {
		case 0xa:	// adc_name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -158;
			}
			m_adc_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x20:	// mode id 4, type uint8_t, coding varint
			set_mode((uint8_t)ud.u32);
			break;
		case 0x28:	// clk_div id 5, type uint8_t, coding varint
			set_clk_div((uint8_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -159;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -160;
	return a-(const uint8_t *)b;
}

ssize_t AdcConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has adc_name?
	if (!m_adc_name.empty()) {
		// 'adc_name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -161;
		*a++ = 0xa;
		n = encode_bytes(m_adc_name,a,e);
		if (n < 0)
			return -162;
		a += n;
	}
	// 'adc1_bits' is unused. Therefore no data will be written.
	// 'adc2_bits' is unused. Therefore no data will be written.
	// has mode?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'mode': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -163;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_mode);
		if (n <= 0)
			return -164;
		a += n;
	}
	// has clk_div?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'clk_div': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -165;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_clk_div);
		if (n <= 0)
			return -166;
		a += n;
	}
	#ifdef CONFIG_IDF_TARGET_ESP32
	// 'hall_name' is unused. Therefore no data will be written.
	#endif // CONFIG_IDF_TARGET_ESP32
	// 'channels' is unused. Therefore no data will be written.
	assert(a <= e);
	return a-b;
}

void AdcConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_adc_name()) {
		fsep = json_indent(json,indLvl,fsep,"adc_name");
		json_cstr(json,m_adc_name.c_str());
	}
	if (has_mode()) {
		fsep = json_indent(json,indLvl,fsep,"mode");
		to_decstr(json,(unsigned) m_mode);
	}
	if (has_clk_div()) {
		fsep = json_indent(json,indLvl,fsep,"clk_div");
		to_decstr(json,(unsigned) m_clk_div);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AdcConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string adc_name, id 1
	if (has_adc_name()) {
		size_t adc_name_s = m_adc_name.size();
		r += adc_name_s + wiresize(adc_name_s) + 1 /* tag(adc_name) 0x8 */;
	}
	// unused optional uint8 adc1_bits, id 2
	// unused optional uint8 adc2_bits, id 3
	// optional uint8 mode, id 4
	if (has_mode()) {
		r += wiresize((varint_t)m_mode) + 1 /* tag(mode) 0x20 */;
	}
	// optional uint8 clk_div, id 5
	if (has_clk_div()) {
		r += wiresize((varint_t)m_clk_div) + 1 /* tag(clk_div) 0x28 */;
	}
	#ifdef CONFIG_IDF_TARGET_ESP32
	// unused optional string hall_name, id 6
	#endif // CONFIG_IDF_TARGET_ESP32
	// unused repeated AdcChannel channels, id 7
	return r;
}

bool AdcConfig::operator == (const AdcConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_adc_name() && (!(m_adc_name == r.m_adc_name)))
		return false;
	if (has_mode() && (!(m_mode == r.m_mode)))
		return false;
	if (has_clk_div() && (!(m_clk_div == r.m_clk_div)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AdcConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"adc_name")) {
		if (value == 0) {
			clear_adc_name();
			return 0;
		}
		m_adc_name = value;
		int r = m_adc_name.size();
		return r;
	}
	if (0 == strcmp(name,"mode")) {
		if (value == 0) {
			clear_mode();
			return 0;
		}
		int r = parse_ascii_u8(&m_mode,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"clk_div")) {
		if (value == 0) {
			clear_clk_div();
			return 0;
		}
		int r = parse_ascii_u8(&m_clk_div,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	return -167;
}

GpioConfig::GpioConfig()
{
}

void GpioConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_config = 0;
	p_validbits = 0;
}

void GpioConfig::toASCII(stream &o, size_t indent) const
{
	o << "GpioConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".mode = " ;
	o << (unsigned) config_mode();
	o << ';';
	ascii_indent(o,indent);
	o << ".intrtype = " ;
	o << (unsigned) config_intrtype();
	o << ';';
	ascii_indent(o,indent);
	o << ".setinit";
	o << (config_setinit() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".initlvl";
	o << (config_initlvl() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pullup";
	o << (config_pullup() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pulldown";
	o << (config_pulldown() ? " = true;" : " = false;");
	--indent;
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t GpioConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -168;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -169;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x18:	// config id 3, type gpiocfg_t, coding varint
			set_config((gpiocfg_t) (gpiocfg_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -170;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -171;
	return a-(const uint8_t *)b;
}

ssize_t GpioConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -172;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -173;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -174;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -175;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -176;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -177;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void GpioConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t GpioConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional gpiocfg_t config, id 3
	if (has_config()) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	return r;
}

bool GpioConfig::operator == (const GpioConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_config() && (!(m_config == r.m_config)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int GpioConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((gpiocfg_t)ull);
			else if (!strcmp(name,"mode"))
				set_config_mode((uint8_t)ull);
			else if (!strcmp(name,"intrtype"))
				set_config_intrtype((uint8_t)ull);
			else if (!strcmp(name,"setinit"))
				set_config_setinit((bool)ull);
			else if (!strcmp(name,"initlvl"))
				set_config_initlvl((bool)ull);
			else if (!strcmp(name,"pullup"))
				set_config_pullup((bool)ull);
			else if (!strcmp(name,"pulldown"))
				set_config_pulldown((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -178;
		} else if (!strcmp(name,"mode")) {
			uint8_t tmp;
			int r = parse_ascii_u8(&tmp,value);
			if (r > 0)
				set_config_mode(tmp);
			return r;
		} else if (!strcmp(name,"intrtype")) {
			uint8_t tmp;
			int r = parse_ascii_u8(&tmp,value);
			if (r > 0)
				set_config_intrtype(tmp);
			return r;
		} else if (!strcmp(name,"setinit")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_setinit(tmp);
			return r;
		} else if (!strcmp(name,"initlvl")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_initlvl(tmp);
			return r;
		} else if (!strcmp(name,"pullup")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_pullup(tmp);
			return r;
		} else if (!strcmp(name,"pulldown")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_pulldown(tmp);
			return r;
		}
	}
	return -179;
}

SpiDeviceConfig::SpiDeviceConfig()
{
}

void SpiDeviceConfig::clear()
{
	m_drv = spidrv_invalid;
	m_cs = -1;
	m_intr = -1;
	m_reset = -1;
	m_cd = -1;
	m_freq = 0;
}

void SpiDeviceConfig::toASCII(stream &o, size_t indent) const
{
	o << "SpiDeviceConfig {";
	++indent;
	ascii_indent(o,indent,"drv");
	if (const char *v = spidrv_t_str(m_drv))
		o << v;
	else
		o << m_drv;
	o << ';';
	ascii_numeric(o, indent, "cs", (signed) m_cs);
	ascii_numeric(o, indent, "intr", (signed) m_intr);
	ascii_numeric(o, indent, "reset", (signed) m_reset);
	ascii_numeric(o, indent, "cd", (signed) m_cd);
	ascii_numeric(o, indent, "freq", m_freq);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SpiDeviceConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -180;
		a += x;
		switch (fid) {
		case 0x8:	// drv id 1, type spidrv_t, coding varint
			set_drv((spidrv_t) (spidrv_t)ud.u32);
			break;
		case 0x10:	// cs id 2, type int8_t, coding signed varint
			set_cs(varint_sint(ud.u8));
			break;
		case 0x18:	// intr id 3, type int8_t, coding signed varint
			set_intr(varint_sint(ud.u8));
			break;
		case 0x20:	// reset id 4, type int8_t, coding signed varint
			set_reset(varint_sint(ud.u8));
			break;
		case 0x28:	// cd id 5, type int8_t, coding signed varint
			set_cd(varint_sint(ud.u8));
			break;
		case 0x30:	// freq id 6, type uint32_t, coding varint
			set_freq((uint32_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -181;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -182;
	return a-(const uint8_t *)b;
}

ssize_t SpiDeviceConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has drv?
	if (m_drv != spidrv_invalid) {
		// 'drv': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -183;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_drv);
		if (n <= 0)
			return -184;
		a += n;
	}
	// has cs?
	if (m_cs != -1) {
		// 'cs': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -185;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_cs));
		if (n <= 0)
			return -186;
		a += n;
	}
	// has intr?
	if (m_intr != -1) {
		// 'intr': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -187;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_intr));
		if (n <= 0)
			return -188;
		a += n;
	}
	// has reset?
	if (m_reset != -1) {
		// 'reset': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -189;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_reset));
		if (n <= 0)
			return -190;
		a += n;
	}
	// has cd?
	if (m_cd != -1) {
		// 'cd': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -191;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_cd));
		if (n <= 0)
			return -192;
		a += n;
	}
	// has freq?
	if (m_freq != 0) {
		// 'freq': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -193;
		*a++ = 0x30;
		n = write_varint(a,e-a,m_freq);
		if (n <= 0)
			return -194;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void SpiDeviceConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_drv()) {
		fsep = json_indent(json,indLvl,fsep,"drv");
		if (const char *v = spidrv_t_str(m_drv)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_drv;
		}
	}
	if (has_cs()) {
		fsep = json_indent(json,indLvl,fsep,"cs");
		to_decstr(json,(int) m_cs);
	}
	if (has_intr()) {
		fsep = json_indent(json,indLvl,fsep,"intr");
		to_decstr(json,(int) m_intr);
	}
	if (has_reset()) {
		fsep = json_indent(json,indLvl,fsep,"reset");
		to_decstr(json,(int) m_reset);
	}
	if (has_cd()) {
		fsep = json_indent(json,indLvl,fsep,"cd");
		to_decstr(json,(int) m_cd);
	}
	if (has_freq()) {
		fsep = json_indent(json,indLvl,fsep,"freq");
		to_decstr(json,m_freq);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SpiDeviceConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional spidrv_t drv, id 1
	if (has_drv()) {
		r += wiresize((varint_t)m_drv) + 1 /* tag(drv) 0x8 */;
	}
	// optional sint8 cs, id 2
	if (has_cs()) {
		r += wiresize_s((varint_t)m_cs) + 1 /* tag(cs) 0x10 */;
	}
	// optional sint8 intr, id 3
	if (has_intr()) {
		r += wiresize_s((varint_t)m_intr) + 1 /* tag(intr) 0x18 */;
	}
	// optional sint8 reset, id 4
	if (has_reset()) {
		r += wiresize_s((varint_t)m_reset) + 1 /* tag(reset) 0x20 */;
	}
	// optional sint8 cd, id 5
	if (has_cd()) {
		r += wiresize_s((varint_t)m_cd) + 1 /* tag(cd) 0x28 */;
	}
	// optional unsigned freq, id 6
	if (has_freq()) {
		r += wiresize((varint_t)m_freq) + 1 /* tag(freq) 0x30 */;
	}
	return r;
}

bool SpiDeviceConfig::operator == (const SpiDeviceConfig &r) const
{
	if (has_drv() && (!(m_drv == r.m_drv)))
		return false;
	if (has_cs() && (!(m_cs == r.m_cs)))
		return false;
	if (has_intr() && (!(m_intr == r.m_intr)))
		return false;
	if (has_reset() && (!(m_reset == r.m_reset)))
		return false;
	if (has_cd() && (!(m_cd == r.m_cd)))
		return false;
	if (has_freq() && (!(m_freq == r.m_freq)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SpiDeviceConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"drv")) {
		if (value == 0) {
			clear_drv();
			return 0;
		}
		spidrv_t v;
		size_t r = parse_ascii_spidrv_t(&v,value);
		if (r == 0)
			return -195;
		set_drv(v);
		return r;
	}
	if (0 == strcmp(name,"cs")) {
		if (value == 0) {
			clear_cs();
			return 0;
		}
		int r = parse_ascii_s8(&m_cs,value);
		return r;
	}
	if (0 == strcmp(name,"intr")) {
		if (value == 0) {
			clear_intr();
			return 0;
		}
		int r = parse_ascii_s8(&m_intr,value);
		return r;
	}
	if (0 == strcmp(name,"reset")) {
		if (value == 0) {
			clear_reset();
			return 0;
		}
		int r = parse_ascii_s8(&m_reset,value);
		return r;
	}
	if (0 == strcmp(name,"cd")) {
		if (value == 0) {
			clear_cd();
			return 0;
		}
		int r = parse_ascii_s8(&m_cd,value);
		return r;
	}
	if (0 == strcmp(name,"freq")) {
		if (value == 0) {
			clear_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_freq,value);
		return r;
	}
	return -196;
}

SpiBusConfig::SpiBusConfig()
{
}

void SpiBusConfig::clear()
{
	m_host = -1;
	m_mosi = -1;
	m_miso = -1;
	m_sclk = -1;
	m_wp = -1;
	m_hold = -1;
	m_options = 0;
	m_dma = -1;
	m_devices.clear();
	p_validbits = 0;
}

void SpiBusConfig::toASCII(stream &o, size_t indent) const
{
	o << "SpiBusConfig {";
	++indent;
	ascii_numeric(o, indent, "host", (signed) m_host);
	ascii_numeric(o, indent, "mosi", (signed) m_mosi);
	ascii_numeric(o, indent, "miso", (signed) m_miso);
	ascii_numeric(o, indent, "sclk", (signed) m_sclk);
	ascii_numeric(o, indent, "wp", (signed) m_wp);
	ascii_numeric(o, indent, "hold", (signed) m_hold);
	ascii_numeric(o, indent, "options", (unsigned) m_options);
	++indent;
	ascii_indent(o,indent);
	o << ".txlsbfirst";
	o << (options_txlsbfirst() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".rxlsbfirst";
	o << (options_rxlsbfirst() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".mosi_as_miso";
	o << (options_mosi_as_miso() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".positive_cs";
	o << (options_positive_cs() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".full_duplex";
	o << (options_full_duplex() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pol_hi";
	o << (options_pol_hi() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pha_hi";
	o << (options_pha_hi() ? " = true;" : " = false;");
	--indent;
	ascii_numeric(o, indent, "dma", (signed) m_dma);
	ascii_indent(o,indent);
	size_t s_devices = m_devices.size();
	o << "devices[" << s_devices << "] = {";
	++indent;
	for (size_t i = 0, e = s_devices; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_devices[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SpiBusConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -197;
		a += x;
		switch (fid) {
		case 0x8:	// host id 1, type int8_t, coding signed varint
			set_host(varint_sint(ud.u8));
			break;
		case 0x10:	// mosi id 2, type int8_t, coding signed varint
			set_mosi(varint_sint(ud.u8));
			break;
		case 0x18:	// miso id 3, type int8_t, coding signed varint
			set_miso(varint_sint(ud.u8));
			break;
		case 0x20:	// sclk id 4, type int8_t, coding signed varint
			set_sclk(varint_sint(ud.u8));
			break;
		case 0x28:	// wp id 5, type int8_t, coding signed varint
			set_wp(varint_sint(ud.u8));
			break;
		case 0x30:	// hold id 6, type int8_t, coding signed varint
			set_hold(varint_sint(ud.u8));
			break;
		case 0x38:	// options id 7, type spiopt_t, coding varint
			set_options((spiopt_t) (spiopt_t)ud.u32);
			break;
		case 0x40:	// dma id 8, type int8_t, coding signed varint
			set_dma(varint_sint(ud.u8));
			break;
		case 0x4a:	// devices id 9, type SpiDeviceConfig, coding byte[]
			m_devices.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_devices.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -198;
				a += ud.vi;
			}
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -199;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -200;
	return a-(const uint8_t *)b;
}

ssize_t SpiBusConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has host?
	if (m_host != -1) {
		// 'host': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -201;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_host));
		if (n <= 0)
			return -202;
		a += n;
	}
	// has mosi?
	if (m_mosi != -1) {
		// 'mosi': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -203;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_mosi));
		if (n <= 0)
			return -204;
		a += n;
	}
	// has miso?
	if (m_miso != -1) {
		// 'miso': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -205;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_miso));
		if (n <= 0)
			return -206;
		a += n;
	}
	// has sclk?
	if (m_sclk != -1) {
		// 'sclk': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -207;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_sclk));
		if (n <= 0)
			return -208;
		a += n;
	}
	// has wp?
	if (m_wp != -1) {
		// 'wp': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -209;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_wp));
		if (n <= 0)
			return -210;
		a += n;
	}
	// has hold?
	if (m_hold != -1) {
		// 'hold': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -211;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_hold));
		if (n <= 0)
			return -212;
		a += n;
	}
	// has options?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'options': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -213;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_options);
		if (n <= 0)
			return -214;
		a += n;
	}
	// has dma?
	if (m_dma != -1) {
		// 'dma': id=8, encoding=varint, tag=0x40
		if (a >= e)
			return -215;
		*a++ = 0x40;
		n = write_varint(a,e-a,sint_varint(m_dma));
		if (n <= 0)
			return -216;
		a += n;
	}
	for (const auto &x : m_devices) {
		// 'devices': id=9, encoding=lenpfx, tag=0x4a
		if (a >= e)
			return -217;
		*a++ = 0x4a;
		ssize_t devices_ws = x.calcSize();
		n = write_varint(a,e-a,devices_ws);
		a += n;
		if ((n <= 0) || (devices_ws > (e-a)))
			return -218;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == devices_ws);
	}
	assert(a <= e);
	return a-b;
}

void SpiBusConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_host()) {
		fsep = json_indent(json,indLvl,fsep,"host");
		to_decstr(json,(int) m_host);
	}
	if (has_mosi()) {
		fsep = json_indent(json,indLvl,fsep,"mosi");
		to_decstr(json,(int) m_mosi);
	}
	if (has_miso()) {
		fsep = json_indent(json,indLvl,fsep,"miso");
		to_decstr(json,(int) m_miso);
	}
	if (has_sclk()) {
		fsep = json_indent(json,indLvl,fsep,"sclk");
		to_decstr(json,(int) m_sclk);
	}
	if (has_wp()) {
		fsep = json_indent(json,indLvl,fsep,"wp");
		to_decstr(json,(int) m_wp);
	}
	if (has_hold()) {
		fsep = json_indent(json,indLvl,fsep,"hold");
		to_decstr(json,(int) m_hold);
	}
	if (has_options()) {
		fsep = json_indent(json,indLvl,fsep,"options");
		json << (unsigned) m_options;
	}
	if (has_dma()) {
		fsep = json_indent(json,indLvl,fsep,"dma");
		to_decstr(json,(int) m_dma);
	}
	if (size_t s = m_devices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"devices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_devices[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SpiBusConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 host, id 1
	if (has_host()) {
		r += wiresize_s((varint_t)m_host) + 1 /* tag(host) 0x8 */;
	}
	// optional sint8 mosi, id 2
	if (has_mosi()) {
		r += wiresize_s((varint_t)m_mosi) + 1 /* tag(mosi) 0x10 */;
	}
	// optional sint8 miso, id 3
	if (has_miso()) {
		r += wiresize_s((varint_t)m_miso) + 1 /* tag(miso) 0x18 */;
	}
	// optional sint8 sclk, id 4
	if (has_sclk()) {
		r += wiresize_s((varint_t)m_sclk) + 1 /* tag(sclk) 0x20 */;
	}
	// optional sint8 wp, id 5
	if (has_wp()) {
		r += wiresize_s((varint_t)m_wp) + 1 /* tag(wp) 0x28 */;
	}
	// optional sint8 hold, id 6
	if (has_hold()) {
		r += wiresize_s((varint_t)m_hold) + 1 /* tag(hold) 0x30 */;
	}
	// optional spiopt_t options, id 7
	if (has_options()) {
		r += wiresize((varint_t)m_options) + 1 /* tag(options) 0x38 */;
	}
	// optional sint8 dma, id 8
	if (has_dma()) {
		r += wiresize_s((varint_t)m_dma) + 1 /* tag(dma) 0x40 */;
	}
	// repeated SpiDeviceConfig devices, id 9
	// repeated message devices
	for (size_t x = 0, y = m_devices.size(); x < y; ++x) {
		size_t s = m_devices[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(devices) 0x48 */;
	}
	return r;
}

bool SpiBusConfig::operator == (const SpiBusConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_host() && (!(m_host == r.m_host)))
		return false;
	if (has_mosi() && (!(m_mosi == r.m_mosi)))
		return false;
	if (has_miso() && (!(m_miso == r.m_miso)))
		return false;
	if (has_sclk() && (!(m_sclk == r.m_sclk)))
		return false;
	if (has_wp() && (!(m_wp == r.m_wp)))
		return false;
	if (has_hold() && (!(m_hold == r.m_hold)))
		return false;
	if (has_options() && (!(m_options == r.m_options)))
		return false;
	if (has_dma() && (!(m_dma == r.m_dma)))
		return false;
	if (!(m_devices == r.m_devices))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SpiBusConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"host")) {
		if (value == 0) {
			clear_host();
			return 0;
		}
		int r = parse_ascii_s8(&m_host,value);
		return r;
	}
	if (0 == strcmp(name,"mosi")) {
		if (value == 0) {
			clear_mosi();
			return 0;
		}
		int r = parse_ascii_s8(&m_mosi,value);
		return r;
	}
	if (0 == strcmp(name,"miso")) {
		if (value == 0) {
			clear_miso();
			return 0;
		}
		int r = parse_ascii_s8(&m_miso,value);
		return r;
	}
	if (0 == strcmp(name,"sclk")) {
		if (value == 0) {
			clear_sclk();
			return 0;
		}
		int r = parse_ascii_s8(&m_sclk,value);
		return r;
	}
	if (0 == strcmp(name,"wp")) {
		if (value == 0) {
			clear_wp();
			return 0;
		}
		int r = parse_ascii_s8(&m_wp,value);
		return r;
	}
	if (0 == strcmp(name,"hold")) {
		if (value == 0) {
			clear_hold();
			return 0;
		}
		int r = parse_ascii_s8(&m_hold,value);
		return r;
	}
	if ((0 == memcmp(name,"options",7)) && ((name[7] == 0) || name[7] == '.')) {
		name += 7;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_options((spiopt_t)ull);
			else if (!strcmp(name,"txlsbfirst"))
				set_options_txlsbfirst((bool)ull);
			else if (!strcmp(name,"rxlsbfirst"))
				set_options_rxlsbfirst((bool)ull);
			else if (!strcmp(name,"mosi_as_miso"))
				set_options_mosi_as_miso((bool)ull);
			else if (!strcmp(name,"positive_cs"))
				set_options_positive_cs((bool)ull);
			else if (!strcmp(name,"full_duplex"))
				set_options_full_duplex((bool)ull);
			else if (!strcmp(name,"pol_hi"))
				set_options_pol_hi((bool)ull);
			else if (!strcmp(name,"pha_hi"))
				set_options_pha_hi((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -219;
		} else if (!strcmp(name,"txlsbfirst")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_txlsbfirst(tmp);
			return r;
		} else if (!strcmp(name,"rxlsbfirst")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_rxlsbfirst(tmp);
			return r;
		} else if (!strcmp(name,"mosi_as_miso")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_mosi_as_miso(tmp);
			return r;
		} else if (!strcmp(name,"positive_cs")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_positive_cs(tmp);
			return r;
		} else if (!strcmp(name,"full_duplex")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_full_duplex(tmp);
			return r;
		} else if (!strcmp(name,"pol_hi")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_pol_hi(tmp);
			return r;
		} else if (!strcmp(name,"pha_hi")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_pha_hi(tmp);
			return r;
		}
	}
	if (0 == strcmp(name,"dma")) {
		if (value == 0) {
			clear_dma();
			return 0;
		}
		int r = parse_ascii_s8(&m_dma,value);
		return r;
	}
	if (0 == memcmp(name,"devices",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_devices();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_devices.size();
				m_devices.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -220;
				if (m_devices.size() <= x)
					return -221;
				if ((idxe[1] == 0) && (value == 0)) {
					m_devices.erase(m_devices.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -222;
			return m_devices[x].setByName(idxe+2,value);
		}
	}
	return -223;
}

GpioCluster::GpioCluster()
{
}

void GpioCluster::clear()
{
	m_name.clear();
	m_base = 0;
	m_numio = 0;
	m_int_a = -1;
	m_int_b = -1;
}

void GpioCluster::toASCII(stream &o, size_t indent) const
{
	o << "GpioCluster {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "base", (unsigned) m_base);
	ascii_numeric(o, indent, "numio", (unsigned) m_numio);
	ascii_numeric(o, indent, "int_a", (signed) m_int_a);
	ascii_numeric(o, indent, "int_b", (signed) m_int_b);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t GpioCluster::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -224;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -225;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// base id 2, type uint8_t, coding varint
			set_base((uint8_t)ud.u32);
			break;
		case 0x18:	// numio id 3, type uint8_t, coding varint
			set_numio((uint8_t)ud.u32);
			break;
		case 0x20:	// int_a id 4, type int8_t, coding signed varint
			set_int_a(varint_sint(ud.u8));
			break;
		case 0x28:	// int_b id 5, type int8_t, coding signed varint
			set_int_b(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -226;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -227;
	return a-(const uint8_t *)b;
}

ssize_t GpioCluster::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -228;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -229;
		a += n;
	}
	// has base?
	if (m_base != 0) {
		// 'base': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -230;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_base);
		if (n <= 0)
			return -231;
		a += n;
	}
	// has numio?
	if (m_numio != 0) {
		// 'numio': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -232;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_numio);
		if (n <= 0)
			return -233;
		a += n;
	}
	// has int_a?
	if (m_int_a != -1) {
		// 'int_a': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -234;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_int_a));
		if (n <= 0)
			return -235;
		a += n;
	}
	// has int_b?
	if (m_int_b != -1) {
		// 'int_b': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -236;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_int_b));
		if (n <= 0)
			return -237;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void GpioCluster::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_base()) {
		fsep = json_indent(json,indLvl,fsep,"base");
		to_decstr(json,(unsigned) m_base);
	}
	if (has_numio()) {
		fsep = json_indent(json,indLvl,fsep,"numio");
		to_decstr(json,(unsigned) m_numio);
	}
	if (has_int_a()) {
		fsep = json_indent(json,indLvl,fsep,"int_a");
		to_decstr(json,(int) m_int_a);
	}
	if (has_int_b()) {
		fsep = json_indent(json,indLvl,fsep,"int_b");
		to_decstr(json,(int) m_int_b);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t GpioCluster::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional uint8 base, id 2
	if (has_base()) {
		r += wiresize((varint_t)m_base) + 1 /* tag(base) 0x10 */;
	}
	// optional uint8 numio, id 3
	if (has_numio()) {
		r += wiresize((varint_t)m_numio) + 1 /* tag(numio) 0x18 */;
	}
	// optional sint8 int_a, id 4
	if (has_int_a()) {
		r += wiresize_s((varint_t)m_int_a) + 1 /* tag(int_a) 0x20 */;
	}
	// optional sint8 int_b, id 5
	if (has_int_b()) {
		r += wiresize_s((varint_t)m_int_b) + 1 /* tag(int_b) 0x28 */;
	}
	return r;
}

bool GpioCluster::operator == (const GpioCluster &r) const
{
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_base() && (!(m_base == r.m_base)))
		return false;
	if (has_numio() && (!(m_numio == r.m_numio)))
		return false;
	if (has_int_a() && (!(m_int_a == r.m_int_a)))
		return false;
	if (has_int_b() && (!(m_int_b == r.m_int_b)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int GpioCluster::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"base")) {
		if (value == 0) {
			clear_base();
			return 0;
		}
		int r = parse_ascii_u8(&m_base,value);
		return r;
	}
	if (0 == strcmp(name,"numio")) {
		if (value == 0) {
			clear_numio();
			return 0;
		}
		int r = parse_ascii_u8(&m_numio,value);
		return r;
	}
	if (0 == strcmp(name,"int_a")) {
		if (value == 0) {
			clear_int_a();
			return 0;
		}
		int r = parse_ascii_s8(&m_int_a,value);
		return r;
	}
	if (0 == strcmp(name,"int_b")) {
		if (value == 0) {
			clear_int_b();
			return 0;
		}
		int r = parse_ascii_s8(&m_int_b,value);
		return r;
	}
	return -238;
}

Hlw8012Config::Hlw8012Config()
{
}

void Hlw8012Config::clear()
{
	m_sel = -1;
	m_cf = -1;
	m_cf1 = -1;
}

void Hlw8012Config::toASCII(stream &o, size_t indent) const
{
	o << "Hlw8012Config {";
	++indent;
	ascii_numeric(o, indent, "sel", (signed) m_sel);
	ascii_numeric(o, indent, "cf", (signed) m_cf);
	ascii_numeric(o, indent, "cf1", (signed) m_cf1);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Hlw8012Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -239;
		a += x;
		switch (fid) {
		case 0x10:	// sel id 2, type int8_t, coding signed varint
			set_sel(varint_sint(ud.u8));
			break;
		case 0x18:	// cf id 3, type int8_t, coding signed varint
			set_cf(varint_sint(ud.u8));
			break;
		case 0x20:	// cf1 id 4, type int8_t, coding signed varint
			set_cf1(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -240;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -241;
	return a-(const uint8_t *)b;
}

ssize_t Hlw8012Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has sel?
	if (m_sel != -1) {
		// 'sel': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -242;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sel));
		if (n <= 0)
			return -243;
		a += n;
	}
	// has cf?
	if (m_cf != -1) {
		// 'cf': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -244;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_cf));
		if (n <= 0)
			return -245;
		a += n;
	}
	// has cf1?
	if (m_cf1 != -1) {
		// 'cf1': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -246;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_cf1));
		if (n <= 0)
			return -247;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Hlw8012Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_sel()) {
		fsep = json_indent(json,indLvl,fsep,"sel");
		to_decstr(json,(int) m_sel);
	}
	if (has_cf()) {
		fsep = json_indent(json,indLvl,fsep,"cf");
		to_decstr(json,(int) m_cf);
	}
	if (has_cf1()) {
		fsep = json_indent(json,indLvl,fsep,"cf1");
		to_decstr(json,(int) m_cf1);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Hlw8012Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 sel, id 2
	if (has_sel()) {
		r += wiresize_s((varint_t)m_sel) + 1 /* tag(sel) 0x10 */;
	}
	// optional sint8 cf, id 3
	if (has_cf()) {
		r += wiresize_s((varint_t)m_cf) + 1 /* tag(cf) 0x18 */;
	}
	// optional sint8 cf1, id 4
	if (has_cf1()) {
		r += wiresize_s((varint_t)m_cf1) + 1 /* tag(cf1) 0x20 */;
	}
	return r;
}

bool Hlw8012Config::operator == (const Hlw8012Config &r) const
{
	if (has_sel() && (!(m_sel == r.m_sel)))
		return false;
	if (has_cf() && (!(m_cf == r.m_cf)))
		return false;
	if (has_cf1() && (!(m_cf1 == r.m_cf1)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Hlw8012Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"sel")) {
		if (value == 0) {
			clear_sel();
			return 0;
		}
		int r = parse_ascii_s8(&m_sel,value);
		return r;
	}
	if (0 == strcmp(name,"cf")) {
		if (value == 0) {
			clear_cf();
			return 0;
		}
		int r = parse_ascii_s8(&m_cf,value);
		return r;
	}
	if (0 == strcmp(name,"cf1")) {
		if (value == 0) {
			clear_cf1();
			return 0;
		}
		int r = parse_ascii_s8(&m_cf1,value);
		return r;
	}
	return -248;
}

Melody::Melody()
{
}

void Melody::clear()
{
	m_name.clear();
	m_tones.clear();
}

void Melody::toASCII(stream &o, size_t indent) const
{
	o << "Melody {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_indent(o,indent);
	size_t s_tones = m_tones.size();
	o << "tones[" << s_tones << "] = {";
	++indent;
	for (size_t i = 0, e = s_tones; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_numeric(o, indent, 0, m_tones[i]);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Melody::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -249;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -250;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x14:	// tones id 2, type uint16_t, coding 16bit
			m_tones.push_back(ud.u16);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -251;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -252;
	return a-(const uint8_t *)b;
}

ssize_t Melody::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -253;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -254;
		a += n;
	}
	for (auto x : m_tones) {
		// 'tones': id=2, encoding=16bit, tag=0x14
		if (3 > (e-a))
			return -255;
		*a++ = 0x14;
		if ((e-a) < 2)
			return -256;
		write_u16(a,x);
		a += 2;
	}
	assert(a <= e);
	return a-b;
}

void Melody::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (size_t s = m_tones.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"tones\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			to_decstr(json,m_tones[i]);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Melody::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// repeated fixed16 tones, id 2
	if (!m_tones.empty()) {
		// tones: non-packed, fixed size elements
		r += m_tones.size() * 3;	// including tag
	}
	return r;
}

bool Melody::operator == (const Melody &r) const
{
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (!(m_tones == r.m_tones))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Melody::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == memcmp(name,"tones",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_tones();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_tones.size();
				m_tones.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -257;
				if (m_tones.size() <= x)
					return -258;
				if ((idxe[1] == 0) && (value == 0)) {
					m_tones.erase(m_tones.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -259;
			return parse_ascii_u16(&m_tones[x],value);
		}
	}
	return -260;
}

BuzzerConfig::BuzzerConfig()
{
}

void BuzzerConfig::clear()
{
	m_gpio = -1;
	m_melodies.clear();
}

void BuzzerConfig::toASCII(stream &o, size_t indent) const
{
	o << "BuzzerConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_indent(o,indent);
	size_t s_melodies = m_melodies.size();
	o << "melodies[" << s_melodies << "] = {";
	++indent;
	for (size_t i = 0, e = s_melodies; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_melodies[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t BuzzerConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -261;
		a += x;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x12:	// melodies id 2, type Melody, coding byte[]
			m_melodies.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_melodies.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -262;
				a += ud.vi;
			}
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -263;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -264;
	return a-(const uint8_t *)b;
}

ssize_t BuzzerConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -265;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -266;
		a += n;
	}
	for (const auto &x : m_melodies) {
		// 'melodies': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -267;
		*a++ = 0x12;
		ssize_t melodies_ws = x.calcSize();
		n = write_varint(a,e-a,melodies_ws);
		a += n;
		if ((n <= 0) || (melodies_ws > (e-a)))
			return -268;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == melodies_ws);
	}
	assert(a <= e);
	return a-b;
}

void BuzzerConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (size_t s = m_melodies.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"melodies\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_melodies[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t BuzzerConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// repeated Melody melodies, id 2
	// repeated message melodies
	for (size_t x = 0, y = m_melodies.size(); x < y; ++x) {
		size_t s = m_melodies[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(melodies) 0x10 */;
	}
	return r;
}

bool BuzzerConfig::operator == (const BuzzerConfig &r) const
{
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (!(m_melodies == r.m_melodies))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int BuzzerConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == memcmp(name,"melodies",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_melodies();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_melodies.size();
				m_melodies.resize(x+1);
				idxe = (char*)(name + 10);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+9)))
					return -269;
				if (m_melodies.size() <= x)
					return -270;
				if ((idxe[1] == 0) && (value == 0)) {
					m_melodies.erase(m_melodies.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -271;
			return m_melodies[x].setByName(idxe+2,value);
		}
	}
	return -272;
}

HardwareConfig::HardwareConfig()
{
}

void HardwareConfig::clear()
{
	m_magic = 0;
	m_system.clear();
	m_adc.clear();
	m_gpios.clear();
	#ifdef CONFIG_SPI
	m_spibus.clear();
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	m_button.clear();
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	m_relay.clear();
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	m_led.clear();
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	m_buzzer.clear();
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	m_hlw8012.clear();
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	m_max7219.clear();
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	m_tlc5947.clear();
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	m_ws2812b.clear();
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	m_dht.clear();
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	m_i2c.clear();
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	m_hcsr04.clear();
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	m_onewire.clear();
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	m_sx1276.clear();
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	m_iocluster.clear();
	#endif // CONFIG_IOEXTENDERS
	p_validbits = 0;
}

void HardwareConfig::toASCII(stream &o, size_t indent) const
{
	o << "HardwareConfig {";
	++indent;
	ascii_numeric(o, indent, "magic", m_magic);
	ascii_indent(o,indent,"system");
	m_system.toASCII(o,indent);
	ascii_indent(o,indent,"adc");
	m_adc.toASCII(o,indent);
	ascii_indent(o,indent);
	size_t s_gpios = m_gpios.size();
	o << "gpios[" << s_gpios << "] = {";
	++indent;
	for (size_t i = 0, e = s_gpios; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_gpios[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_SPI
	ascii_indent(o,indent);
	size_t s_spibus = m_spibus.size();
	o << "spibus[" << s_spibus << "] = {";
	++indent;
	for (size_t i = 0, e = s_spibus; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_spibus[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	ascii_indent(o,indent);
	size_t s_button = m_button.size();
	o << "button[" << s_button << "] = {";
	++indent;
	for (size_t i = 0, e = s_button; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_button[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	ascii_indent(o,indent);
	size_t s_relay = m_relay.size();
	o << "relay[" << s_relay << "] = {";
	++indent;
	for (size_t i = 0, e = s_relay; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_relay[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	ascii_indent(o,indent);
	size_t s_led = m_led.size();
	o << "led[" << s_led << "] = {";
	++indent;
	for (size_t i = 0, e = s_led; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_led[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	ascii_indent(o,indent,"buzzer");
	m_buzzer.toASCII(o,indent);
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	ascii_indent(o,indent,"hlw8012");
	m_hlw8012.toASCII(o,indent);
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	ascii_indent(o,indent,"max7219");
	m_max7219.toASCII(o,indent);
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	ascii_indent(o,indent,"tlc5947");
	m_tlc5947.toASCII(o,indent);
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	ascii_indent(o,indent);
	size_t s_ws2812b = m_ws2812b.size();
	o << "ws2812b[" << s_ws2812b << "] = {";
	++indent;
	for (size_t i = 0, e = s_ws2812b; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_ws2812b[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	ascii_indent(o,indent,"dht");
	m_dht.toASCII(o,indent);
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	ascii_indent(o,indent);
	size_t s_i2c = m_i2c.size();
	o << "i2c[" << s_i2c << "] = {";
	++indent;
	for (size_t i = 0, e = s_i2c; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_i2c[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	ascii_indent(o,indent);
	size_t s_hcsr04 = m_hcsr04.size();
	o << "hcsr04[" << s_hcsr04 << "] = {";
	++indent;
	for (size_t i = 0, e = s_hcsr04; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_hcsr04[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	ascii_indent(o,indent,"onewire");
	m_onewire.toASCII(o,indent);
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	ascii_indent(o,indent,"sx1276");
	m_sx1276.toASCII(o,indent);
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	ascii_indent(o,indent);
	size_t s_iocluster = m_iocluster.size();
	o << "iocluster[" << s_iocluster << "] = {";
	++indent;
	for (size_t i = 0, e = s_iocluster; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_iocluster[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_IOEXTENDERS
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t HardwareConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -273;
		a += x;
		switch (fid) {
		case 0x5:	// magic id 0, type uint32_t, coding 32bit
			set_magic(ud.u32);
			break;
		case 0xa:	// system id 1, type SystemConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_system.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -274;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 1);
			break;
		case 0x22:	// adc id 4, type AdcConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_adc.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -275;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 2);
			break;
		case 0x3a:	// gpios id 7, type GpioConfig, coding byte[]
			m_gpios.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_gpios.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -276;
				a += ud.vi;
			}
			break;
			#ifdef CONFIG_SPI
		case 0x42:	// spibus id 8, type SpiBusConfig, coding byte[]
			m_spibus.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_spibus.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -277;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_SPI
			#ifdef CONFIG_BUTTON
		case 0x82:	// button id 16, type ButtonConfig, coding byte[]
			m_button.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_button.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -278;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_BUTTON
			#ifdef CONFIG_RELAY
		case 0x8a:	// relay id 17, type RelayConfig, coding byte[]
			m_relay.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_relay.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -279;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_RELAY
			#ifdef CONFIG_LEDS
		case 0x92:	// led id 18, type LedConfig, coding byte[]
			m_led.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_led.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -280;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_LEDS
			#ifdef CONFIG_BUZZER
		case 0x9a:	// buzzer id 19, type BuzzerConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_buzzer.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -281;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 3);
			break;
			#endif // CONFIG_BUZZER
			#ifdef CONFIG_HLW8012
		case 0xa2:	// hlw8012 id 20, type Hlw8012Config, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_hlw8012.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -282;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 4);
			break;
			#endif // CONFIG_HLW8012
			#ifdef CONFIG_MAX7219
		case 0x102:	// max7219 id 32, type Max7219Config, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_max7219.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -283;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 5);
			break;
			#endif // CONFIG_MAX7219
			#ifdef CONFIG_TLC5947
		case 0x10a:	// tlc5947 id 33, type Tlc5947Config, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_tlc5947.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -284;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 6);
			break;
			#endif // CONFIG_TLC5947
			#ifdef CONFIG_RGBLEDS
		case 0x112:	// ws2812b id 34, type Ws2812bConfig, coding byte[]
			m_ws2812b.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_ws2812b.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -285;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_RGBLEDS
			#ifdef CONFIG_DHT
		case 0x11a:	// dht id 35, type DhtConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_dht.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -286;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 7);
			break;
			#endif // CONFIG_DHT
			#ifdef CONFIG_I2C
		case 0x122:	// i2c id 36, type I2CConfig, coding byte[]
			m_i2c.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_i2c.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -287;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_I2C
			#ifdef CONFIG_HCSR04
		case 0x12a:	// hcsr04 id 37, type HcSr04Config, coding byte[]
			m_hcsr04.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_hcsr04.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -288;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_HCSR04
			#ifdef CONFIG_ONEWIRE
		case 0x132:	// onewire id 38, type OneWireConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_onewire.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -289;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 8);
			break;
			#endif // CONFIG_ONEWIRE
			#ifdef CONFIG_SX1276
		case 0x13a:	// sx1276 id 39, type SX1276Config, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_sx1276.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -290;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 9);
			break;
			#endif // CONFIG_SX1276
			#ifdef CONFIG_IOEXTENDERS
		case 0x142:	// iocluster id 40, type GpioCluster, coding byte[]
			m_iocluster.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_iocluster.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -291;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_IOEXTENDERS
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -292;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -293;
	return a-(const uint8_t *)b;
}

ssize_t HardwareConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has magic?
	if (0 != (p_validbits & ((uint16_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		if (5 > (e-a))
			return -294;
		*a++ = 0x5;
		if ((e-a) < 4)
			return -295;
		write_u32(a,(uint32_t)m_magic);
		a += 4;
	}
	// has system?
	if (0 != (p_validbits & ((uint16_t)1U << 1))) {
		// 'system': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -296;
		*a++ = 0xa;
		ssize_t system_ws = m_system.calcSize();
		n = write_varint(a,e-a,system_ws);
		a += n;
		if ((n <= 0) || (system_ws > (e-a)))
			return -297;
		n = m_system.toMemory(a,e-a);
		a += n;
		assert(n == system_ws);
	}
	// 'uart' is unused. Therefore no data will be written.
	// has adc?
	if (0 != (p_validbits & ((uint16_t)1U << 2))) {
		// 'adc': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -298;
		*a++ = 0x22;
		ssize_t adc_ws = m_adc.calcSize();
		n = write_varint(a,e-a,adc_ws);
		a += n;
		if ((n <= 0) || (adc_ws > (e-a)))
			return -299;
		n = m_adc.toMemory(a,e-a);
		a += n;
		assert(n == adc_ws);
	}
	#ifdef CONFIG_TOUCHPAD
	// 'touchpad' is unused. Therefore no data will be written.
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	// 'tp_channel' is unused. Therefore no data will be written.
	#endif // CONFIG_TOUCHPAD
	for (const auto &x : m_gpios) {
		// 'gpios': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -300;
		*a++ = 0x3a;
		ssize_t gpios_ws = x.calcSize();
		n = write_varint(a,e-a,gpios_ws);
		a += n;
		if ((n <= 0) || (gpios_ws > (e-a)))
			return -301;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == gpios_ws);
	}
	#ifdef CONFIG_SPI
	for (const auto &x : m_spibus) {
		// 'spibus': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -302;
		*a++ = 0x42;
		ssize_t spibus_ws = x.calcSize();
		n = write_varint(a,e-a,spibus_ws);
		a += n;
		if ((n <= 0) || (spibus_ws > (e-a)))
			return -303;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == spibus_ws);
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	for (const auto &x : m_button) {
		// 'button': id=16, encoding=lenpfx, tag=0x82
		if (2 > (e-a))
			return -304;
		*a++ = 0x82;
		*a++ = 0x1;
		ssize_t button_ws = x.calcSize();
		n = write_varint(a,e-a,button_ws);
		a += n;
		if ((n <= 0) || (button_ws > (e-a)))
			return -305;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == button_ws);
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	for (const auto &x : m_relay) {
		// 'relay': id=17, encoding=lenpfx, tag=0x8a
		if (2 > (e-a))
			return -306;
		*a++ = 0x8a;
		*a++ = 0x1;
		ssize_t relay_ws = x.calcSize();
		n = write_varint(a,e-a,relay_ws);
		a += n;
		if ((n <= 0) || (relay_ws > (e-a)))
			return -307;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == relay_ws);
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	for (const auto &x : m_led) {
		// 'led': id=18, encoding=lenpfx, tag=0x92
		if (2 > (e-a))
			return -308;
		*a++ = 0x92;
		*a++ = 0x1;
		ssize_t led_ws = x.calcSize();
		n = write_varint(a,e-a,led_ws);
		a += n;
		if ((n <= 0) || (led_ws > (e-a)))
			return -309;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == led_ws);
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	// has buzzer?
	if (0 != (p_validbits & ((uint16_t)1U << 3))) {
		// 'buzzer': id=19, encoding=lenpfx, tag=0x9a
		if (2 > (e-a))
			return -310;
		*a++ = 0x9a;
		*a++ = 0x1;
		ssize_t buzzer_ws = m_buzzer.calcSize();
		n = write_varint(a,e-a,buzzer_ws);
		a += n;
		if ((n <= 0) || (buzzer_ws > (e-a)))
			return -311;
		n = m_buzzer.toMemory(a,e-a);
		a += n;
		assert(n == buzzer_ws);
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	// has hlw8012?
	if (0 != (p_validbits & ((uint16_t)1U << 4))) {
		// 'hlw8012': id=20, encoding=lenpfx, tag=0xa2
		if (2 > (e-a))
			return -312;
		*a++ = 0xa2;
		*a++ = 0x1;
		ssize_t hlw8012_ws = m_hlw8012.calcSize();
		n = write_varint(a,e-a,hlw8012_ws);
		a += n;
		if ((n <= 0) || (hlw8012_ws > (e-a)))
			return -313;
		n = m_hlw8012.toMemory(a,e-a);
		a += n;
		assert(n == hlw8012_ws);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	// has max7219?
	if (0 != (p_validbits & ((uint16_t)1U << 5))) {
		// 'max7219': id=32, encoding=lenpfx, tag=0x102
		if (2 > (e-a))
			return -314;
		*a++ = 0x82;
		*a++ = 0x2;
		ssize_t max7219_ws = m_max7219.calcSize();
		n = write_varint(a,e-a,max7219_ws);
		a += n;
		if ((n <= 0) || (max7219_ws > (e-a)))
			return -315;
		n = m_max7219.toMemory(a,e-a);
		a += n;
		assert(n == max7219_ws);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	// has tlc5947?
	if (0 != (p_validbits & ((uint16_t)1U << 6))) {
		// 'tlc5947': id=33, encoding=lenpfx, tag=0x10a
		if (2 > (e-a))
			return -316;
		*a++ = 0x8a;
		*a++ = 0x2;
		ssize_t tlc5947_ws = m_tlc5947.calcSize();
		n = write_varint(a,e-a,tlc5947_ws);
		a += n;
		if ((n <= 0) || (tlc5947_ws > (e-a)))
			return -317;
		n = m_tlc5947.toMemory(a,e-a);
		a += n;
		assert(n == tlc5947_ws);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	for (const auto &x : m_ws2812b) {
		// 'ws2812b': id=34, encoding=lenpfx, tag=0x112
		if (2 > (e-a))
			return -318;
		*a++ = 0x92;
		*a++ = 0x2;
		ssize_t ws2812b_ws = x.calcSize();
		n = write_varint(a,e-a,ws2812b_ws);
		a += n;
		if ((n <= 0) || (ws2812b_ws > (e-a)))
			return -319;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == ws2812b_ws);
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	// has dht?
	if (0 != (p_validbits & ((uint16_t)1U << 7))) {
		// 'dht': id=35, encoding=lenpfx, tag=0x11a
		if (2 > (e-a))
			return -320;
		*a++ = 0x9a;
		*a++ = 0x2;
		ssize_t dht_ws = m_dht.calcSize();
		n = write_varint(a,e-a,dht_ws);
		a += n;
		if ((n <= 0) || (dht_ws > (e-a)))
			return -321;
		n = m_dht.toMemory(a,e-a);
		a += n;
		assert(n == dht_ws);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	for (const auto &x : m_i2c) {
		// 'i2c': id=36, encoding=lenpfx, tag=0x122
		if (2 > (e-a))
			return -322;
		*a++ = 0xa2;
		*a++ = 0x2;
		ssize_t i2c_ws = x.calcSize();
		n = write_varint(a,e-a,i2c_ws);
		a += n;
		if ((n <= 0) || (i2c_ws > (e-a)))
			return -323;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == i2c_ws);
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	for (const auto &x : m_hcsr04) {
		// 'hcsr04': id=37, encoding=lenpfx, tag=0x12a
		if (2 > (e-a))
			return -324;
		*a++ = 0xaa;
		*a++ = 0x2;
		ssize_t hcsr04_ws = x.calcSize();
		n = write_varint(a,e-a,hcsr04_ws);
		a += n;
		if ((n <= 0) || (hcsr04_ws > (e-a)))
			return -325;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == hcsr04_ws);
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	// has onewire?
	if (0 != (p_validbits & ((uint16_t)1U << 8))) {
		// 'onewire': id=38, encoding=lenpfx, tag=0x132
		if (2 > (e-a))
			return -326;
		*a++ = 0xb2;
		*a++ = 0x2;
		ssize_t onewire_ws = m_onewire.calcSize();
		n = write_varint(a,e-a,onewire_ws);
		a += n;
		if ((n <= 0) || (onewire_ws > (e-a)))
			return -327;
		n = m_onewire.toMemory(a,e-a);
		a += n;
		assert(n == onewire_ws);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	// has sx1276?
	if (0 != (p_validbits & ((uint16_t)1U << 9))) {
		// 'sx1276': id=39, encoding=lenpfx, tag=0x13a
		if (2 > (e-a))
			return -328;
		*a++ = 0xba;
		*a++ = 0x2;
		ssize_t sx1276_ws = m_sx1276.calcSize();
		n = write_varint(a,e-a,sx1276_ws);
		a += n;
		if ((n <= 0) || (sx1276_ws > (e-a)))
			return -329;
		n = m_sx1276.toMemory(a,e-a);
		a += n;
		assert(n == sx1276_ws);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	for (const auto &x : m_iocluster) {
		// 'iocluster': id=40, encoding=lenpfx, tag=0x142
		if (2 > (e-a))
			return -330;
		*a++ = 0xc2;
		*a++ = 0x2;
		ssize_t iocluster_ws = x.calcSize();
		n = write_varint(a,e-a,iocluster_ws);
		a += n;
		if ((n <= 0) || (iocluster_ws > (e-a)))
			return -331;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == iocluster_ws);
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	// 'display' is unused. Therefore no data will be written.
	#endif // CONFIG_DISPLAY
	assert(a <= e);
	return a-b;
}

void HardwareConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_magic()) {
		fsep = json_indent(json,indLvl,fsep,"magic");
		to_decstr(json,m_magic);
	}
	if (has_system()) {
		fsep = json_indent(json,indLvl,fsep,"system");
		m_system.toJSON(json,indLvl);
	}
	if (has_adc()) {
		fsep = json_indent(json,indLvl,fsep,"adc");
		m_adc.toJSON(json,indLvl);
	}
	if (size_t s = m_gpios.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"gpios\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_gpios[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_SPI
	if (size_t s = m_spibus.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"spibus\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_spibus[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (size_t s = m_button.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"button\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_button[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (size_t s = m_relay.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"relay\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_relay[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (size_t s = m_led.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"led\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_led[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (has_buzzer()) {
		fsep = json_indent(json,indLvl,fsep,"buzzer");
		m_buzzer.toJSON(json,indLvl);
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (has_hlw8012()) {
		fsep = json_indent(json,indLvl,fsep,"hlw8012");
		m_hlw8012.toJSON(json,indLvl);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (has_max7219()) {
		fsep = json_indent(json,indLvl,fsep,"max7219");
		m_max7219.toJSON(json,indLvl);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (has_tlc5947()) {
		fsep = json_indent(json,indLvl,fsep,"tlc5947");
		m_tlc5947.toJSON(json,indLvl);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (size_t s = m_ws2812b.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"ws2812b\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_ws2812b[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (has_dht()) {
		fsep = json_indent(json,indLvl,fsep,"dht");
		m_dht.toJSON(json,indLvl);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (size_t s = m_i2c.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"i2c\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_i2c[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (size_t s = m_hcsr04.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"hcsr04\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_hcsr04[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (has_onewire()) {
		fsep = json_indent(json,indLvl,fsep,"onewire");
		m_onewire.toJSON(json,indLvl);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (has_sx1276()) {
		fsep = json_indent(json,indLvl,fsep,"sx1276");
		m_sx1276.toJSON(json,indLvl);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (size_t s = m_iocluster.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"iocluster\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_iocluster[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_IOEXTENDERS
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t HardwareConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed32 magic, id 0
	if (has_magic()) {
		r += 5;
	}
	// optional SystemConfig system, id 1
	if (has_system()) {
		size_t system_s = m_system.calcSize();
		r += system_s + wiresize(system_s) + 1 /* tag(system) 0x8 */;
	}
	// unused repeated UartConfig uart, id 3
	// optional AdcConfig adc, id 4
	if (has_adc()) {
		size_t adc_s = m_adc.calcSize();
		r += adc_s + wiresize(adc_s) + 1 /* tag(adc) 0x20 */;
	}
	#ifdef CONFIG_TOUCHPAD
	// unused optional TouchpadConfig touchpad, id 5
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	// unused repeated TouchChannelConfig tp_channel, id 6
	#endif // CONFIG_TOUCHPAD
	// repeated GpioConfig gpios, id 7
	// repeated message gpios
	for (size_t x = 0, y = m_gpios.size(); x < y; ++x) {
		size_t s = m_gpios[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(gpios) 0x38 */;
	}
	#ifdef CONFIG_SPI
	// repeated SpiBusConfig spibus, id 8
	// repeated message spibus
	for (size_t x = 0, y = m_spibus.size(); x < y; ++x) {
		size_t s = m_spibus[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(spibus) 0x40 */;
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	// repeated ButtonConfig button, id 16
	// repeated message button
	for (size_t x = 0, y = m_button.size(); x < y; ++x) {
		size_t s = m_button[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(button) 0x80 */;
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	// repeated RelayConfig relay, id 17
	// repeated message relay
	for (size_t x = 0, y = m_relay.size(); x < y; ++x) {
		size_t s = m_relay[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(relay) 0x88 */;
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	// repeated LedConfig led, id 18
	// repeated message led
	for (size_t x = 0, y = m_led.size(); x < y; ++x) {
		size_t s = m_led[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(led) 0x90 */;
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	// optional BuzzerConfig buzzer, id 19
	if (has_buzzer()) {
		size_t buzzer_s = m_buzzer.calcSize();
		r += buzzer_s + wiresize(buzzer_s) + 2 /* tag(buzzer) 0x98 */;
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	// optional Hlw8012Config hlw8012, id 20
	if (has_hlw8012()) {
		size_t hlw8012_s = m_hlw8012.calcSize();
		r += hlw8012_s + wiresize(hlw8012_s) + 2 /* tag(hlw8012) 0xa0 */;
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	// optional Max7219Config max7219, id 32
	if (has_max7219()) {
		size_t max7219_s = m_max7219.calcSize();
		r += max7219_s + wiresize(max7219_s) + 2 /* tag(max7219) 0x100 */;
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	// optional Tlc5947Config tlc5947, id 33
	if (has_tlc5947()) {
		size_t tlc5947_s = m_tlc5947.calcSize();
		r += tlc5947_s + wiresize(tlc5947_s) + 2 /* tag(tlc5947) 0x108 */;
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	// repeated Ws2812bConfig ws2812b, id 34
	// repeated message ws2812b
	for (size_t x = 0, y = m_ws2812b.size(); x < y; ++x) {
		size_t s = m_ws2812b[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(ws2812b) 0x110 */;
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	// optional DhtConfig dht, id 35
	if (has_dht()) {
		size_t dht_s = m_dht.calcSize();
		r += dht_s + wiresize(dht_s) + 2 /* tag(dht) 0x118 */;
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	// repeated I2CConfig i2c, id 36
	// repeated message i2c
	for (size_t x = 0, y = m_i2c.size(); x < y; ++x) {
		size_t s = m_i2c[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(i2c) 0x120 */;
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	// repeated HcSr04Config hcsr04, id 37
	// repeated message hcsr04
	for (size_t x = 0, y = m_hcsr04.size(); x < y; ++x) {
		size_t s = m_hcsr04[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(hcsr04) 0x128 */;
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	// optional OneWireConfig onewire, id 38
	if (has_onewire()) {
		size_t onewire_s = m_onewire.calcSize();
		r += onewire_s + wiresize(onewire_s) + 2 /* tag(onewire) 0x130 */;
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	// optional SX1276Config sx1276, id 39
	if (has_sx1276()) {
		size_t sx1276_s = m_sx1276.calcSize();
		r += sx1276_s + wiresize(sx1276_s) + 2 /* tag(sx1276) 0x138 */;
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	// repeated GpioCluster iocluster, id 40
	// repeated message iocluster
	for (size_t x = 0, y = m_iocluster.size(); x < y; ++x) {
		size_t s = m_iocluster[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(iocluster) 0x140 */;
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	// unused optional DisplayConfig display, id 50
	#endif // CONFIG_DISPLAY
	return r;
}

bool HardwareConfig::operator == (const HardwareConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_magic() && (!(m_magic == r.m_magic)))
		return false;
	if (has_system() && (!(m_system == r.m_system)))
		return false;
	if (has_adc() && (!(m_adc == r.m_adc)))
		return false;
	if (!(m_gpios == r.m_gpios))
		return false;
	#ifdef CONFIG_SPI
	if (!(m_spibus == r.m_spibus))
		return false;
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (!(m_button == r.m_button))
		return false;
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (!(m_relay == r.m_relay))
		return false;
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (!(m_led == r.m_led))
		return false;
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (has_buzzer() && (!(m_buzzer == r.m_buzzer)))
		return false;
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (has_hlw8012() && (!(m_hlw8012 == r.m_hlw8012)))
		return false;
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (has_max7219() && (!(m_max7219 == r.m_max7219)))
		return false;
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (has_tlc5947() && (!(m_tlc5947 == r.m_tlc5947)))
		return false;
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (!(m_ws2812b == r.m_ws2812b))
		return false;
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (has_dht() && (!(m_dht == r.m_dht)))
		return false;
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (!(m_i2c == r.m_i2c))
		return false;
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (!(m_hcsr04 == r.m_hcsr04))
		return false;
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (has_onewire() && (!(m_onewire == r.m_onewire)))
		return false;
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (has_sx1276() && (!(m_sx1276 == r.m_sx1276)))
		return false;
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (!(m_iocluster == r.m_iocluster))
		return false;
	#endif // CONFIG_IOEXTENDERS
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int HardwareConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"magic")) {
		if (value == 0) {
			clear_magic();
			return 0;
		}
		int r = parse_ascii_u32(&m_magic,value);
		if (r > 0)
			p_validbits |= ((uint16_t)1U << 0);
		return r;
	}
	if (0 == memcmp(name,"system",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_system();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 1);
			return m_system.setByName(name+7,value);
		}
	}
	if (0 == memcmp(name,"adc",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_adc();
			return 0;
		} else if (name[3] == '.') {
			p_validbits |= ((uint16_t)1U << 2);
			return m_adc.setByName(name+4,value);
		}
	}
	if (0 == memcmp(name,"gpios",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_gpios();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_gpios.size();
				m_gpios.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -332;
				if (m_gpios.size() <= x)
					return -333;
				if ((idxe[1] == 0) && (value == 0)) {
					m_gpios.erase(m_gpios.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -334;
			return m_gpios[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_SPI
	if (0 == memcmp(name,"spibus",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_spibus();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_spibus.size();
				m_spibus.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -335;
				if (m_spibus.size() <= x)
					return -336;
				if ((idxe[1] == 0) && (value == 0)) {
					m_spibus.erase(m_spibus.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -337;
			return m_spibus[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (0 == memcmp(name,"button",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_button();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_button.size();
				m_button.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -338;
				if (m_button.size() <= x)
					return -339;
				if ((idxe[1] == 0) && (value == 0)) {
					m_button.erase(m_button.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -340;
			return m_button[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (0 == memcmp(name,"relay",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_relay();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_relay.size();
				m_relay.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -341;
				if (m_relay.size() <= x)
					return -342;
				if ((idxe[1] == 0) && (value == 0)) {
					m_relay.erase(m_relay.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -343;
			return m_relay[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (0 == memcmp(name,"led",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_led();
			return 0;
		} else if (name[3] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[4] == '+') && (name[5] == ']')) {
				x = m_led.size();
				m_led.resize(x+1);
				idxe = (char*)(name + 5);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+4,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+4)))
					return -344;
				if (m_led.size() <= x)
					return -345;
				if ((idxe[1] == 0) && (value == 0)) {
					m_led.erase(m_led.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -346;
			return m_led[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (0 == memcmp(name,"buzzer",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_buzzer();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 3);
			return m_buzzer.setByName(name+7,value);
		}
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (0 == memcmp(name,"hlw8012",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_hlw8012();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 4);
			return m_hlw8012.setByName(name+8,value);
		}
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (0 == memcmp(name,"max7219",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_max7219();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 5);
			return m_max7219.setByName(name+8,value);
		}
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (0 == memcmp(name,"tlc5947",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_tlc5947();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 6);
			return m_tlc5947.setByName(name+8,value);
		}
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (0 == memcmp(name,"ws2812b",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_ws2812b();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_ws2812b.size();
				m_ws2812b.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -347;
				if (m_ws2812b.size() <= x)
					return -348;
				if ((idxe[1] == 0) && (value == 0)) {
					m_ws2812b.erase(m_ws2812b.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -349;
			return m_ws2812b[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (0 == memcmp(name,"dht",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_dht();
			return 0;
		} else if (name[3] == '.') {
			p_validbits |= ((uint16_t)1U << 7);
			return m_dht.setByName(name+4,value);
		}
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (0 == memcmp(name,"i2c",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_i2c();
			return 0;
		} else if (name[3] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[4] == '+') && (name[5] == ']')) {
				x = m_i2c.size();
				m_i2c.resize(x+1);
				idxe = (char*)(name + 5);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+4,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+4)))
					return -350;
				if (m_i2c.size() <= x)
					return -351;
				if ((idxe[1] == 0) && (value == 0)) {
					m_i2c.erase(m_i2c.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -352;
			return m_i2c[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (0 == memcmp(name,"hcsr04",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_hcsr04();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_hcsr04.size();
				m_hcsr04.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -353;
				if (m_hcsr04.size() <= x)
					return -354;
				if ((idxe[1] == 0) && (value == 0)) {
					m_hcsr04.erase(m_hcsr04.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -355;
			return m_hcsr04[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (0 == memcmp(name,"onewire",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_onewire();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 8);
			return m_onewire.setByName(name+8,value);
		}
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (0 == memcmp(name,"sx1276",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_sx1276();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 9);
			return m_sx1276.setByName(name+7,value);
		}
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (0 == memcmp(name,"iocluster",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_iocluster();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_iocluster.size();
				m_iocluster.resize(x+1);
				idxe = (char*)(name + 11);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+10)))
					return -356;
				if (m_iocluster.size() <= x)
					return -357;
				if ((idxe[1] == 0) && (value == 0)) {
					m_iocluster.erase(m_iocluster.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -358;
			return m_iocluster[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_IOEXTENDERS
	return -359;
}

