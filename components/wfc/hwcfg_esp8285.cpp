/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: P2304.4 (hg:460/3a4ad1ac493b)
 * WFC is Copyright 2015-2023, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : hwcfg.wfc
 * Copyright: 2018-2023
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2024-01-12, 11:32:19 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from esp8285:
 * BaseClass       : ""
 * getMember       : ""
 * 
 * options from esp8266:
 * Optimize        : "size"
 * 
 * options from esp:
 * bytestype       : "estring"
 * intsize         : 32
 * SortMembers     : "size"
 * stringtype      : "estring"
 * toASCII         : "toASCII"
 * toSink          : ""
 * toString        : ""
 * toWire          : ""
 * varintbits      : 32
 * 
 * options from common:
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bool      : "ascii_bool"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * calcSize        : "calcSize"
 * cfgdefs         : ""
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * copyright       : ""
 * email           : ""
 * endian          : "unknown"
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * UnknownField    : "skip"
 * wireput         : ""
 * wiresize        : ""
 * 
 * disabled flags from esp8266:
 * 	withUnequal
 * enabled flags from esp:
 * 	enumnames, withEqual
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux
 */

#include <map>
#include <stdlib.h>
#include <string.h>
#include "hwcfg_esp8285.h"

#include "wfccore_esp8285.h"

#if !defined(WFC_ENDIAN) || (WFC_ENDIAN != 0)
#error wfc: incompatible settings concerning endian
#endif


#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
struct cstr_less {
	bool operator () (const char *l, const char *r) const
	{ return strcmp(l,r) < 0; }
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *pull_mode_e_names[] = {
	"pull_dir",
	"pull_down",
	"pull_en",
	"pull_none",
	"pull_up",
};

static pull_mode_e pull_mode_e_values[] = {
	pull_dir,
	pull_down,
	pull_en,
	pull_none,
	pull_up,
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_pull_mode_e(pull_mode_e *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,pull_mode_e, cstr_less> namesmap = {
		{ "pull_dir", pull_dir},
		{ "pull_down", pull_down},
		{ "pull_en", pull_en},
		{ "pull_none", pull_none},
		{ "pull_up", pull_up},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (pull_mode_e)ull;
		return e-s;
	}
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	auto i = namesmap.find(s);
	if (i == namesmap.end())
		return 0;
	*v = i->second;
	return strlen(s);
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(pull_mode_e_names)/sizeof(pull_mode_e_names[0]); ++i) {
			if (0 == strcmp(pull_mode_e_names[i],s)) {
				*v = pull_mode_e_values[i];
			return strlen(s);
		}
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *pull_mode_e_str(pull_mode_e e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case pull_none:
		return "pull_none";
	case pull_en:
		// alias pull_down
		return "pull_en";
	case pull_dir:
		return "pull_dir";
	case pull_up:
		return "pull_up";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	for (size_t i = 0; i < sizeof(pull_mode_e_values)/sizeof(pull_mode_e_values[0]); ++i) {
		if (e == pull_mode_e_values[i])
			return pull_mode_e_names[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *dht_model_t_names[] = {
	"AM2301",
	"AM2302",
	"DHT11",
	"DHT21",
	"DHT22",
	"DHT_NONE",
	"RHT03",
};

static dht_model_t dht_model_t_values[] = {
	AM2301,
	AM2302,
	DHT11,
	DHT21,
	DHT22,
	DHT_NONE,
	RHT03,
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_dht_model_t(dht_model_t *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,dht_model_t, cstr_less> namesmap = {
		{ "AM2301", AM2301},
		{ "AM2302", AM2302},
		{ "DHT11", DHT11},
		{ "DHT21", DHT21},
		{ "DHT22", DHT22},
		{ "DHT_NONE", DHT_NONE},
		{ "RHT03", RHT03},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (dht_model_t)ull;
		return e-s;
	}
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	auto i = namesmap.find(s);
	if (i == namesmap.end())
		return 0;
	*v = i->second;
	return strlen(s);
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(dht_model_t_names)/sizeof(dht_model_t_names[0]); ++i) {
			if (0 == strcmp(dht_model_t_names[i],s)) {
				*v = dht_model_t_values[i];
			return strlen(s);
		}
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *dht_model_t_str(dht_model_t e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case DHT_NONE:
		return "DHT_NONE";
	case RHT03:
		return "RHT03";
	case DHT11:
		return "DHT11";
	case DHT21:
		return "DHT21";
	case DHT22:
		return "DHT22";
	case AM2301:
		return "AM2301";
	case AM2302:
		return "AM2302";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	for (size_t i = 0; i < sizeof(dht_model_t_values)/sizeof(dht_model_t_values[0]); ++i) {
		if (e == dht_model_t_values[i])
			return dht_model_t_names[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *i2cdrv_t_names[] = {
	"i2cdrv_ads1013",
	"i2cdrv_ads1014",
	"i2cdrv_ads1015",
	"i2cdrv_ads1113",
	"i2cdrv_ads1114",
	"i2cdrv_ads1115",
	"i2cdrv_ht16k33",
	"i2cdrv_ina219",
	"i2cdrv_invalid",
	"i2cdrv_mcp2300x",
	"i2cdrv_mcp2301x",
	"i2cdrv_pca9685",
	"i2cdrv_pca9685_npn",
	"i2cdrv_pca9685_pnp",
	"i2cdrv_pca9685_xclk",
	"i2cdrv_pca9685_xclk_npn",
	"i2cdrv_pca9685_xclk_pnp",
	"i2cdrv_pcf8574",
	"i2cdrv_sh1106",
	"i2cdrv_si7021",
	"i2cdrv_ssd1306",
	"i2cdrv_tca9555",
};

static i2cdrv_t i2cdrv_t_values[] = {
	i2cdrv_ads1013,
	i2cdrv_ads1014,
	i2cdrv_ads1015,
	i2cdrv_ads1113,
	i2cdrv_ads1114,
	i2cdrv_ads1115,
	i2cdrv_ht16k33,
	i2cdrv_ina219,
	i2cdrv_invalid,
	i2cdrv_mcp2300x,
	i2cdrv_mcp2301x,
	i2cdrv_pca9685,
	i2cdrv_pca9685_npn,
	i2cdrv_pca9685_pnp,
	i2cdrv_pca9685_xclk,
	i2cdrv_pca9685_xclk_npn,
	i2cdrv_pca9685_xclk_pnp,
	i2cdrv_pcf8574,
	i2cdrv_sh1106,
	i2cdrv_si7021,
	i2cdrv_ssd1306,
	i2cdrv_tca9555,
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_i2cdrv_t(i2cdrv_t *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,i2cdrv_t, cstr_less> namesmap = {
		{ "i2cdrv_ads1013", i2cdrv_ads1013},
		{ "i2cdrv_ads1014", i2cdrv_ads1014},
		{ "i2cdrv_ads1015", i2cdrv_ads1015},
		{ "i2cdrv_ads1113", i2cdrv_ads1113},
		{ "i2cdrv_ads1114", i2cdrv_ads1114},
		{ "i2cdrv_ads1115", i2cdrv_ads1115},
		{ "i2cdrv_ht16k33", i2cdrv_ht16k33},
		{ "i2cdrv_ina219", i2cdrv_ina219},
		{ "i2cdrv_invalid", i2cdrv_invalid},
		{ "i2cdrv_mcp2300x", i2cdrv_mcp2300x},
		{ "i2cdrv_mcp2301x", i2cdrv_mcp2301x},
		{ "i2cdrv_pca9685", i2cdrv_pca9685},
		{ "i2cdrv_pca9685_npn", i2cdrv_pca9685_npn},
		{ "i2cdrv_pca9685_pnp", i2cdrv_pca9685_pnp},
		{ "i2cdrv_pca9685_xclk", i2cdrv_pca9685_xclk},
		{ "i2cdrv_pca9685_xclk_npn", i2cdrv_pca9685_xclk_npn},
		{ "i2cdrv_pca9685_xclk_pnp", i2cdrv_pca9685_xclk_pnp},
		{ "i2cdrv_pcf8574", i2cdrv_pcf8574},
		{ "i2cdrv_sh1106", i2cdrv_sh1106},
		{ "i2cdrv_si7021", i2cdrv_si7021},
		{ "i2cdrv_ssd1306", i2cdrv_ssd1306},
		{ "i2cdrv_tca9555", i2cdrv_tca9555},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (i2cdrv_t)ull;
		return e-s;
	}
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	auto i = namesmap.find(s);
	if (i == namesmap.end())
		return 0;
	*v = i->second;
	return strlen(s);
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(i2cdrv_t_names)/sizeof(i2cdrv_t_names[0]); ++i) {
			if (0 == strcmp(i2cdrv_t_names[i],s)) {
				*v = i2cdrv_t_values[i];
			return strlen(s);
		}
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *i2cdrv_t_str(i2cdrv_t e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case i2cdrv_invalid:
		return "i2cdrv_invalid";
	case i2cdrv_pcf8574:
		return "i2cdrv_pcf8574";
	case i2cdrv_mcp2300x:
		return "i2cdrv_mcp2300x";
	case i2cdrv_mcp2301x:
		return "i2cdrv_mcp2301x";
	case i2cdrv_pca9685:
		return "i2cdrv_pca9685";
	case i2cdrv_pca9685_npn:
		return "i2cdrv_pca9685_npn";
	case i2cdrv_pca9685_pnp:
		return "i2cdrv_pca9685_pnp";
	case i2cdrv_pca9685_xclk:
		return "i2cdrv_pca9685_xclk";
	case i2cdrv_pca9685_xclk_npn:
		return "i2cdrv_pca9685_xclk_npn";
	case i2cdrv_pca9685_xclk_pnp:
		return "i2cdrv_pca9685_xclk_pnp";
	case i2cdrv_ht16k33:
		return "i2cdrv_ht16k33";
	case i2cdrv_ina219:
		return "i2cdrv_ina219";
	case i2cdrv_si7021:
		return "i2cdrv_si7021";
	case i2cdrv_tca9555:
		return "i2cdrv_tca9555";
	case i2cdrv_ssd1306:
		return "i2cdrv_ssd1306";
	case i2cdrv_sh1106:
		return "i2cdrv_sh1106";
	case i2cdrv_ads1013:
		return "i2cdrv_ads1013";
	case i2cdrv_ads1014:
		return "i2cdrv_ads1014";
	case i2cdrv_ads1015:
		return "i2cdrv_ads1015";
	case i2cdrv_ads1113:
		return "i2cdrv_ads1113";
	case i2cdrv_ads1114:
		return "i2cdrv_ads1114";
	case i2cdrv_ads1115:
		return "i2cdrv_ads1115";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	for (size_t i = 0; i < sizeof(i2cdrv_t_values)/sizeof(i2cdrv_t_values[0]); ++i) {
		if (e == i2cdrv_t_values[i])
			return i2cdrv_t_names[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *disp_t_names[] = {
	"dt_ili9341",
	"dt_none",
	"dt_pcf8574_hd44780u",
	"dt_sd_14seg",
	"dt_sd_7seg",
	"dt_sh1106",
	"dt_ssd1306",
	"dt_ssd1309",
};

static disp_t disp_t_values[] = {
	dt_ili9341,
	dt_none,
	dt_pcf8574_hd44780u,
	dt_sd_14seg,
	dt_sd_7seg,
	dt_sh1106,
	dt_ssd1306,
	dt_ssd1309,
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_disp_t(disp_t *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,disp_t, cstr_less> namesmap = {
		{ "dt_ili9341", dt_ili9341},
		{ "dt_none", dt_none},
		{ "dt_pcf8574_hd44780u", dt_pcf8574_hd44780u},
		{ "dt_sd_14seg", dt_sd_14seg},
		{ "dt_sd_7seg", dt_sd_7seg},
		{ "dt_sh1106", dt_sh1106},
		{ "dt_ssd1306", dt_ssd1306},
		{ "dt_ssd1309", dt_ssd1309},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (disp_t)ull;
		return e-s;
	}
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	auto i = namesmap.find(s);
	if (i == namesmap.end())
		return 0;
	*v = i->second;
	return strlen(s);
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(disp_t_names)/sizeof(disp_t_names[0]); ++i) {
			if (0 == strcmp(disp_t_names[i],s)) {
				*v = disp_t_values[i];
			return strlen(s);
		}
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *disp_t_str(disp_t e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case dt_none:
		return "dt_none";
	case dt_sd_7seg:
		return "dt_sd_7seg";
	case dt_sd_14seg:
		return "dt_sd_14seg";
	case dt_pcf8574_hd44780u:
		return "dt_pcf8574_hd44780u";
	case dt_ssd1306:
		return "dt_ssd1306";
	case dt_ssd1309:
		return "dt_ssd1309";
	case dt_sh1106:
		return "dt_sh1106";
	case dt_ili9341:
		return "dt_ili9341";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	for (size_t i = 0; i < sizeof(disp_t_values)/sizeof(disp_t_values[0]); ++i) {
		if (e == disp_t_values[i])
			return disp_t_names[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
static const char *spidrv_t_names[] = {
	"spidrv_ili9341",
	"spidrv_invalid",
	"spidrv_sdcard",
	"spidrv_ssd1309",
	"spidrv_sx1276",
	"spidrv_xpt2046",
};

static spidrv_t spidrv_t_values[] = {
	spidrv_ili9341,
	spidrv_invalid,
	spidrv_sdcard,
	spidrv_ssd1309,
	spidrv_sx1276,
	spidrv_xpt2046,
};
#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB

size_t parse_ascii_spidrv_t(spidrv_t *v, const char *s)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	static std::map<const char *,spidrv_t, cstr_less> namesmap = {
		{ "spidrv_ili9341", spidrv_ili9341},
		{ "spidrv_invalid", spidrv_invalid},
		{ "spidrv_sdcard", spidrv_sdcard},
		{ "spidrv_ssd1309", spidrv_ssd1309},
		{ "spidrv_sx1276", spidrv_sx1276},
		{ "spidrv_xpt2046", spidrv_xpt2046},
	};
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	char *e;
	unsigned long long ull = strtoull(s,&e,0);
	if (e != s) {
		*v = (spidrv_t)ull;
		return e-s;
	}
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	auto i = namesmap.find(s);
	if (i == namesmap.end())
		return 0;
	*v = i->second;
	return strlen(s);
	#else // !!CONFIG_ESPTOOLPY_FLASHSIZE_1MB
		for (size_t i = 0; i < sizeof(spidrv_t_names)/sizeof(spidrv_t_names[0]); ++i) {
			if (0 == strcmp(spidrv_t_names[i],s)) {
				*v = spidrv_t_values[i];
			return strlen(s);
		}
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

const char *spidrv_t_str(spidrv_t e)
{
	#ifndef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	switch (e) {
	default:
		return 0;
	case spidrv_invalid:
		return "spidrv_invalid";
	case spidrv_sx1276:
		return "spidrv_sx1276";
	case spidrv_ssd1309:
		return "spidrv_ssd1309";
	case spidrv_ili9341:
		return "spidrv_ili9341";
	case spidrv_xpt2046:
		return "spidrv_xpt2046";
	case spidrv_sdcard:
		return "spidrv_sdcard";
	}
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	#ifdef CONFIG_ESPTOOLPY_FLASHSIZE_1MB
	for (size_t i = 0; i < sizeof(spidrv_t_values)/sizeof(spidrv_t_values[0]); ++i) {
		if (e == spidrv_t_values[i])
			return spidrv_t_names[i];
	}
	return 0;
	#endif // !CONFIG_ESPTOOLPY_FLASHSIZE_1MB
}

SystemConfig::SystemConfig()
{
}

void SystemConfig::clear()
{
	m_manufacturer.clear();
	m_board_name.clear();
	m_board_rev.clear();
	m_diag_uart = 0;
	m_console_rx = 0;
	m_console_tx = 0;
	m_model_name.clear();
	m_model_number.clear();
	#ifdef CONFIG_USB_DIAGLOG
	m_usb_diag = true;
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	m_usb_con = true;
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	m_cc1_gpio = -1;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	m_cc2_gpio = -1;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	p_validbits = 0;
}

void SystemConfig::toASCII(stream &o, size_t indent) const
{
	o << "SystemConfig {";
	++indent;
	ascii_string(o,indent,m_manufacturer.data(),m_manufacturer.size(),"manufacturer");
	ascii_string(o,indent,m_board_name.data(),m_board_name.size(),"board_name");
	ascii_string(o,indent,m_board_rev.data(),m_board_rev.size(),"board_rev");
	ascii_numeric(o, indent, "diag_uart", (signed) m_diag_uart);
	ascii_numeric(o, indent, "console_rx", (signed) m_console_rx);
	ascii_numeric(o, indent, "console_tx", (signed) m_console_tx);
	ascii_string(o,indent,m_model_name.data(),m_model_name.size(),"model_name");
	ascii_string(o,indent,m_model_number.data(),m_model_number.size(),"model_number");
	#ifdef CONFIG_USB_DIAGLOG
	ascii_bool(o, indent, "usb_diag", m_usb_diag);
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	ascii_bool(o, indent, "usb_con", m_usb_con);
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	ascii_numeric(o, indent, "cc1_gpio", (signed) m_cc1_gpio);
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	ascii_numeric(o, indent, "cc2_gpio", (signed) m_cc2_gpio);
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SystemConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -1;
		a += x;
		switch (fid) {
		case 0xa:	// manufacturer id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -2;
			}
			m_manufacturer.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x12:	// board_name id 2, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -3;
			}
			m_board_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x1a:	// board_rev id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -4;
			}
			m_board_rev.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x20:	// diag_uart id 4, type int8_t, coding signed varint
			set_diag_uart(varint_sint(ud.u8));
			break;
		case 0x28:	// console_rx id 5, type int8_t, coding signed varint
			set_console_rx(varint_sint(ud.u8));
			break;
		case 0x30:	// console_tx id 6, type int8_t, coding signed varint
			set_console_tx(varint_sint(ud.u8));
			break;
		case 0x3a:	// model_name id 7, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -5;
			}
			m_model_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x42:	// model_number id 8, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -6;
			}
			m_model_number.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
			#ifdef CONFIG_USB_DIAGLOG
		case 0x4b:	// usb_diag id 9, type bool, coding 8bit
			set_usb_diag(ud.u8);
			break;
			#endif // CONFIG_USB_DIAGLOG
			#ifdef CONFIG_USB_CONSOLE
		case 0x53:	// usb_con id 10, type bool, coding 8bit
			set_usb_con(ud.u8);
			break;
			#endif // CONFIG_USB_CONSOLE
			#ifdef CONFIG_ESP_PHY_ENABLE_USB
		case 0x58:	// cc1_gpio id 11, type int8_t, coding signed varint
			set_cc1_gpio(varint_sint(ud.u8));
			break;
			#endif // CONFIG_ESP_PHY_ENABLE_USB
			#ifdef CONFIG_ESP_PHY_ENABLE_USB
		case 0x60:	// cc2_gpio id 12, type int8_t, coding signed varint
			set_cc2_gpio(varint_sint(ud.u8));
			break;
			#endif // CONFIG_ESP_PHY_ENABLE_USB
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -7;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -8;
	return a-(const uint8_t *)b;
}

ssize_t SystemConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has manufacturer?
	if (!m_manufacturer.empty()) {
		// 'manufacturer': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -9;
		*a++ = 0xa;
		n = encode_bytes(m_manufacturer,a,e);
		if (n < 0)
			return -10;
		a += n;
	}
	// has board_name?
	if (!m_board_name.empty()) {
		// 'board_name': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -11;
		*a++ = 0x12;
		n = encode_bytes(m_board_name,a,e);
		if (n < 0)
			return -12;
		a += n;
	}
	// has board_rev?
	if (!m_board_rev.empty()) {
		// 'board_rev': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -13;
		*a++ = 0x1a;
		n = encode_bytes(m_board_rev,a,e);
		if (n < 0)
			return -14;
		a += n;
	}
	// has diag_uart?
	if (m_diag_uart != 0) {
		// 'diag_uart': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -15;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_diag_uart));
		if (n <= 0)
			return -16;
		a += n;
	}
	// has console_rx?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'console_rx': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -17;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_console_rx));
		if (n <= 0)
			return -18;
		a += n;
	}
	// has console_tx?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'console_tx': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -19;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_console_tx));
		if (n <= 0)
			return -20;
		a += n;
	}
	// has model_name?
	if (!m_model_name.empty()) {
		// 'model_name': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -21;
		*a++ = 0x3a;
		n = encode_bytes(m_model_name,a,e);
		if (n < 0)
			return -22;
		a += n;
	}
	// has model_number?
	if (!m_model_number.empty()) {
		// 'model_number': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -23;
		*a++ = 0x42;
		n = encode_bytes(m_model_number,a,e);
		if (n < 0)
			return -24;
		a += n;
	}
	#ifdef CONFIG_USB_DIAGLOG
	// has usb_diag?
	if (m_usb_diag != true) {
		// 'usb_diag': id=9, encoding=8bit, tag=0x4b
		if (2 > (e-a))
			return -25;
		*a++ = 0x4b;
		*a++ = m_usb_diag;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	// has usb_con?
	if (m_usb_con != true) {
		// 'usb_con': id=10, encoding=8bit, tag=0x53
		if (2 > (e-a))
			return -26;
		*a++ = 0x53;
		*a++ = m_usb_con;
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// has cc1_gpio?
	if (m_cc1_gpio != -1) {
		// 'cc1_gpio': id=11, encoding=varint, tag=0x58
		if (a >= e)
			return -27;
		*a++ = 0x58;
		n = write_varint(a,e-a,sint_varint(m_cc1_gpio));
		if (n <= 0)
			return -28;
		a += n;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// has cc2_gpio?
	if (m_cc2_gpio != -1) {
		// 'cc2_gpio': id=12, encoding=varint, tag=0x60
		if (a >= e)
			return -29;
		*a++ = 0x60;
		n = write_varint(a,e-a,sint_varint(m_cc2_gpio));
		if (n <= 0)
			return -30;
		a += n;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	assert(a <= e);
	return a-b;
}

void SystemConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_manufacturer()) {
		fsep = json_indent(json,indLvl,fsep,"manufacturer");
		json_cstr(json,m_manufacturer.c_str());
	}
	if (has_board_name()) {
		fsep = json_indent(json,indLvl,fsep,"board_name");
		json_cstr(json,m_board_name.c_str());
	}
	if (has_board_rev()) {
		fsep = json_indent(json,indLvl,fsep,"board_rev");
		json_cstr(json,m_board_rev.c_str());
	}
	if (has_diag_uart()) {
		fsep = json_indent(json,indLvl,fsep,"diag_uart");
		to_decstr(json,(int) m_diag_uart);
	}
	if (has_console_rx()) {
		fsep = json_indent(json,indLvl,fsep,"console_rx");
		to_decstr(json,(int) m_console_rx);
	}
	if (has_console_tx()) {
		fsep = json_indent(json,indLvl,fsep,"console_tx");
		to_decstr(json,(int) m_console_tx);
	}
	if (has_model_name()) {
		fsep = json_indent(json,indLvl,fsep,"model_name");
		json_cstr(json,m_model_name.c_str());
	}
	if (has_model_number()) {
		fsep = json_indent(json,indLvl,fsep,"model_number");
		json_cstr(json,m_model_number.c_str());
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (has_usb_diag()) {
		fsep = json_indent(json,indLvl,fsep,"usb_diag");
		json << (m_usb_diag ? "true" : "false");
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (has_usb_con()) {
		fsep = json_indent(json,indLvl,fsep,"usb_con");
		json << (m_usb_con ? "true" : "false");
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (has_cc1_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"cc1_gpio");
		to_decstr(json,(int) m_cc1_gpio);
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (has_cc2_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"cc2_gpio");
		to_decstr(json,(int) m_cc2_gpio);
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SystemConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string manufacturer, id 1
	if (has_manufacturer()) {
		size_t manufacturer_s = m_manufacturer.size();
		r += manufacturer_s + wiresize(manufacturer_s) + 1 /* tag(manufacturer) 0x8 */;
	}
	// optional string board_name, id 2
	if (has_board_name()) {
		size_t board_name_s = m_board_name.size();
		r += board_name_s + wiresize(board_name_s) + 1 /* tag(board_name) 0x10 */;
	}
	// optional string board_rev, id 3
	if (has_board_rev()) {
		size_t board_rev_s = m_board_rev.size();
		r += board_rev_s + wiresize(board_rev_s) + 1 /* tag(board_rev) 0x18 */;
	}
	// optional sint8 diag_uart, id 4
	if (has_diag_uart()) {
		r += wiresize_s((varint_t)m_diag_uart) + 1 /* tag(diag_uart) 0x20 */;
	}
	// optional sint8 console_rx, id 5
	if (has_console_rx()) {
		r += wiresize_s((varint_t)m_console_rx) + 1 /* tag(console_rx) 0x28 */;
	}
	// optional sint8 console_tx, id 6
	if (has_console_tx()) {
		r += wiresize_s((varint_t)m_console_tx) + 1 /* tag(console_tx) 0x30 */;
	}
	// optional string model_name, id 7
	if (has_model_name()) {
		size_t model_name_s = m_model_name.size();
		r += model_name_s + wiresize(model_name_s) + 1 /* tag(model_name) 0x38 */;
	}
	// optional string model_number, id 8
	if (has_model_number()) {
		size_t model_number_s = m_model_number.size();
		r += model_number_s + wiresize(model_number_s) + 1 /* tag(model_number) 0x40 */;
	}
	#ifdef CONFIG_USB_DIAGLOG
	// optional bool usb_diag, id 9
	if (has_usb_diag()) {
		r += 2;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	// optional bool usb_con, id 10
	if (has_usb_con()) {
		r += 2;
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// optional sint8 cc1_gpio, id 11
	if (has_cc1_gpio()) {
		r += wiresize_s((varint_t)m_cc1_gpio) + 1 /* tag(cc1_gpio) 0x58 */;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	// optional sint8 cc2_gpio, id 12
	if (has_cc2_gpio()) {
		r += wiresize_s((varint_t)m_cc2_gpio) + 1 /* tag(cc2_gpio) 0x60 */;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	return r;
}

bool SystemConfig::operator == (const SystemConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_manufacturer() && (!(m_manufacturer == r.m_manufacturer)))
		return false;
	if (has_board_name() && (!(m_board_name == r.m_board_name)))
		return false;
	if (has_board_rev() && (!(m_board_rev == r.m_board_rev)))
		return false;
	if (has_diag_uart() && (!(m_diag_uart == r.m_diag_uart)))
		return false;
	if (has_console_rx() && (!(m_console_rx == r.m_console_rx)))
		return false;
	if (has_console_tx() && (!(m_console_tx == r.m_console_tx)))
		return false;
	if (has_model_name() && (!(m_model_name == r.m_model_name)))
		return false;
	if (has_model_number() && (!(m_model_number == r.m_model_number)))
		return false;
	#ifdef CONFIG_USB_DIAGLOG
	if (has_usb_diag() && (!(m_usb_diag == r.m_usb_diag)))
		return false;
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (has_usb_con() && (!(m_usb_con == r.m_usb_con)))
		return false;
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (has_cc1_gpio() && (!(m_cc1_gpio == r.m_cc1_gpio)))
		return false;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (has_cc2_gpio() && (!(m_cc2_gpio == r.m_cc2_gpio)))
		return false;
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SystemConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"manufacturer")) {
		if (value == 0) {
			clear_manufacturer();
			return 0;
		}
		m_manufacturer = value;
		int r = m_manufacturer.size();
		return r;
	}
	if (0 == strcmp(name,"board_name")) {
		if (value == 0) {
			clear_board_name();
			return 0;
		}
		m_board_name = value;
		int r = m_board_name.size();
		return r;
	}
	if (0 == strcmp(name,"board_rev")) {
		if (value == 0) {
			clear_board_rev();
			return 0;
		}
		m_board_rev = value;
		int r = m_board_rev.size();
		return r;
	}
	if (0 == strcmp(name,"diag_uart")) {
		if (value == 0) {
			clear_diag_uart();
			return 0;
		}
		int r = parse_ascii_s8(&m_diag_uart,value);
		return r;
	}
	if (0 == strcmp(name,"console_rx")) {
		if (value == 0) {
			clear_console_rx();
			return 0;
		}
		int r = parse_ascii_s8(&m_console_rx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"console_tx")) {
		if (value == 0) {
			clear_console_tx();
			return 0;
		}
		int r = parse_ascii_s8(&m_console_tx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"model_name")) {
		if (value == 0) {
			clear_model_name();
			return 0;
		}
		m_model_name = value;
		int r = m_model_name.size();
		return r;
	}
	if (0 == strcmp(name,"model_number")) {
		if (value == 0) {
			clear_model_number();
			return 0;
		}
		m_model_number = value;
		int r = m_model_number.size();
		return r;
	}
	#ifdef CONFIG_USB_DIAGLOG
	if (0 == strcmp(name,"usb_diag")) {
		if (value == 0) {
			clear_usb_diag();
			return 0;
		}
		int r = parse_ascii_bool(&m_usb_diag,value);
		return r;
	}
	#endif // CONFIG_USB_DIAGLOG
	#ifdef CONFIG_USB_CONSOLE
	if (0 == strcmp(name,"usb_con")) {
		if (value == 0) {
			clear_usb_con();
			return 0;
		}
		int r = parse_ascii_bool(&m_usb_con,value);
		return r;
	}
	#endif // CONFIG_USB_CONSOLE
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (0 == strcmp(name,"cc1_gpio")) {
		if (value == 0) {
			clear_cc1_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_cc1_gpio,value);
		return r;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	#ifdef CONFIG_ESP_PHY_ENABLE_USB
	if (0 == strcmp(name,"cc2_gpio")) {
		if (value == 0) {
			clear_cc2_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_cc2_gpio,value);
		return r;
	}
	#endif // CONFIG_ESP_PHY_ENABLE_USB
	return -31;
}

TouchpadConfig::TouchpadConfig()
{
}

void TouchpadConfig::clear()
{
	m_fsm_mode = false;
	m_lvolt = -1;
	m_hvolt = -1;
	m_atten = -1;
	m_interval = 0;
	p_validbits = 0;
}

void TouchpadConfig::toASCII(stream &o, size_t indent) const
{
	o << "TouchpadConfig {";
	++indent;
	ascii_bool(o, indent, "fsm_mode", m_fsm_mode);
	ascii_numeric(o, indent, "lvolt", (signed) m_lvolt);
	ascii_numeric(o, indent, "hvolt", (signed) m_hvolt);
	ascii_numeric(o, indent, "atten", (signed) m_atten);
	ascii_numeric(o, indent, "interval", m_interval);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t TouchpadConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -32;
		a += x;
		switch (fid) {
		case 0xb:	// fsm_mode id 1, type bool, coding 8bit
			set_fsm_mode(ud.u8);
			break;
		case 0x10:	// lvolt id 2, type int8_t, coding signed varint
			set_lvolt(varint_sint(ud.u8));
			break;
		case 0x18:	// hvolt id 3, type int8_t, coding signed varint
			set_hvolt(varint_sint(ud.u8));
			break;
		case 0x20:	// atten id 4, type int8_t, coding signed varint
			set_atten(varint_sint(ud.u8));
			break;
		case 0x38:	// interval id 7, type uint32_t, coding varint
			set_interval((uint32_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -33;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -34;
	return a-(const uint8_t *)b;
}

ssize_t TouchpadConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has fsm_mode?
	if (m_fsm_mode != false) {
		// 'fsm_mode': id=1, encoding=8bit, tag=0xb
		if (2 > (e-a))
			return -35;
		*a++ = 0xb;
		*a++ = m_fsm_mode;
	}
	// has lvolt?
	if (m_lvolt != -1) {
		// 'lvolt': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -36;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_lvolt));
		if (n <= 0)
			return -37;
		a += n;
	}
	// has hvolt?
	if (m_hvolt != -1) {
		// 'hvolt': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -38;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_hvolt));
		if (n <= 0)
			return -39;
		a += n;
	}
	// has atten?
	if (m_atten != -1) {
		// 'atten': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -40;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_atten));
		if (n <= 0)
			return -41;
		a += n;
	}
	// has interval?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'interval': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -42;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_interval);
		if (n <= 0)
			return -43;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void TouchpadConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_fsm_mode()) {
		fsep = json_indent(json,indLvl,fsep,"fsm_mode");
		json << (m_fsm_mode ? "true" : "false");
	}
	if (has_lvolt()) {
		fsep = json_indent(json,indLvl,fsep,"lvolt");
		to_decstr(json,(int) m_lvolt);
	}
	if (has_hvolt()) {
		fsep = json_indent(json,indLvl,fsep,"hvolt");
		to_decstr(json,(int) m_hvolt);
	}
	if (has_atten()) {
		fsep = json_indent(json,indLvl,fsep,"atten");
		to_decstr(json,(int) m_atten);
	}
	if (has_interval()) {
		fsep = json_indent(json,indLvl,fsep,"interval");
		to_decstr(json,m_interval);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TouchpadConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional bool fsm_mode, id 1
	if (has_fsm_mode()) {
		r += 2;
	}
	// optional sint8 lvolt, id 2
	if (has_lvolt()) {
		r += wiresize_s((varint_t)m_lvolt) + 1 /* tag(lvolt) 0x10 */;
	}
	// optional sint8 hvolt, id 3
	if (has_hvolt()) {
		r += wiresize_s((varint_t)m_hvolt) + 1 /* tag(hvolt) 0x18 */;
	}
	// optional sint8 atten, id 4
	if (has_atten()) {
		r += wiresize_s((varint_t)m_atten) + 1 /* tag(atten) 0x20 */;
	}
	// optional unsigned interval, id 7
	if (has_interval()) {
		r += wiresize((varint_t)m_interval) + 1 /* tag(interval) 0x38 */;
	}
	return r;
}

bool TouchpadConfig::operator == (const TouchpadConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_fsm_mode() && (!(m_fsm_mode == r.m_fsm_mode)))
		return false;
	if (has_lvolt() && (!(m_lvolt == r.m_lvolt)))
		return false;
	if (has_hvolt() && (!(m_hvolt == r.m_hvolt)))
		return false;
	if (has_atten() && (!(m_atten == r.m_atten)))
		return false;
	if (has_interval() && (!(m_interval == r.m_interval)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TouchpadConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"fsm_mode")) {
		if (value == 0) {
			clear_fsm_mode();
			return 0;
		}
		int r = parse_ascii_bool(&m_fsm_mode,value);
		return r;
	}
	if (0 == strcmp(name,"lvolt")) {
		if (value == 0) {
			clear_lvolt();
			return 0;
		}
		int r = parse_ascii_s8(&m_lvolt,value);
		return r;
	}
	if (0 == strcmp(name,"hvolt")) {
		if (value == 0) {
			clear_hvolt();
			return 0;
		}
		int r = parse_ascii_s8(&m_hvolt,value);
		return r;
	}
	if (0 == strcmp(name,"atten")) {
		if (value == 0) {
			clear_atten();
			return 0;
		}
		int r = parse_ascii_s8(&m_atten,value);
		return r;
	}
	if (0 == strcmp(name,"interval")) {
		if (value == 0) {
			clear_interval();
			return 0;
		}
		int r = parse_ascii_u32(&m_interval,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	return -44;
}

TouchChannelConfig::TouchChannelConfig()
{
}

void TouchChannelConfig::clear()
{
	m_name.clear();
	m_channel = -1;
	m_threshold = 0;
	m_slope = 0;
	m_tieopt = 0;
	p_validbits = 0;
}

void TouchChannelConfig::toASCII(stream &o, size_t indent) const
{
	o << "TouchChannelConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "channel", (signed) m_channel);
	ascii_numeric(o, indent, "threshold", m_threshold);
	ascii_numeric(o, indent, "slope", (unsigned) m_slope);
	ascii_numeric(o, indent, "tieopt", (unsigned) m_tieopt);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t TouchChannelConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -45;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -46;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// channel id 2, type int8_t, coding signed varint
			set_channel(varint_sint(ud.u8));
			break;
		case 0x1c:	// threshold id 3, type uint16_t, coding 16bit
			set_threshold(ud.u16);
			break;
		case 0x20:	// slope id 4, type uint8_t, coding varint
			set_slope((uint8_t)ud.u32);
			break;
		case 0x28:	// tieopt id 5, type uint8_t, coding varint
			set_tieopt((uint8_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -47;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -48;
	return a-(const uint8_t *)b;
}

ssize_t TouchChannelConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -49;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -50;
		a += n;
	}
	// has channel?
	if (m_channel != -1) {
		// 'channel': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -51;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_channel));
		if (n <= 0)
			return -52;
		a += n;
	}
	// has threshold?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'threshold': id=3, encoding=16bit, tag=0x1c
		if (3 > (e-a))
			return -53;
		*a++ = 0x1c;
		write_u16(a,m_threshold);
		a += 2;
	}
	// has slope?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'slope': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -54;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_slope);
		if (n <= 0)
			return -55;
		a += n;
	}
	// has tieopt?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'tieopt': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -56;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_tieopt);
		if (n <= 0)
			return -57;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void TouchChannelConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_channel()) {
		fsep = json_indent(json,indLvl,fsep,"channel");
		to_decstr(json,(int) m_channel);
	}
	if (has_threshold()) {
		fsep = json_indent(json,indLvl,fsep,"threshold");
		to_decstr(json,m_threshold);
	}
	if (has_slope()) {
		fsep = json_indent(json,indLvl,fsep,"slope");
		to_decstr(json,(unsigned) m_slope);
	}
	if (has_tieopt()) {
		fsep = json_indent(json,indLvl,fsep,"tieopt");
		to_decstr(json,(unsigned) m_tieopt);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t TouchChannelConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 channel, id 2
	if (has_channel()) {
		r += wiresize_s((varint_t)m_channel) + 1 /* tag(channel) 0x10 */;
	}
	// optional fixed16 threshold, id 3
	if (has_threshold()) {
		r += 3;
	}
	// optional uint8 slope, id 4
	if (has_slope()) {
		r += wiresize((varint_t)m_slope) + 1 /* tag(slope) 0x20 */;
	}
	// optional uint8 tieopt, id 5
	if (has_tieopt()) {
		r += wiresize((varint_t)m_tieopt) + 1 /* tag(tieopt) 0x28 */;
	}
	return r;
}

bool TouchChannelConfig::operator == (const TouchChannelConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_channel() && (!(m_channel == r.m_channel)))
		return false;
	if (has_threshold() && (!(m_threshold == r.m_threshold)))
		return false;
	if (has_slope() && (!(m_slope == r.m_slope)))
		return false;
	if (has_tieopt() && (!(m_tieopt == r.m_tieopt)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int TouchChannelConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"channel")) {
		if (value == 0) {
			clear_channel();
			return 0;
		}
		int r = parse_ascii_s8(&m_channel,value);
		return r;
	}
	if (0 == strcmp(name,"threshold")) {
		if (value == 0) {
			clear_threshold();
			return 0;
		}
		int r = parse_ascii_u16(&m_threshold,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"slope")) {
		if (value == 0) {
			clear_slope();
			return 0;
		}
		int r = parse_ascii_u8(&m_slope,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"tieopt")) {
		if (value == 0) {
			clear_tieopt();
			return 0;
		}
		int r = parse_ascii_u8(&m_tieopt,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	return -58;
}

ButtonConfig::ButtonConfig()
{
}

void ButtonConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_presslvl = 0;
	m_pull_mode = pull_none;
	#ifdef CONFIG_ROTARYENCODER
	m_clk = -1;
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	m_dt = -1;
	#endif // CONFIG_ROTARYENCODER
}

void ButtonConfig::toASCII(stream &o, size_t indent) const
{
	o << "ButtonConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_bool(o, indent, "presslvl", m_presslvl);
	ascii_numeric(o, indent, "pull_mode", (unsigned) m_pull_mode);
	++indent;
	ascii_indent(o,indent);
	o << ".enable";
	o << (pull_mode_enable() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".up";
	o << (pull_mode_up() ? " = true;" : " = false;");
	--indent;
	#ifdef CONFIG_ROTARYENCODER
	ascii_numeric(o, indent, "clk", (signed) m_clk);
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	ascii_numeric(o, indent, "dt", (signed) m_dt);
	#endif // CONFIG_ROTARYENCODER
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t ButtonConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -59;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -60;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x1b:	// presslvl id 3, type bool, coding 8bit
			set_presslvl(ud.u8);
			break;
		case 0x20:	// pull_mode id 4, type pull_mode_t, coding varint
			set_pull_mode((pull_mode_t) (pull_mode_t)ud.u32);
			break;
			#ifdef CONFIG_ROTARYENCODER
		case 0x28:	// clk id 5, type int8_t, coding signed varint
			set_clk(varint_sint(ud.u8));
			break;
			#endif // CONFIG_ROTARYENCODER
			#ifdef CONFIG_ROTARYENCODER
		case 0x30:	// dt id 6, type int8_t, coding signed varint
			set_dt(varint_sint(ud.u8));
			break;
			#endif // CONFIG_ROTARYENCODER
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -61;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -62;
	return a-(const uint8_t *)b;
}

ssize_t ButtonConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -63;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -64;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -65;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -66;
		a += n;
	}
	// has presslvl?
	if (m_presslvl != 0) {
		// 'presslvl': id=3, encoding=8bit, tag=0x1b
		if (2 > (e-a))
			return -67;
		*a++ = 0x1b;
		*a++ = m_presslvl;
	}
	// has pull_mode?
	if (m_pull_mode != pull_none) {
		// 'pull_mode': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -68;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_pull_mode);
		if (n <= 0)
			return -69;
		a += n;
	}
	#ifdef CONFIG_ROTARYENCODER
	// has clk?
	if (m_clk != -1) {
		// 'clk': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -70;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_clk));
		if (n <= 0)
			return -71;
		a += n;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	// has dt?
	if (m_dt != -1) {
		// 'dt': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -72;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_dt));
		if (n <= 0)
			return -73;
		a += n;
	}
	#endif // CONFIG_ROTARYENCODER
	assert(a <= e);
	return a-b;
}

void ButtonConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_presslvl()) {
		fsep = json_indent(json,indLvl,fsep,"presslvl");
		json << (m_presslvl ? "true" : "false");
	}
	if (has_pull_mode()) {
		fsep = json_indent(json,indLvl,fsep,"pull_mode");
		json << (unsigned) m_pull_mode;
	}
	#ifdef CONFIG_ROTARYENCODER
	if (has_clk()) {
		fsep = json_indent(json,indLvl,fsep,"clk");
		to_decstr(json,(int) m_clk);
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (has_dt()) {
		fsep = json_indent(json,indLvl,fsep,"dt");
		to_decstr(json,(int) m_dt);
	}
	#endif // CONFIG_ROTARYENCODER
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t ButtonConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional bool presslvl, id 3
	if (has_presslvl()) {
		r += 2;
	}
	// optional pull_mode_t pull_mode, id 4
	if (has_pull_mode()) {
		r += wiresize((varint_t)m_pull_mode) + 1 /* tag(pull_mode) 0x20 */;
	}
	#ifdef CONFIG_ROTARYENCODER
	// optional sint8 clk, id 5
	if (has_clk()) {
		r += wiresize_s((varint_t)m_clk) + 1 /* tag(clk) 0x28 */;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	// optional sint8 dt, id 6
	if (has_dt()) {
		r += wiresize_s((varint_t)m_dt) + 1 /* tag(dt) 0x30 */;
	}
	#endif // CONFIG_ROTARYENCODER
	return r;
}

bool ButtonConfig::operator == (const ButtonConfig &r) const
{
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_presslvl() && (!(m_presslvl == r.m_presslvl)))
		return false;
	if (has_pull_mode() && (!(m_pull_mode == r.m_pull_mode)))
		return false;
	#ifdef CONFIG_ROTARYENCODER
	if (has_clk() && (!(m_clk == r.m_clk)))
		return false;
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (has_dt() && (!(m_dt == r.m_dt)))
		return false;
	#endif // CONFIG_ROTARYENCODER
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int ButtonConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"presslvl")) {
		if (value == 0) {
			clear_presslvl();
			return 0;
		}
		int r = parse_ascii_bool(&m_presslvl,value);
		return r;
	}
	if ((0 == memcmp(name,"pull_mode",9)) && ((name[9] == 0) || name[9] == '.')) {
		name += 9;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_pull_mode((pull_mode_t)ull);
			else if (!strcmp(name,"enable"))
				set_pull_mode_enable((bool)ull);
			else if (!strcmp(name,"up"))
				set_pull_mode_up((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -74;
		} else if (!strcmp(name,"enable")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_pull_mode_enable(tmp);
			return r;
		} else if (!strcmp(name,"up")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_pull_mode_up(tmp);
			return r;
		}
	}
	#ifdef CONFIG_ROTARYENCODER
	if (0 == strcmp(name,"clk")) {
		if (value == 0) {
			clear_clk();
			return 0;
		}
		int r = parse_ascii_s8(&m_clk,value);
		return r;
	}
	#endif // CONFIG_ROTARYENCODER
	#ifdef CONFIG_ROTARYENCODER
	if (0 == strcmp(name,"dt")) {
		if (value == 0) {
			clear_dt();
			return 0;
		}
		int r = parse_ascii_s8(&m_dt,value);
		return r;
	}
	#endif // CONFIG_ROTARYENCODER
	return -75;
}

RelayConfig::RelayConfig()
{
}

void RelayConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_config = 0;
	m_min_itv = 0;
	m_interlock = -1;
	p_validbits = 0;
}

void RelayConfig::toASCII(stream &o, size_t indent) const
{
	o << "RelayConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", (unsigned) m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".active_high";
	o << (config_active_high() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".init_on";
	o << (config_init_on() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".persistent";
	o << (config_persistent() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".opendrain";
	o << (config_opendrain() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".mqtt";
	o << (config_mqtt() ? " = true;" : " = false;");
	--indent;
	ascii_numeric(o, indent, "min_itv", m_min_itv);
	ascii_numeric(o, indent, "interlock", (signed) m_interlock);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t RelayConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -76;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -77;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x18:	// config id 3, type relay_cfg_t, coding varint
			set_config((relay_cfg_t) (relay_cfg_t)ud.u32);
			break;
		case 0x20:	// min_itv id 4, type uint32_t, coding varint
			set_min_itv((uint32_t)ud.u32);
			break;
		case 0x28:	// interlock id 5, type int8_t, coding signed varint
			set_interlock(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -78;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -79;
	return a-(const uint8_t *)b;
}

ssize_t RelayConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -80;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -81;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -82;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -83;
		a += n;
	}
	// has config?
	if (m_config != 0) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -84;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -85;
		a += n;
	}
	// has min_itv?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'min_itv': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -86;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_min_itv);
		if (n <= 0)
			return -87;
		a += n;
	}
	// has interlock?
	if (m_interlock != -1) {
		// 'interlock': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -88;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_interlock));
		if (n <= 0)
			return -89;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void RelayConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (has_min_itv()) {
		fsep = json_indent(json,indLvl,fsep,"min_itv");
		to_decstr(json,m_min_itv);
	}
	if (has_interlock()) {
		fsep = json_indent(json,indLvl,fsep,"interlock");
		to_decstr(json,(int) m_interlock);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t RelayConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional relay_cfg_t config, id 3
	if (has_config()) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	// optional unsigned min_itv, id 4
	if (has_min_itv()) {
		r += wiresize((varint_t)m_min_itv) + 1 /* tag(min_itv) 0x20 */;
	}
	// optional sint8 interlock, id 5
	if (has_interlock()) {
		r += wiresize_s((varint_t)m_interlock) + 1 /* tag(interlock) 0x28 */;
	}
	return r;
}

bool RelayConfig::operator == (const RelayConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_config() && (!(m_config == r.m_config)))
		return false;
	if (has_min_itv() && (!(m_min_itv == r.m_min_itv)))
		return false;
	if (has_interlock() && (!(m_interlock == r.m_interlock)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int RelayConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((relay_cfg_t)ull);
			else if (!strcmp(name,"active_high"))
				set_config_active_high((bool)ull);
			else if (!strcmp(name,"init_on"))
				set_config_init_on((bool)ull);
			else if (!strcmp(name,"persistent"))
				set_config_persistent((bool)ull);
			else if (!strcmp(name,"opendrain"))
				set_config_opendrain((bool)ull);
			else if (!strcmp(name,"mqtt"))
				set_config_mqtt((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -90;
		} else if (!strcmp(name,"active_high")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_active_high(tmp);
			return r;
		} else if (!strcmp(name,"init_on")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_init_on(tmp);
			return r;
		} else if (!strcmp(name,"persistent")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_persistent(tmp);
			return r;
		} else if (!strcmp(name,"opendrain")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_opendrain(tmp);
			return r;
		} else if (!strcmp(name,"mqtt")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_mqtt(tmp);
			return r;
		}
	}
	if (0 == strcmp(name,"min_itv")) {
		if (value == 0) {
			clear_min_itv();
			return 0;
		}
		int r = parse_ascii_u32(&m_min_itv,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"interlock")) {
		if (value == 0) {
			clear_interlock();
			return 0;
		}
		int r = parse_ascii_s8(&m_interlock,value);
		return r;
	}
	return -91;
}

Max7219Config::Max7219Config()
{
}

void Max7219Config::clear()
{
	m_clk = -1;
	m_dout = -1;
	m_cs = -1;
	m_odrain = false;
	m_digits = 0;
}

void Max7219Config::toASCII(stream &o, size_t indent) const
{
	o << "Max7219Config {";
	++indent;
	ascii_numeric(o, indent, "clk", (signed) m_clk);
	ascii_numeric(o, indent, "dout", (signed) m_dout);
	ascii_numeric(o, indent, "cs", (signed) m_cs);
	ascii_bool(o, indent, "odrain", m_odrain);
	ascii_numeric(o, indent, "digits", (unsigned) m_digits);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Max7219Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -92;
		a += x;
		switch (fid) {
		case 0x8:	// clk id 1, type int8_t, coding signed varint
			set_clk(varint_sint(ud.u8));
			break;
		case 0x10:	// dout id 2, type int8_t, coding signed varint
			set_dout(varint_sint(ud.u8));
			break;
		case 0x18:	// cs id 3, type int8_t, coding signed varint
			set_cs(varint_sint(ud.u8));
			break;
		case 0x23:	// odrain id 4, type bool, coding 8bit
			set_odrain(ud.u8);
			break;
		case 0x28:	// digits id 5, type uint8_t, coding varint
			set_digits((uint8_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -93;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -94;
	return a-(const uint8_t *)b;
}

ssize_t Max7219Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has clk?
	if (m_clk != -1) {
		// 'clk': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -95;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_clk));
		if (n <= 0)
			return -96;
		a += n;
	}
	// has dout?
	if (m_dout != -1) {
		// 'dout': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -97;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_dout));
		if (n <= 0)
			return -98;
		a += n;
	}
	// has cs?
	if (m_cs != -1) {
		// 'cs': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -99;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_cs));
		if (n <= 0)
			return -100;
		a += n;
	}
	// has odrain?
	if (m_odrain != false) {
		// 'odrain': id=4, encoding=8bit, tag=0x23
		if (2 > (e-a))
			return -101;
		*a++ = 0x23;
		*a++ = m_odrain;
	}
	// has digits?
	if (m_digits != 0) {
		// 'digits': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -102;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_digits);
		if (n <= 0)
			return -103;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Max7219Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_clk()) {
		fsep = json_indent(json,indLvl,fsep,"clk");
		to_decstr(json,(int) m_clk);
	}
	if (has_dout()) {
		fsep = json_indent(json,indLvl,fsep,"dout");
		to_decstr(json,(int) m_dout);
	}
	if (has_cs()) {
		fsep = json_indent(json,indLvl,fsep,"cs");
		to_decstr(json,(int) m_cs);
	}
	if (has_odrain()) {
		fsep = json_indent(json,indLvl,fsep,"odrain");
		json << (m_odrain ? "true" : "false");
	}
	if (has_digits()) {
		fsep = json_indent(json,indLvl,fsep,"digits");
		to_decstr(json,(unsigned) m_digits);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Max7219Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 clk, id 1
	if (has_clk()) {
		r += wiresize_s((varint_t)m_clk) + 1 /* tag(clk) 0x8 */;
	}
	// optional sint8 dout, id 2
	if (has_dout()) {
		r += wiresize_s((varint_t)m_dout) + 1 /* tag(dout) 0x10 */;
	}
	// optional sint8 cs, id 3
	if (has_cs()) {
		r += wiresize_s((varint_t)m_cs) + 1 /* tag(cs) 0x18 */;
	}
	// optional bool odrain, id 4
	if (has_odrain()) {
		r += 2;
	}
	// optional uint8 digits, id 5
	if (has_digits()) {
		r += wiresize((varint_t)m_digits) + 1 /* tag(digits) 0x28 */;
	}
	return r;
}

bool Max7219Config::operator == (const Max7219Config &r) const
{
	if (has_clk() && (!(m_clk == r.m_clk)))
		return false;
	if (has_dout() && (!(m_dout == r.m_dout)))
		return false;
	if (has_cs() && (!(m_cs == r.m_cs)))
		return false;
	if (has_odrain() && (!(m_odrain == r.m_odrain)))
		return false;
	if (has_digits() && (!(m_digits == r.m_digits)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Max7219Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"clk")) {
		if (value == 0) {
			clear_clk();
			return 0;
		}
		int r = parse_ascii_s8(&m_clk,value);
		return r;
	}
	if (0 == strcmp(name,"dout")) {
		if (value == 0) {
			clear_dout();
			return 0;
		}
		int r = parse_ascii_s8(&m_dout,value);
		return r;
	}
	if (0 == strcmp(name,"cs")) {
		if (value == 0) {
			clear_cs();
			return 0;
		}
		int r = parse_ascii_s8(&m_cs,value);
		return r;
	}
	if (0 == strcmp(name,"odrain")) {
		if (value == 0) {
			clear_odrain();
			return 0;
		}
		int r = parse_ascii_bool(&m_odrain,value);
		return r;
	}
	if (0 == strcmp(name,"digits")) {
		if (value == 0) {
			clear_digits();
			return 0;
		}
		int r = parse_ascii_u8(&m_digits,value);
		return r;
	}
	return -104;
}

Tlc5947Config::Tlc5947Config()
{
}

void Tlc5947Config::clear()
{
	m_sin = -1;
	m_sclk = -1;
	m_xlat = -1;
	m_blank = -1;
	m_ntlc = 0;
}

void Tlc5947Config::toASCII(stream &o, size_t indent) const
{
	o << "Tlc5947Config {";
	++indent;
	ascii_numeric(o, indent, "sin", (signed) m_sin);
	ascii_numeric(o, indent, "sclk", (signed) m_sclk);
	ascii_numeric(o, indent, "xlat", (signed) m_xlat);
	ascii_numeric(o, indent, "blank", (signed) m_blank);
	ascii_numeric(o, indent, "ntlc", (unsigned) m_ntlc);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Tlc5947Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -105;
		a += x;
		switch (fid) {
		case 0x8:	// sin id 1, type int8_t, coding signed varint
			set_sin(varint_sint(ud.u8));
			break;
		case 0x10:	// sclk id 2, type int8_t, coding signed varint
			set_sclk(varint_sint(ud.u8));
			break;
		case 0x18:	// xlat id 3, type int8_t, coding signed varint
			set_xlat(varint_sint(ud.u8));
			break;
		case 0x20:	// blank id 4, type int8_t, coding signed varint
			set_blank(varint_sint(ud.u8));
			break;
		case 0x28:	// ntlc id 5, type uint8_t, coding varint
			set_ntlc((uint8_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -106;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -107;
	return a-(const uint8_t *)b;
}

ssize_t Tlc5947Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has sin?
	if (m_sin != -1) {
		// 'sin': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -108;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_sin));
		if (n <= 0)
			return -109;
		a += n;
	}
	// has sclk?
	if (m_sclk != -1) {
		// 'sclk': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -110;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sclk));
		if (n <= 0)
			return -111;
		a += n;
	}
	// has xlat?
	if (m_xlat != -1) {
		// 'xlat': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -112;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_xlat));
		if (n <= 0)
			return -113;
		a += n;
	}
	// has blank?
	if (m_blank != -1) {
		// 'blank': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -114;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_blank));
		if (n <= 0)
			return -115;
		a += n;
	}
	// has ntlc?
	if (m_ntlc != 0) {
		// 'ntlc': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -116;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_ntlc);
		if (n <= 0)
			return -117;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Tlc5947Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_sin()) {
		fsep = json_indent(json,indLvl,fsep,"sin");
		to_decstr(json,(int) m_sin);
	}
	if (has_sclk()) {
		fsep = json_indent(json,indLvl,fsep,"sclk");
		to_decstr(json,(int) m_sclk);
	}
	if (has_xlat()) {
		fsep = json_indent(json,indLvl,fsep,"xlat");
		to_decstr(json,(int) m_xlat);
	}
	if (has_blank()) {
		fsep = json_indent(json,indLvl,fsep,"blank");
		to_decstr(json,(int) m_blank);
	}
	if (has_ntlc()) {
		fsep = json_indent(json,indLvl,fsep,"ntlc");
		to_decstr(json,(unsigned) m_ntlc);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Tlc5947Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 sin, id 1
	if (has_sin()) {
		r += wiresize_s((varint_t)m_sin) + 1 /* tag(sin) 0x8 */;
	}
	// optional sint8 sclk, id 2
	if (has_sclk()) {
		r += wiresize_s((varint_t)m_sclk) + 1 /* tag(sclk) 0x10 */;
	}
	// optional sint8 xlat, id 3
	if (has_xlat()) {
		r += wiresize_s((varint_t)m_xlat) + 1 /* tag(xlat) 0x18 */;
	}
	// optional sint8 blank, id 4
	if (has_blank()) {
		r += wiresize_s((varint_t)m_blank) + 1 /* tag(blank) 0x20 */;
	}
	// optional uint8 ntlc, id 5
	if (has_ntlc()) {
		r += wiresize((varint_t)m_ntlc) + 1 /* tag(ntlc) 0x28 */;
	}
	return r;
}

bool Tlc5947Config::operator == (const Tlc5947Config &r) const
{
	if (has_sin() && (!(m_sin == r.m_sin)))
		return false;
	if (has_sclk() && (!(m_sclk == r.m_sclk)))
		return false;
	if (has_xlat() && (!(m_xlat == r.m_xlat)))
		return false;
	if (has_blank() && (!(m_blank == r.m_blank)))
		return false;
	if (has_ntlc() && (!(m_ntlc == r.m_ntlc)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Tlc5947Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"sin")) {
		if (value == 0) {
			clear_sin();
			return 0;
		}
		int r = parse_ascii_s8(&m_sin,value);
		return r;
	}
	if (0 == strcmp(name,"sclk")) {
		if (value == 0) {
			clear_sclk();
			return 0;
		}
		int r = parse_ascii_s8(&m_sclk,value);
		return r;
	}
	if (0 == strcmp(name,"xlat")) {
		if (value == 0) {
			clear_xlat();
			return 0;
		}
		int r = parse_ascii_s8(&m_xlat,value);
		return r;
	}
	if (0 == strcmp(name,"blank")) {
		if (value == 0) {
			clear_blank();
			return 0;
		}
		int r = parse_ascii_s8(&m_blank,value);
		return r;
	}
	if (0 == strcmp(name,"ntlc")) {
		if (value == 0) {
			clear_ntlc();
			return 0;
		}
		int r = parse_ascii_u8(&m_ntlc,value);
		return r;
	}
	return -118;
}

Ws2812bConfig::Ws2812bConfig()
{
}

void Ws2812bConfig::clear()
{
	m_gpio = -1;
	m_nleds = 0;
	m_name.clear();
}

void Ws2812bConfig::toASCII(stream &o, size_t indent) const
{
	o << "Ws2812bConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "nleds", (unsigned) m_nleds);
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Ws2812bConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -119;
		a += x;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x18:	// nleds id 3, type uint8_t, coding varint
			set_nleds((uint8_t)ud.u32);
			break;
		case 0x22:	// name id 4, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -120;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -121;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -122;
	return a-(const uint8_t *)b;
}

ssize_t Ws2812bConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -123;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -124;
		a += n;
	}
	// 'ch' is unused. Therefore no data will be written.
	// has nleds?
	if (m_nleds != 0) {
		// 'nleds': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -125;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_nleds);
		if (n <= 0)
			return -126;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -127;
		*a++ = 0x22;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -128;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Ws2812bConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_nleds()) {
		fsep = json_indent(json,indLvl,fsep,"nleds");
		to_decstr(json,(unsigned) m_nleds);
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Ws2812bConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// unused optional sint8 ch, id 2
	// optional uint8 nleds, id 3
	if (has_nleds()) {
		r += wiresize((varint_t)m_nleds) + 1 /* tag(nleds) 0x18 */;
	}
	// optional string name, id 4
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x20 */;
	}
	return r;
}

bool Ws2812bConfig::operator == (const Ws2812bConfig &r) const
{
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_nleds() && (!(m_nleds == r.m_nleds)))
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Ws2812bConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"nleds")) {
		if (value == 0) {
			clear_nleds();
			return 0;
		}
		int r = parse_ascii_u8(&m_nleds,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	return -129;
}

DhtConfig::DhtConfig()
{
}

void DhtConfig::clear()
{
	m_model = DHT_NONE;
	m_gpio = -1;
}

void DhtConfig::toASCII(stream &o, size_t indent) const
{
	o << "DhtConfig {";
	++indent;
	ascii_indent(o,indent,"model");
	if (const char *v = dht_model_t_str(m_model))
		o << v;
	else
		o << m_model;
	o << ';';
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t DhtConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -130;
		a += x;
		switch (fid) {
		case 0x8:	// model id 1, type dht_model_t, coding varint
			set_model((dht_model_t) (dht_model_t)ud.u32);
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -131;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -132;
	return a-(const uint8_t *)b;
}

ssize_t DhtConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has model?
	if (m_model != DHT_NONE) {
		// 'model': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -133;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_model);
		if (n <= 0)
			return -134;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -135;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -136;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void DhtConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_model()) {
		fsep = json_indent(json,indLvl,fsep,"model");
		if (const char *v = dht_model_t_str(m_model)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_model;
		}
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t DhtConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional dht_model_t model, id 1
	if (has_model()) {
		r += wiresize((varint_t)m_model) + 1 /* tag(model) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	return r;
}

bool DhtConfig::operator == (const DhtConfig &r) const
{
	if (has_model() && (!(m_model == r.m_model)))
		return false;
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int DhtConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"model")) {
		if (value == 0) {
			clear_model();
			return 0;
		}
		dht_model_t v;
		size_t r = parse_ascii_dht_model_t(&v,value);
		if (r == 0)
			return -137;
		set_model(v);
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	return -138;
}

I2CConfig::I2CConfig()
{
}

void I2CConfig::clear()
{
	m_port = 0;
	m_sda = -1;
	m_scl = -1;
	m_xpullup = false;
	#ifdef CONFIG_I2C_XDEV
	m_devices.clear();
	#endif // CONFIG_I2C_XDEV
	p_validbits = 0;
}

void I2CConfig::toASCII(stream &o, size_t indent) const
{
	o << "I2CConfig {";
	++indent;
	ascii_numeric(o, indent, "port", (unsigned) m_port);
	ascii_numeric(o, indent, "sda", (signed) m_sda);
	ascii_numeric(o, indent, "scl", (signed) m_scl);
	ascii_bool(o, indent, "xpullup", m_xpullup);
	#ifdef CONFIG_I2C_XDEV
	ascii_indent(o,indent);
	size_t s_devices = m_devices.size();
	o << "devices[" << s_devices << "] = {";
	++indent;
	for (size_t i = 0, e = s_devices; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_numeric(o, indent, 0, m_devices[i]);
		++indent;
		ascii_indent(o,indent);
		o << ".addr = " ;
		o << (unsigned) devices_addr(i);
		o << ';';
		ascii_indent(o,indent);
		o << ".drv = " ;
		o << i2cdrv_t_str(devices_drv(i));
		o << ';';
		ascii_indent(o,indent);
		o << ".intr = " ;
		o << (unsigned) devices_intr(i);
		o << ';';
		--indent;
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_I2C_XDEV
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t I2CConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -139;
		a += x;
		switch (fid) {
		case 0x8:	// port id 1, type uint8_t, coding varint
			set_port((uint8_t)ud.u32);
			break;
		case 0x10:	// sda id 2, type int8_t, coding signed varint
			set_sda(varint_sint(ud.u8));
			break;
		case 0x18:	// scl id 3, type int8_t, coding signed varint
			set_scl(varint_sint(ud.u8));
			break;
		case 0x2b:	// xpullup id 5, type bool, coding 8bit
			set_xpullup(ud.u8);
			break;
			#ifdef CONFIG_I2C_XDEV
		case 0x32: {	// devices id 6, packed i2cdev_t[] coding 2
				varint_t v = ud.u64;
				const uint8_t *ae = a + v;
				do {
					varint_t v;
					int n = read_varint(a,e-a,&v);
					if (n <= 0)
						return -140;
					a += n;
					m_devices.push_back((i2cdev_t)v);
				} while (a < ae);
				break;
			}
			#endif // CONFIG_I2C_XDEV
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -141;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -142;
	return a-(const uint8_t *)b;
}

ssize_t I2CConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -143;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_port);
		if (n <= 0)
			return -144;
		a += n;
	}
	// has sda?
	if (m_sda != -1) {
		// 'sda': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -145;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sda));
		if (n <= 0)
			return -146;
		a += n;
	}
	// has scl?
	if (m_scl != -1) {
		// 'scl': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -147;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_scl));
		if (n <= 0)
			return -148;
		a += n;
	}
	// 'freq' is unused. Therefore no data will be written.
	// has xpullup?
	if (m_xpullup != false) {
		// 'xpullup': id=5, encoding=8bit, tag=0x2b
		if (2 > (e-a))
			return -149;
		*a++ = 0x2b;
		*a++ = m_xpullup;
	}
	#ifdef CONFIG_I2C_XDEV
	if (size_t devices_ne = m_devices.size()) {
		// 'devices': id=6, encoding=lenpfx, tag=0x32
		if (a >= e)
			return -150;
		*a++ = 0x32;
		ssize_t devices_ws = 0;
		for (size_t x = 0; x != devices_ne; ++x)
			devices_ws += wiresize(m_devices[x]);
		n = write_varint(a,e-a,devices_ws);
		a += n;
		if ((n <= 0) || (devices_ws > (e-a)))
			return -151;
		for (size_t x = 0; x != devices_ne; ++x)
			a += write_varint(a,e-a,m_devices[x]);
	}
	#endif // CONFIG_I2C_XDEV
	assert(a <= e);
	return a-b;
}

void I2CConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		to_decstr(json,(unsigned) m_port);
	}
	if (has_sda()) {
		fsep = json_indent(json,indLvl,fsep,"sda");
		to_decstr(json,(int) m_sda);
	}
	if (has_scl()) {
		fsep = json_indent(json,indLvl,fsep,"scl");
		to_decstr(json,(int) m_scl);
	}
	if (has_xpullup()) {
		fsep = json_indent(json,indLvl,fsep,"xpullup");
		json << (m_xpullup ? "true" : "false");
	}
	#ifdef CONFIG_I2C_XDEV
	if (size_t s = m_devices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"devices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json << m_devices[i];
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_I2C_XDEV
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t I2CConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional uint8 port, id 1
	if (has_port()) {
		r += wiresize((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// optional sint8 sda, id 2
	if (has_sda()) {
		r += wiresize_s((varint_t)m_sda) + 1 /* tag(sda) 0x10 */;
	}
	// optional sint8 scl, id 3
	if (has_scl()) {
		r += wiresize_s((varint_t)m_scl) + 1 /* tag(scl) 0x18 */;
	}
	// unused optional unsigned freq, id 4
	// optional bool xpullup, id 5
	if (has_xpullup()) {
		r += 2;
	}
	#ifdef CONFIG_I2C_XDEV
	// repeated i2cdev_t devices, id 6
	if (!m_devices.empty()) {
		// devices: packed repeated i2cdev_t
		size_t devices_dl = 0;
		for (size_t x = 0, y = m_devices.size(); x < y; ++x)
			devices_dl += wiresize((varint_t)m_devices[x]);
		r += devices_dl + wiresize(devices_dl) /* data length */ + 1 /* tag(devices) 0x30 */;
	}
	#endif // CONFIG_I2C_XDEV
	return r;
}

bool I2CConfig::operator == (const I2CConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_port() && (!(m_port == r.m_port)))
		return false;
	if (has_sda() && (!(m_sda == r.m_sda)))
		return false;
	if (has_scl() && (!(m_scl == r.m_scl)))
		return false;
	if (has_xpullup() && (!(m_xpullup == r.m_xpullup)))
		return false;
	#ifdef CONFIG_I2C_XDEV
	if (!(m_devices == r.m_devices))
		return false;
	#endif // CONFIG_I2C_XDEV
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int I2CConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_u8(&m_port,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"sda")) {
		if (value == 0) {
			clear_sda();
			return 0;
		}
		int r = parse_ascii_s8(&m_sda,value);
		return r;
	}
	if (0 == strcmp(name,"scl")) {
		if (value == 0) {
			clear_scl();
			return 0;
		}
		int r = parse_ascii_s8(&m_scl,value);
		return r;
	}
	if (0 == strcmp(name,"xpullup")) {
		if (value == 0) {
			clear_xpullup();
			return 0;
		}
		int r = parse_ascii_bool(&m_xpullup,value);
		return r;
	}
	#ifdef CONFIG_I2C_XDEV
	if (0 == memcmp(name,"devices",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_devices();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_devices.size();
				m_devices.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -152;
				if (m_devices.size() <= x)
					return -153;
				if ((idxe[1] == 0) && (value == 0)) {
					m_devices.erase(m_devices.begin()+x);
					return 0;
				}
			}
			char *eptr = 0;
			unsigned long long ull = strtoull(value,&eptr,0);
			if (idxe[1] == 0) {
				m_devices[x] = (i2cdev_t) ull;
				return eptr - value;
			}
			if (idxe[1] != '.')
				return -154;
			idxe += 2;
			if (!strcmp("addr",idxe)) {
				if (eptr != value) {
					set_devices_addr(x,(uint8_t)ull);
					return 0;
				}
			}
			if (!strcmp("drv",idxe)) {
				if (eptr != value) {
					set_devices_drv(x,(i2cdrv_t)ull);
					return 0;
				} else {
					i2cdrv_t ev;
					size_t r = parse_ascii_i2cdrv_t(&ev,value);
					if (r != 0) {
						set_devices_drv(x,ev);
						return r;
					}
				}
			}
			if (!strcmp("intr",idxe)) {
				if (eptr != value) {
					set_devices_intr(x,(uint8_t)ull);
					return 0;
				}
			}
			return -155;
		}
	}
	#endif // CONFIG_I2C_XDEV
	return -156;
}

HcSr04Config::HcSr04Config()
{
}

void HcSr04Config::clear()
{
	m_trigger = -1;
	m_echo = -1;
	m_name.clear();
}

void HcSr04Config::toASCII(stream &o, size_t indent) const
{
	o << "HcSr04Config {";
	++indent;
	ascii_numeric(o, indent, "trigger", (signed) m_trigger);
	ascii_numeric(o, indent, "echo", (signed) m_echo);
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t HcSr04Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -157;
		a += x;
		switch (fid) {
		case 0x8:	// trigger id 1, type int8_t, coding signed varint
			set_trigger(varint_sint(ud.u8));
			break;
		case 0x10:	// echo id 2, type int8_t, coding signed varint
			set_echo(varint_sint(ud.u8));
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -158;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -159;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -160;
	return a-(const uint8_t *)b;
}

ssize_t HcSr04Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has trigger?
	if (m_trigger != -1) {
		// 'trigger': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -161;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_trigger));
		if (n <= 0)
			return -162;
		a += n;
	}
	// has echo?
	if (m_echo != -1) {
		// 'echo': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -163;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_echo));
		if (n <= 0)
			return -164;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -165;
		*a++ = 0x1a;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -166;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void HcSr04Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_trigger()) {
		fsep = json_indent(json,indLvl,fsep,"trigger");
		to_decstr(json,(int) m_trigger);
	}
	if (has_echo()) {
		fsep = json_indent(json,indLvl,fsep,"echo");
		to_decstr(json,(int) m_echo);
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t HcSr04Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 trigger, id 1
	if (has_trigger()) {
		r += wiresize_s((varint_t)m_trigger) + 1 /* tag(trigger) 0x8 */;
	}
	// optional sint8 echo, id 2
	if (has_echo()) {
		r += wiresize_s((varint_t)m_echo) + 1 /* tag(echo) 0x10 */;
	}
	// optional string name, id 3
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	return r;
}

bool HcSr04Config::operator == (const HcSr04Config &r) const
{
	if (has_trigger() && (!(m_trigger == r.m_trigger)))
		return false;
	if (has_echo() && (!(m_echo == r.m_echo)))
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int HcSr04Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"trigger")) {
		if (value == 0) {
			clear_trigger();
			return 0;
		}
		int r = parse_ascii_s8(&m_trigger,value);
		return r;
	}
	if (0 == strcmp(name,"echo")) {
		if (value == 0) {
			clear_echo();
			return 0;
		}
		int r = parse_ascii_s8(&m_echo,value);
		return r;
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	return -167;
}

LedConfig::LedConfig()
{
}

void LedConfig::clear()
{
	m_gpio = -1;
	m_config = 0;
	m_name.clear();
	m_pwm_ch = -1;
	p_validbits = 0;
}

void LedConfig::toASCII(stream &o, size_t indent) const
{
	o << "LedConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", (unsigned) m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".active_high";
	o << (config_active_high() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".open_drain";
	o << (config_open_drain() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".init_high";
	o << (config_init_high() ? " = true;" : " = false;");
	--indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "pwm_ch", (signed) m_pwm_ch);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t LedConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -168;
		a += x;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x10:	// config id 2, type ledcfg_t, coding varint
			set_config((ledcfg_t) (ledcfg_t)ud.u32);
			break;
		case 0x1a:	// name id 3, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -169;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x20:	// pwm_ch id 4, type int8_t, coding signed varint
			set_pwm_ch(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -170;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -171;
	return a-(const uint8_t *)b;
}

ssize_t LedConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -172;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -173;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -174;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -175;
		a += n;
	}
	// has name?
	if (!m_name.empty()) {
		// 'name': id=3, encoding=lenpfx, tag=0x1a
		if (a >= e)
			return -176;
		*a++ = 0x1a;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -177;
		a += n;
	}
	// has pwm_ch?
	if (m_pwm_ch != -1) {
		// 'pwm_ch': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -178;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_pwm_ch));
		if (n <= 0)
			return -179;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void LedConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << (unsigned) m_config;
	}
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_pwm_ch()) {
		fsep = json_indent(json,indLvl,fsep,"pwm_ch");
		to_decstr(json,(int) m_pwm_ch);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t LedConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional ledcfg_t config, id 2
	if (has_config()) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x10 */;
	}
	// optional string name, id 3
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x18 */;
	}
	// optional sint8 pwm_ch, id 4
	if (has_pwm_ch()) {
		r += wiresize_s((varint_t)m_pwm_ch) + 1 /* tag(pwm_ch) 0x20 */;
	}
	return r;
}

bool LedConfig::operator == (const LedConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_config() && (!(m_config == r.m_config)))
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_pwm_ch() && (!(m_pwm_ch == r.m_pwm_ch)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int LedConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((ledcfg_t)ull);
			else if (!strcmp(name,"active_high"))
				set_config_active_high((bool)ull);
			else if (!strcmp(name,"open_drain"))
				set_config_open_drain((bool)ull);
			else if (!strcmp(name,"init_high"))
				set_config_init_high((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -180;
		} else if (!strcmp(name,"active_high")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_active_high(tmp);
			return r;
		} else if (!strcmp(name,"open_drain")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_open_drain(tmp);
			return r;
		} else if (!strcmp(name,"init_high")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_init_high(tmp);
			return r;
		}
	}
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"pwm_ch")) {
		if (value == 0) {
			clear_pwm_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_pwm_ch,value);
		return r;
	}
	return -181;
}

OneWireConfig::OneWireConfig()
{
}

void OneWireConfig::clear()
{
	m_gpio = -1;
	m_pullup = false;
	m_power = -1;
}

void OneWireConfig::toASCII(stream &o, size_t indent) const
{
	o << "OneWireConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_bool(o, indent, "pullup", m_pullup);
	ascii_numeric(o, indent, "power", (signed) m_power);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t OneWireConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -182;
		a += x;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x13:	// pullup id 2, type bool, coding 8bit
			set_pullup(ud.u8);
			break;
		case 0x18:	// power id 3, type int8_t, coding signed varint
			set_power(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -183;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -184;
	return a-(const uint8_t *)b;
}

ssize_t OneWireConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -185;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -186;
		a += n;
	}
	// has pullup?
	if (m_pullup != false) {
		// 'pullup': id=2, encoding=8bit, tag=0x13
		if (2 > (e-a))
			return -187;
		*a++ = 0x13;
		*a++ = m_pullup;
	}
	// has power?
	if (m_power != -1) {
		// 'power': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -188;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_power));
		if (n <= 0)
			return -189;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void OneWireConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_pullup()) {
		fsep = json_indent(json,indLvl,fsep,"pullup");
		json << (m_pullup ? "true" : "false");
	}
	if (has_power()) {
		fsep = json_indent(json,indLvl,fsep,"power");
		to_decstr(json,(int) m_power);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t OneWireConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// optional bool pullup, id 2
	if (has_pullup()) {
		r += 2;
	}
	// optional sint8 power, id 3
	if (has_power()) {
		r += wiresize_s((varint_t)m_power) + 1 /* tag(power) 0x18 */;
	}
	return r;
}

bool OneWireConfig::operator == (const OneWireConfig &r) const
{
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_pullup() && (!(m_pullup == r.m_pullup)))
		return false;
	if (has_power() && (!(m_power == r.m_power)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int OneWireConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == strcmp(name,"pullup")) {
		if (value == 0) {
			clear_pullup();
			return 0;
		}
		int r = parse_ascii_bool(&m_pullup,value);
		return r;
	}
	if (0 == strcmp(name,"power")) {
		if (value == 0) {
			clear_power();
			return 0;
		}
		int r = parse_ascii_s8(&m_power,value);
		return r;
	}
	return -190;
}

UartConfig::UartConfig()
{
}

void UartConfig::clear()
{
	m_port = -1;
}

void UartConfig::toASCII(stream &o, size_t indent) const
{
	o << "UartConfig {";
	++indent;
	ascii_numeric(o, indent, "port", (signed) m_port);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t UartConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -191;
		a += x;
		switch (fid) {
		case 0x8:	// port id 1, type int8_t, coding signed varint
			set_port(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -192;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -193;
	return a-(const uint8_t *)b;
}

ssize_t UartConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has port?
	if (m_port != -1) {
		// 'port': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -194;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_port));
		if (n <= 0)
			return -195;
		a += n;
	}
	// 'tx_gpio' is unused. Therefore no data will be written.
	// 'rx_gpio' is unused. Therefore no data will be written.
	// 'cts_gpio' is unused. Therefore no data will be written.
	// 'rts_gpio' is unused. Therefore no data will be written.
	assert(a <= e);
	return a-b;
}

void UartConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_port()) {
		fsep = json_indent(json,indLvl,fsep,"port");
		to_decstr(json,(int) m_port);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t UartConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 port, id 1
	if (has_port()) {
		r += wiresize_s((varint_t)m_port) + 1 /* tag(port) 0x8 */;
	}
	// unused optional sint8 tx_gpio, id 2
	// unused optional sint8 rx_gpio, id 3
	// unused optional sint8 cts_gpio, id 4
	// unused optional sint8 rts_gpio, id 5
	return r;
}

bool UartConfig::operator == (const UartConfig &r) const
{
	if (has_port() && (!(m_port == r.m_port)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int UartConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"port")) {
		if (value == 0) {
			clear_port();
			return 0;
		}
		int r = parse_ascii_s8(&m_port,value);
		return r;
	}
	return -196;
}

AdcChannel::AdcChannel()
{
}

void AdcChannel::clear()
{
	m_name.clear();
	m_unit = 0;
	m_ch = -1;
	m_atten = 0;
	m_interval = 0;
	m_window = 0;
	m_scale = 1;
	m_offset = 0;
	m_dim.clear();
	p_validbits = 0;
}

void AdcChannel::toASCII(stream &o, size_t indent) const
{
	o << "AdcChannel {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "unit", (unsigned) m_unit);
	ascii_numeric(o, indent, "ch", (signed) m_ch);
	ascii_numeric(o, indent, "atten", (unsigned) m_atten);
	ascii_numeric(o, indent, "interval", m_interval);
	ascii_numeric(o, indent, "window", (unsigned) m_window);
	ascii_numeric(o, indent, "scale", m_scale);
	ascii_numeric(o, indent, "offset", m_offset);
	ascii_string(o,indent,m_dim.data(),m_dim.size(),"dim");
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AdcChannel::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -197;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -198;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// unit id 2, type uint8_t, coding varint
			set_unit((uint8_t)ud.u32);
			break;
		case 0x18:	// ch id 3, type int8_t, coding signed varint
			set_ch(varint_sint(ud.u8));
			break;
		case 0x20:	// atten id 4, type uint8_t, coding varint
			set_atten((uint8_t)ud.u32);
			break;
		case 0x28:	// interval id 5, type uint16_t, coding varint
			set_interval((uint16_t)ud.u32);
			break;
		case 0x30:	// window id 6, type uint8_t, coding varint
			set_window((uint8_t)ud.u32);
			break;
		case 0x45:	// scale id 8, type float, coding 32bit
			set_scale(ud.f);
			break;
		case 0x4d:	// offset id 9, type float, coding 32bit
			set_offset(ud.f);
			break;
		case 0x52:	// dim id 10, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -199;
			}
			m_dim.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -200;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -201;
	return a-(const uint8_t *)b;
}

ssize_t AdcChannel::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -202;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -203;
		a += n;
	}
	// has unit?
	if (m_unit != 0) {
		// 'unit': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -204;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_unit);
		if (n <= 0)
			return -205;
		a += n;
	}
	// has ch?
	if (m_ch != -1) {
		// 'ch': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -206;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_ch));
		if (n <= 0)
			return -207;
		a += n;
	}
	// has atten?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'atten': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -208;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_atten);
		if (n <= 0)
			return -209;
		a += n;
	}
	// has interval?
	if (m_interval != 0) {
		// 'interval': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -210;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_interval);
		if (n <= 0)
			return -211;
		a += n;
	}
	// has window?
	if (m_window != 0) {
		// 'window': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -212;
		*a++ = 0x30;
		n = write_varint(a,e-a,m_window);
		if (n <= 0)
			return -213;
		a += n;
	}
	// has scale?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'scale': id=8, encoding=32bit, tag=0x45
		if (5 > (e-a))
			return -214;
		*a++ = 0x45;
		if ((e-a) < 4)
			return -215;
		write_u32(a,mangle_float(m_scale));
		a += 4;
	}
	// has offset?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'offset': id=9, encoding=32bit, tag=0x4d
		if (5 > (e-a))
			return -216;
		*a++ = 0x4d;
		if ((e-a) < 4)
			return -217;
		write_u32(a,mangle_float(m_offset));
		a += 4;
	}
	// has dim?
	if (!m_dim.empty()) {
		// 'dim': id=10, encoding=lenpfx, tag=0x52
		if (a >= e)
			return -218;
		*a++ = 0x52;
		n = encode_bytes(m_dim,a,e);
		if (n < 0)
			return -219;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void AdcChannel::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_unit()) {
		fsep = json_indent(json,indLvl,fsep,"unit");
		to_decstr(json,(unsigned) m_unit);
	}
	if (has_ch()) {
		fsep = json_indent(json,indLvl,fsep,"ch");
		to_decstr(json,(int) m_ch);
	}
	if (has_atten()) {
		fsep = json_indent(json,indLvl,fsep,"atten");
		to_decstr(json,(unsigned) m_atten);
	}
	if (has_interval()) {
		fsep = json_indent(json,indLvl,fsep,"interval");
		to_decstr(json,m_interval);
	}
	if (has_window()) {
		fsep = json_indent(json,indLvl,fsep,"window");
		to_decstr(json,(unsigned) m_window);
	}
	if (has_scale()) {
		fsep = json_indent(json,indLvl,fsep,"scale");
		to_dblstr(json,m_scale);
	}
	if (has_offset()) {
		fsep = json_indent(json,indLvl,fsep,"offset");
		to_dblstr(json,m_offset);
	}
	if (has_dim()) {
		fsep = json_indent(json,indLvl,fsep,"dim");
		json_cstr(json,m_dim.c_str());
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AdcChannel::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional uint8 unit, id 2
	if (has_unit()) {
		r += wiresize((varint_t)m_unit) + 1 /* tag(unit) 0x10 */;
	}
	// optional sint8 ch, id 3
	if (has_ch()) {
		r += wiresize_s((varint_t)m_ch) + 1 /* tag(ch) 0x18 */;
	}
	// optional uint8 atten, id 4
	if (has_atten()) {
		r += wiresize((varint_t)m_atten) + 1 /* tag(atten) 0x20 */;
	}
	// optional uint16 interval, id 5
	if (has_interval()) {
		r += wiresize((varint_t)m_interval) + 1 /* tag(interval) 0x28 */;
	}
	// optional uint8 window, id 6
	if (has_window()) {
		r += wiresize((varint_t)m_window) + 1 /* tag(window) 0x30 */;
	}
	// optional float scale, id 8
	if (has_scale()) {
		r += 5;
	}
	// optional float offset, id 9
	if (has_offset()) {
		r += 5;
	}
	// optional string dim, id 10
	if (has_dim()) {
		size_t dim_s = m_dim.size();
		r += dim_s + wiresize(dim_s) + 1 /* tag(dim) 0x50 */;
	}
	return r;
}

bool AdcChannel::operator == (const AdcChannel &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_unit() && (!(m_unit == r.m_unit)))
		return false;
	if (has_ch() && (!(m_ch == r.m_ch)))
		return false;
	if (has_atten() && (!(m_atten == r.m_atten)))
		return false;
	if (has_interval() && (!(m_interval == r.m_interval)))
		return false;
	if (has_window() && (!(m_window == r.m_window)))
		return false;
	if (has_scale() && (!(m_scale == r.m_scale)))
		return false;
	if (has_offset() && (!(m_offset == r.m_offset)))
		return false;
	if (has_dim() && (!(m_dim == r.m_dim)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AdcChannel::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"unit")) {
		if (value == 0) {
			clear_unit();
			return 0;
		}
		int r = parse_ascii_u8(&m_unit,value);
		return r;
	}
	if (0 == strcmp(name,"ch")) {
		if (value == 0) {
			clear_ch();
			return 0;
		}
		int r = parse_ascii_s8(&m_ch,value);
		return r;
	}
	if (0 == strcmp(name,"atten")) {
		if (value == 0) {
			clear_atten();
			return 0;
		}
		int r = parse_ascii_u8(&m_atten,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"interval")) {
		if (value == 0) {
			clear_interval();
			return 0;
		}
		int r = parse_ascii_u16(&m_interval,value);
		return r;
	}
	if (0 == strcmp(name,"window")) {
		if (value == 0) {
			clear_window();
			return 0;
		}
		int r = parse_ascii_u8(&m_window,value);
		return r;
	}
	if (0 == strcmp(name,"scale")) {
		if (value == 0) {
			clear_scale();
			return 0;
		}
		int r = parse_ascii_flt(&m_scale,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"offset")) {
		if (value == 0) {
			clear_offset();
			return 0;
		}
		int r = parse_ascii_flt(&m_offset,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == strcmp(name,"dim")) {
		if (value == 0) {
			clear_dim();
			return 0;
		}
		m_dim = value;
		int r = m_dim.size();
		return r;
	}
	return -220;
}

AdcConfig::AdcConfig()
{
}

void AdcConfig::clear()
{
	m_adc_name.clear();
	m_mode = 0;
	m_clk_div = 0;
	p_validbits = 0;
}

void AdcConfig::toASCII(stream &o, size_t indent) const
{
	o << "AdcConfig {";
	++indent;
	ascii_string(o,indent,m_adc_name.data(),m_adc_name.size(),"adc_name");
	ascii_numeric(o, indent, "mode", (unsigned) m_mode);
	ascii_numeric(o, indent, "clk_div", (unsigned) m_clk_div);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t AdcConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -221;
		a += x;
		switch (fid) {
		case 0xa:	// adc_name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -222;
			}
			m_adc_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x20:	// mode id 4, type uint8_t, coding varint
			set_mode((uint8_t)ud.u32);
			break;
		case 0x28:	// clk_div id 5, type uint8_t, coding varint
			set_clk_div((uint8_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -223;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -224;
	return a-(const uint8_t *)b;
}

ssize_t AdcConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has adc_name?
	if (!m_adc_name.empty()) {
		// 'adc_name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -225;
		*a++ = 0xa;
		n = encode_bytes(m_adc_name,a,e);
		if (n < 0)
			return -226;
		a += n;
	}
	// 'adc1_bits' is unused. Therefore no data will be written.
	// 'adc2_bits' is unused. Therefore no data will be written.
	// has mode?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'mode': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -227;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_mode);
		if (n <= 0)
			return -228;
		a += n;
	}
	// has clk_div?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'clk_div': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -229;
		*a++ = 0x28;
		n = write_varint(a,e-a,m_clk_div);
		if (n <= 0)
			return -230;
		a += n;
	}
	#ifdef CONFIG_IDF_TARGET_ESP32
	// 'hall_name' is unused. Therefore no data will be written.
	#endif // CONFIG_IDF_TARGET_ESP32
	// 'channels' is unused. Therefore no data will be written.
	assert(a <= e);
	return a-b;
}

void AdcConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_adc_name()) {
		fsep = json_indent(json,indLvl,fsep,"adc_name");
		json_cstr(json,m_adc_name.c_str());
	}
	if (has_mode()) {
		fsep = json_indent(json,indLvl,fsep,"mode");
		to_decstr(json,(unsigned) m_mode);
	}
	if (has_clk_div()) {
		fsep = json_indent(json,indLvl,fsep,"clk_div");
		to_decstr(json,(unsigned) m_clk_div);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t AdcConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string adc_name, id 1
	if (has_adc_name()) {
		size_t adc_name_s = m_adc_name.size();
		r += adc_name_s + wiresize(adc_name_s) + 1 /* tag(adc_name) 0x8 */;
	}
	// unused optional uint8 adc1_bits, id 2
	// unused optional uint8 adc2_bits, id 3
	// optional uint8 mode, id 4
	if (has_mode()) {
		r += wiresize((varint_t)m_mode) + 1 /* tag(mode) 0x20 */;
	}
	// optional uint8 clk_div, id 5
	if (has_clk_div()) {
		r += wiresize((varint_t)m_clk_div) + 1 /* tag(clk_div) 0x28 */;
	}
	#ifdef CONFIG_IDF_TARGET_ESP32
	// unused optional string hall_name, id 6
	#endif // CONFIG_IDF_TARGET_ESP32
	// unused repeated AdcChannel channels, id 7
	return r;
}

bool AdcConfig::operator == (const AdcConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_adc_name() && (!(m_adc_name == r.m_adc_name)))
		return false;
	if (has_mode() && (!(m_mode == r.m_mode)))
		return false;
	if (has_clk_div() && (!(m_clk_div == r.m_clk_div)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int AdcConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"adc_name")) {
		if (value == 0) {
			clear_adc_name();
			return 0;
		}
		m_adc_name = value;
		int r = m_adc_name.size();
		return r;
	}
	if (0 == strcmp(name,"mode")) {
		if (value == 0) {
			clear_mode();
			return 0;
		}
		int r = parse_ascii_u8(&m_mode,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"clk_div")) {
		if (value == 0) {
			clear_clk_div();
			return 0;
		}
		int r = parse_ascii_u8(&m_clk_div,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	return -231;
}

GpioConfig::GpioConfig()
{
}

void GpioConfig::clear()
{
	m_name.clear();
	m_gpio = -1;
	m_config = 0;
	p_validbits = 0;
}

void GpioConfig::toASCII(stream &o, size_t indent) const
{
	o << "GpioConfig {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_numeric(o, indent, "config", m_config);
	++indent;
	ascii_indent(o,indent);
	o << ".mode = " ;
	o << (unsigned) config_mode();
	o << ';';
	ascii_indent(o,indent);
	o << ".intrtype = " ;
	o << (unsigned) config_intrtype();
	o << ';';
	ascii_indent(o,indent);
	o << ".setinit";
	o << (config_setinit() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".initlvl";
	o << (config_initlvl() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pullup";
	o << (config_pullup() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pulldown";
	o << (config_pulldown() ? " = true;" : " = false;");
	--indent;
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t GpioConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -232;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -233;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// gpio id 2, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x18:	// config id 3, type gpiocfg_t, coding varint
			set_config((gpiocfg_t) (gpiocfg_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -234;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -235;
	return a-(const uint8_t *)b;
}

ssize_t GpioConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -236;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -237;
		a += n;
	}
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -238;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -239;
		a += n;
	}
	// has config?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'config': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -240;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_config);
		if (n <= 0)
			return -241;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void GpioConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (has_config()) {
		fsep = json_indent(json,indLvl,fsep,"config");
		json << m_config;
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t GpioConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional sint8 gpio, id 2
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x10 */;
	}
	// optional gpiocfg_t config, id 3
	if (has_config()) {
		r += wiresize((varint_t)m_config) + 1 /* tag(config) 0x18 */;
	}
	return r;
}

bool GpioConfig::operator == (const GpioConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (has_config() && (!(m_config == r.m_config)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int GpioConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if ((0 == memcmp(name,"config",6)) && ((name[6] == 0) || name[6] == '.')) {
		name += 6;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_config((gpiocfg_t)ull);
			else if (!strcmp(name,"mode"))
				set_config_mode((uint8_t)ull);
			else if (!strcmp(name,"intrtype"))
				set_config_intrtype((uint8_t)ull);
			else if (!strcmp(name,"setinit"))
				set_config_setinit((bool)ull);
			else if (!strcmp(name,"initlvl"))
				set_config_initlvl((bool)ull);
			else if (!strcmp(name,"pullup"))
				set_config_pullup((bool)ull);
			else if (!strcmp(name,"pulldown"))
				set_config_pulldown((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -242;
		} else if (!strcmp(name,"mode")) {
			uint8_t tmp;
			int r = parse_ascii_u8(&tmp,value);
			if (r > 0)
				set_config_mode(tmp);
			return r;
		} else if (!strcmp(name,"intrtype")) {
			uint8_t tmp;
			int r = parse_ascii_u8(&tmp,value);
			if (r > 0)
				set_config_intrtype(tmp);
			return r;
		} else if (!strcmp(name,"setinit")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_setinit(tmp);
			return r;
		} else if (!strcmp(name,"initlvl")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_initlvl(tmp);
			return r;
		} else if (!strcmp(name,"pullup")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_pullup(tmp);
			return r;
		} else if (!strcmp(name,"pulldown")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_config_pulldown(tmp);
			return r;
		}
	}
	return -243;
}

DisplayConfig::DisplayConfig()
{
}

void DisplayConfig::clear()
{
	m_type = dt_none;
	m_options = 0;
	m_maxx = 0;
	m_maxy = 1;
	m_skip_env.clear();
	p_validbits = 0;
}

void DisplayConfig::toASCII(stream &o, size_t indent) const
{
	o << "DisplayConfig {";
	++indent;
	ascii_indent(o,indent,"type");
	if (const char *v = disp_t_str(m_type))
		o << v;
	else
		o << m_type;
	o << ';';
	ascii_numeric(o, indent, "options", m_options);
	ascii_numeric(o, indent, "maxx", m_maxx);
	ascii_numeric(o, indent, "maxy", m_maxy);
	ascii_indent(o,indent);
	size_t s_skip_env = m_skip_env.size();
	o << "skip_env[" << s_skip_env << "] = {";
	++indent;
	for (size_t i = 0, e = s_skip_env; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_string(o,indent,m_skip_env[i].data(),m_skip_env[i].size(),0);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t DisplayConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -244;
		a += x;
		switch (fid) {
		case 0x8:	// type id 1, type disp_t, coding varint
			set_type((disp_t) (disp_t)ud.u32);
			break;
		case 0x10:	// options id 2, type uint32_t, coding varint
			set_options((uint32_t)ud.u32);
			break;
		case 0x18:	// maxx id 3, type uint32_t, coding varint
			set_maxx((uint32_t)ud.u32);
			break;
		case 0x20:	// maxy id 4, type uint32_t, coding varint
			set_maxy((uint32_t)ud.u32);
			break;
		case 0x2a:	// skip_env id 5, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -245;
			}
			m_skip_env.emplace_back((const char*)a,ud.vi);
			a += ud.vi;
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -246;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -247;
	return a-(const uint8_t *)b;
}

ssize_t DisplayConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has type?
	if (m_type != dt_none) {
		// 'type': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -248;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_type);
		if (n <= 0)
			return -249;
		a += n;
	}
	// has options?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'options': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -250;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_options);
		if (n <= 0)
			return -251;
		a += n;
	}
	// has maxx?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'maxx': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -252;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_maxx);
		if (n <= 0)
			return -253;
		a += n;
	}
	// has maxy?
	if (0 != (p_validbits & ((uint8_t)1U << 2))) {
		// 'maxy': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -254;
		*a++ = 0x20;
		n = write_varint(a,e-a,m_maxy);
		if (n <= 0)
			return -255;
		a += n;
	}
	for (const auto &x : m_skip_env) {
		// 'skip_env': id=5, encoding=lenpfx, tag=0x2a
		if (a >= e)
			return -256;
		*a++ = 0x2a;
		n = encode_bytes(x,a,e);
		if (n < 0)
			return -257;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void DisplayConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_type()) {
		fsep = json_indent(json,indLvl,fsep,"type");
		if (const char *v = disp_t_str(m_type)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_type;
		}
	}
	if (has_options()) {
		fsep = json_indent(json,indLvl,fsep,"options");
		to_decstr(json,m_options);
	}
	if (has_maxx()) {
		fsep = json_indent(json,indLvl,fsep,"maxx");
		to_decstr(json,m_maxx);
	}
	if (has_maxy()) {
		fsep = json_indent(json,indLvl,fsep,"maxy");
		to_decstr(json,m_maxy);
	}
	if (size_t s = m_skip_env.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"skip_env\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			json_cstr(json,m_skip_env[i].c_str());
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t DisplayConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional disp_t type, id 1
	if (has_type()) {
		r += wiresize((varint_t)m_type) + 1 /* tag(type) 0x8 */;
	}
	// optional unsigned options, id 2
	if (has_options()) {
		r += wiresize((varint_t)m_options) + 1 /* tag(options) 0x10 */;
	}
	// optional unsigned maxx, id 3
	if (has_maxx()) {
		r += wiresize((varint_t)m_maxx) + 1 /* tag(maxx) 0x18 */;
	}
	// optional unsigned maxy, id 4
	if (has_maxy()) {
		r += wiresize((varint_t)m_maxy) + 1 /* tag(maxy) 0x20 */;
	}
	// repeated string skip_env, id 5
	if (!m_skip_env.empty()) {
		// skip_env: repeated estring
		for (size_t x = 0, y = m_skip_env.size(); x < y; ++x) {
			size_t s = m_skip_env[x].size();
			r += wiresize(s);
			r += s + 1 /* tag(skip_env) 0x28 */;
		}
	}
	return r;
}

bool DisplayConfig::operator == (const DisplayConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_type() && (!(m_type == r.m_type)))
		return false;
	if (has_options() && (!(m_options == r.m_options)))
		return false;
	if (has_maxx() && (!(m_maxx == r.m_maxx)))
		return false;
	if (has_maxy() && (!(m_maxy == r.m_maxy)))
		return false;
	if (!(m_skip_env == r.m_skip_env))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int DisplayConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"type")) {
		if (value == 0) {
			clear_type();
			return 0;
		}
		disp_t v;
		size_t r = parse_ascii_disp_t(&v,value);
		if (r == 0)
			return -258;
		set_type(v);
		return r;
	}
	if (0 == strcmp(name,"options")) {
		if (value == 0) {
			clear_options();
			return 0;
		}
		int r = parse_ascii_u32(&m_options,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"maxx")) {
		if (value == 0) {
			clear_maxx();
			return 0;
		}
		int r = parse_ascii_u32(&m_maxx,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	if (0 == strcmp(name,"maxy")) {
		if (value == 0) {
			clear_maxy();
			return 0;
		}
		int r = parse_ascii_u32(&m_maxy,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 2);
		return r;
	}
	if (0 == memcmp(name,"skip_env",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_skip_env();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_skip_env.size();
				m_skip_env.resize(x+1);
				idxe = (char*)(name + 10);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+9)))
					return -259;
				if (m_skip_env.size() <= x)
					return -260;
				if ((idxe[1] == 0) && (value == 0)) {
					m_skip_env.erase(m_skip_env.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -261;
			m_skip_env[x] = value;
			return m_skip_env[x].size();
		}
	}
	return -262;
}

SpiDeviceConfig::SpiDeviceConfig()
{
}

void SpiDeviceConfig::clear()
{
	m_drv = spidrv_invalid;
	m_cs = -1;
	m_intr = -1;
	m_reset = -1;
	m_cd = -1;
	m_freq = 0;
}

void SpiDeviceConfig::toASCII(stream &o, size_t indent) const
{
	o << "SpiDeviceConfig {";
	++indent;
	ascii_indent(o,indent,"drv");
	if (const char *v = spidrv_t_str(m_drv))
		o << v;
	else
		o << m_drv;
	o << ';';
	ascii_numeric(o, indent, "cs", (signed) m_cs);
	ascii_numeric(o, indent, "intr", (signed) m_intr);
	ascii_numeric(o, indent, "reset", (signed) m_reset);
	ascii_numeric(o, indent, "cd", (signed) m_cd);
	ascii_numeric(o, indent, "freq", m_freq);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SpiDeviceConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -263;
		a += x;
		switch (fid) {
		case 0x8:	// drv id 1, type spidrv_t, coding varint
			set_drv((spidrv_t) (spidrv_t)ud.u32);
			break;
		case 0x10:	// cs id 2, type int8_t, coding signed varint
			set_cs(varint_sint(ud.u8));
			break;
		case 0x18:	// intr id 3, type int8_t, coding signed varint
			set_intr(varint_sint(ud.u8));
			break;
		case 0x20:	// reset id 4, type int8_t, coding signed varint
			set_reset(varint_sint(ud.u8));
			break;
		case 0x28:	// cd id 5, type int8_t, coding signed varint
			set_cd(varint_sint(ud.u8));
			break;
		case 0x30:	// freq id 6, type uint32_t, coding varint
			set_freq((uint32_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -264;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -265;
	return a-(const uint8_t *)b;
}

ssize_t SpiDeviceConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has drv?
	if (m_drv != spidrv_invalid) {
		// 'drv': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -266;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_drv);
		if (n <= 0)
			return -267;
		a += n;
	}
	// has cs?
	if (m_cs != -1) {
		// 'cs': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -268;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_cs));
		if (n <= 0)
			return -269;
		a += n;
	}
	// has intr?
	if (m_intr != -1) {
		// 'intr': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -270;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_intr));
		if (n <= 0)
			return -271;
		a += n;
	}
	// has reset?
	if (m_reset != -1) {
		// 'reset': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -272;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_reset));
		if (n <= 0)
			return -273;
		a += n;
	}
	// has cd?
	if (m_cd != -1) {
		// 'cd': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -274;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_cd));
		if (n <= 0)
			return -275;
		a += n;
	}
	// has freq?
	if (m_freq != 0) {
		// 'freq': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -276;
		*a++ = 0x30;
		n = write_varint(a,e-a,m_freq);
		if (n <= 0)
			return -277;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void SpiDeviceConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_drv()) {
		fsep = json_indent(json,indLvl,fsep,"drv");
		if (const char *v = spidrv_t_str(m_drv)) {
			json.put('"');
			json << v;
			json.put('"');
		} else {
			json << m_drv;
		}
	}
	if (has_cs()) {
		fsep = json_indent(json,indLvl,fsep,"cs");
		to_decstr(json,(int) m_cs);
	}
	if (has_intr()) {
		fsep = json_indent(json,indLvl,fsep,"intr");
		to_decstr(json,(int) m_intr);
	}
	if (has_reset()) {
		fsep = json_indent(json,indLvl,fsep,"reset");
		to_decstr(json,(int) m_reset);
	}
	if (has_cd()) {
		fsep = json_indent(json,indLvl,fsep,"cd");
		to_decstr(json,(int) m_cd);
	}
	if (has_freq()) {
		fsep = json_indent(json,indLvl,fsep,"freq");
		to_decstr(json,m_freq);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SpiDeviceConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional spidrv_t drv, id 1
	if (has_drv()) {
		r += wiresize((varint_t)m_drv) + 1 /* tag(drv) 0x8 */;
	}
	// optional sint8 cs, id 2
	if (has_cs()) {
		r += wiresize_s((varint_t)m_cs) + 1 /* tag(cs) 0x10 */;
	}
	// optional sint8 intr, id 3
	if (has_intr()) {
		r += wiresize_s((varint_t)m_intr) + 1 /* tag(intr) 0x18 */;
	}
	// optional sint8 reset, id 4
	if (has_reset()) {
		r += wiresize_s((varint_t)m_reset) + 1 /* tag(reset) 0x20 */;
	}
	// optional sint8 cd, id 5
	if (has_cd()) {
		r += wiresize_s((varint_t)m_cd) + 1 /* tag(cd) 0x28 */;
	}
	// optional unsigned freq, id 6
	if (has_freq()) {
		r += wiresize((varint_t)m_freq) + 1 /* tag(freq) 0x30 */;
	}
	return r;
}

bool SpiDeviceConfig::operator == (const SpiDeviceConfig &r) const
{
	if (has_drv() && (!(m_drv == r.m_drv)))
		return false;
	if (has_cs() && (!(m_cs == r.m_cs)))
		return false;
	if (has_intr() && (!(m_intr == r.m_intr)))
		return false;
	if (has_reset() && (!(m_reset == r.m_reset)))
		return false;
	if (has_cd() && (!(m_cd == r.m_cd)))
		return false;
	if (has_freq() && (!(m_freq == r.m_freq)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SpiDeviceConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"drv")) {
		if (value == 0) {
			clear_drv();
			return 0;
		}
		spidrv_t v;
		size_t r = parse_ascii_spidrv_t(&v,value);
		if (r == 0)
			return -278;
		set_drv(v);
		return r;
	}
	if (0 == strcmp(name,"cs")) {
		if (value == 0) {
			clear_cs();
			return 0;
		}
		int r = parse_ascii_s8(&m_cs,value);
		return r;
	}
	if (0 == strcmp(name,"intr")) {
		if (value == 0) {
			clear_intr();
			return 0;
		}
		int r = parse_ascii_s8(&m_intr,value);
		return r;
	}
	if (0 == strcmp(name,"reset")) {
		if (value == 0) {
			clear_reset();
			return 0;
		}
		int r = parse_ascii_s8(&m_reset,value);
		return r;
	}
	if (0 == strcmp(name,"cd")) {
		if (value == 0) {
			clear_cd();
			return 0;
		}
		int r = parse_ascii_s8(&m_cd,value);
		return r;
	}
	if (0 == strcmp(name,"freq")) {
		if (value == 0) {
			clear_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_freq,value);
		return r;
	}
	return -279;
}

SpiBusConfig::SpiBusConfig()
{
}

void SpiBusConfig::clear()
{
	m_host = -1;
	m_mosi = -1;
	m_miso = -1;
	m_sclk = -1;
	m_wp = -1;
	m_hold = -1;
	m_options = 0;
	m_dma = -1;
	m_devices.clear();
	p_validbits = 0;
}

void SpiBusConfig::toASCII(stream &o, size_t indent) const
{
	o << "SpiBusConfig {";
	++indent;
	ascii_numeric(o, indent, "host", (signed) m_host);
	ascii_numeric(o, indent, "mosi", (signed) m_mosi);
	ascii_numeric(o, indent, "miso", (signed) m_miso);
	ascii_numeric(o, indent, "sclk", (signed) m_sclk);
	ascii_numeric(o, indent, "wp", (signed) m_wp);
	ascii_numeric(o, indent, "hold", (signed) m_hold);
	ascii_numeric(o, indent, "options", (unsigned) m_options);
	++indent;
	ascii_indent(o,indent);
	o << ".txlsbfirst";
	o << (options_txlsbfirst() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".rxlsbfirst";
	o << (options_rxlsbfirst() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".mosi_as_miso";
	o << (options_mosi_as_miso() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".positive_cs";
	o << (options_positive_cs() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".full_duplex";
	o << (options_full_duplex() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pol_hi";
	o << (options_pol_hi() ? " = true;" : " = false;");
	ascii_indent(o,indent);
	o << ".pha_hi";
	o << (options_pha_hi() ? " = true;" : " = false;");
	--indent;
	ascii_numeric(o, indent, "dma", (signed) m_dma);
	ascii_indent(o,indent);
	size_t s_devices = m_devices.size();
	o << "devices[" << s_devices << "] = {";
	++indent;
	for (size_t i = 0, e = s_devices; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_devices[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SpiBusConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -280;
		a += x;
		switch (fid) {
		case 0x8:	// host id 1, type int8_t, coding signed varint
			set_host(varint_sint(ud.u8));
			break;
		case 0x10:	// mosi id 2, type int8_t, coding signed varint
			set_mosi(varint_sint(ud.u8));
			break;
		case 0x18:	// miso id 3, type int8_t, coding signed varint
			set_miso(varint_sint(ud.u8));
			break;
		case 0x20:	// sclk id 4, type int8_t, coding signed varint
			set_sclk(varint_sint(ud.u8));
			break;
		case 0x28:	// wp id 5, type int8_t, coding signed varint
			set_wp(varint_sint(ud.u8));
			break;
		case 0x30:	// hold id 6, type int8_t, coding signed varint
			set_hold(varint_sint(ud.u8));
			break;
		case 0x38:	// options id 7, type spiopt_t, coding varint
			set_options((spiopt_t) (spiopt_t)ud.u32);
			break;
		case 0x40:	// dma id 8, type int8_t, coding signed varint
			set_dma(varint_sint(ud.u8));
			break;
		case 0x4a:	// devices id 9, type SpiDeviceConfig, coding byte[]
			m_devices.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_devices.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -281;
				a += ud.vi;
			}
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -282;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -283;
	return a-(const uint8_t *)b;
}

ssize_t SpiBusConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has host?
	if (m_host != -1) {
		// 'host': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -284;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_host));
		if (n <= 0)
			return -285;
		a += n;
	}
	// has mosi?
	if (m_mosi != -1) {
		// 'mosi': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -286;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_mosi));
		if (n <= 0)
			return -287;
		a += n;
	}
	// has miso?
	if (m_miso != -1) {
		// 'miso': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -288;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_miso));
		if (n <= 0)
			return -289;
		a += n;
	}
	// has sclk?
	if (m_sclk != -1) {
		// 'sclk': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -290;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_sclk));
		if (n <= 0)
			return -291;
		a += n;
	}
	// has wp?
	if (m_wp != -1) {
		// 'wp': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -292;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_wp));
		if (n <= 0)
			return -293;
		a += n;
	}
	// has hold?
	if (m_hold != -1) {
		// 'hold': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -294;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_hold));
		if (n <= 0)
			return -295;
		a += n;
	}
	// has options?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'options': id=7, encoding=varint, tag=0x38
		if (a >= e)
			return -296;
		*a++ = 0x38;
		n = write_varint(a,e-a,m_options);
		if (n <= 0)
			return -297;
		a += n;
	}
	// has dma?
	if (m_dma != -1) {
		// 'dma': id=8, encoding=varint, tag=0x40
		if (a >= e)
			return -298;
		*a++ = 0x40;
		n = write_varint(a,e-a,sint_varint(m_dma));
		if (n <= 0)
			return -299;
		a += n;
	}
	for (const auto &x : m_devices) {
		// 'devices': id=9, encoding=lenpfx, tag=0x4a
		if (a >= e)
			return -300;
		*a++ = 0x4a;
		ssize_t devices_ws = x.calcSize();
		n = write_varint(a,e-a,devices_ws);
		a += n;
		if ((n <= 0) || (devices_ws > (e-a)))
			return -301;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == devices_ws);
	}
	assert(a <= e);
	return a-b;
}

void SpiBusConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_host()) {
		fsep = json_indent(json,indLvl,fsep,"host");
		to_decstr(json,(int) m_host);
	}
	if (has_mosi()) {
		fsep = json_indent(json,indLvl,fsep,"mosi");
		to_decstr(json,(int) m_mosi);
	}
	if (has_miso()) {
		fsep = json_indent(json,indLvl,fsep,"miso");
		to_decstr(json,(int) m_miso);
	}
	if (has_sclk()) {
		fsep = json_indent(json,indLvl,fsep,"sclk");
		to_decstr(json,(int) m_sclk);
	}
	if (has_wp()) {
		fsep = json_indent(json,indLvl,fsep,"wp");
		to_decstr(json,(int) m_wp);
	}
	if (has_hold()) {
		fsep = json_indent(json,indLvl,fsep,"hold");
		to_decstr(json,(int) m_hold);
	}
	if (has_options()) {
		fsep = json_indent(json,indLvl,fsep,"options");
		json << (unsigned) m_options;
	}
	if (has_dma()) {
		fsep = json_indent(json,indLvl,fsep,"dma");
		to_decstr(json,(int) m_dma);
	}
	if (size_t s = m_devices.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"devices\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_devices[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SpiBusConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 host, id 1
	if (has_host()) {
		r += wiresize_s((varint_t)m_host) + 1 /* tag(host) 0x8 */;
	}
	// optional sint8 mosi, id 2
	if (has_mosi()) {
		r += wiresize_s((varint_t)m_mosi) + 1 /* tag(mosi) 0x10 */;
	}
	// optional sint8 miso, id 3
	if (has_miso()) {
		r += wiresize_s((varint_t)m_miso) + 1 /* tag(miso) 0x18 */;
	}
	// optional sint8 sclk, id 4
	if (has_sclk()) {
		r += wiresize_s((varint_t)m_sclk) + 1 /* tag(sclk) 0x20 */;
	}
	// optional sint8 wp, id 5
	if (has_wp()) {
		r += wiresize_s((varint_t)m_wp) + 1 /* tag(wp) 0x28 */;
	}
	// optional sint8 hold, id 6
	if (has_hold()) {
		r += wiresize_s((varint_t)m_hold) + 1 /* tag(hold) 0x30 */;
	}
	// optional spiopt_t options, id 7
	if (has_options()) {
		r += wiresize((varint_t)m_options) + 1 /* tag(options) 0x38 */;
	}
	// optional sint8 dma, id 8
	if (has_dma()) {
		r += wiresize_s((varint_t)m_dma) + 1 /* tag(dma) 0x40 */;
	}
	// repeated SpiDeviceConfig devices, id 9
	// repeated message devices
	for (size_t x = 0, y = m_devices.size(); x < y; ++x) {
		size_t s = m_devices[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(devices) 0x48 */;
	}
	return r;
}

bool SpiBusConfig::operator == (const SpiBusConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_host() && (!(m_host == r.m_host)))
		return false;
	if (has_mosi() && (!(m_mosi == r.m_mosi)))
		return false;
	if (has_miso() && (!(m_miso == r.m_miso)))
		return false;
	if (has_sclk() && (!(m_sclk == r.m_sclk)))
		return false;
	if (has_wp() && (!(m_wp == r.m_wp)))
		return false;
	if (has_hold() && (!(m_hold == r.m_hold)))
		return false;
	if (has_options() && (!(m_options == r.m_options)))
		return false;
	if (has_dma() && (!(m_dma == r.m_dma)))
		return false;
	if (!(m_devices == r.m_devices))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SpiBusConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"host")) {
		if (value == 0) {
			clear_host();
			return 0;
		}
		int r = parse_ascii_s8(&m_host,value);
		return r;
	}
	if (0 == strcmp(name,"mosi")) {
		if (value == 0) {
			clear_mosi();
			return 0;
		}
		int r = parse_ascii_s8(&m_mosi,value);
		return r;
	}
	if (0 == strcmp(name,"miso")) {
		if (value == 0) {
			clear_miso();
			return 0;
		}
		int r = parse_ascii_s8(&m_miso,value);
		return r;
	}
	if (0 == strcmp(name,"sclk")) {
		if (value == 0) {
			clear_sclk();
			return 0;
		}
		int r = parse_ascii_s8(&m_sclk,value);
		return r;
	}
	if (0 == strcmp(name,"wp")) {
		if (value == 0) {
			clear_wp();
			return 0;
		}
		int r = parse_ascii_s8(&m_wp,value);
		return r;
	}
	if (0 == strcmp(name,"hold")) {
		if (value == 0) {
			clear_hold();
			return 0;
		}
		int r = parse_ascii_s8(&m_hold,value);
		return r;
	}
	if ((0 == memcmp(name,"options",7)) && ((name[7] == 0) || name[7] == '.')) {
		name += 7;
		char *eptr;
		unsigned long long ull = strtoull(value,&eptr,0);
		if (eptr != value) {
			if (*name++ == 0)
				set_options((spiopt_t)ull);
			else if (!strcmp(name,"txlsbfirst"))
				set_options_txlsbfirst((bool)ull);
			else if (!strcmp(name,"rxlsbfirst"))
				set_options_rxlsbfirst((bool)ull);
			else if (!strcmp(name,"mosi_as_miso"))
				set_options_mosi_as_miso((bool)ull);
			else if (!strcmp(name,"positive_cs"))
				set_options_positive_cs((bool)ull);
			else if (!strcmp(name,"full_duplex"))
				set_options_full_duplex((bool)ull);
			else if (!strcmp(name,"pol_hi"))
				set_options_pol_hi((bool)ull);
			else if (!strcmp(name,"pha_hi"))
				set_options_pha_hi((bool)ull);
			return eptr - value;
		}
		if (*name++ != '.') {
			return -302;
		} else if (!strcmp(name,"txlsbfirst")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_txlsbfirst(tmp);
			return r;
		} else if (!strcmp(name,"rxlsbfirst")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_rxlsbfirst(tmp);
			return r;
		} else if (!strcmp(name,"mosi_as_miso")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_mosi_as_miso(tmp);
			return r;
		} else if (!strcmp(name,"positive_cs")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_positive_cs(tmp);
			return r;
		} else if (!strcmp(name,"full_duplex")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_full_duplex(tmp);
			return r;
		} else if (!strcmp(name,"pol_hi")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_pol_hi(tmp);
			return r;
		} else if (!strcmp(name,"pha_hi")) {
			bool tmp;
			int r = parse_ascii_bool(&tmp,value);
			if (r > 0)
				set_options_pha_hi(tmp);
			return r;
		}
	}
	if (0 == strcmp(name,"dma")) {
		if (value == 0) {
			clear_dma();
			return 0;
		}
		int r = parse_ascii_s8(&m_dma,value);
		return r;
	}
	if (0 == memcmp(name,"devices",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_devices();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_devices.size();
				m_devices.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -303;
				if (m_devices.size() <= x)
					return -304;
				if ((idxe[1] == 0) && (value == 0)) {
					m_devices.erase(m_devices.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -305;
			return m_devices[x].setByName(idxe+2,value);
		}
	}
	return -306;
}

GpioCluster::GpioCluster()
{
}

void GpioCluster::clear()
{
	m_name.clear();
	m_base = 0;
	m_numio = 0;
	m_int_a = -1;
	m_int_b = -1;
}

void GpioCluster::toASCII(stream &o, size_t indent) const
{
	o << "GpioCluster {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_numeric(o, indent, "base", (unsigned) m_base);
	ascii_numeric(o, indent, "numio", (unsigned) m_numio);
	ascii_numeric(o, indent, "int_a", (signed) m_int_a);
	ascii_numeric(o, indent, "int_b", (signed) m_int_b);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t GpioCluster::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -307;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -308;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x10:	// base id 2, type uint8_t, coding varint
			set_base((uint8_t)ud.u32);
			break;
		case 0x18:	// numio id 3, type uint8_t, coding varint
			set_numio((uint8_t)ud.u32);
			break;
		case 0x20:	// int_a id 4, type int8_t, coding signed varint
			set_int_a(varint_sint(ud.u8));
			break;
		case 0x28:	// int_b id 5, type int8_t, coding signed varint
			set_int_b(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -309;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -310;
	return a-(const uint8_t *)b;
}

ssize_t GpioCluster::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -311;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -312;
		a += n;
	}
	// has base?
	if (m_base != 0) {
		// 'base': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -313;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_base);
		if (n <= 0)
			return -314;
		a += n;
	}
	// has numio?
	if (m_numio != 0) {
		// 'numio': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -315;
		*a++ = 0x18;
		n = write_varint(a,e-a,m_numio);
		if (n <= 0)
			return -316;
		a += n;
	}
	// has int_a?
	if (m_int_a != -1) {
		// 'int_a': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -317;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_int_a));
		if (n <= 0)
			return -318;
		a += n;
	}
	// has int_b?
	if (m_int_b != -1) {
		// 'int_b': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -319;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_int_b));
		if (n <= 0)
			return -320;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void GpioCluster::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (has_base()) {
		fsep = json_indent(json,indLvl,fsep,"base");
		to_decstr(json,(unsigned) m_base);
	}
	if (has_numio()) {
		fsep = json_indent(json,indLvl,fsep,"numio");
		to_decstr(json,(unsigned) m_numio);
	}
	if (has_int_a()) {
		fsep = json_indent(json,indLvl,fsep,"int_a");
		to_decstr(json,(int) m_int_a);
	}
	if (has_int_b()) {
		fsep = json_indent(json,indLvl,fsep,"int_b");
		to_decstr(json,(int) m_int_b);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t GpioCluster::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// optional uint8 base, id 2
	if (has_base()) {
		r += wiresize((varint_t)m_base) + 1 /* tag(base) 0x10 */;
	}
	// optional uint8 numio, id 3
	if (has_numio()) {
		r += wiresize((varint_t)m_numio) + 1 /* tag(numio) 0x18 */;
	}
	// optional sint8 int_a, id 4
	if (has_int_a()) {
		r += wiresize_s((varint_t)m_int_a) + 1 /* tag(int_a) 0x20 */;
	}
	// optional sint8 int_b, id 5
	if (has_int_b()) {
		r += wiresize_s((varint_t)m_int_b) + 1 /* tag(int_b) 0x28 */;
	}
	return r;
}

bool GpioCluster::operator == (const GpioCluster &r) const
{
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (has_base() && (!(m_base == r.m_base)))
		return false;
	if (has_numio() && (!(m_numio == r.m_numio)))
		return false;
	if (has_int_a() && (!(m_int_a == r.m_int_a)))
		return false;
	if (has_int_b() && (!(m_int_b == r.m_int_b)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int GpioCluster::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == strcmp(name,"base")) {
		if (value == 0) {
			clear_base();
			return 0;
		}
		int r = parse_ascii_u8(&m_base,value);
		return r;
	}
	if (0 == strcmp(name,"numio")) {
		if (value == 0) {
			clear_numio();
			return 0;
		}
		int r = parse_ascii_u8(&m_numio,value);
		return r;
	}
	if (0 == strcmp(name,"int_a")) {
		if (value == 0) {
			clear_int_a();
			return 0;
		}
		int r = parse_ascii_s8(&m_int_a,value);
		return r;
	}
	if (0 == strcmp(name,"int_b")) {
		if (value == 0) {
			clear_int_b();
			return 0;
		}
		int r = parse_ascii_s8(&m_int_b,value);
		return r;
	}
	return -321;
}

Hlw8012Config::Hlw8012Config()
{
}

void Hlw8012Config::clear()
{
	m_sel = -1;
	m_cf = -1;
	m_cf1 = -1;
}

void Hlw8012Config::toASCII(stream &o, size_t indent) const
{
	o << "Hlw8012Config {";
	++indent;
	ascii_numeric(o, indent, "sel", (signed) m_sel);
	ascii_numeric(o, indent, "cf", (signed) m_cf);
	ascii_numeric(o, indent, "cf1", (signed) m_cf1);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Hlw8012Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -322;
		a += x;
		switch (fid) {
		case 0x10:	// sel id 2, type int8_t, coding signed varint
			set_sel(varint_sint(ud.u8));
			break;
		case 0x18:	// cf id 3, type int8_t, coding signed varint
			set_cf(varint_sint(ud.u8));
			break;
		case 0x20:	// cf1 id 4, type int8_t, coding signed varint
			set_cf1(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -323;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -324;
	return a-(const uint8_t *)b;
}

ssize_t Hlw8012Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has sel?
	if (m_sel != -1) {
		// 'sel': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -325;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_sel));
		if (n <= 0)
			return -326;
		a += n;
	}
	// has cf?
	if (m_cf != -1) {
		// 'cf': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -327;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_cf));
		if (n <= 0)
			return -328;
		a += n;
	}
	// has cf1?
	if (m_cf1 != -1) {
		// 'cf1': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -329;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_cf1));
		if (n <= 0)
			return -330;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Hlw8012Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_sel()) {
		fsep = json_indent(json,indLvl,fsep,"sel");
		to_decstr(json,(int) m_sel);
	}
	if (has_cf()) {
		fsep = json_indent(json,indLvl,fsep,"cf");
		to_decstr(json,(int) m_cf);
	}
	if (has_cf1()) {
		fsep = json_indent(json,indLvl,fsep,"cf1");
		to_decstr(json,(int) m_cf1);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Hlw8012Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 sel, id 2
	if (has_sel()) {
		r += wiresize_s((varint_t)m_sel) + 1 /* tag(sel) 0x10 */;
	}
	// optional sint8 cf, id 3
	if (has_cf()) {
		r += wiresize_s((varint_t)m_cf) + 1 /* tag(cf) 0x18 */;
	}
	// optional sint8 cf1, id 4
	if (has_cf1()) {
		r += wiresize_s((varint_t)m_cf1) + 1 /* tag(cf1) 0x20 */;
	}
	return r;
}

bool Hlw8012Config::operator == (const Hlw8012Config &r) const
{
	if (has_sel() && (!(m_sel == r.m_sel)))
		return false;
	if (has_cf() && (!(m_cf == r.m_cf)))
		return false;
	if (has_cf1() && (!(m_cf1 == r.m_cf1)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Hlw8012Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"sel")) {
		if (value == 0) {
			clear_sel();
			return 0;
		}
		int r = parse_ascii_s8(&m_sel,value);
		return r;
	}
	if (0 == strcmp(name,"cf")) {
		if (value == 0) {
			clear_cf();
			return 0;
		}
		int r = parse_ascii_s8(&m_cf,value);
		return r;
	}
	if (0 == strcmp(name,"cf1")) {
		if (value == 0) {
			clear_cf1();
			return 0;
		}
		int r = parse_ascii_s8(&m_cf1,value);
		return r;
	}
	return -331;
}

SX1276Config::SX1276Config()
{
}

void SX1276Config::clear()
{
	m_dio0 = -1;
	m_dio1 = -1;
	m_dio2 = -1;
	m_dio3 = -1;
	m_dio4 = -1;
	m_dio5 = -1;
}

void SX1276Config::toASCII(stream &o, size_t indent) const
{
	o << "SX1276Config {";
	++indent;
	ascii_numeric(o, indent, "dio0", (signed) m_dio0);
	ascii_numeric(o, indent, "dio1", (signed) m_dio1);
	ascii_numeric(o, indent, "dio2", (signed) m_dio2);
	ascii_numeric(o, indent, "dio3", (signed) m_dio3);
	ascii_numeric(o, indent, "dio4", (signed) m_dio4);
	ascii_numeric(o, indent, "dio5", (signed) m_dio5);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t SX1276Config::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -332;
		a += x;
		switch (fid) {
		case 0x8:	// dio0 id 1, type int8_t, coding signed varint
			set_dio0(varint_sint(ud.u8));
			break;
		case 0x10:	// dio1 id 2, type int8_t, coding signed varint
			set_dio1(varint_sint(ud.u8));
			break;
		case 0x18:	// dio2 id 3, type int8_t, coding signed varint
			set_dio2(varint_sint(ud.u8));
			break;
		case 0x20:	// dio3 id 4, type int8_t, coding signed varint
			set_dio3(varint_sint(ud.u8));
			break;
		case 0x28:	// dio4 id 5, type int8_t, coding signed varint
			set_dio4(varint_sint(ud.u8));
			break;
		case 0x30:	// dio5 id 6, type int8_t, coding signed varint
			set_dio5(varint_sint(ud.u8));
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -333;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -334;
	return a-(const uint8_t *)b;
}

ssize_t SX1276Config::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has dio0?
	if (m_dio0 != -1) {
		// 'dio0': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -335;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_dio0));
		if (n <= 0)
			return -336;
		a += n;
	}
	// has dio1?
	if (m_dio1 != -1) {
		// 'dio1': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -337;
		*a++ = 0x10;
		n = write_varint(a,e-a,sint_varint(m_dio1));
		if (n <= 0)
			return -338;
		a += n;
	}
	// has dio2?
	if (m_dio2 != -1) {
		// 'dio2': id=3, encoding=varint, tag=0x18
		if (a >= e)
			return -339;
		*a++ = 0x18;
		n = write_varint(a,e-a,sint_varint(m_dio2));
		if (n <= 0)
			return -340;
		a += n;
	}
	// has dio3?
	if (m_dio3 != -1) {
		// 'dio3': id=4, encoding=varint, tag=0x20
		if (a >= e)
			return -341;
		*a++ = 0x20;
		n = write_varint(a,e-a,sint_varint(m_dio3));
		if (n <= 0)
			return -342;
		a += n;
	}
	// has dio4?
	if (m_dio4 != -1) {
		// 'dio4': id=5, encoding=varint, tag=0x28
		if (a >= e)
			return -343;
		*a++ = 0x28;
		n = write_varint(a,e-a,sint_varint(m_dio4));
		if (n <= 0)
			return -344;
		a += n;
	}
	// has dio5?
	if (m_dio5 != -1) {
		// 'dio5': id=6, encoding=varint, tag=0x30
		if (a >= e)
			return -345;
		*a++ = 0x30;
		n = write_varint(a,e-a,sint_varint(m_dio5));
		if (n <= 0)
			return -346;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void SX1276Config::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_dio0()) {
		fsep = json_indent(json,indLvl,fsep,"dio0");
		to_decstr(json,(int) m_dio0);
	}
	if (has_dio1()) {
		fsep = json_indent(json,indLvl,fsep,"dio1");
		to_decstr(json,(int) m_dio1);
	}
	if (has_dio2()) {
		fsep = json_indent(json,indLvl,fsep,"dio2");
		to_decstr(json,(int) m_dio2);
	}
	if (has_dio3()) {
		fsep = json_indent(json,indLvl,fsep,"dio3");
		to_decstr(json,(int) m_dio3);
	}
	if (has_dio4()) {
		fsep = json_indent(json,indLvl,fsep,"dio4");
		to_decstr(json,(int) m_dio4);
	}
	if (has_dio5()) {
		fsep = json_indent(json,indLvl,fsep,"dio5");
		to_decstr(json,(int) m_dio5);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t SX1276Config::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 dio0, id 1
	if (has_dio0()) {
		r += wiresize_s((varint_t)m_dio0) + 1 /* tag(dio0) 0x8 */;
	}
	// optional sint8 dio1, id 2
	if (has_dio1()) {
		r += wiresize_s((varint_t)m_dio1) + 1 /* tag(dio1) 0x10 */;
	}
	// optional sint8 dio2, id 3
	if (has_dio2()) {
		r += wiresize_s((varint_t)m_dio2) + 1 /* tag(dio2) 0x18 */;
	}
	// optional sint8 dio3, id 4
	if (has_dio3()) {
		r += wiresize_s((varint_t)m_dio3) + 1 /* tag(dio3) 0x20 */;
	}
	// optional sint8 dio4, id 5
	if (has_dio4()) {
		r += wiresize_s((varint_t)m_dio4) + 1 /* tag(dio4) 0x28 */;
	}
	// optional sint8 dio5, id 6
	if (has_dio5()) {
		r += wiresize_s((varint_t)m_dio5) + 1 /* tag(dio5) 0x30 */;
	}
	return r;
}

bool SX1276Config::operator == (const SX1276Config &r) const
{
	if (has_dio0() && (!(m_dio0 == r.m_dio0)))
		return false;
	if (has_dio1() && (!(m_dio1 == r.m_dio1)))
		return false;
	if (has_dio2() && (!(m_dio2 == r.m_dio2)))
		return false;
	if (has_dio3() && (!(m_dio3 == r.m_dio3)))
		return false;
	if (has_dio4() && (!(m_dio4 == r.m_dio4)))
		return false;
	if (has_dio5() && (!(m_dio5 == r.m_dio5)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int SX1276Config::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"dio0")) {
		if (value == 0) {
			clear_dio0();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio0,value);
		return r;
	}
	if (0 == strcmp(name,"dio1")) {
		if (value == 0) {
			clear_dio1();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio1,value);
		return r;
	}
	if (0 == strcmp(name,"dio2")) {
		if (value == 0) {
			clear_dio2();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio2,value);
		return r;
	}
	if (0 == strcmp(name,"dio3")) {
		if (value == 0) {
			clear_dio3();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio3,value);
		return r;
	}
	if (0 == strcmp(name,"dio4")) {
		if (value == 0) {
			clear_dio4();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio4,value);
		return r;
	}
	if (0 == strcmp(name,"dio5")) {
		if (value == 0) {
			clear_dio5();
			return 0;
		}
		int r = parse_ascii_s8(&m_dio5,value);
		return r;
	}
	return -347;
}

Tone::Tone()
{
}

void Tone::clear()
{
	m_freq = 0;
	m_duration = 0;
	p_validbits = 0;
}

void Tone::toASCII(stream &o, size_t indent) const
{
	o << "Tone {";
	++indent;
	ascii_numeric(o, indent, "freq", m_freq);
	ascii_numeric(o, indent, "duration", m_duration);
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Tone::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -348;
		a += x;
		switch (fid) {
		case 0x8:	// freq id 1, type uint32_t, coding varint
			set_freq((uint32_t)ud.u32);
			break;
		case 0x10:	// duration id 2, type uint32_t, coding varint
			set_duration((uint32_t)ud.u32);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -349;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -350;
	return a-(const uint8_t *)b;
}

ssize_t Tone::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has freq?
	if (0 != (p_validbits & ((uint8_t)1U << 0))) {
		// 'freq': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -351;
		*a++ = 0x8;
		n = write_varint(a,e-a,m_freq);
		if (n <= 0)
			return -352;
		a += n;
	}
	// has duration?
	if (0 != (p_validbits & ((uint8_t)1U << 1))) {
		// 'duration': id=2, encoding=varint, tag=0x10
		if (a >= e)
			return -353;
		*a++ = 0x10;
		n = write_varint(a,e-a,m_duration);
		if (n <= 0)
			return -354;
		a += n;
	}
	assert(a <= e);
	return a-b;
}

void Tone::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_freq()) {
		fsep = json_indent(json,indLvl,fsep,"freq");
		to_decstr(json,m_freq);
	}
	if (has_duration()) {
		fsep = json_indent(json,indLvl,fsep,"duration");
		to_decstr(json,m_duration);
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Tone::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional unsigned freq, id 1
	if (has_freq()) {
		r += wiresize((varint_t)m_freq) + 1 /* tag(freq) 0x8 */;
	}
	// optional unsigned duration, id 2
	if (has_duration()) {
		r += wiresize((varint_t)m_duration) + 1 /* tag(duration) 0x10 */;
	}
	return r;
}

bool Tone::operator == (const Tone &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_freq() && (!(m_freq == r.m_freq)))
		return false;
	if (has_duration() && (!(m_duration == r.m_duration)))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Tone::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"freq")) {
		if (value == 0) {
			clear_freq();
			return 0;
		}
		int r = parse_ascii_u32(&m_freq,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 0);
		return r;
	}
	if (0 == strcmp(name,"duration")) {
		if (value == 0) {
			clear_duration();
			return 0;
		}
		int r = parse_ascii_u32(&m_duration,value);
		if (r > 0)
			p_validbits |= ((uint8_t)1U << 1);
		return r;
	}
	return -355;
}

Melody::Melody()
{
}

void Melody::clear()
{
	m_name.clear();
	m_tones.clear();
}

void Melody::toASCII(stream &o, size_t indent) const
{
	o << "Melody {";
	++indent;
	ascii_string(o,indent,m_name.data(),m_name.size(),"name");
	ascii_indent(o,indent);
	size_t s_tones = m_tones.size();
	o << "tones[" << s_tones << "] = {";
	++indent;
	for (size_t i = 0, e = s_tones; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		ascii_numeric(o, indent, 0, m_tones[i]);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t Melody::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -356;
		a += x;
		switch (fid) {
		case 0xa:	// name id 1, type estring, coding byte[]
			if ((ssize_t)ud.vi > e-a) {
				return -357;
			}
			m_name.assign((const char*)a,ud.vi);
			a += ud.vi;
			break;
		case 0x14:	// tones id 2, type uint16_t, coding 16bit
			m_tones.push_back(ud.u16);
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -358;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -359;
	return a-(const uint8_t *)b;
}

ssize_t Melody::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has name?
	if (!m_name.empty()) {
		// 'name': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -360;
		*a++ = 0xa;
		n = encode_bytes(m_name,a,e);
		if (n < 0)
			return -361;
		a += n;
	}
	for (auto x : m_tones) {
		// 'tones': id=2, encoding=16bit, tag=0x14
		if (3 > (e-a))
			return -362;
		*a++ = 0x14;
		if ((e-a) < 2)
			return -363;
		write_u16(a,x);
		a += 2;
	}
	assert(a <= e);
	return a-b;
}

void Melody::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_name()) {
		fsep = json_indent(json,indLvl,fsep,"name");
		json_cstr(json,m_name.c_str());
	}
	if (size_t s = m_tones.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"tones\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			to_decstr(json,m_tones[i]);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t Melody::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional string name, id 1
	if (has_name()) {
		size_t name_s = m_name.size();
		r += name_s + wiresize(name_s) + 1 /* tag(name) 0x8 */;
	}
	// repeated fixed16 tones, id 2
	if (!m_tones.empty()) {
		// tones: non-packed, fixed size elements
		r += m_tones.size() * 3;	// including tag
	}
	return r;
}

bool Melody::operator == (const Melody &r) const
{
	if (has_name() && (!(m_name == r.m_name)))
		return false;
	if (!(m_tones == r.m_tones))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int Melody::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"name")) {
		if (value == 0) {
			clear_name();
			return 0;
		}
		m_name = value;
		int r = m_name.size();
		return r;
	}
	if (0 == memcmp(name,"tones",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_tones();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_tones.size();
				m_tones.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -364;
				if (m_tones.size() <= x)
					return -365;
				if ((idxe[1] == 0) && (value == 0)) {
					m_tones.erase(m_tones.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != 0)
				return -366;
			return parse_ascii_u16(&m_tones[x],value);
		}
	}
	return -367;
}

BuzzerConfig::BuzzerConfig()
{
}

void BuzzerConfig::clear()
{
	m_gpio = -1;
	m_melodies.clear();
}

void BuzzerConfig::toASCII(stream &o, size_t indent) const
{
	o << "BuzzerConfig {";
	++indent;
	ascii_numeric(o, indent, "gpio", (signed) m_gpio);
	ascii_indent(o,indent);
	size_t s_melodies = m_melodies.size();
	o << "melodies[" << s_melodies << "] = {";
	++indent;
	for (size_t i = 0, e = s_melodies; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_melodies[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t BuzzerConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -368;
		a += x;
		switch (fid) {
		case 0x8:	// gpio id 1, type int8_t, coding signed varint
			set_gpio(varint_sint(ud.u8));
			break;
		case 0x12:	// melodies id 2, type Melody, coding byte[]
			m_melodies.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_melodies.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -369;
				a += ud.vi;
			}
			break;
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -370;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -371;
	return a-(const uint8_t *)b;
}

ssize_t BuzzerConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has gpio?
	if (m_gpio != -1) {
		// 'gpio': id=1, encoding=varint, tag=0x8
		if (a >= e)
			return -372;
		*a++ = 0x8;
		n = write_varint(a,e-a,sint_varint(m_gpio));
		if (n <= 0)
			return -373;
		a += n;
	}
	for (const auto &x : m_melodies) {
		// 'melodies': id=2, encoding=lenpfx, tag=0x12
		if (a >= e)
			return -374;
		*a++ = 0x12;
		ssize_t melodies_ws = x.calcSize();
		n = write_varint(a,e-a,melodies_ws);
		a += n;
		if ((n <= 0) || (melodies_ws > (e-a)))
			return -375;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == melodies_ws);
	}
	assert(a <= e);
	return a-b;
}

void BuzzerConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_gpio()) {
		fsep = json_indent(json,indLvl,fsep,"gpio");
		to_decstr(json,(int) m_gpio);
	}
	if (size_t s = m_melodies.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"melodies\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_melodies[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t BuzzerConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional sint8 gpio, id 1
	if (has_gpio()) {
		r += wiresize_s((varint_t)m_gpio) + 1 /* tag(gpio) 0x8 */;
	}
	// repeated Melody melodies, id 2
	// repeated message melodies
	for (size_t x = 0, y = m_melodies.size(); x < y; ++x) {
		size_t s = m_melodies[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(melodies) 0x10 */;
	}
	return r;
}

bool BuzzerConfig::operator == (const BuzzerConfig &r) const
{
	if (has_gpio() && (!(m_gpio == r.m_gpio)))
		return false;
	if (!(m_melodies == r.m_melodies))
		return false;
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int BuzzerConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"gpio")) {
		if (value == 0) {
			clear_gpio();
			return 0;
		}
		int r = parse_ascii_s8(&m_gpio,value);
		return r;
	}
	if (0 == memcmp(name,"melodies",8)) {
		if ((name[8] == 0) && (value == 0)) {
			clear_melodies();
			return 0;
		} else if (name[8] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[9] == '+') && (name[10] == ']')) {
				x = m_melodies.size();
				m_melodies.resize(x+1);
				idxe = (char*)(name + 10);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+9,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+9)))
					return -376;
				if (m_melodies.size() <= x)
					return -377;
				if ((idxe[1] == 0) && (value == 0)) {
					m_melodies.erase(m_melodies.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -378;
			return m_melodies[x].setByName(idxe+2,value);
		}
	}
	return -379;
}

HardwareConfig::HardwareConfig()
{
}

void HardwareConfig::clear()
{
	m_magic = 0;
	m_system.clear();
	m_adc.clear();
	m_gpios.clear();
	#ifdef CONFIG_SPI
	m_spibus.clear();
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	m_button.clear();
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	m_relay.clear();
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	m_led.clear();
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	m_buzzer.clear();
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	m_hlw8012.clear();
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	m_max7219.clear();
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	m_tlc5947.clear();
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	m_ws2812b.clear();
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	m_dht.clear();
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	m_i2c.clear();
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	m_hcsr04.clear();
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	m_onewire.clear();
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	m_sx1276.clear();
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	m_iocluster.clear();
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	m_display.clear();
	#endif // CONFIG_DISPLAY
	p_validbits = 0;
}

void HardwareConfig::toASCII(stream &o, size_t indent) const
{
	o << "HardwareConfig {";
	++indent;
	ascii_numeric(o, indent, "magic", m_magic);
	ascii_indent(o,indent,"system");
	m_system.toASCII(o,indent);
	ascii_indent(o,indent,"adc");
	m_adc.toASCII(o,indent);
	ascii_indent(o,indent);
	size_t s_gpios = m_gpios.size();
	o << "gpios[" << s_gpios << "] = {";
	++indent;
	for (size_t i = 0, e = s_gpios; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_gpios[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#ifdef CONFIG_SPI
	ascii_indent(o,indent);
	size_t s_spibus = m_spibus.size();
	o << "spibus[" << s_spibus << "] = {";
	++indent;
	for (size_t i = 0, e = s_spibus; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_spibus[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	ascii_indent(o,indent);
	size_t s_button = m_button.size();
	o << "button[" << s_button << "] = {";
	++indent;
	for (size_t i = 0, e = s_button; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_button[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	ascii_indent(o,indent);
	size_t s_relay = m_relay.size();
	o << "relay[" << s_relay << "] = {";
	++indent;
	for (size_t i = 0, e = s_relay; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_relay[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	ascii_indent(o,indent);
	size_t s_led = m_led.size();
	o << "led[" << s_led << "] = {";
	++indent;
	for (size_t i = 0, e = s_led; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_led[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	ascii_indent(o,indent,"buzzer");
	m_buzzer.toASCII(o,indent);
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	ascii_indent(o,indent,"hlw8012");
	m_hlw8012.toASCII(o,indent);
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	ascii_indent(o,indent,"max7219");
	m_max7219.toASCII(o,indent);
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	ascii_indent(o,indent,"tlc5947");
	m_tlc5947.toASCII(o,indent);
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	ascii_indent(o,indent);
	size_t s_ws2812b = m_ws2812b.size();
	o << "ws2812b[" << s_ws2812b << "] = {";
	++indent;
	for (size_t i = 0, e = s_ws2812b; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_ws2812b[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	ascii_indent(o,indent,"dht");
	m_dht.toASCII(o,indent);
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	ascii_indent(o,indent);
	size_t s_i2c = m_i2c.size();
	o << "i2c[" << s_i2c << "] = {";
	++indent;
	for (size_t i = 0, e = s_i2c; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_i2c[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	ascii_indent(o,indent);
	size_t s_hcsr04 = m_hcsr04.size();
	o << "hcsr04[" << s_hcsr04 << "] = {";
	++indent;
	for (size_t i = 0, e = s_hcsr04; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_hcsr04[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	ascii_indent(o,indent,"onewire");
	m_onewire.toASCII(o,indent);
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	ascii_indent(o,indent,"sx1276");
	m_sx1276.toASCII(o,indent);
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	ascii_indent(o,indent);
	size_t s_iocluster = m_iocluster.size();
	o << "iocluster[" << s_iocluster << "] = {";
	++indent;
	for (size_t i = 0, e = s_iocluster; i != e; ++i) {
		ascii_indent(o,indent);
		o << i << ": ";
		m_iocluster[i].toASCII(o,indent);
	}
	--indent;
	ascii_indent(o,indent);
	o << '}';
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	ascii_indent(o,indent,"display");
	m_display.toASCII(o,indent);
	#endif // CONFIG_DISPLAY
	--indent;
	ascii_indent(o,indent);
	o << '}';
}

ssize_t HardwareConfig::fromMemory(const void *b, ssize_t s)
{
	const uint8_t *a = (const uint8_t *)b;
	const uint8_t *e = a + s;
	while (a < e) {
		varint_t fid;
		union decode_union ud;
		ssize_t x = decode_early(a,e,&ud,&fid);
		if (x < 0)
			return -380;
		a += x;
		switch (fid) {
		case 0x5:	// magic id 0, type uint32_t, coding 32bit
			set_magic(ud.u32);
			break;
		case 0xa:	// system id 1, type SystemConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_system.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -381;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 1);
			break;
		case 0x22:	// adc id 4, type AdcConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_adc.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -382;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 2);
			break;
		case 0x3a:	// gpios id 7, type GpioConfig, coding byte[]
			m_gpios.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_gpios.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -383;
				a += ud.vi;
			}
			break;
			#ifdef CONFIG_SPI
		case 0x42:	// spibus id 8, type SpiBusConfig, coding byte[]
			m_spibus.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_spibus.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -384;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_SPI
			#ifdef CONFIG_BUTTON
		case 0x82:	// button id 16, type ButtonConfig, coding byte[]
			m_button.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_button.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -385;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_BUTTON
			#ifdef CONFIG_RELAY
		case 0x8a:	// relay id 17, type RelayConfig, coding byte[]
			m_relay.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_relay.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -386;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_RELAY
			#ifdef CONFIG_LEDS
		case 0x92:	// led id 18, type LedConfig, coding byte[]
			m_led.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_led.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -387;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_LEDS
			#ifdef CONFIG_BUZZER
		case 0x9a:	// buzzer id 19, type BuzzerConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_buzzer.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -388;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 3);
			break;
			#endif // CONFIG_BUZZER
			#ifdef CONFIG_HLW8012
		case 0xa2:	// hlw8012 id 20, type Hlw8012Config, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_hlw8012.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -389;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 4);
			break;
			#endif // CONFIG_HLW8012
			#ifdef CONFIG_MAX7219
		case 0x102:	// max7219 id 32, type Max7219Config, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_max7219.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -390;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 5);
			break;
			#endif // CONFIG_MAX7219
			#ifdef CONFIG_TLC5947
		case 0x10a:	// tlc5947 id 33, type Tlc5947Config, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_tlc5947.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -391;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 6);
			break;
			#endif // CONFIG_TLC5947
			#ifdef CONFIG_RGBLEDS
		case 0x112:	// ws2812b id 34, type Ws2812bConfig, coding byte[]
			m_ws2812b.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_ws2812b.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -392;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_RGBLEDS
			#ifdef CONFIG_DHT
		case 0x11a:	// dht id 35, type DhtConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_dht.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -393;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 7);
			break;
			#endif // CONFIG_DHT
			#ifdef CONFIG_I2C
		case 0x122:	// i2c id 36, type I2CConfig, coding byte[]
			m_i2c.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_i2c.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -394;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_I2C
			#ifdef CONFIG_HCSR04
		case 0x12a:	// hcsr04 id 37, type HcSr04Config, coding byte[]
			m_hcsr04.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_hcsr04.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -395;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_HCSR04
			#ifdef CONFIG_ONEWIRE
		case 0x132:	// onewire id 38, type OneWireConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_onewire.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -396;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 8);
			break;
			#endif // CONFIG_ONEWIRE
			#ifdef CONFIG_SX1276
		case 0x13a:	// sx1276 id 39, type SX1276Config, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_sx1276.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -397;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 9);
			break;
			#endif // CONFIG_SX1276
			#ifdef CONFIG_IOEXTENDERS
		case 0x142:	// iocluster id 40, type GpioCluster, coding byte[]
			m_iocluster.emplace_back();
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_iocluster.back().fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -398;
				a += ud.vi;
			}
			break;
			#endif // CONFIG_IOEXTENDERS
			#ifdef CONFIG_DISPLAY
		case 0x192:	// display id 50, type DisplayConfig, coding byte[]
			if (((ssize_t)ud.vi > 0) && ((ssize_t)ud.vi <= (e-a))) {
				int n;
				n = m_display.fromMemory((const uint8_t*)a,ud.vi);
				if (n != (ssize_t)ud.vi)
					return -399;
				a += ud.vi;
			}
			p_validbits |= ((uint16_t)1U << 10);
			break;
			#endif // CONFIG_DISPLAY
		default:
			if ((fid & 7) == 2) {
				// need only to skip len prefixed data
				a += ud.vi;
				if (a > e)
					return -400;
			}
		}
	}
	assert((a-(const uint8_t *)b) == s);
	if (a > e)
		return -401;
	return a-(const uint8_t *)b;
}

ssize_t HardwareConfig::toMemory(uint8_t *b, ssize_t s) const
{
	assert(s >= 0);
	uint8_t *a = b, *e = b + s;
	signed n;
	// has magic?
	if (0 != (p_validbits & ((uint16_t)1U << 0))) {
		// 'magic': id=0, encoding=32bit, tag=0x5
		if (5 > (e-a))
			return -402;
		*a++ = 0x5;
		if ((e-a) < 4)
			return -403;
		write_u32(a,(uint32_t)m_magic);
		a += 4;
	}
	// has system?
	if (0 != (p_validbits & ((uint16_t)1U << 1))) {
		// 'system': id=1, encoding=lenpfx, tag=0xa
		if (a >= e)
			return -404;
		*a++ = 0xa;
		ssize_t system_ws = m_system.calcSize();
		n = write_varint(a,e-a,system_ws);
		a += n;
		if ((n <= 0) || (system_ws > (e-a)))
			return -405;
		n = m_system.toMemory(a,e-a);
		a += n;
		assert(n == system_ws);
	}
	// 'uart' is unused. Therefore no data will be written.
	// has adc?
	if (0 != (p_validbits & ((uint16_t)1U << 2))) {
		// 'adc': id=4, encoding=lenpfx, tag=0x22
		if (a >= e)
			return -406;
		*a++ = 0x22;
		ssize_t adc_ws = m_adc.calcSize();
		n = write_varint(a,e-a,adc_ws);
		a += n;
		if ((n <= 0) || (adc_ws > (e-a)))
			return -407;
		n = m_adc.toMemory(a,e-a);
		a += n;
		assert(n == adc_ws);
	}
	#ifdef CONFIG_TOUCHPAD
	// 'touchpad' is unused. Therefore no data will be written.
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	// 'tp_channel' is unused. Therefore no data will be written.
	#endif // CONFIG_TOUCHPAD
	for (const auto &x : m_gpios) {
		// 'gpios': id=7, encoding=lenpfx, tag=0x3a
		if (a >= e)
			return -408;
		*a++ = 0x3a;
		ssize_t gpios_ws = x.calcSize();
		n = write_varint(a,e-a,gpios_ws);
		a += n;
		if ((n <= 0) || (gpios_ws > (e-a)))
			return -409;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == gpios_ws);
	}
	#ifdef CONFIG_SPI
	for (const auto &x : m_spibus) {
		// 'spibus': id=8, encoding=lenpfx, tag=0x42
		if (a >= e)
			return -410;
		*a++ = 0x42;
		ssize_t spibus_ws = x.calcSize();
		n = write_varint(a,e-a,spibus_ws);
		a += n;
		if ((n <= 0) || (spibus_ws > (e-a)))
			return -411;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == spibus_ws);
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	for (const auto &x : m_button) {
		// 'button': id=16, encoding=lenpfx, tag=0x82
		if (2 > (e-a))
			return -412;
		*a++ = 0x82;
		*a++ = 0x1;
		ssize_t button_ws = x.calcSize();
		n = write_varint(a,e-a,button_ws);
		a += n;
		if ((n <= 0) || (button_ws > (e-a)))
			return -413;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == button_ws);
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	for (const auto &x : m_relay) {
		// 'relay': id=17, encoding=lenpfx, tag=0x8a
		if (2 > (e-a))
			return -414;
		*a++ = 0x8a;
		*a++ = 0x1;
		ssize_t relay_ws = x.calcSize();
		n = write_varint(a,e-a,relay_ws);
		a += n;
		if ((n <= 0) || (relay_ws > (e-a)))
			return -415;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == relay_ws);
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	for (const auto &x : m_led) {
		// 'led': id=18, encoding=lenpfx, tag=0x92
		if (2 > (e-a))
			return -416;
		*a++ = 0x92;
		*a++ = 0x1;
		ssize_t led_ws = x.calcSize();
		n = write_varint(a,e-a,led_ws);
		a += n;
		if ((n <= 0) || (led_ws > (e-a)))
			return -417;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == led_ws);
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	// has buzzer?
	if (0 != (p_validbits & ((uint16_t)1U << 3))) {
		// 'buzzer': id=19, encoding=lenpfx, tag=0x9a
		if (2 > (e-a))
			return -418;
		*a++ = 0x9a;
		*a++ = 0x1;
		ssize_t buzzer_ws = m_buzzer.calcSize();
		n = write_varint(a,e-a,buzzer_ws);
		a += n;
		if ((n <= 0) || (buzzer_ws > (e-a)))
			return -419;
		n = m_buzzer.toMemory(a,e-a);
		a += n;
		assert(n == buzzer_ws);
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	// has hlw8012?
	if (0 != (p_validbits & ((uint16_t)1U << 4))) {
		// 'hlw8012': id=20, encoding=lenpfx, tag=0xa2
		if (2 > (e-a))
			return -420;
		*a++ = 0xa2;
		*a++ = 0x1;
		ssize_t hlw8012_ws = m_hlw8012.calcSize();
		n = write_varint(a,e-a,hlw8012_ws);
		a += n;
		if ((n <= 0) || (hlw8012_ws > (e-a)))
			return -421;
		n = m_hlw8012.toMemory(a,e-a);
		a += n;
		assert(n == hlw8012_ws);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	// has max7219?
	if (0 != (p_validbits & ((uint16_t)1U << 5))) {
		// 'max7219': id=32, encoding=lenpfx, tag=0x102
		if (2 > (e-a))
			return -422;
		*a++ = 0x82;
		*a++ = 0x2;
		ssize_t max7219_ws = m_max7219.calcSize();
		n = write_varint(a,e-a,max7219_ws);
		a += n;
		if ((n <= 0) || (max7219_ws > (e-a)))
			return -423;
		n = m_max7219.toMemory(a,e-a);
		a += n;
		assert(n == max7219_ws);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	// has tlc5947?
	if (0 != (p_validbits & ((uint16_t)1U << 6))) {
		// 'tlc5947': id=33, encoding=lenpfx, tag=0x10a
		if (2 > (e-a))
			return -424;
		*a++ = 0x8a;
		*a++ = 0x2;
		ssize_t tlc5947_ws = m_tlc5947.calcSize();
		n = write_varint(a,e-a,tlc5947_ws);
		a += n;
		if ((n <= 0) || (tlc5947_ws > (e-a)))
			return -425;
		n = m_tlc5947.toMemory(a,e-a);
		a += n;
		assert(n == tlc5947_ws);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	for (const auto &x : m_ws2812b) {
		// 'ws2812b': id=34, encoding=lenpfx, tag=0x112
		if (2 > (e-a))
			return -426;
		*a++ = 0x92;
		*a++ = 0x2;
		ssize_t ws2812b_ws = x.calcSize();
		n = write_varint(a,e-a,ws2812b_ws);
		a += n;
		if ((n <= 0) || (ws2812b_ws > (e-a)))
			return -427;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == ws2812b_ws);
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	// has dht?
	if (0 != (p_validbits & ((uint16_t)1U << 7))) {
		// 'dht': id=35, encoding=lenpfx, tag=0x11a
		if (2 > (e-a))
			return -428;
		*a++ = 0x9a;
		*a++ = 0x2;
		ssize_t dht_ws = m_dht.calcSize();
		n = write_varint(a,e-a,dht_ws);
		a += n;
		if ((n <= 0) || (dht_ws > (e-a)))
			return -429;
		n = m_dht.toMemory(a,e-a);
		a += n;
		assert(n == dht_ws);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	for (const auto &x : m_i2c) {
		// 'i2c': id=36, encoding=lenpfx, tag=0x122
		if (2 > (e-a))
			return -430;
		*a++ = 0xa2;
		*a++ = 0x2;
		ssize_t i2c_ws = x.calcSize();
		n = write_varint(a,e-a,i2c_ws);
		a += n;
		if ((n <= 0) || (i2c_ws > (e-a)))
			return -431;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == i2c_ws);
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	for (const auto &x : m_hcsr04) {
		// 'hcsr04': id=37, encoding=lenpfx, tag=0x12a
		if (2 > (e-a))
			return -432;
		*a++ = 0xaa;
		*a++ = 0x2;
		ssize_t hcsr04_ws = x.calcSize();
		n = write_varint(a,e-a,hcsr04_ws);
		a += n;
		if ((n <= 0) || (hcsr04_ws > (e-a)))
			return -433;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == hcsr04_ws);
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	// has onewire?
	if (0 != (p_validbits & ((uint16_t)1U << 8))) {
		// 'onewire': id=38, encoding=lenpfx, tag=0x132
		if (2 > (e-a))
			return -434;
		*a++ = 0xb2;
		*a++ = 0x2;
		ssize_t onewire_ws = m_onewire.calcSize();
		n = write_varint(a,e-a,onewire_ws);
		a += n;
		if ((n <= 0) || (onewire_ws > (e-a)))
			return -435;
		n = m_onewire.toMemory(a,e-a);
		a += n;
		assert(n == onewire_ws);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	// has sx1276?
	if (0 != (p_validbits & ((uint16_t)1U << 9))) {
		// 'sx1276': id=39, encoding=lenpfx, tag=0x13a
		if (2 > (e-a))
			return -436;
		*a++ = 0xba;
		*a++ = 0x2;
		ssize_t sx1276_ws = m_sx1276.calcSize();
		n = write_varint(a,e-a,sx1276_ws);
		a += n;
		if ((n <= 0) || (sx1276_ws > (e-a)))
			return -437;
		n = m_sx1276.toMemory(a,e-a);
		a += n;
		assert(n == sx1276_ws);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	for (const auto &x : m_iocluster) {
		// 'iocluster': id=40, encoding=lenpfx, tag=0x142
		if (2 > (e-a))
			return -438;
		*a++ = 0xc2;
		*a++ = 0x2;
		ssize_t iocluster_ws = x.calcSize();
		n = write_varint(a,e-a,iocluster_ws);
		a += n;
		if ((n <= 0) || (iocluster_ws > (e-a)))
			return -439;
		n = x.toMemory(a,e-a);
		a += n;
		assert(n == iocluster_ws);
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	// has display?
	if (0 != (p_validbits & ((uint16_t)1U << 10))) {
		// 'display': id=50, encoding=lenpfx, tag=0x192
		if (2 > (e-a))
			return -440;
		*a++ = 0x92;
		*a++ = 0x3;
		ssize_t display_ws = m_display.calcSize();
		n = write_varint(a,e-a,display_ws);
		a += n;
		if ((n <= 0) || (display_ws > (e-a)))
			return -441;
		n = m_display.toMemory(a,e-a);
		a += n;
		assert(n == display_ws);
	}
	#endif // CONFIG_DISPLAY
	assert(a <= e);
	return a-b;
}

void HardwareConfig::toJSON(stream &json, unsigned indLvl) const
{
	char fsep = '{';
	++indLvl;
	if (has_magic()) {
		fsep = json_indent(json,indLvl,fsep,"magic");
		to_decstr(json,m_magic);
	}
	if (has_system()) {
		fsep = json_indent(json,indLvl,fsep,"system");
		m_system.toJSON(json,indLvl);
	}
	if (has_adc()) {
		fsep = json_indent(json,indLvl,fsep,"adc");
		m_adc.toJSON(json,indLvl);
	}
	if (size_t s = m_gpios.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"gpios\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_gpios[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#ifdef CONFIG_SPI
	if (size_t s = m_spibus.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"spibus\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_spibus[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (size_t s = m_button.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"button\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_button[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (size_t s = m_relay.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"relay\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_relay[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (size_t s = m_led.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"led\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_led[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (has_buzzer()) {
		fsep = json_indent(json,indLvl,fsep,"buzzer");
		m_buzzer.toJSON(json,indLvl);
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (has_hlw8012()) {
		fsep = json_indent(json,indLvl,fsep,"hlw8012");
		m_hlw8012.toJSON(json,indLvl);
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (has_max7219()) {
		fsep = json_indent(json,indLvl,fsep,"max7219");
		m_max7219.toJSON(json,indLvl);
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (has_tlc5947()) {
		fsep = json_indent(json,indLvl,fsep,"tlc5947");
		m_tlc5947.toJSON(json,indLvl);
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (size_t s = m_ws2812b.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"ws2812b\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_ws2812b[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (has_dht()) {
		fsep = json_indent(json,indLvl,fsep,"dht");
		m_dht.toJSON(json,indLvl);
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (size_t s = m_i2c.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"i2c\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_i2c[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (size_t s = m_hcsr04.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"hcsr04\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_hcsr04[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (has_onewire()) {
		fsep = json_indent(json,indLvl,fsep,"onewire");
		m_onewire.toJSON(json,indLvl);
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (has_sx1276()) {
		fsep = json_indent(json,indLvl,fsep,"sx1276");
		m_sx1276.toJSON(json,indLvl);
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (size_t s = m_iocluster.size()) {
		fsep = json_indent(json,indLvl,fsep);
		indLvl += 2;
		json << "\"iocluster\":[\n";
		size_t i = 0;
		for (;;) {
			json_indent(json,indLvl,0);
			m_iocluster[i].toJSON(json,indLvl);
			++i;
			if (i == s)
				break;
			json << ",\n";
		}
		indLvl -= 2;
		json.put('\n');
		json_indent(json,indLvl,0);
		json.put(']');
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (has_display()) {
		fsep = json_indent(json,indLvl,fsep,"display");
		m_display.toJSON(json,indLvl);
	}
	#endif // CONFIG_DISPLAY
	if (fsep == '{')
		json.put('{');
	json.put('\n');
	--indLvl;
	json_indent(json,indLvl,0);
	json.put('}');
	if (indLvl == 0)
		json.put('\n');
}

size_t HardwareConfig::calcSize() const
{
	size_t r = 0;	// required size, default is fixed length
	// optional fixed32 magic, id 0
	if (has_magic()) {
		r += 5;
	}
	// optional SystemConfig system, id 1
	if (has_system()) {
		size_t system_s = m_system.calcSize();
		r += system_s + wiresize(system_s) + 1 /* tag(system) 0x8 */;
	}
	// unused repeated UartConfig uart, id 3
	// optional AdcConfig adc, id 4
	if (has_adc()) {
		size_t adc_s = m_adc.calcSize();
		r += adc_s + wiresize(adc_s) + 1 /* tag(adc) 0x20 */;
	}
	#ifdef CONFIG_TOUCHPAD
	// unused optional TouchpadConfig touchpad, id 5
	#endif // CONFIG_TOUCHPAD
	#ifdef CONFIG_TOUCHPAD
	// unused repeated TouchChannelConfig tp_channel, id 6
	#endif // CONFIG_TOUCHPAD
	// repeated GpioConfig gpios, id 7
	// repeated message gpios
	for (size_t x = 0, y = m_gpios.size(); x < y; ++x) {
		size_t s = m_gpios[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(gpios) 0x38 */;
	}
	#ifdef CONFIG_SPI
	// repeated SpiBusConfig spibus, id 8
	// repeated message spibus
	for (size_t x = 0, y = m_spibus.size(); x < y; ++x) {
		size_t s = m_spibus[x].calcSize();
		r += wiresize(s);
		r += s + 1 /* tag(spibus) 0x40 */;
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	// repeated ButtonConfig button, id 16
	// repeated message button
	for (size_t x = 0, y = m_button.size(); x < y; ++x) {
		size_t s = m_button[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(button) 0x80 */;
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	// repeated RelayConfig relay, id 17
	// repeated message relay
	for (size_t x = 0, y = m_relay.size(); x < y; ++x) {
		size_t s = m_relay[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(relay) 0x88 */;
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	// repeated LedConfig led, id 18
	// repeated message led
	for (size_t x = 0, y = m_led.size(); x < y; ++x) {
		size_t s = m_led[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(led) 0x90 */;
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	// optional BuzzerConfig buzzer, id 19
	if (has_buzzer()) {
		size_t buzzer_s = m_buzzer.calcSize();
		r += buzzer_s + wiresize(buzzer_s) + 2 /* tag(buzzer) 0x98 */;
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	// optional Hlw8012Config hlw8012, id 20
	if (has_hlw8012()) {
		size_t hlw8012_s = m_hlw8012.calcSize();
		r += hlw8012_s + wiresize(hlw8012_s) + 2 /* tag(hlw8012) 0xa0 */;
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	// optional Max7219Config max7219, id 32
	if (has_max7219()) {
		size_t max7219_s = m_max7219.calcSize();
		r += max7219_s + wiresize(max7219_s) + 2 /* tag(max7219) 0x100 */;
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	// optional Tlc5947Config tlc5947, id 33
	if (has_tlc5947()) {
		size_t tlc5947_s = m_tlc5947.calcSize();
		r += tlc5947_s + wiresize(tlc5947_s) + 2 /* tag(tlc5947) 0x108 */;
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	// repeated Ws2812bConfig ws2812b, id 34
	// repeated message ws2812b
	for (size_t x = 0, y = m_ws2812b.size(); x < y; ++x) {
		size_t s = m_ws2812b[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(ws2812b) 0x110 */;
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	// optional DhtConfig dht, id 35
	if (has_dht()) {
		size_t dht_s = m_dht.calcSize();
		r += dht_s + wiresize(dht_s) + 2 /* tag(dht) 0x118 */;
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	// repeated I2CConfig i2c, id 36
	// repeated message i2c
	for (size_t x = 0, y = m_i2c.size(); x < y; ++x) {
		size_t s = m_i2c[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(i2c) 0x120 */;
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	// repeated HcSr04Config hcsr04, id 37
	// repeated message hcsr04
	for (size_t x = 0, y = m_hcsr04.size(); x < y; ++x) {
		size_t s = m_hcsr04[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(hcsr04) 0x128 */;
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	// optional OneWireConfig onewire, id 38
	if (has_onewire()) {
		size_t onewire_s = m_onewire.calcSize();
		r += onewire_s + wiresize(onewire_s) + 2 /* tag(onewire) 0x130 */;
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	// optional SX1276Config sx1276, id 39
	if (has_sx1276()) {
		size_t sx1276_s = m_sx1276.calcSize();
		r += sx1276_s + wiresize(sx1276_s) + 2 /* tag(sx1276) 0x138 */;
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	// repeated GpioCluster iocluster, id 40
	// repeated message iocluster
	for (size_t x = 0, y = m_iocluster.size(); x < y; ++x) {
		size_t s = m_iocluster[x].calcSize();
		r += wiresize(s);
		r += s + 2 /* tag(iocluster) 0x140 */;
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	// optional DisplayConfig display, id 50
	if (has_display()) {
		size_t display_s = m_display.calcSize();
		r += display_s + wiresize(display_s) + 2 /* tag(display) 0x190 */;
	}
	#endif // CONFIG_DISPLAY
	return r;
}

bool HardwareConfig::operator == (const HardwareConfig &r) const
{
	if (p_validbits != r.p_validbits)
		return false;
	if (has_magic() && (!(m_magic == r.m_magic)))
		return false;
	if (has_system() && (!(m_system == r.m_system)))
		return false;
	if (has_adc() && (!(m_adc == r.m_adc)))
		return false;
	if (!(m_gpios == r.m_gpios))
		return false;
	#ifdef CONFIG_SPI
	if (!(m_spibus == r.m_spibus))
		return false;
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (!(m_button == r.m_button))
		return false;
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (!(m_relay == r.m_relay))
		return false;
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (!(m_led == r.m_led))
		return false;
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (has_buzzer() && (!(m_buzzer == r.m_buzzer)))
		return false;
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (has_hlw8012() && (!(m_hlw8012 == r.m_hlw8012)))
		return false;
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (has_max7219() && (!(m_max7219 == r.m_max7219)))
		return false;
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (has_tlc5947() && (!(m_tlc5947 == r.m_tlc5947)))
		return false;
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (!(m_ws2812b == r.m_ws2812b))
		return false;
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (has_dht() && (!(m_dht == r.m_dht)))
		return false;
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (!(m_i2c == r.m_i2c))
		return false;
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (!(m_hcsr04 == r.m_hcsr04))
		return false;
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (has_onewire() && (!(m_onewire == r.m_onewire)))
		return false;
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (has_sx1276() && (!(m_sx1276 == r.m_sx1276)))
		return false;
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (!(m_iocluster == r.m_iocluster))
		return false;
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (has_display() && (!(m_display == r.m_display)))
		return false;
	#endif // CONFIG_DISPLAY
	return true;
}


/*
 * Function for setting an element in dot notation with an ASCII value.
 * It will call the specified parse_ascii function for parsing the value.
 *
 * @return number of bytes successfully parsed or negative value indicating
 *         an error.
 */
int HardwareConfig::setByName(const char *name, const char *value)
{
	if (0 == strcmp(name,"magic")) {
		if (value == 0) {
			clear_magic();
			return 0;
		}
		int r = parse_ascii_u32(&m_magic,value);
		if (r > 0)
			p_validbits |= ((uint16_t)1U << 0);
		return r;
	}
	if (0 == memcmp(name,"system",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_system();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 1);
			return m_system.setByName(name+7,value);
		}
	}
	if (0 == memcmp(name,"adc",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_adc();
			return 0;
		} else if (name[3] == '.') {
			p_validbits |= ((uint16_t)1U << 2);
			return m_adc.setByName(name+4,value);
		}
	}
	if (0 == memcmp(name,"gpios",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_gpios();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_gpios.size();
				m_gpios.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -442;
				if (m_gpios.size() <= x)
					return -443;
				if ((idxe[1] == 0) && (value == 0)) {
					m_gpios.erase(m_gpios.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -444;
			return m_gpios[x].setByName(idxe+2,value);
		}
	}
	#ifdef CONFIG_SPI
	if (0 == memcmp(name,"spibus",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_spibus();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_spibus.size();
				m_spibus.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -445;
				if (m_spibus.size() <= x)
					return -446;
				if ((idxe[1] == 0) && (value == 0)) {
					m_spibus.erase(m_spibus.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -447;
			return m_spibus[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_SPI
	#ifdef CONFIG_BUTTON
	if (0 == memcmp(name,"button",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_button();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_button.size();
				m_button.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -448;
				if (m_button.size() <= x)
					return -449;
				if ((idxe[1] == 0) && (value == 0)) {
					m_button.erase(m_button.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -450;
			return m_button[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_BUTTON
	#ifdef CONFIG_RELAY
	if (0 == memcmp(name,"relay",5)) {
		if ((name[5] == 0) && (value == 0)) {
			clear_relay();
			return 0;
		} else if (name[5] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[6] == '+') && (name[7] == ']')) {
				x = m_relay.size();
				m_relay.resize(x+1);
				idxe = (char*)(name + 7);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+6,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+6)))
					return -451;
				if (m_relay.size() <= x)
					return -452;
				if ((idxe[1] == 0) && (value == 0)) {
					m_relay.erase(m_relay.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -453;
			return m_relay[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_RELAY
	#ifdef CONFIG_LEDS
	if (0 == memcmp(name,"led",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_led();
			return 0;
		} else if (name[3] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[4] == '+') && (name[5] == ']')) {
				x = m_led.size();
				m_led.resize(x+1);
				idxe = (char*)(name + 5);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+4,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+4)))
					return -454;
				if (m_led.size() <= x)
					return -455;
				if ((idxe[1] == 0) && (value == 0)) {
					m_led.erase(m_led.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -456;
			return m_led[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_LEDS
	#ifdef CONFIG_BUZZER
	if (0 == memcmp(name,"buzzer",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_buzzer();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 3);
			return m_buzzer.setByName(name+7,value);
		}
	}
	#endif // CONFIG_BUZZER
	#ifdef CONFIG_HLW8012
	if (0 == memcmp(name,"hlw8012",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_hlw8012();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 4);
			return m_hlw8012.setByName(name+8,value);
		}
	}
	#endif // CONFIG_HLW8012
	#ifdef CONFIG_MAX7219
	if (0 == memcmp(name,"max7219",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_max7219();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 5);
			return m_max7219.setByName(name+8,value);
		}
	}
	#endif // CONFIG_MAX7219
	#ifdef CONFIG_TLC5947
	if (0 == memcmp(name,"tlc5947",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_tlc5947();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 6);
			return m_tlc5947.setByName(name+8,value);
		}
	}
	#endif // CONFIG_TLC5947
	#ifdef CONFIG_RGBLEDS
	if (0 == memcmp(name,"ws2812b",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_ws2812b();
			return 0;
		} else if (name[7] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[8] == '+') && (name[9] == ']')) {
				x = m_ws2812b.size();
				m_ws2812b.resize(x+1);
				idxe = (char*)(name + 9);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+8,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+8)))
					return -457;
				if (m_ws2812b.size() <= x)
					return -458;
				if ((idxe[1] == 0) && (value == 0)) {
					m_ws2812b.erase(m_ws2812b.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -459;
			return m_ws2812b[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_RGBLEDS
	#ifdef CONFIG_DHT
	if (0 == memcmp(name,"dht",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_dht();
			return 0;
		} else if (name[3] == '.') {
			p_validbits |= ((uint16_t)1U << 7);
			return m_dht.setByName(name+4,value);
		}
	}
	#endif // CONFIG_DHT
	#ifdef CONFIG_I2C
	if (0 == memcmp(name,"i2c",3)) {
		if ((name[3] == 0) && (value == 0)) {
			clear_i2c();
			return 0;
		} else if (name[3] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[4] == '+') && (name[5] == ']')) {
				x = m_i2c.size();
				m_i2c.resize(x+1);
				idxe = (char*)(name + 5);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+4,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+4)))
					return -460;
				if (m_i2c.size() <= x)
					return -461;
				if ((idxe[1] == 0) && (value == 0)) {
					m_i2c.erase(m_i2c.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -462;
			return m_i2c[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_I2C
	#ifdef CONFIG_HCSR04
	if (0 == memcmp(name,"hcsr04",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_hcsr04();
			return 0;
		} else if (name[6] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[7] == '+') && (name[8] == ']')) {
				x = m_hcsr04.size();
				m_hcsr04.resize(x+1);
				idxe = (char*)(name + 8);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+7,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+7)))
					return -463;
				if (m_hcsr04.size() <= x)
					return -464;
				if ((idxe[1] == 0) && (value == 0)) {
					m_hcsr04.erase(m_hcsr04.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -465;
			return m_hcsr04[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_HCSR04
	#ifdef CONFIG_ONEWIRE
	if (0 == memcmp(name,"onewire",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_onewire();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 8);
			return m_onewire.setByName(name+8,value);
		}
	}
	#endif // CONFIG_ONEWIRE
	#ifdef CONFIG_SX1276
	if (0 == memcmp(name,"sx1276",6)) {
		if ((name[6] == 0) && (value == 0)) {
			clear_sx1276();
			return 0;
		} else if (name[6] == '.') {
			p_validbits |= ((uint16_t)1U << 9);
			return m_sx1276.setByName(name+7,value);
		}
	}
	#endif // CONFIG_SX1276
	#ifdef CONFIG_IOEXTENDERS
	if (0 == memcmp(name,"iocluster",9)) {
		if ((name[9] == 0) && (value == 0)) {
			clear_iocluster();
			return 0;
		} else if (name[9] == '[') {
			char *idxe;
			unsigned long x;
			if ((name[10] == '+') && (name[11] == ']')) {
				x = m_iocluster.size();
				m_iocluster.resize(x+1);
				idxe = (char*)(name + 11);
				if (value == 0)
					return 0;
			} else {
				x = strtoul(name+10,&idxe,0);
				if ((idxe[0] != ']') || (idxe == (name+10)))
					return -466;
				if (m_iocluster.size() <= x)
					return -467;
				if ((idxe[1] == 0) && (value == 0)) {
					m_iocluster.erase(m_iocluster.begin()+x);
					return 0;
				}
			}
			if (idxe[1] != '.')
				return -468;
			return m_iocluster[x].setByName(idxe+2,value);
		}
	}
	#endif // CONFIG_IOEXTENDERS
	#ifdef CONFIG_DISPLAY
	if (0 == memcmp(name,"display",7)) {
		if ((name[7] == 0) && (value == 0)) {
			clear_display();
			return 0;
		} else if (name[7] == '.') {
			p_validbits |= ((uint16_t)1U << 10);
			return m_display.setByName(name+8,value);
		}
	}
	#endif // CONFIG_DISPLAY
	return -469;
}

