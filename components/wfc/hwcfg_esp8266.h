/****************************************************************************
 * 
 * Code generated by Wire-Format-Compiler (WFC)
 * WFC Version: R2104.15 (hg:403/b1f5b8e6c836)
 * WFC is Copyright 2015-2021, Thomas Maier-Komor
 * 
 * Source Information:
 * ===================
 * Filename : hwcfg.wfc
 * Copyright: 2018-2021
 * Author   : Thomas Maier-Komor
 * 
 * Code generated on 2021-06-27, 23:06:09 (CET).
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 ****************************************************************************/


/*
 * options from commandline:
 * 
 * options from esp8266:
 * Optimize        : "size"
 * 
 * options from esp:
 * bytestype       : "estring"
 * intsize         : 32
 * SortMembers     : "size"
 * stringtype      : "estring"
 * toASCII         : "toASCII"
 * toSink          : ""
 * toString        : ""
 * toWire          : ""
 * varintbits      : 32
 * 
 * options from common:
 * wfclib          : "extern"
 * 
 * options from defaults:
 * AddPrefix       : "add_"
 * ascii_bytes     : "ascii_bytes"
 * ascii_indent    : "ascii_indent"
 * ascii_string    : "ascii_string"
 * author          : ""
 * BaseClass       : ""
 * calcSize        : "calcSize"
 * ClearName       : "clear"
 * ClearPrefix     : "clear_"
 * copyright       : ""
 * email           : ""
 * endian          : "unknown"
 * ErrorHandling   : "cancel"
 * fromMemory      : "fromMemory"
 * GetPrefix       : ""
 * HasPrefix       : "has_"
 * inline          : ""
 * json_indent     : "json_indent"
 * lang            : "c++"
 * MutablePrefix   : "mutable_"
 * namespace       : ""
 * SetByName       : "setByName"
 * SetPrefix       : "set_"
 * toJSON          : "toJSON"
 * toMemory        : "toMemory"
 * UnknownField    : "skip"
 * wireput         : ""
 * wiresize        : ""
 * 
 * disabled flags from esp8266:
 * 	withUnequal
 * enabled flags from esp:
 * 	enumnames, withEqual
 * enabled flags from common:
 * 	id0
 * disabled flags from defaults:
 * 	debug, enummap, SubClasses
 * enabled flags from defaults:
 * 	asserts, comments, genlib, gnux
 */

#ifndef HWCFG_H
#define HWCFG_H

#include <assert.h>
#define OUTPUT_TO_ASCII 1
#include <string>
/* std::map support not needed */
#include <vector>
/* array support not needed */
#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>

/* user requested header files */
#include "estring.h"
#include <sdkconfig.h>
#include "stream.h"
#ifdef WFC_ENDIAN
#if WFC_ENDIAN != 0
#error WFC generated code incompatible due to endian
#endif
#else
#define WFC_ENDIAN     0 // unknown endian
#endif

#define HAVE_TO_MEMORY 1
#define HAVE_TO_ASCII 1
#define HAVE_TO_JSON 1
#define HAVE_FROM_MEMORY 1
#define ON_ERROR_CANCEL 1
#define HAVE_ENUM_NAMES 1

/* wfc support functions not needed */

typedef _ssize_t ssize_t;
typedef uint32_t varint_t;

typedef int32_t varsint_t;


typedef enum {
	pull_none = 0,
	pull_en = 1,
	pull_down = 1,
	pull_dir = 2,
	pull_up = 3,
} pull_mode_t;
const char *pull_mode_t_str(pull_mode_t e);
size_t parse_ascii_pull_mode_t(pull_mode_t *, const char *);

typedef enum {
	rc_active_low = 0,
	rc_active_high = 1,
	rc_init_on = 2,
	rc_persistent = 4,
	rc_open_drain = 8,
	rc_mqtt = 16,
} relay_cfg_t;
const char *relay_cfg_t_str(relay_cfg_t e);
size_t parse_ascii_relay_cfg_t(relay_cfg_t *, const char *);

typedef enum {
	DHT_NONE = 0,
	RHT03 = 3,
	DHT11 = 11,
	DHT21 = 21,
	DHT22 = 22,
	AM2301 = 2301,
	AM2302 = 2302,
} dht_model_t;
const char *dht_model_t_str(dht_model_t e);
size_t parse_ascii_dht_model_t(dht_model_t *, const char *);

typedef enum {
	dt_none = 0,
	dt_sd_7seg = 1,
	dt_sd_14seg = 2,
	dt_pcf8574_hd44780u = 16,
	dt_ssd1306 = 32,
} disp_t;
const char *disp_t_str(disp_t e);
size_t parse_ascii_disp_t(disp_t *, const char *);

class SystemConfig
{
	public:
	SystemConfig();
	
	bool operator == (const SystemConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string manufacturer, id 1
	bool has_manufacturer() const;
	void clear_manufacturer();
	const estring &manufacturer() const;
	void set_manufacturer(const void *data, size_t s);
	void set_manufacturer(const estring & v);
	void set_manufacturer(const char *);
	estring *mutable_manufacturer();
	
	// string board_name, id 2
	bool has_board_name() const;
	void clear_board_name();
	const estring &board_name() const;
	void set_board_name(const void *data, size_t s);
	void set_board_name(const estring & v);
	void set_board_name(const char *);
	estring *mutable_board_name();
	
	// string board_rev, id 3
	bool has_board_rev() const;
	void clear_board_rev();
	const estring &board_rev() const;
	void set_board_rev(const void *data, size_t s);
	void set_board_rev(const estring & v);
	void set_board_rev(const char *);
	estring *mutable_board_rev();
	
	// sint8 diag_uart, id 4
	bool has_diag_uart() const;
	void clear_diag_uart();
	int8_t diag_uart() const;
	void set_diag_uart(int8_t  v);
	int8_t *mutable_diag_uart();
	
	// sint8 console_rx, id 5
	bool has_console_rx() const;
	void clear_console_rx();
	int8_t console_rx() const;
	void set_console_rx(int8_t  v);
	int8_t *mutable_console_rx();
	
	// sint8 console_tx, id 6
	bool has_console_tx() const;
	void clear_console_tx();
	int8_t console_tx() const;
	void set_console_tx(int8_t  v);
	int8_t *mutable_console_tx();
	
	// string model_name, id 7
	bool has_model_name() const;
	void clear_model_name();
	const estring &model_name() const;
	void set_model_name(const void *data, size_t s);
	void set_model_name(const estring & v);
	void set_model_name(const char *);
	estring *mutable_model_name();
	
	// string model_number, id 8
	bool has_model_number() const;
	void clear_model_number();
	const estring &model_number() const;
	void set_model_number(const void *data, size_t s);
	void set_model_number(const estring & v);
	void set_model_number(const char *);
	estring *mutable_model_number();
	
	
	protected:
	// string manufacturer, id 1
	estring m_manufacturer;
	// string board_name, id 2
	estring m_board_name;
	// string board_rev, id 3
	estring m_board_rev;
	// string model_name, id 7
	estring m_model_name;
	// string model_number, id 8
	estring m_model_number;
	// sint8 diag_uart, id 4
	int8_t m_diag_uart;
	// sint8 console_rx, id 5
	int8_t m_console_rx;
	// sint8 console_tx, id 6
	int8_t m_console_tx;
	
	private:
	uint8_t p_validbits;
};


class TouchpadConfig
{
	public:
	TouchpadConfig();
	
	bool operator == (const TouchpadConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// bool fsm_mode, id 1
	bool has_fsm_mode() const;
	void clear_fsm_mode();
	bool fsm_mode() const;
	void set_fsm_mode(bool  v);
	bool *mutable_fsm_mode();
	
	// sint8 lvolt, id 2
	bool has_lvolt() const;
	void clear_lvolt();
	int8_t lvolt() const;
	void set_lvolt(int8_t  v);
	int8_t *mutable_lvolt();
	
	// sint8 hvolt, id 3
	bool has_hvolt() const;
	void clear_hvolt();
	int8_t hvolt() const;
	void set_hvolt(int8_t  v);
	int8_t *mutable_hvolt();
	
	// sint8 atten, id 4
	bool has_atten() const;
	void clear_atten();
	int8_t atten() const;
	void set_atten(int8_t  v);
	int8_t *mutable_atten();
	
	// unsigned interval, id 7
	bool has_interval() const;
	void clear_interval();
	uint32_t interval() const;
	void set_interval(uint32_t  v);
	uint32_t *mutable_interval();
	
	
	protected:
	// unsigned interval, id 7
	uint32_t m_interval;
	// bool fsm_mode, id 1
	bool m_fsm_mode;
	// sint8 lvolt, id 2
	int8_t m_lvolt;
	// sint8 hvolt, id 3
	int8_t m_hvolt;
	// sint8 atten, id 4
	int8_t m_atten;
	
	private:
	uint8_t p_validbits;
};


class TouchChannelConfig
{
	public:
	TouchChannelConfig();
	
	bool operator == (const TouchChannelConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string name, id 1
	bool has_name() const;
	void clear_name();
	const estring &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const estring & v);
	void set_name(const char *);
	estring *mutable_name();
	
	// sint8 channel, id 2
	bool has_channel() const;
	void clear_channel();
	int8_t channel() const;
	void set_channel(int8_t  v);
	int8_t *mutable_channel();
	
	// fixed16 threshold, id 3
	bool has_threshold() const;
	void clear_threshold();
	uint16_t threshold() const;
	void set_threshold(uint16_t  v);
	uint16_t *mutable_threshold();
	
	// uint8 slope, id 4
	bool has_slope() const;
	void clear_slope();
	uint8_t slope() const;
	void set_slope(uint8_t  v);
	uint8_t *mutable_slope();
	
	// uint8 tieopt, id 5
	bool has_tieopt() const;
	void clear_tieopt();
	uint8_t tieopt() const;
	void set_tieopt(uint8_t  v);
	uint8_t *mutable_tieopt();
	
	
	protected:
	// string name, id 1
	estring m_name;
	// fixed16 threshold, id 3
	uint16_t m_threshold;
	// sint8 channel, id 2
	int8_t m_channel;
	// uint8 slope, id 4
	uint8_t m_slope;
	// uint8 tieopt, id 5
	uint8_t m_tieopt;
	
	private:
	uint8_t p_validbits;
};


class ButtonConfig
{
	public:
	ButtonConfig();
	
	bool operator == (const ButtonConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string name, id 1
	bool has_name() const;
	void clear_name();
	const estring &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const estring & v);
	void set_name(const char *);
	estring *mutable_name();
	
	// sint8 gpio, id 2
	bool has_gpio() const;
	void clear_gpio();
	int8_t gpio() const;
	void set_gpio(int8_t  v);
	int8_t *mutable_gpio();
	
	// bool presslvl, id 3
	bool has_presslvl() const;
	void clear_presslvl();
	bool presslvl() const;
	void set_presslvl(bool  v);
	bool *mutable_presslvl();
	
	// pull_mode_t pull_mode, id 4
	bool has_pull_mode() const;
	void clear_pull_mode();
	pull_mode_t pull_mode() const;
	void set_pull_mode(pull_mode_t  v);
	pull_mode_t *mutable_pull_mode();
	
	
	protected:
	// string name, id 1
	estring m_name;
	// pull_mode_t pull_mode, id 4
	pull_mode_t m_pull_mode;
	// sint8 gpio, id 2
	int8_t m_gpio;
	// bool presslvl, id 3
	bool m_presslvl;
};


class RelayConfig
{
	public:
	RelayConfig();
	
	bool operator == (const RelayConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string name, id 1
	bool has_name() const;
	void clear_name();
	const estring &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const estring & v);
	void set_name(const char *);
	estring *mutable_name();
	
	// sint8 gpio, id 2
	bool has_gpio() const;
	void clear_gpio();
	int8_t gpio() const;
	void set_gpio(int8_t  v);
	int8_t *mutable_gpio();
	
	// relay_cfg_t config, id 3
	bool has_config() const;
	void clear_config();
	relay_cfg_t config() const;
	void set_config(relay_cfg_t  v);
	relay_cfg_t *mutable_config();
	
	// unsigned min_itv, id 4
	bool has_min_itv() const;
	void clear_min_itv();
	uint32_t min_itv() const;
	void set_min_itv(uint32_t  v);
	uint32_t *mutable_min_itv();
	
	// sint8 interlock, id 5
	bool has_interlock() const;
	void clear_interlock();
	int8_t interlock() const;
	void set_interlock(int8_t  v);
	int8_t *mutable_interlock();
	
	
	protected:
	// string name, id 1
	estring m_name;
	// relay_cfg_t config, id 3
	relay_cfg_t m_config;
	// unsigned min_itv, id 4
	uint32_t m_min_itv;
	// sint8 gpio, id 2
	int8_t m_gpio;
	// sint8 interlock, id 5
	int8_t m_interlock;
	
	private:
	uint8_t p_validbits;
};


class Max7219Config
{
	public:
	Max7219Config();
	
	bool operator == (const Max7219Config &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// sint8 clk, id 1
	bool has_clk() const;
	void clear_clk();
	int8_t clk() const;
	void set_clk(int8_t  v);
	int8_t *mutable_clk();
	
	// sint8 dout, id 2
	bool has_dout() const;
	void clear_dout();
	int8_t dout() const;
	void set_dout(int8_t  v);
	int8_t *mutable_dout();
	
	// sint8 cs, id 3
	bool has_cs() const;
	void clear_cs();
	int8_t cs() const;
	void set_cs(int8_t  v);
	int8_t *mutable_cs();
	
	// bool odrain, id 4
	bool has_odrain() const;
	void clear_odrain();
	bool odrain() const;
	void set_odrain(bool  v);
	bool *mutable_odrain();
	
	// uint8 digits, id 5
	bool has_digits() const;
	void clear_digits();
	uint8_t digits() const;
	void set_digits(uint8_t  v);
	uint8_t *mutable_digits();
	
	
	protected:
	// sint8 clk, id 1
	int8_t m_clk;
	// sint8 dout, id 2
	int8_t m_dout;
	// sint8 cs, id 3
	int8_t m_cs;
	// bool odrain, id 4
	bool m_odrain;
	// uint8 digits, id 5
	uint8_t m_digits;
};


class Tlc5947Config
{
	public:
	Tlc5947Config();
	
	bool operator == (const Tlc5947Config &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// sint8 sin, id 1
	bool has_sin() const;
	void clear_sin();
	int8_t sin() const;
	void set_sin(int8_t  v);
	int8_t *mutable_sin();
	
	// sint8 sclk, id 2
	bool has_sclk() const;
	void clear_sclk();
	int8_t sclk() const;
	void set_sclk(int8_t  v);
	int8_t *mutable_sclk();
	
	// sint8 xlat, id 3
	bool has_xlat() const;
	void clear_xlat();
	int8_t xlat() const;
	void set_xlat(int8_t  v);
	int8_t *mutable_xlat();
	
	// sint8 blank, id 4
	bool has_blank() const;
	void clear_blank();
	int8_t blank() const;
	void set_blank(int8_t  v);
	int8_t *mutable_blank();
	
	// uint8 ntlc, id 5
	bool has_ntlc() const;
	void clear_ntlc();
	uint8_t ntlc() const;
	void set_ntlc(uint8_t  v);
	uint8_t *mutable_ntlc();
	
	
	protected:
	// sint8 sin, id 1
	int8_t m_sin;
	// sint8 sclk, id 2
	int8_t m_sclk;
	// sint8 xlat, id 3
	int8_t m_xlat;
	// sint8 blank, id 4
	int8_t m_blank;
	// uint8 ntlc, id 5
	uint8_t m_ntlc;
};


class Ws2812bConfig
{
	public:
	Ws2812bConfig();
	
	bool operator == (const Ws2812bConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// sint8 gpio, id 1
	bool has_gpio() const;
	void clear_gpio();
	int8_t gpio() const;
	void set_gpio(int8_t  v);
	int8_t *mutable_gpio();
	
	// unused sint8 ch, id 2
	// uint8 nleds, id 3
	bool has_nleds() const;
	void clear_nleds();
	uint8_t nleds() const;
	void set_nleds(uint8_t  v);
	uint8_t *mutable_nleds();
	
	
	protected:
	// sint8 gpio, id 1
	int8_t m_gpio;
	// omitted unused member ch
	// uint8 nleds, id 3
	uint8_t m_nleds;
};


class DhtConfig
{
	public:
	DhtConfig();
	
	bool operator == (const DhtConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// dht_model_t model, id 1
	bool has_model() const;
	void clear_model();
	dht_model_t model() const;
	void set_model(dht_model_t  v);
	dht_model_t *mutable_model();
	
	// sint8 gpio, id 2
	bool has_gpio() const;
	void clear_gpio();
	int8_t gpio() const;
	void set_gpio(int8_t  v);
	int8_t *mutable_gpio();
	
	
	protected:
	// dht_model_t model, id 1
	dht_model_t m_model;
	// sint8 gpio, id 2
	int8_t m_gpio;
};


class I2CConfig
{
	public:
	I2CConfig();
	
	bool operator == (const I2CConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// uint8 port, id 1
	bool has_port() const;
	void clear_port();
	uint8_t port() const;
	void set_port(uint8_t  v);
	uint8_t *mutable_port();
	
	// sint8 sda, id 2
	bool has_sda() const;
	void clear_sda();
	int8_t sda() const;
	void set_sda(int8_t  v);
	int8_t *mutable_sda();
	
	// sint8 scl, id 3
	bool has_scl() const;
	void clear_scl();
	int8_t scl() const;
	void set_scl(int8_t  v);
	int8_t *mutable_scl();
	
	// unused unsigned freq, id 4
	// bool xpullup, id 5
	bool has_xpullup() const;
	void clear_xpullup();
	bool xpullup() const;
	void set_xpullup(bool  v);
	bool *mutable_xpullup();
	
	
	protected:
	// omitted unused member freq
	// uint8 port, id 1
	uint8_t m_port;
	// sint8 sda, id 2
	int8_t m_sda;
	// sint8 scl, id 3
	int8_t m_scl;
	// bool xpullup, id 5
	bool m_xpullup;
	
	private:
	uint8_t p_validbits;
};


class HcSr04Config
{
	public:
	HcSr04Config();
	
	bool operator == (const HcSr04Config &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// sint8 trigger, id 1
	bool has_trigger() const;
	void clear_trigger();
	int8_t trigger() const;
	void set_trigger(int8_t  v);
	int8_t *mutable_trigger();
	
	// sint8 echo, id 2
	bool has_echo() const;
	void clear_echo();
	int8_t echo() const;
	void set_echo(int8_t  v);
	int8_t *mutable_echo();
	
	// string name, id 3
	bool has_name() const;
	void clear_name();
	const estring &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const estring & v);
	void set_name(const char *);
	estring *mutable_name();
	
	
	protected:
	// string name, id 3
	estring m_name;
	// sint8 trigger, id 1
	int8_t m_trigger;
	// sint8 echo, id 2
	int8_t m_echo;
	
	private:
	uint8_t p_validbits;
};


class LedConfig
{
	public:
	LedConfig();
	
	bool operator == (const LedConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// sint8 gpio, id 1
	bool has_gpio() const;
	void clear_gpio();
	int8_t gpio() const;
	void set_gpio(int8_t  v);
	int8_t *mutable_gpio();
	
	// uint8 config, id 2
	bool has_config() const;
	void clear_config();
	uint8_t config() const;
	void set_config(uint8_t  v);
	uint8_t *mutable_config();
	
	// string name, id 3
	bool has_name() const;
	void clear_name();
	const estring &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const estring & v);
	void set_name(const char *);
	estring *mutable_name();
	
	// sint8 pwm_ch, id 4
	bool has_pwm_ch() const;
	void clear_pwm_ch();
	int8_t pwm_ch() const;
	void set_pwm_ch(int8_t  v);
	int8_t *mutable_pwm_ch();
	
	
	protected:
	// string name, id 3
	estring m_name;
	// sint8 gpio, id 1
	int8_t m_gpio;
	// uint8 config, id 2
	uint8_t m_config;
	// sint8 pwm_ch, id 4
	int8_t m_pwm_ch;
	
	private:
	uint8_t p_validbits;
};


class OneWireConfig
{
	public:
	OneWireConfig();
	
	bool operator == (const OneWireConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// sint8 gpio, id 1
	bool has_gpio() const;
	void clear_gpio();
	int8_t gpio() const;
	void set_gpio(int8_t  v);
	int8_t *mutable_gpio();
	
	// bool pullup, id 2
	bool has_pullup() const;
	void clear_pullup();
	bool pullup() const;
	void set_pullup(bool  v);
	bool *mutable_pullup();
	
	// sint8 power, id 3
	bool has_power() const;
	void clear_power();
	int8_t power() const;
	void set_power(int8_t  v);
	int8_t *mutable_power();
	
	
	protected:
	// sint8 gpio, id 1
	int8_t m_gpio;
	// bool pullup, id 2
	bool m_pullup;
	// sint8 power, id 3
	int8_t m_power;
};


class UartConfig
{
	public:
	UartConfig();
	
	bool operator == (const UartConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// sint8 port, id 1
	bool has_port() const;
	void clear_port();
	int8_t port() const;
	void set_port(int8_t  v);
	int8_t *mutable_port();
	
	// unused sint8 tx_gpio, id 2
	// unused sint8 rx_gpio, id 3
	// unused sint8 cts_gpio, id 4
	// unused sint8 rts_gpio, id 5
	
	protected:
	// sint8 port, id 1
	int8_t m_port;
	// omitted unused member tx_gpio
	// omitted unused member rx_gpio
	// omitted unused member cts_gpio
	// omitted unused member rts_gpio
	
	private:
	uint8_t p_validbits;
};


class AdcChannel
{
	public:
	AdcChannel();
	
	bool operator == (const AdcChannel &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string name, id 1
	bool has_name() const;
	void clear_name();
	const estring &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const estring & v);
	void set_name(const char *);
	estring *mutable_name();
	
	// uint8 unit, id 2
	bool has_unit() const;
	void clear_unit();
	uint8_t unit() const;
	void set_unit(uint8_t  v);
	uint8_t *mutable_unit();
	
	// sint8 ch, id 3
	bool has_ch() const;
	void clear_ch();
	int8_t ch() const;
	void set_ch(int8_t  v);
	int8_t *mutable_ch();
	
	// uint8 atten, id 4
	bool has_atten() const;
	void clear_atten();
	uint8_t atten() const;
	void set_atten(uint8_t  v);
	uint8_t *mutable_atten();
	
	
	protected:
	// string name, id 1
	estring m_name;
	// uint8 unit, id 2
	uint8_t m_unit;
	// sint8 ch, id 3
	int8_t m_ch;
	// uint8 atten, id 4
	uint8_t m_atten;
	
	private:
	uint8_t p_validbits;
};


class AdcConfig
{
	public:
	AdcConfig();
	
	bool operator == (const AdcConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string adc_name, id 1
	bool has_adc_name() const;
	void clear_adc_name();
	const estring &adc_name() const;
	void set_adc_name(const void *data, size_t s);
	void set_adc_name(const estring & v);
	void set_adc_name(const char *);
	estring *mutable_adc_name();
	
	// unused uint8 adc1_bits, id 2
	// unused uint8 adc2_bits, id 3
	// uint8 mode, id 4
	bool has_mode() const;
	void clear_mode();
	uint8_t mode() const;
	void set_mode(uint8_t  v);
	uint8_t *mutable_mode();
	
	// uint8 clk_div, id 5
	bool has_clk_div() const;
	void clear_clk_div();
	uint8_t clk_div() const;
	void set_clk_div(uint8_t  v);
	uint8_t *mutable_clk_div();
	
	// unused string hall_name, id 6
	// unused AdcChannel channels, id 7
	
	protected:
	// string adc_name, id 1
	estring m_adc_name;
	// omitted unused member hall_name
	// omitted unused member adc1_bits
	// omitted unused member adc2_bits
	// uint8 mode, id 4
	uint8_t m_mode;
	// uint8 clk_div, id 5
	uint8_t m_clk_div;
	// omitted unused member channels
	
	private:
	uint8_t p_validbits;
};


class GpioConfig
{
	public:
	GpioConfig();
	
	bool operator == (const GpioConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// string name, id 1
	bool has_name() const;
	void clear_name();
	const estring &name() const;
	void set_name(const void *data, size_t s);
	void set_name(const estring & v);
	void set_name(const char *);
	estring *mutable_name();
	
	// sint8 gpio, id 2
	bool has_gpio() const;
	void clear_gpio();
	int8_t gpio() const;
	void set_gpio(int8_t  v);
	int8_t *mutable_gpio();
	
	// unsigned config, id 3
	bool has_config() const;
	void clear_config();
	uint32_t config() const;
	void set_config(uint32_t  v);
	uint32_t *mutable_config();
	
	
	protected:
	// string name, id 1
	estring m_name;
	// unsigned config, id 3
	uint32_t m_config;
	// sint8 gpio, id 2
	int8_t m_gpio;
	
	private:
	uint8_t p_validbits;
};


class DisplayConfig
{
	public:
	DisplayConfig();
	
	bool operator == (const DisplayConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// disp_t type, id 1
	bool has_type() const;
	void clear_type();
	disp_t type() const;
	void set_type(disp_t  v);
	disp_t *mutable_type();
	
	// unsigned options, id 2
	bool has_options() const;
	void clear_options();
	uint32_t options() const;
	void set_options(uint32_t  v);
	uint32_t *mutable_options();
	
	// unsigned maxx, id 3
	bool has_maxx() const;
	void clear_maxx();
	uint32_t maxx() const;
	void set_maxx(uint32_t  v);
	uint32_t *mutable_maxx();
	
	// unsigned maxy, id 4
	bool has_maxy() const;
	void clear_maxy();
	uint32_t maxy() const;
	void set_maxy(uint32_t  v);
	uint32_t *mutable_maxy();
	
	
	protected:
	// disp_t type, id 1
	disp_t m_type;
	// unsigned options, id 2
	uint32_t m_options;
	// unsigned maxx, id 3
	uint32_t m_maxx;
	// unsigned maxy, id 4
	uint32_t m_maxy;
	
	private:
	uint8_t p_validbits;
};


class HardwareConfig
{
	public:
	HardwareConfig();
	
	bool operator == (const HardwareConfig &r) const;
	
	//! function for resetting all members to their default values
	void clear();
	
	//! Calculate the required number of bytes for serializing this object.
	//! If the data of the object change, the number ob bytes needed for
	//! serialization, may change, too.
	size_t calcSize() const;
	
	//! Function for parsing memory with serialized data to append and update this object.
	//! @param b buffer of serialized data
	//! @param s number of bytes available in the buffer
	//! @return number of bytes parsed or negative value if an error occured
	ssize_t fromMemory(const void *b, ssize_t s);
	
	//! Serialize the object to memory.
	//! param b buffer the data should be written to
	//! param s number of bytes available in the buffer
	//! return number of bytes written
	ssize_t toMemory(uint8_t *, ssize_t) const;
	
	//! Function for writing the JSON representation of this object to a stream.
	void toJSON(stream &json, unsigned indLvl = 0) const;
	
	//! Function for writing an ASCII representation of this object to a stream.
	void toASCII(stream &o, size_t indent = 0) const;
	
	//! Function for determining the maximum size that the object may need for
	//! its serialized representation
	static size_t getMaxSize();
	
	//! Function for setting a parameter by its ASCII name using an ASCII representation of value.
	//! @param param parameter name
	//! @param value ASCII representation of the value
	//! @return number of bytes parsed from value or negative value if an error occurs
	int setByName(const char *param, const char *value);
	
	// fixed32 magic, id 0
	bool has_magic() const;
	void clear_magic();
	uint32_t magic() const;
	void set_magic(uint32_t  v);
	uint32_t *mutable_magic();
	
	// SystemConfig system, id 1
	bool has_system() const;
	void clear_system();
	const SystemConfig &system() const;
	void set_system(const void *data, size_t s);
	void set_system(const SystemConfig & v);
	SystemConfig *mutable_system();
	
	// unused UartConfig uart, id 3
	// AdcConfig adc, id 4
	bool has_adc() const;
	void clear_adc();
	const AdcConfig &adc() const;
	void set_adc(const void *data, size_t s);
	void set_adc(const AdcConfig & v);
	AdcConfig *mutable_adc();
	
	// unused TouchpadConfig touchpad, id 5
	// unused TouchChannelConfig tp_channel, id 6
	// GpioConfig gpio, id 7
	const std::vector<GpioConfig> &gpio() const;
	size_t gpio_size() const;
	GpioConfig* add_gpio();
	void clear_gpio();
	const GpioConfig &gpio(unsigned x) const;
	void set_gpio(unsigned x, const GpioConfig &v);
	GpioConfig *mutable_gpio(unsigned x);
	std::vector<GpioConfig> *mutable_gpio();
	
	// ButtonConfig button, id 16
	const std::vector<ButtonConfig> &button() const;
	size_t button_size() const;
	ButtonConfig* add_button();
	void clear_button();
	const ButtonConfig &button(unsigned x) const;
	void set_button(unsigned x, const ButtonConfig &v);
	ButtonConfig *mutable_button(unsigned x);
	std::vector<ButtonConfig> *mutable_button();
	
	// RelayConfig relay, id 17
	const std::vector<RelayConfig> &relay() const;
	size_t relay_size() const;
	RelayConfig* add_relay();
	void clear_relay();
	const RelayConfig &relay(unsigned x) const;
	void set_relay(unsigned x, const RelayConfig &v);
	RelayConfig *mutable_relay(unsigned x);
	std::vector<RelayConfig> *mutable_relay();
	
	// LedConfig led, id 18
	const std::vector<LedConfig> &led() const;
	size_t led_size() const;
	LedConfig* add_led();
	void clear_led();
	const LedConfig &led(unsigned x) const;
	void set_led(unsigned x, const LedConfig &v);
	LedConfig *mutable_led(unsigned x);
	std::vector<LedConfig> *mutable_led();
	
	// Max7219Config max7219, id 32
	#ifdef CONFIG_MAX7219
	bool has_max7219() const;
	void clear_max7219();
	const Max7219Config &max7219() const;
	void set_max7219(const void *data, size_t s);
	void set_max7219(const Max7219Config & v);
	Max7219Config *mutable_max7219();
	#endif //CONFIG_MAX7219
	
	// Tlc5947Config tlc5947, id 33
	#ifdef CONFIG_NIGHTSKY
	bool has_tlc5947() const;
	void clear_tlc5947();
	const Tlc5947Config &tlc5947() const;
	void set_tlc5947(const void *data, size_t s);
	void set_tlc5947(const Tlc5947Config & v);
	Tlc5947Config *mutable_tlc5947();
	#endif //CONFIG_NIGHTSKY
	
	// Ws2812bConfig ws2812b, id 34
	#ifdef CONFIG_LEDSTRIP
	bool has_ws2812b() const;
	void clear_ws2812b();
	const Ws2812bConfig &ws2812b() const;
	void set_ws2812b(const void *data, size_t s);
	void set_ws2812b(const Ws2812bConfig & v);
	Ws2812bConfig *mutable_ws2812b();
	#endif //CONFIG_LEDSTRIP
	
	// DhtConfig dht, id 35
	#ifdef CONFIG_DHT
	bool has_dht() const;
	void clear_dht();
	const DhtConfig &dht() const;
	void set_dht(const void *data, size_t s);
	void set_dht(const DhtConfig & v);
	DhtConfig *mutable_dht();
	#endif //CONFIG_DHT
	
	// I2CConfig i2c, id 36
	#ifdef CONFIG_I2C
	const std::vector<I2CConfig> &i2c() const;
	size_t i2c_size() const;
	I2CConfig* add_i2c();
	void clear_i2c();
	const I2CConfig &i2c(unsigned x) const;
	void set_i2c(unsigned x, const I2CConfig &v);
	I2CConfig *mutable_i2c(unsigned x);
	std::vector<I2CConfig> *mutable_i2c();
	#endif //CONFIG_I2C
	
	// HcSr04Config hcsr04, id 37
	#ifdef CONFIG_HCSR04
	const std::vector<HcSr04Config> &hcsr04() const;
	size_t hcsr04_size() const;
	HcSr04Config* add_hcsr04();
	void clear_hcsr04();
	const HcSr04Config &hcsr04(unsigned x) const;
	void set_hcsr04(unsigned x, const HcSr04Config &v);
	HcSr04Config *mutable_hcsr04(unsigned x);
	std::vector<HcSr04Config> *mutable_hcsr04();
	#endif //CONFIG_HCSR04
	
	// OneWireConfig onewire, id 38
	#ifdef CONFIG_ONEWIRE
	bool has_onewire() const;
	void clear_onewire();
	const OneWireConfig &onewire() const;
	void set_onewire(const void *data, size_t s);
	void set_onewire(const OneWireConfig & v);
	OneWireConfig *mutable_onewire();
	#endif //CONFIG_ONEWIRE
	
	// DisplayConfig display, id 50
	#ifdef CONFIG_DISPLAY
	bool has_display() const;
	void clear_display();
	const DisplayConfig &display() const;
	void set_display(const void *data, size_t s);
	void set_display(const DisplayConfig & v);
	DisplayConfig *mutable_display();
	#endif //CONFIG_DISPLAY
	
	
	protected:
	// fixed32 magic, id 0
	uint32_t m_magic;
	// LedConfig led, id 18
	std::vector<LedConfig> m_led;
	#ifdef CONFIG_DISPLAY
	// DisplayConfig display, id 50
	DisplayConfig m_display;
	#endif //CONFIG_DISPLAY
	#ifdef CONFIG_ONEWIRE
	// OneWireConfig onewire, id 38
	OneWireConfig m_onewire;
	#endif //CONFIG_ONEWIRE
	#ifdef CONFIG_HCSR04
	// HcSr04Config hcsr04, id 37
	std::vector<HcSr04Config> m_hcsr04;
	#endif //CONFIG_HCSR04
	#ifdef CONFIG_I2C
	// I2CConfig i2c, id 36
	std::vector<I2CConfig> m_i2c;
	#endif //CONFIG_I2C
	#ifdef CONFIG_DHT
	// DhtConfig dht, id 35
	DhtConfig m_dht;
	#endif //CONFIG_DHT
	#ifdef CONFIG_LEDSTRIP
	// Ws2812bConfig ws2812b, id 34
	Ws2812bConfig m_ws2812b;
	#endif //CONFIG_LEDSTRIP
	#ifdef CONFIG_NIGHTSKY
	// Tlc5947Config tlc5947, id 33
	Tlc5947Config m_tlc5947;
	#endif //CONFIG_NIGHTSKY
	#ifdef CONFIG_MAX7219
	// Max7219Config max7219, id 32
	Max7219Config m_max7219;
	#endif //CONFIG_MAX7219
	// RelayConfig relay, id 17
	std::vector<RelayConfig> m_relay;
	// ButtonConfig button, id 16
	std::vector<ButtonConfig> m_button;
	// GpioConfig gpio, id 7
	std::vector<GpioConfig> m_gpio;
	// omitted unused member tp_channel
	// omitted unused member touchpad
	// AdcConfig adc, id 4
	AdcConfig m_adc;
	// omitted unused member uart
	// SystemConfig system, id 1
	SystemConfig m_system;
	
	private:
	uint16_t p_validbits;
};


inline size_t SystemConfig::getMaxSize()
{
	// manufacturer has unlimited size
	// board_name has unlimited size
	// board_rev has unlimited size
	// diag_uart has maximum size 3
	// console_rx has maximum size 3
	// console_tx has maximum size 3
	// model_name has unlimited size
	// model_number has unlimited size
	return SIZE_MAX;
}

inline const estring &SystemConfig::manufacturer() const
{
	return m_manufacturer;
}

inline bool SystemConfig::has_manufacturer() const
{
	return !m_manufacturer.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_manufacturer()
{
	m_manufacturer = "";
}

inline estring *SystemConfig::mutable_manufacturer()
{
	return &m_manufacturer;
}

inline void SystemConfig::set_manufacturer(const void *data, size_t s)
{
	m_manufacturer.assign((const char *)data,s);
}

inline void SystemConfig::set_manufacturer(const char *data)
{
	m_manufacturer = data;
}

inline void SystemConfig::set_manufacturer(const estring & v)
{
	m_manufacturer = v;
}

inline const estring &SystemConfig::board_name() const
{
	return m_board_name;
}

inline bool SystemConfig::has_board_name() const
{
	return !m_board_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_board_name()
{
	m_board_name = "";
}

inline estring *SystemConfig::mutable_board_name()
{
	return &m_board_name;
}

inline void SystemConfig::set_board_name(const void *data, size_t s)
{
	m_board_name.assign((const char *)data,s);
}

inline void SystemConfig::set_board_name(const char *data)
{
	m_board_name = data;
}

inline void SystemConfig::set_board_name(const estring & v)
{
	m_board_name = v;
}

inline const estring &SystemConfig::board_rev() const
{
	return m_board_rev;
}

inline bool SystemConfig::has_board_rev() const
{
	return !m_board_rev.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_board_rev()
{
	m_board_rev = "";
}

inline estring *SystemConfig::mutable_board_rev()
{
	return &m_board_rev;
}

inline void SystemConfig::set_board_rev(const void *data, size_t s)
{
	m_board_rev.assign((const char *)data,s);
}

inline void SystemConfig::set_board_rev(const char *data)
{
	m_board_rev = data;
}

inline void SystemConfig::set_board_rev(const estring & v)
{
	m_board_rev = v;
}

inline int8_t SystemConfig::diag_uart() const
{
	return m_diag_uart;
}

inline bool SystemConfig::has_diag_uart() const
{
	return m_diag_uart != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_diag_uart()
{
	m_diag_uart = 0;
}

inline int8_t *SystemConfig::mutable_diag_uart()
{
	return &m_diag_uart;
}

inline void SystemConfig::set_diag_uart(int8_t  v)
{
	m_diag_uart = v;
}

inline int8_t SystemConfig::console_rx() const
{
	return m_console_rx;
}

inline bool SystemConfig::has_console_rx() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_console_rx()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_console_rx = 0;
}

inline int8_t *SystemConfig::mutable_console_rx()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_console_rx = 0;
	}
	return &m_console_rx;
}

inline void SystemConfig::set_console_rx(int8_t  v)
{
	m_console_rx = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline int8_t SystemConfig::console_tx() const
{
	return m_console_tx;
}

inline bool SystemConfig::has_console_tx() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_console_tx()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_console_tx = 0;
}

inline int8_t *SystemConfig::mutable_console_tx()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_console_tx = 0;
	}
	return &m_console_tx;
}

inline void SystemConfig::set_console_tx(int8_t  v)
{
	m_console_tx = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline const estring &SystemConfig::model_name() const
{
	return m_model_name;
}

inline bool SystemConfig::has_model_name() const
{
	return !m_model_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_model_name()
{
	m_model_name = "";
}

inline estring *SystemConfig::mutable_model_name()
{
	return &m_model_name;
}

inline void SystemConfig::set_model_name(const void *data, size_t s)
{
	m_model_name.assign((const char *)data,s);
}

inline void SystemConfig::set_model_name(const char *data)
{
	m_model_name = data;
}

inline void SystemConfig::set_model_name(const estring & v)
{
	m_model_name = v;
}

inline const estring &SystemConfig::model_number() const
{
	return m_model_number;
}

inline bool SystemConfig::has_model_number() const
{
	return !m_model_number.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void SystemConfig::clear_model_number()
{
	m_model_number = "";
}

inline estring *SystemConfig::mutable_model_number()
{
	return &m_model_number;
}

inline void SystemConfig::set_model_number(const void *data, size_t s)
{
	m_model_number.assign((const char *)data,s);
}

inline void SystemConfig::set_model_number(const char *data)
{
	m_model_number = data;
}

inline void SystemConfig::set_model_number(const estring & v)
{
	m_model_number = v;
}

inline size_t TouchpadConfig::getMaxSize()
{
	// fsm_mode has maximum size 2
	// lvolt has maximum size 3
	// hvolt has maximum size 3
	// atten has maximum size 3
	// interval has maximum size 6
	return 17;
}

inline bool TouchpadConfig::fsm_mode() const
{
	return m_fsm_mode;
}

inline bool TouchpadConfig::has_fsm_mode() const
{
	return m_fsm_mode != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchpadConfig::clear_fsm_mode()
{
	m_fsm_mode = false;
}

inline bool *TouchpadConfig::mutable_fsm_mode()
{
	return &m_fsm_mode;
}

inline void TouchpadConfig::set_fsm_mode(bool  v)
{
	m_fsm_mode = v;
}

inline int8_t TouchpadConfig::lvolt() const
{
	return m_lvolt;
}

inline bool TouchpadConfig::has_lvolt() const
{
	return m_lvolt != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchpadConfig::clear_lvolt()
{
	m_lvolt = -1;
}

inline int8_t *TouchpadConfig::mutable_lvolt()
{
	return &m_lvolt;
}

inline void TouchpadConfig::set_lvolt(int8_t  v)
{
	m_lvolt = v;
}

inline int8_t TouchpadConfig::hvolt() const
{
	return m_hvolt;
}

inline bool TouchpadConfig::has_hvolt() const
{
	return m_hvolt != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchpadConfig::clear_hvolt()
{
	m_hvolt = -1;
}

inline int8_t *TouchpadConfig::mutable_hvolt()
{
	return &m_hvolt;
}

inline void TouchpadConfig::set_hvolt(int8_t  v)
{
	m_hvolt = v;
}

inline int8_t TouchpadConfig::atten() const
{
	return m_atten;
}

inline bool TouchpadConfig::has_atten() const
{
	return m_atten != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchpadConfig::clear_atten()
{
	m_atten = -1;
}

inline int8_t *TouchpadConfig::mutable_atten()
{
	return &m_atten;
}

inline void TouchpadConfig::set_atten(int8_t  v)
{
	m_atten = v;
}

inline uint32_t TouchpadConfig::interval() const
{
	return m_interval;
}

inline bool TouchpadConfig::has_interval() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchpadConfig::clear_interval()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_interval = 0;
}

inline uint32_t *TouchpadConfig::mutable_interval()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_interval = 0;
	}
	return &m_interval;
}

inline void TouchpadConfig::set_interval(uint32_t  v)
{
	m_interval = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline size_t TouchChannelConfig::getMaxSize()
{
	// name has unlimited size
	// channel has maximum size 3
	// threshold has maximum size 3
	// slope has maximum size 3
	// tieopt has maximum size 3
	return SIZE_MAX;
}

inline const estring &TouchChannelConfig::name() const
{
	return m_name;
}

inline bool TouchChannelConfig::has_name() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchChannelConfig::clear_name()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_name.clear();
}

inline estring *TouchChannelConfig::mutable_name()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_name.clear();
	}
	return &m_name;
}

inline void TouchChannelConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void TouchChannelConfig::set_name(const char *data)
{
	m_name = data;
	p_validbits |= ((uint8_t)1U << 0);
}

inline void TouchChannelConfig::set_name(const estring & v)
{
	m_name = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline int8_t TouchChannelConfig::channel() const
{
	return m_channel;
}

inline bool TouchChannelConfig::has_channel() const
{
	return m_channel != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchChannelConfig::clear_channel()
{
	m_channel = -1;
}

inline int8_t *TouchChannelConfig::mutable_channel()
{
	return &m_channel;
}

inline void TouchChannelConfig::set_channel(int8_t  v)
{
	m_channel = v;
}

inline uint16_t TouchChannelConfig::threshold() const
{
	return m_threshold;
}

inline bool TouchChannelConfig::has_threshold() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchChannelConfig::clear_threshold()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_threshold = 0;
}

inline uint16_t *TouchChannelConfig::mutable_threshold()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_threshold = 0;
	}
	return &m_threshold;
}

inline void TouchChannelConfig::set_threshold(uint16_t  v)
{
	m_threshold = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline uint8_t TouchChannelConfig::slope() const
{
	return m_slope;
}

inline bool TouchChannelConfig::has_slope() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchChannelConfig::clear_slope()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_slope = 0;
}

inline uint8_t *TouchChannelConfig::mutable_slope()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_slope = 0;
	}
	return &m_slope;
}

inline void TouchChannelConfig::set_slope(uint8_t  v)
{
	m_slope = v;
	p_validbits |= ((uint8_t)1U << 2);
}

inline uint8_t TouchChannelConfig::tieopt() const
{
	return m_tieopt;
}

inline bool TouchChannelConfig::has_tieopt() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 3));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void TouchChannelConfig::clear_tieopt()
{
	p_validbits &= ~((uint8_t)1U << 3);
	m_tieopt = 0;
}

inline uint8_t *TouchChannelConfig::mutable_tieopt()
{
	if (0 == (p_validbits & ((uint8_t)1U << 3))) {
		p_validbits |= ((uint8_t)1U << 3);
		m_tieopt = 0;
	}
	return &m_tieopt;
}

inline void TouchChannelConfig::set_tieopt(uint8_t  v)
{
	m_tieopt = v;
	p_validbits |= ((uint8_t)1U << 3);
}

inline size_t ButtonConfig::getMaxSize()
{
	// name has unlimited size
	// gpio has maximum size 3
	// presslvl has maximum size 2
	// pull_mode has maximum size 2
	return SIZE_MAX;
}

inline const estring &ButtonConfig::name() const
{
	return m_name;
}

inline bool ButtonConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ButtonConfig::clear_name()
{
	m_name = "";
}

inline estring *ButtonConfig::mutable_name()
{
	return &m_name;
}

inline void ButtonConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void ButtonConfig::set_name(const char *data)
{
	m_name = data;
}

inline void ButtonConfig::set_name(const estring & v)
{
	m_name = v;
}

inline int8_t ButtonConfig::gpio() const
{
	return m_gpio;
}

inline bool ButtonConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ButtonConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *ButtonConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void ButtonConfig::set_gpio(int8_t  v)
{
	m_gpio = v;
}

inline bool ButtonConfig::presslvl() const
{
	return m_presslvl;
}

inline bool ButtonConfig::has_presslvl() const
{
	return m_presslvl != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ButtonConfig::clear_presslvl()
{
	m_presslvl = 0;
}

inline bool *ButtonConfig::mutable_presslvl()
{
	return &m_presslvl;
}

inline void ButtonConfig::set_presslvl(bool  v)
{
	m_presslvl = v;
}

inline pull_mode_t ButtonConfig::pull_mode() const
{
	return m_pull_mode;
}

inline bool ButtonConfig::has_pull_mode() const
{
	return m_pull_mode != pull_none;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void ButtonConfig::clear_pull_mode()
{
	m_pull_mode = pull_none;
}

inline pull_mode_t *ButtonConfig::mutable_pull_mode()
{
	return &m_pull_mode;
}

inline void ButtonConfig::set_pull_mode(pull_mode_t  v)
{
	m_pull_mode = v;
}

inline size_t RelayConfig::getMaxSize()
{
	// name has unlimited size
	// gpio has maximum size 3
	// config has maximum size 2
	// min_itv has maximum size 6
	// interlock has maximum size 3
	return SIZE_MAX;
}

inline const estring &RelayConfig::name() const
{
	return m_name;
}

inline bool RelayConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void RelayConfig::clear_name()
{
	m_name = "";
}

inline estring *RelayConfig::mutable_name()
{
	return &m_name;
}

inline void RelayConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void RelayConfig::set_name(const char *data)
{
	m_name = data;
}

inline void RelayConfig::set_name(const estring & v)
{
	m_name = v;
}

inline int8_t RelayConfig::gpio() const
{
	return m_gpio;
}

inline bool RelayConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void RelayConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *RelayConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void RelayConfig::set_gpio(int8_t  v)
{
	m_gpio = v;
}

inline relay_cfg_t RelayConfig::config() const
{
	return m_config;
}

inline bool RelayConfig::has_config() const
{
	return m_config != rc_active_low;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void RelayConfig::clear_config()
{
	m_config = rc_active_low;
}

inline relay_cfg_t *RelayConfig::mutable_config()
{
	return &m_config;
}

inline void RelayConfig::set_config(relay_cfg_t  v)
{
	m_config = v;
}

inline uint32_t RelayConfig::min_itv() const
{
	return m_min_itv;
}

inline bool RelayConfig::has_min_itv() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void RelayConfig::clear_min_itv()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_min_itv = 0;
}

inline uint32_t *RelayConfig::mutable_min_itv()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_min_itv = 0;
	}
	return &m_min_itv;
}

inline void RelayConfig::set_min_itv(uint32_t  v)
{
	m_min_itv = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline int8_t RelayConfig::interlock() const
{
	return m_interlock;
}

inline bool RelayConfig::has_interlock() const
{
	return m_interlock != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void RelayConfig::clear_interlock()
{
	m_interlock = -1;
}

inline int8_t *RelayConfig::mutable_interlock()
{
	return &m_interlock;
}

inline void RelayConfig::set_interlock(int8_t  v)
{
	m_interlock = v;
}

inline size_t Max7219Config::getMaxSize()
{
	// clk has maximum size 3
	// dout has maximum size 3
	// cs has maximum size 3
	// odrain has maximum size 2
	// digits has maximum size 3
	return 14;
}

inline int8_t Max7219Config::clk() const
{
	return m_clk;
}

inline bool Max7219Config::has_clk() const
{
	return m_clk != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Max7219Config::clear_clk()
{
	m_clk = -1;
}

inline int8_t *Max7219Config::mutable_clk()
{
	return &m_clk;
}

inline void Max7219Config::set_clk(int8_t  v)
{
	m_clk = v;
}

inline int8_t Max7219Config::dout() const
{
	return m_dout;
}

inline bool Max7219Config::has_dout() const
{
	return m_dout != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Max7219Config::clear_dout()
{
	m_dout = -1;
}

inline int8_t *Max7219Config::mutable_dout()
{
	return &m_dout;
}

inline void Max7219Config::set_dout(int8_t  v)
{
	m_dout = v;
}

inline int8_t Max7219Config::cs() const
{
	return m_cs;
}

inline bool Max7219Config::has_cs() const
{
	return m_cs != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Max7219Config::clear_cs()
{
	m_cs = -1;
}

inline int8_t *Max7219Config::mutable_cs()
{
	return &m_cs;
}

inline void Max7219Config::set_cs(int8_t  v)
{
	m_cs = v;
}

inline bool Max7219Config::odrain() const
{
	return m_odrain;
}

inline bool Max7219Config::has_odrain() const
{
	return m_odrain != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Max7219Config::clear_odrain()
{
	m_odrain = false;
}

inline bool *Max7219Config::mutable_odrain()
{
	return &m_odrain;
}

inline void Max7219Config::set_odrain(bool  v)
{
	m_odrain = v;
}

inline uint8_t Max7219Config::digits() const
{
	return m_digits;
}

inline bool Max7219Config::has_digits() const
{
	return m_digits != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Max7219Config::clear_digits()
{
	m_digits = 0;
}

inline uint8_t *Max7219Config::mutable_digits()
{
	return &m_digits;
}

inline void Max7219Config::set_digits(uint8_t  v)
{
	m_digits = v;
}

inline size_t Tlc5947Config::getMaxSize()
{
	// sin has maximum size 3
	// sclk has maximum size 3
	// xlat has maximum size 3
	// blank has maximum size 3
	// ntlc has maximum size 3
	return 15;
}

inline int8_t Tlc5947Config::sin() const
{
	return m_sin;
}

inline bool Tlc5947Config::has_sin() const
{
	return m_sin != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tlc5947Config::clear_sin()
{
	m_sin = -1;
}

inline int8_t *Tlc5947Config::mutable_sin()
{
	return &m_sin;
}

inline void Tlc5947Config::set_sin(int8_t  v)
{
	m_sin = v;
}

inline int8_t Tlc5947Config::sclk() const
{
	return m_sclk;
}

inline bool Tlc5947Config::has_sclk() const
{
	return m_sclk != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tlc5947Config::clear_sclk()
{
	m_sclk = -1;
}

inline int8_t *Tlc5947Config::mutable_sclk()
{
	return &m_sclk;
}

inline void Tlc5947Config::set_sclk(int8_t  v)
{
	m_sclk = v;
}

inline int8_t Tlc5947Config::xlat() const
{
	return m_xlat;
}

inline bool Tlc5947Config::has_xlat() const
{
	return m_xlat != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tlc5947Config::clear_xlat()
{
	m_xlat = -1;
}

inline int8_t *Tlc5947Config::mutable_xlat()
{
	return &m_xlat;
}

inline void Tlc5947Config::set_xlat(int8_t  v)
{
	m_xlat = v;
}

inline int8_t Tlc5947Config::blank() const
{
	return m_blank;
}

inline bool Tlc5947Config::has_blank() const
{
	return m_blank != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tlc5947Config::clear_blank()
{
	m_blank = -1;
}

inline int8_t *Tlc5947Config::mutable_blank()
{
	return &m_blank;
}

inline void Tlc5947Config::set_blank(int8_t  v)
{
	m_blank = v;
}

inline uint8_t Tlc5947Config::ntlc() const
{
	return m_ntlc;
}

inline bool Tlc5947Config::has_ntlc() const
{
	return m_ntlc != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Tlc5947Config::clear_ntlc()
{
	m_ntlc = 0;
}

inline uint8_t *Tlc5947Config::mutable_ntlc()
{
	return &m_ntlc;
}

inline void Tlc5947Config::set_ntlc(uint8_t  v)
{
	m_ntlc = v;
}

inline size_t Ws2812bConfig::getMaxSize()
{
	// gpio has maximum size 3
	// ch is unused
	// nleds has maximum size 3
	return 6;
}

inline int8_t Ws2812bConfig::gpio() const
{
	return m_gpio;
}

inline bool Ws2812bConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Ws2812bConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *Ws2812bConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void Ws2812bConfig::set_gpio(int8_t  v)
{
	m_gpio = v;
}

inline uint8_t Ws2812bConfig::nleds() const
{
	return m_nleds;
}

inline bool Ws2812bConfig::has_nleds() const
{
	return m_nleds != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void Ws2812bConfig::clear_nleds()
{
	m_nleds = 0;
}

inline uint8_t *Ws2812bConfig::mutable_nleds()
{
	return &m_nleds;
}

inline void Ws2812bConfig::set_nleds(uint8_t  v)
{
	m_nleds = v;
}

inline size_t DhtConfig::getMaxSize()
{
	// model has maximum size 3
	// gpio has maximum size 3
	return 6;
}

inline dht_model_t DhtConfig::model() const
{
	return m_model;
}

inline bool DhtConfig::has_model() const
{
	return m_model != DHT_NONE;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DhtConfig::clear_model()
{
	m_model = DHT_NONE;
}

inline dht_model_t *DhtConfig::mutable_model()
{
	return &m_model;
}

inline void DhtConfig::set_model(dht_model_t  v)
{
	m_model = v;
}

inline int8_t DhtConfig::gpio() const
{
	return m_gpio;
}

inline bool DhtConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DhtConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *DhtConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void DhtConfig::set_gpio(int8_t  v)
{
	m_gpio = v;
}

inline size_t I2CConfig::getMaxSize()
{
	// port has maximum size 3
	// sda has maximum size 3
	// scl has maximum size 3
	// freq is unused
	// xpullup has maximum size 2
	return 11;
}

inline uint8_t I2CConfig::port() const
{
	return m_port;
}

inline bool I2CConfig::has_port() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void I2CConfig::clear_port()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_port = 0;
}

inline uint8_t *I2CConfig::mutable_port()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_port = 0;
	}
	return &m_port;
}

inline void I2CConfig::set_port(uint8_t  v)
{
	m_port = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline int8_t I2CConfig::sda() const
{
	return m_sda;
}

inline bool I2CConfig::has_sda() const
{
	return m_sda != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void I2CConfig::clear_sda()
{
	m_sda = -1;
}

inline int8_t *I2CConfig::mutable_sda()
{
	return &m_sda;
}

inline void I2CConfig::set_sda(int8_t  v)
{
	m_sda = v;
}

inline int8_t I2CConfig::scl() const
{
	return m_scl;
}

inline bool I2CConfig::has_scl() const
{
	return m_scl != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void I2CConfig::clear_scl()
{
	m_scl = -1;
}

inline int8_t *I2CConfig::mutable_scl()
{
	return &m_scl;
}

inline void I2CConfig::set_scl(int8_t  v)
{
	m_scl = v;
}

inline bool I2CConfig::xpullup() const
{
	return m_xpullup;
}

inline bool I2CConfig::has_xpullup() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void I2CConfig::clear_xpullup()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_xpullup = 0;
}

inline bool *I2CConfig::mutable_xpullup()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_xpullup = 0;
	}
	return &m_xpullup;
}

inline void I2CConfig::set_xpullup(bool  v)
{
	m_xpullup = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline size_t HcSr04Config::getMaxSize()
{
	// trigger has maximum size 3
	// echo has maximum size 3
	// name has unlimited size
	return SIZE_MAX;
}

inline int8_t HcSr04Config::trigger() const
{
	return m_trigger;
}

inline bool HcSr04Config::has_trigger() const
{
	return m_trigger != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HcSr04Config::clear_trigger()
{
	m_trigger = -1;
}

inline int8_t *HcSr04Config::mutable_trigger()
{
	return &m_trigger;
}

inline void HcSr04Config::set_trigger(int8_t  v)
{
	m_trigger = v;
}

inline int8_t HcSr04Config::echo() const
{
	return m_echo;
}

inline bool HcSr04Config::has_echo() const
{
	return m_echo != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HcSr04Config::clear_echo()
{
	m_echo = -1;
}

inline int8_t *HcSr04Config::mutable_echo()
{
	return &m_echo;
}

inline void HcSr04Config::set_echo(int8_t  v)
{
	m_echo = v;
}

inline const estring &HcSr04Config::name() const
{
	return m_name;
}

inline bool HcSr04Config::has_name() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HcSr04Config::clear_name()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_name.clear();
}

inline estring *HcSr04Config::mutable_name()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_name.clear();
	}
	return &m_name;
}

inline void HcSr04Config::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void HcSr04Config::set_name(const char *data)
{
	m_name = data;
	p_validbits |= ((uint8_t)1U << 0);
}

inline void HcSr04Config::set_name(const estring & v)
{
	m_name = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline size_t LedConfig::getMaxSize()
{
	// gpio has maximum size 3
	// config has maximum size 3
	// name has unlimited size
	// pwm_ch has maximum size 3
	return SIZE_MAX;
}

inline int8_t LedConfig::gpio() const
{
	return m_gpio;
}

inline bool LedConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void LedConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *LedConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void LedConfig::set_gpio(int8_t  v)
{
	m_gpio = v;
}

inline uint8_t LedConfig::config() const
{
	return m_config;
}

inline bool LedConfig::has_config() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void LedConfig::clear_config()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_config = 0;
}

inline uint8_t *LedConfig::mutable_config()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_config = 0;
	}
	return &m_config;
}

inline void LedConfig::set_config(uint8_t  v)
{
	m_config = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline const estring &LedConfig::name() const
{
	return m_name;
}

inline bool LedConfig::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void LedConfig::clear_name()
{
	m_name = "";
}

inline estring *LedConfig::mutable_name()
{
	return &m_name;
}

inline void LedConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void LedConfig::set_name(const char *data)
{
	m_name = data;
}

inline void LedConfig::set_name(const estring & v)
{
	m_name = v;
}

inline int8_t LedConfig::pwm_ch() const
{
	return m_pwm_ch;
}

inline bool LedConfig::has_pwm_ch() const
{
	return m_pwm_ch != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void LedConfig::clear_pwm_ch()
{
	m_pwm_ch = -1;
}

inline int8_t *LedConfig::mutable_pwm_ch()
{
	return &m_pwm_ch;
}

inline void LedConfig::set_pwm_ch(int8_t  v)
{
	m_pwm_ch = v;
}

inline size_t OneWireConfig::getMaxSize()
{
	// gpio has maximum size 3
	// pullup has maximum size 2
	// power has maximum size 3
	return 8;
}

inline int8_t OneWireConfig::gpio() const
{
	return m_gpio;
}

inline bool OneWireConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void OneWireConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *OneWireConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void OneWireConfig::set_gpio(int8_t  v)
{
	m_gpio = v;
}

inline bool OneWireConfig::pullup() const
{
	return m_pullup;
}

inline bool OneWireConfig::has_pullup() const
{
	return m_pullup != false;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void OneWireConfig::clear_pullup()
{
	m_pullup = false;
}

inline bool *OneWireConfig::mutable_pullup()
{
	return &m_pullup;
}

inline void OneWireConfig::set_pullup(bool  v)
{
	m_pullup = v;
}

inline int8_t OneWireConfig::power() const
{
	return m_power;
}

inline bool OneWireConfig::has_power() const
{
	return m_power != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void OneWireConfig::clear_power()
{
	m_power = -1;
}

inline int8_t *OneWireConfig::mutable_power()
{
	return &m_power;
}

inline void OneWireConfig::set_power(int8_t  v)
{
	m_power = v;
}

inline size_t UartConfig::getMaxSize()
{
	// port has maximum size 3
	// tx_gpio is unused
	// rx_gpio is unused
	// cts_gpio is unused
	// rts_gpio is unused
	return 3;
}

inline int8_t UartConfig::port() const
{
	return m_port;
}

inline bool UartConfig::has_port() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void UartConfig::clear_port()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_port = 0;
}

inline int8_t *UartConfig::mutable_port()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_port = 0;
	}
	return &m_port;
}

inline void UartConfig::set_port(int8_t  v)
{
	m_port = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline size_t AdcChannel::getMaxSize()
{
	// name has unlimited size
	// unit has maximum size 3
	// ch has maximum size 3
	// atten has maximum size 3
	return SIZE_MAX;
}

inline const estring &AdcChannel::name() const
{
	return m_name;
}

inline bool AdcChannel::has_name() const
{
	return !m_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_name()
{
	m_name = "";
}

inline estring *AdcChannel::mutable_name()
{
	return &m_name;
}

inline void AdcChannel::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
}

inline void AdcChannel::set_name(const char *data)
{
	m_name = data;
}

inline void AdcChannel::set_name(const estring & v)
{
	m_name = v;
}

inline uint8_t AdcChannel::unit() const
{
	return m_unit;
}

inline bool AdcChannel::has_unit() const
{
	return m_unit != 0;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_unit()
{
	m_unit = 0;
}

inline uint8_t *AdcChannel::mutable_unit()
{
	return &m_unit;
}

inline void AdcChannel::set_unit(uint8_t  v)
{
	m_unit = v;
}

inline int8_t AdcChannel::ch() const
{
	return m_ch;
}

inline bool AdcChannel::has_ch() const
{
	return m_ch != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_ch()
{
	m_ch = -1;
}

inline int8_t *AdcChannel::mutable_ch()
{
	return &m_ch;
}

inline void AdcChannel::set_ch(int8_t  v)
{
	m_ch = v;
}

inline uint8_t AdcChannel::atten() const
{
	return m_atten;
}

inline bool AdcChannel::has_atten() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcChannel::clear_atten()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_atten = 0;
}

inline uint8_t *AdcChannel::mutable_atten()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_atten = 0;
	}
	return &m_atten;
}

inline void AdcChannel::set_atten(uint8_t  v)
{
	m_atten = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline size_t AdcConfig::getMaxSize()
{
	// adc_name has unlimited size
	// adc1_bits is unused
	// adc2_bits is unused
	// mode has maximum size 3
	// clk_div has maximum size 3
	// hall_name is unused
	// channels is unused
	return SIZE_MAX;
}

inline const estring &AdcConfig::adc_name() const
{
	return m_adc_name;
}

inline bool AdcConfig::has_adc_name() const
{
	return !m_adc_name.empty();
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcConfig::clear_adc_name()
{
	m_adc_name = "";
}

inline estring *AdcConfig::mutable_adc_name()
{
	return &m_adc_name;
}

inline void AdcConfig::set_adc_name(const void *data, size_t s)
{
	m_adc_name.assign((const char *)data,s);
}

inline void AdcConfig::set_adc_name(const char *data)
{
	m_adc_name = data;
}

inline void AdcConfig::set_adc_name(const estring & v)
{
	m_adc_name = v;
}

inline uint8_t AdcConfig::mode() const
{
	return m_mode;
}

inline bool AdcConfig::has_mode() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcConfig::clear_mode()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_mode = 0;
}

inline uint8_t *AdcConfig::mutable_mode()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_mode = 0;
	}
	return &m_mode;
}

inline void AdcConfig::set_mode(uint8_t  v)
{
	m_mode = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline uint8_t AdcConfig::clk_div() const
{
	return m_clk_div;
}

inline bool AdcConfig::has_clk_div() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void AdcConfig::clear_clk_div()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_clk_div = 0;
}

inline uint8_t *AdcConfig::mutable_clk_div()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_clk_div = 0;
	}
	return &m_clk_div;
}

inline void AdcConfig::set_clk_div(uint8_t  v)
{
	m_clk_div = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline size_t GpioConfig::getMaxSize()
{
	// name has unlimited size
	// gpio has maximum size 3
	// config has maximum size 6
	return SIZE_MAX;
}

inline const estring &GpioConfig::name() const
{
	return m_name;
}

inline bool GpioConfig::has_name() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioConfig::clear_name()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_name.clear();
}

inline estring *GpioConfig::mutable_name()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_name.clear();
	}
	return &m_name;
}

inline void GpioConfig::set_name(const void *data, size_t s)
{
	m_name.assign((const char *)data,s);
	p_validbits |= ((uint8_t)1U << 0);
}

inline void GpioConfig::set_name(const char *data)
{
	m_name = data;
	p_validbits |= ((uint8_t)1U << 0);
}

inline void GpioConfig::set_name(const estring & v)
{
	m_name = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline int8_t GpioConfig::gpio() const
{
	return m_gpio;
}

inline bool GpioConfig::has_gpio() const
{
	return m_gpio != -1;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioConfig::clear_gpio()
{
	m_gpio = -1;
}

inline int8_t *GpioConfig::mutable_gpio()
{
	return &m_gpio;
}

inline void GpioConfig::set_gpio(int8_t  v)
{
	m_gpio = v;
}

inline uint32_t GpioConfig::config() const
{
	return m_config;
}

inline bool GpioConfig::has_config() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void GpioConfig::clear_config()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_config = 0;
}

inline uint32_t *GpioConfig::mutable_config()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_config = 0;
	}
	return &m_config;
}

inline void GpioConfig::set_config(uint32_t  v)
{
	m_config = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline size_t DisplayConfig::getMaxSize()
{
	// type has maximum size 2
	// options has maximum size 6
	// maxx has maximum size 6
	// maxy has maximum size 6
	return 20;
}

inline disp_t DisplayConfig::type() const
{
	return m_type;
}

inline bool DisplayConfig::has_type() const
{
	return m_type != dt_none;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DisplayConfig::clear_type()
{
	m_type = dt_none;
}

inline disp_t *DisplayConfig::mutable_type()
{
	return &m_type;
}

inline void DisplayConfig::set_type(disp_t  v)
{
	m_type = v;
}

inline uint32_t DisplayConfig::options() const
{
	return m_options;
}

inline bool DisplayConfig::has_options() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DisplayConfig::clear_options()
{
	p_validbits &= ~((uint8_t)1U << 0);
	m_options = 0;
}

inline uint32_t *DisplayConfig::mutable_options()
{
	if (0 == (p_validbits & ((uint8_t)1U << 0))) {
		p_validbits |= ((uint8_t)1U << 0);
		m_options = 0;
	}
	return &m_options;
}

inline void DisplayConfig::set_options(uint32_t  v)
{
	m_options = v;
	p_validbits |= ((uint8_t)1U << 0);
}

inline uint32_t DisplayConfig::maxx() const
{
	return m_maxx;
}

inline bool DisplayConfig::has_maxx() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DisplayConfig::clear_maxx()
{
	p_validbits &= ~((uint8_t)1U << 1);
	m_maxx = 0;
}

inline uint32_t *DisplayConfig::mutable_maxx()
{
	if (0 == (p_validbits & ((uint8_t)1U << 1))) {
		p_validbits |= ((uint8_t)1U << 1);
		m_maxx = 0;
	}
	return &m_maxx;
}

inline void DisplayConfig::set_maxx(uint32_t  v)
{
	m_maxx = v;
	p_validbits |= ((uint8_t)1U << 1);
}

inline uint32_t DisplayConfig::maxy() const
{
	return m_maxy;
}

inline bool DisplayConfig::has_maxy() const
{
	return 0 != (p_validbits & ((uint8_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void DisplayConfig::clear_maxy()
{
	p_validbits &= ~((uint8_t)1U << 2);
	m_maxy = 1;
}

inline uint32_t *DisplayConfig::mutable_maxy()
{
	if (0 == (p_validbits & ((uint8_t)1U << 2))) {
		p_validbits |= ((uint8_t)1U << 2);
		m_maxy = 1;
	}
	return &m_maxy;
}

inline void DisplayConfig::set_maxy(uint32_t  v)
{
	m_maxy = v;
	p_validbits |= ((uint8_t)1U << 2);
}

inline size_t HardwareConfig::getMaxSize()
{
	// magic has maximum size 5
	// system has maximum size 5
	// uart is unused
	// adc has maximum size 10
	// touchpad is unused
	// tp_channel is unused
	// gpio has unlimited size
	// button has unlimited size
	// relay has unlimited size
	// led has unlimited size
	// max7219 has maximum size 16
	// tlc5947 has maximum size 17
	// ws2812b has maximum size 11
	// dht has maximum size 8
	// i2c has unlimited size
	// hcsr04 has unlimited size
	// onewire has maximum size 10
	// display has maximum size 22
	return SIZE_MAX;
}

inline uint32_t HardwareConfig::magic() const
{
	return m_magic;
}

inline bool HardwareConfig::has_magic() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 0));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_magic()
{
	p_validbits &= ~((uint16_t)1U << 0);
	m_magic = 0;
}

inline uint32_t *HardwareConfig::mutable_magic()
{
	if (0 == (p_validbits & ((uint16_t)1U << 0))) {
		p_validbits |= ((uint16_t)1U << 0);
		m_magic = 0;
	}
	return &m_magic;
}

inline void HardwareConfig::set_magic(uint32_t  v)
{
	m_magic = v;
	p_validbits |= ((uint16_t)1U << 0);
}

inline const SystemConfig &HardwareConfig::system() const
{
	return m_system;
}

inline bool HardwareConfig::has_system() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 1));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_system()
{
	p_validbits &= ~((uint16_t)1U << 1);
	m_system.clear();
}

inline SystemConfig *HardwareConfig::mutable_system()
{
	if (0 == (p_validbits & ((uint16_t)1U << 1))) {
		p_validbits |= ((uint16_t)1U << 1);
		m_system.clear();
	}
	return &m_system;
}

inline void HardwareConfig::set_system(const void *data, size_t s)
{
	m_system.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 1);
}

inline void HardwareConfig::set_system(const SystemConfig & v)
{
	m_system = v;
	p_validbits |= ((uint16_t)1U << 1);
}

inline const AdcConfig &HardwareConfig::adc() const
{
	return m_adc;
}

inline bool HardwareConfig::has_adc() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 2));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_adc()
{
	p_validbits &= ~((uint16_t)1U << 2);
	m_adc.clear();
}

inline AdcConfig *HardwareConfig::mutable_adc()
{
	if (0 == (p_validbits & ((uint16_t)1U << 2))) {
		p_validbits |= ((uint16_t)1U << 2);
		m_adc.clear();
	}
	return &m_adc;
}

inline void HardwareConfig::set_adc(const void *data, size_t s)
{
	m_adc.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 2);
}

inline void HardwareConfig::set_adc(const AdcConfig & v)
{
	m_adc = v;
	p_validbits |= ((uint16_t)1U << 2);
}

inline const GpioConfig &HardwareConfig::gpio(unsigned x) const
{
	return m_gpio[x];
}

inline const std::vector<GpioConfig> &HardwareConfig::gpio() const
{
	return m_gpio;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_gpio()
{
	m_gpio.clear();
}

inline GpioConfig *HardwareConfig::mutable_gpio(unsigned x)
{
	if (x >= m_gpio.size())
		m_gpio.resize(x+1);
	return &m_gpio[x];
}

inline std::vector<GpioConfig> *HardwareConfig::mutable_gpio()
{
	return &m_gpio;
}

inline GpioConfig *HardwareConfig::add_gpio()
{
	m_gpio.resize(m_gpio.size()+1);
	return &m_gpio.back();
}

inline void HardwareConfig::set_gpio(unsigned x, const GpioConfig &v)
{
	assert(x < m_gpio.size());
	m_gpio[x] = v;
}

inline size_t HardwareConfig::gpio_size() const
{
	return m_gpio.size();
}

inline const ButtonConfig &HardwareConfig::button(unsigned x) const
{
	return m_button[x];
}

inline const std::vector<ButtonConfig> &HardwareConfig::button() const
{
	return m_button;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_button()
{
	m_button.clear();
}

inline ButtonConfig *HardwareConfig::mutable_button(unsigned x)
{
	if (x >= m_button.size())
		m_button.resize(x+1);
	return &m_button[x];
}

inline std::vector<ButtonConfig> *HardwareConfig::mutable_button()
{
	return &m_button;
}

inline ButtonConfig *HardwareConfig::add_button()
{
	m_button.resize(m_button.size()+1);
	return &m_button.back();
}

inline void HardwareConfig::set_button(unsigned x, const ButtonConfig &v)
{
	assert(x < m_button.size());
	m_button[x] = v;
}

inline size_t HardwareConfig::button_size() const
{
	return m_button.size();
}

inline const RelayConfig &HardwareConfig::relay(unsigned x) const
{
	return m_relay[x];
}

inline const std::vector<RelayConfig> &HardwareConfig::relay() const
{
	return m_relay;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_relay()
{
	m_relay.clear();
}

inline RelayConfig *HardwareConfig::mutable_relay(unsigned x)
{
	if (x >= m_relay.size())
		m_relay.resize(x+1);
	return &m_relay[x];
}

inline std::vector<RelayConfig> *HardwareConfig::mutable_relay()
{
	return &m_relay;
}

inline RelayConfig *HardwareConfig::add_relay()
{
	m_relay.resize(m_relay.size()+1);
	return &m_relay.back();
}

inline void HardwareConfig::set_relay(unsigned x, const RelayConfig &v)
{
	assert(x < m_relay.size());
	m_relay[x] = v;
}

inline size_t HardwareConfig::relay_size() const
{
	return m_relay.size();
}

inline const LedConfig &HardwareConfig::led(unsigned x) const
{
	return m_led[x];
}

inline const std::vector<LedConfig> &HardwareConfig::led() const
{
	return m_led;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_led()
{
	m_led.clear();
}

inline LedConfig *HardwareConfig::mutable_led(unsigned x)
{
	if (x >= m_led.size())
		m_led.resize(x+1);
	return &m_led[x];
}

inline std::vector<LedConfig> *HardwareConfig::mutable_led()
{
	return &m_led;
}

inline LedConfig *HardwareConfig::add_led()
{
	m_led.resize(m_led.size()+1);
	return &m_led.back();
}

inline void HardwareConfig::set_led(unsigned x, const LedConfig &v)
{
	assert(x < m_led.size());
	m_led[x] = v;
}

inline size_t HardwareConfig::led_size() const
{
	return m_led.size();
}

#ifdef CONFIG_MAX7219
inline const Max7219Config &HardwareConfig::max7219() const
{
	return m_max7219;
}

inline bool HardwareConfig::has_max7219() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 3));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_max7219()
{
	p_validbits &= ~((uint16_t)1U << 3);
	m_max7219.clear();
}

inline Max7219Config *HardwareConfig::mutable_max7219()
{
	if (0 == (p_validbits & ((uint16_t)1U << 3))) {
		p_validbits |= ((uint16_t)1U << 3);
		m_max7219.clear();
	}
	return &m_max7219;
}

inline void HardwareConfig::set_max7219(const void *data, size_t s)
{
	m_max7219.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 3);
}

inline void HardwareConfig::set_max7219(const Max7219Config & v)
{
	m_max7219 = v;
	p_validbits |= ((uint16_t)1U << 3);
}

#endif // CONFIG_MAX7219
#ifdef CONFIG_NIGHTSKY
inline const Tlc5947Config &HardwareConfig::tlc5947() const
{
	return m_tlc5947;
}

inline bool HardwareConfig::has_tlc5947() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 4));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_tlc5947()
{
	p_validbits &= ~((uint16_t)1U << 4);
	m_tlc5947.clear();
}

inline Tlc5947Config *HardwareConfig::mutable_tlc5947()
{
	if (0 == (p_validbits & ((uint16_t)1U << 4))) {
		p_validbits |= ((uint16_t)1U << 4);
		m_tlc5947.clear();
	}
	return &m_tlc5947;
}

inline void HardwareConfig::set_tlc5947(const void *data, size_t s)
{
	m_tlc5947.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 4);
}

inline void HardwareConfig::set_tlc5947(const Tlc5947Config & v)
{
	m_tlc5947 = v;
	p_validbits |= ((uint16_t)1U << 4);
}

#endif // CONFIG_NIGHTSKY
#ifdef CONFIG_LEDSTRIP
inline const Ws2812bConfig &HardwareConfig::ws2812b() const
{
	return m_ws2812b;
}

inline bool HardwareConfig::has_ws2812b() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 5));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_ws2812b()
{
	p_validbits &= ~((uint16_t)1U << 5);
	m_ws2812b.clear();
}

inline Ws2812bConfig *HardwareConfig::mutable_ws2812b()
{
	if (0 == (p_validbits & ((uint16_t)1U << 5))) {
		p_validbits |= ((uint16_t)1U << 5);
		m_ws2812b.clear();
	}
	return &m_ws2812b;
}

inline void HardwareConfig::set_ws2812b(const void *data, size_t s)
{
	m_ws2812b.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 5);
}

inline void HardwareConfig::set_ws2812b(const Ws2812bConfig & v)
{
	m_ws2812b = v;
	p_validbits |= ((uint16_t)1U << 5);
}

#endif // CONFIG_LEDSTRIP
#ifdef CONFIG_DHT
inline const DhtConfig &HardwareConfig::dht() const
{
	return m_dht;
}

inline bool HardwareConfig::has_dht() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 6));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_dht()
{
	p_validbits &= ~((uint16_t)1U << 6);
	m_dht.clear();
}

inline DhtConfig *HardwareConfig::mutable_dht()
{
	if (0 == (p_validbits & ((uint16_t)1U << 6))) {
		p_validbits |= ((uint16_t)1U << 6);
		m_dht.clear();
	}
	return &m_dht;
}

inline void HardwareConfig::set_dht(const void *data, size_t s)
{
	m_dht.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 6);
}

inline void HardwareConfig::set_dht(const DhtConfig & v)
{
	m_dht = v;
	p_validbits |= ((uint16_t)1U << 6);
}

#endif // CONFIG_DHT
#ifdef CONFIG_I2C
inline const I2CConfig &HardwareConfig::i2c(unsigned x) const
{
	return m_i2c[x];
}

inline const std::vector<I2CConfig> &HardwareConfig::i2c() const
{
	return m_i2c;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_i2c()
{
	m_i2c.clear();
}

inline I2CConfig *HardwareConfig::mutable_i2c(unsigned x)
{
	if (x >= m_i2c.size())
		m_i2c.resize(x+1);
	return &m_i2c[x];
}

inline std::vector<I2CConfig> *HardwareConfig::mutable_i2c()
{
	return &m_i2c;
}

inline I2CConfig *HardwareConfig::add_i2c()
{
	m_i2c.resize(m_i2c.size()+1);
	return &m_i2c.back();
}

inline void HardwareConfig::set_i2c(unsigned x, const I2CConfig &v)
{
	assert(x < m_i2c.size());
	m_i2c[x] = v;
}

inline size_t HardwareConfig::i2c_size() const
{
	return m_i2c.size();
}

#endif // CONFIG_I2C
#ifdef CONFIG_HCSR04
inline const HcSr04Config &HardwareConfig::hcsr04(unsigned x) const
{
	return m_hcsr04[x];
}

inline const std::vector<HcSr04Config> &HardwareConfig::hcsr04() const
{
	return m_hcsr04;
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_hcsr04()
{
	m_hcsr04.clear();
}

inline HcSr04Config *HardwareConfig::mutable_hcsr04(unsigned x)
{
	if (x >= m_hcsr04.size())
		m_hcsr04.resize(x+1);
	return &m_hcsr04[x];
}

inline std::vector<HcSr04Config> *HardwareConfig::mutable_hcsr04()
{
	return &m_hcsr04;
}

inline HcSr04Config *HardwareConfig::add_hcsr04()
{
	m_hcsr04.resize(m_hcsr04.size()+1);
	return &m_hcsr04.back();
}

inline void HardwareConfig::set_hcsr04(unsigned x, const HcSr04Config &v)
{
	assert(x < m_hcsr04.size());
	m_hcsr04[x] = v;
}

inline size_t HardwareConfig::hcsr04_size() const
{
	return m_hcsr04.size();
}

#endif // CONFIG_HCSR04
#ifdef CONFIG_ONEWIRE
inline const OneWireConfig &HardwareConfig::onewire() const
{
	return m_onewire;
}

inline bool HardwareConfig::has_onewire() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 7));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_onewire()
{
	p_validbits &= ~((uint16_t)1U << 7);
	m_onewire.clear();
}

inline OneWireConfig *HardwareConfig::mutable_onewire()
{
	if (0 == (p_validbits & ((uint16_t)1U << 7))) {
		p_validbits |= ((uint16_t)1U << 7);
		m_onewire.clear();
	}
	return &m_onewire;
}

inline void HardwareConfig::set_onewire(const void *data, size_t s)
{
	m_onewire.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 7);
}

inline void HardwareConfig::set_onewire(const OneWireConfig & v)
{
	m_onewire = v;
	p_validbits |= ((uint16_t)1U << 7);
}

#endif // CONFIG_ONEWIRE
#ifdef CONFIG_DISPLAY
inline const DisplayConfig &HardwareConfig::display() const
{
	return m_display;
}

inline bool HardwareConfig::has_display() const
{
	return 0 != (p_validbits & ((uint16_t)1U << 8));
}

/*!
 * Function for clearing the associated member variable.
 * It will reset the value to the default value.
 */
inline void HardwareConfig::clear_display()
{
	p_validbits &= ~((uint16_t)1U << 8);
	m_display.clear();
}

inline DisplayConfig *HardwareConfig::mutable_display()
{
	if (0 == (p_validbits & ((uint16_t)1U << 8))) {
		p_validbits |= ((uint16_t)1U << 8);
		m_display.clear();
	}
	return &m_display;
}

inline void HardwareConfig::set_display(const void *data, size_t s)
{
	m_display.fromMemory((const char *)data,s);
	p_validbits |= ((uint16_t)1U << 8);
}

inline void HardwareConfig::set_display(const DisplayConfig & v)
{
	m_display = v;
	p_validbits |= ((uint16_t)1U << 8);
}

#endif // CONFIG_DISPLAY
#endif
