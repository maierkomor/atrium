/*
 *  Copyright (C) 2018-2020, Thomas Maier-Komor
 *  Atrium Firmware Package for ESP
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <sdkconfig.h>
#include "romfs.h"

#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "log.h"
#include <esp_partition.h>
#ifdef ESP32
#include <esp_spi_flash.h>
#else
#include <spi_flash.h>
#endif


#include <vector>

#ifdef CONFIG_ROMFS

// flash ROM entry generated by mkrom

typedef struct RomEntry16
{
	uint16_t offset, size;
	char name[12];
} RomEntry16;


typedef struct RomEntry32
{
	uint32_t offset, size;
	char name[24];
} RomEntry32;

#if defined ROMFS16
#define RomEntry RomEntry16
#define ROMFS_MAGIC "ROMFS16"
#elif defined ROMFS32
#define RomEntry RomEntry32
#define ROMFS_MAGIC "ROMFS32"
#elif defined ESP8266
#define RomEntry RomEntry16
#define ROMFS_MAGIC "ROMFS16"
#elif defined ESP32
#define RomEntry RomEntry32
#define ROMFS_MAGIC "ROMFS32"
#else
#error RomEntry variant not set
#endif

using namespace std;

static char TAG[] = "romfs";
static RomEntry *Entries;
static unsigned NumEntries;
uint32_t RomfsBaseAddr, RomfsSpace;


uint32_t romfs_get_base(const char *pn)
{
	return RomfsBaseAddr;
}


size_t romfs_size(const char *n)
{
	for (RomEntry *i = Entries, *e = Entries+NumEntries; i != e; ++i) {
		if (0 == strcmp(n,i->name))
			return i->size;
	}
	return 0;
}


int romfs_open(const char *n)
{
	for (size_t i = 0; i != NumEntries; ++i) {
		if (0 == strcmp(n,Entries[i].name))
			return i;
	}
	return -1;
}


size_t romfs_size(int i)
{
	if ((i < 0) || (i >= NumEntries))
		return 0;
	return Entries[i].size;
}


const char *romfs_name(int i)
{
	if ((i < 0) || (i >= NumEntries))
		return 0;
	return Entries[i].name;
}


size_t romfs_offset(const char *n)
{
	for (RomEntry *i = Entries, *e = Entries+NumEntries; i != e; ++i) {
		if (0 == strcmp(n,i->name))
			return i->offset;
	}
	return 0;
}


size_t romfs_offset(int i)
{
	if ((i < 0) || (i >= NumEntries))
		return 0;
	return Entries[i].offset;
}


int romfs_read_at(int i, char *buf, size_t n, size_t o)
{
	if ((i < 0) || (i >= NumEntries))
		return -1;
	uint32_t off = romfs_offset(i);
	uint32_t s = romfs_size(i);
	if ((o+n) > s)
		return -1;
	assert(((uint32_t)buf & 3) == 0);
	if (auto e = spi_flash_read(RomfsBaseAddr+off+o,buf,n)) {
		log_error(TAG,"spi_flash_read returned %s",esp_err_to_name(e));
		return -1;
	}
	return n;
}


void romfs_getentry(const char *n, size_t *s, size_t *o)
{
	for (size_t i = 0; i != NumEntries; ++i) {
		if (0 == strcmp(n,Entries[i].name)) {
			*o = Entries[i].offset;
			*s = Entries[i].size;
			return;
		}
	}
	*o = 0;
	*s = 0;
	return;
}


size_t romfs_num_entries()
{
	return NumEntries;
}


extern "C"
void romfs_setup()
{
	auto p = esp_partition_find_first(ESP_PARTITION_TYPE_DATA,ESP_PARTITION_SUBTYPE_ANY,CONFIG_ROMFS_PARTITION);
	if (p == 0) {
		log_error(TAG,"unable to find romfs partition '" CONFIG_ROMFS_PARTITION "'");
		return;
	}
	NumEntries = 0;
	RomfsBaseAddr = p->address;
	RomfsSpace = p->size;
	uint32_t flashrom = RomfsBaseAddr;
	char magic[8];
	spi_flash_read(flashrom,magic,sizeof(magic));
	if (strcmp(magic,ROMFS_MAGIC)) {
		log_error(TAG,"no " ROMFS_MAGIC " at 0x%x",flashrom);
		return;
	}
	flashrom += 8;
	RomEntry e;
	spi_flash_read(flashrom,&e,sizeof(e));
	while ((e.size != 0) && (e.offset != 0)) {
		++NumEntries;
		RomEntry *n = (RomEntry*) realloc(Entries,NumEntries*sizeof(RomEntry));
		if (n == 0) {
			log_error(TAG,"out of memory during setup");
			NumEntries = 0;
			free(Entries);
			Entries = 0;
			return;
		}
		Entries = n;
		memcpy(Entries+(NumEntries-1),&e,sizeof(RomEntry));
		flashrom += sizeof(RomEntry);
		spi_flash_read(flashrom,&e,sizeof(e));
	}
	log_info(TAG,"romfs at 0x%x has %u entries",RomfsBaseAddr,NumEntries);
}

#endif
